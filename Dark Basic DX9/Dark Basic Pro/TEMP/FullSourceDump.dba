rem
rem FPS CREATOR - GLOBAL DATA
rem

rem X10 - 301007 - place here to switch OFF all render/processmessagewaits/etc
rem which will speed up the FPSC-Game.exe initial run time (remove 25 second pause)
sync on : sync rate 0

rem App Independent Data
dim filecollection$()

rem Time stamp outside level scope reset
global timestampactivitymax=0
global timestampactivityflagged=0
global timestampactivityindex=0
dim timestampactivity$(1000)
global timebasepercycle# as float : timebasepercycle#=0
global timebasepercyclestamp as DWORD : timebasepercyclestamp=timer()
global dim logfilereport$(100)
global logfilereportindex=0
`global seeitems : seeitems=0
`global dim seeitems$(1)
 
rem FPSCV104RC9 - loading time readout to file
global gloadreportstate : gloadreportstate=0
global gloadreporttime : gloadreporttime=0
global gloadreportlasttime : gloadreportlasttime=0
global gloadreportindex : gloadreportindex=0
dim loadreport$(100000)

rem Ghost Run globals
global ghostrunstage : ghostrunstage=0
global ghostrunmarkerindex : ghostrunmarkerindex=0
global ghostrunx# : ghostrunx#=0
global ghostruny# : ghostruny#=0
global ghostrunz# : ghostrunz#=0
global ghostrunrx# : ghostrunrx#=0
global ghostrunry# : ghostrunry#=0
global ghostrunrz# : ghostrunrz#=0
global gcameraflymode : gcameraflymode=0
global snapshotmodeframebyframe : snapshotmodeframebyframe=0

rem Data structure to old player save data
type saveplayerstatetype
 lives as integer
 health as integer
 weaponindexholding as integer
 score as integer
endtype
saveplayerstate as saveplayerstatetype
global hudhaveplayername as integer : hudhaveplayername=0
global localipaddress$ : localipaddress$=""
global serveripaddress$ : serveripaddress$=""
global playername$ : playername$=""
global playercam : playercam=0 : rem X10 sync sequence control
global globaltitlepagevolume : globaltitlepagevolume=0
global globalloadingpagevolume : globalloadingpagevolume=0

rem X10 Array for effect menu
type x10effectmenudatatype
 ttop
 tleft
 tclick
 tdrag
 thighlight
 tmouselook
endtype
x10effectmenudata as x10effectmenudatatype
x10effectmenudata.thighlight=-1
x10effectmenudata.tleft=screen width()-238-10
x10effectmenudata.ttop=0
dim x10effectmenu(20)
for t=0 to 19 : x10effectmenu(t)=0 : next t

rem X10 Volume meter structures
type x10volumemenudatatype
 ttop
 tleft
 tclick
 tdrag
 thighlight
endtype
x10volumemenudata as x10volumemenudatatype
x10volumemenudata.thighlight=-1
x10volumemenudata.ttop=0
x10volumemenudata.tleft=screen width()-238-10-238-10
dim volumemeter(5)
for rmi=0 to 4
 volumemeter(rmi)=50
next rmi
global gvolumetitlemusic=0
global gvolumetitlemusic$=""
global gvolumeloadingmusic=0
global gvolumeloadingmusic$=""
global lastmusicplayedinit : lastmusicplayedinit=0
global lastmusicplayed : lastmusicplayed=0
global firstmusicplayed : firstmusicplayed=0

rem X10 video and snapshots
global gvideofootagecapture : gvideofootagecapture=0
global ghidehudgraphics : ghidehudgraphics=0
global gtakesnapshot : gtakesnapshot=0

rem X10 Settings
global gx10settingcapturecodec$ : gx10settingcapture$="XVID"
global gx10settingcapturecompression : gx10settingcapturecompression=1
global gx10settingcapturewidth : gx10settingcapturewidth=512
global gx10settingcaptureheight : gx10settingcaptureheight=384
global gx10settingcapturefps : gx10settingcapturefps=24
global gx10settingcapturethreaded : gx10settingcapturethreaded=1
global gx10settingcapturewait : gx10settingcapturewait=1

rem X10 Resource meter structures
dim resourcemeter(5)
dim resourcemeter#(5)
dim resourcemeterdest#(5)

` FPSCV10X SAVE LOAD Data Structures
type saveloadtype
 saveloaddir$
 slothighlight
 saveloadimg
 saveloadx
 saveloady
 liney
 slotselected
 areyousure
 loadswitch
endtype
saveload as saveloadtype
dim saveloadslot$(9)
gosub _saveload_savebox_init

` FPSCV10X Game Position Data Structure
type saveloadgamepositiontype
 level
 playerx
 playery
 playerz
 playerrx
 playerry
 playerhealth
 playerlives
 playerinventorymax
 missiongoaltotal
 playerholdinggun
 playercrouchmode
endtype
type saveloadgamepositionentitytype
 spawnleaderid as integer
 ailibindex as integer
 aistate as integer
 aioldstate as integer
 active as integer
 dormant as integer
 beenkilled as integer
 x as float
 y as float
 z as float
 rx as float
 ry as float
 rz as float
 orx as float
 ory as float
 orz as float
 floorposy as float
 animset as integer
 animdo as integer
 animframe as float
 currentammo as integer
 health as integer
 collected as integer
 activated as integer
 texturearrayindex as integer
 collisionactive as integer
 actualtarget as integer
 waypointstate as integer
 waypointcurrent as integer
 waypointtracker as integer
 waypointdirection as integer
 waypointxstart as float
 waypointystart as float
 waypointzstart as float
 waypointxinc as float
 waypointyinc as float
 waypointzinc as float
 aiusinginternalai as integer
 aioldwaypointstate as integer
 aioldanimframe as float
 aiolddestanimframe as float
 spawnatstart as integer
 spawnupto as integer
 ailastactionmode as integer
 ailastpatrolpoint as integer
 lightislit as integer
endtype

type saveloadgamepositionweaponslottype
 pref got invpos
 weaponammo
 weaponclipammo
 weaponhud
endtype
saveloadgameposition as saveloadgamepositiontype
dim saveloadgamepositionplayerinventory(100) as inventorytype
dim saveloadgamepositionplayerobjective(99) as integer
dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
dim saveloadgamepositionweaponslot(10) as saveloadgamepositionweaponslottype
global gsaveloadobjectivesloaded : gsaveloadobjectivesloaded=0

rem Init FPSC then leap to SETUP.INI loader
leavegamedataalone=0
gosub _FPSC_Full_Data_Init
goto _FPSC_Setup

rem Subroutine to completely construct FPSCData
_FPSC_Full_Data_Init:

`
` Performance globals
`

rem performance counters
global gprogressmax as integer
global dim perf(20) as DWORD
global dim perfsync(10) as DWORD
global gameperftimetracker as DWORD
global gameperftimestamp as DWORD
global gameperftimestamp2 as DWORD
global gameperftimestamplocal as DWORD
global gameperftotalcountTOP as DWORD
global gameperftotalcount as DWORD
global gameperflighting as DWORD
global gameperfplayer as DWORD
global gameperfentities1 as DWORD
global gameperfentities2 as DWORD
global gameperfentities3 as DWORD
global gameperfentities4 as DWORD
global gameperfentities5 as DWORD
global gameperfentities as DWORD
global gameperfgun as DWORD
global gameperfmisc as DWORD
global gameperfdebug as DWORD
global gameperfresttosync as DWORD
global gameperfphysics as DWORD
global gameperfsync as DWORD
global gameperfai as DWORD
global dim gamesyncperfsync(10) as DWORD
global deactivatecollision=0
global entitysystemdisabled=0
global lightingsystemdisabled=0
gameperftimetracker=timer()
global guniverseeffectindex=0
global gamewarmupcount=0
global gamewarmupstarttime as DWORD : gamewarmupstarttime=0

rem logic control
global logicprioritycount=0
global logicprioritymax#=0.0

rem memory counters
dim mshot(500)
global mshoti=0
global mshotmem=0
global mshotfirst=0
global mshotmemlargest=0
global lastmshoti=0
global lastmshotmem=0

rem workload counters
dim wshot(400,4)
dim wshotmax(4)
global wshoti=0


`
` Editors Data
`

rem Input Control System Data Structure
type inputsystemtype
 activemouse as integer
 xmouse as integer
 ymouse as integer
 xmousemove as integer
 ymousemove as integer
 wheelmousemove as integer
 mclick as integer
 lockdown as integer
 k$ as string
 mmx as integer
 mmy as integer
 localx# as float
 localy# as float
 kscancode as integer
 keypress as integer
 keycontrol as integer
 keyreturn as integer
 keyshift as integer
 keyleft as integer
 keyright as integer
 keyup as integer
 keydown as integer
 keyspace as integer
 constructselection as integer
 dorotation as integer
 domirror as integer
 doflip as integer
 doload as integer
 dosave as integer
 doopen as integer
 donew as integer
 donewarena as integer
 dosaveas as integer
 dosaveandrun as integer
 domodepaint as integer
 domodeselect as integer
 domodeart as integer
 domodeentity as integer
 domodewaypoint as integer
 dowaypointview as integer
 doentityrotate as integer
 dozoomin as integer
 dozoomout as integer
 doshrouddecrease as integer
 doshroudincrease as integer
 doshroudfull as integer
 doscrollleft as integer
 doscrollright as integer
 doscrollup as integer
 doscrolldown as integer
 domapresize as integer
 dolayerchange as integer
 dogroundmode as integer
 doundo as integer
 doredo as integer
 domapview as integer
 dozoomview as integer
 doautozoomview as integer
 dozoomviewmovex as integer
 dozoomviewmovey as integer
 dozoomviewmovez as integer
 dozoomviewrotatex as integer
 dozoomviewrotatey as integer
 dozoomviewrotatez as integer
 dosinglelayer as integer
 dopickmapid as integer
 doartresize as integer
 undoredoevent as integer
 undokeypress as integer
 tselcontrol as integer
 tselcut as integer
 tselcopy as integer
 tselfloor as integer
 tselpaste as integer
 tseldelete as integer
 tselwipe as integer
 tselsaveselection as integer
endtype
inputsys as inputsystemtype

rem UndoRedo list data structure
type undoredotype
 event as integer
 x as integer
 y as integer
 z as integer
 a as integer
 b as integer
endtype

rem Empty list with a single null event
dim undoredolist(0) as undoredotype
empty array undoredolist(0)
array insert at top undoredolist()

rem Browser Folder History
dim browserfolderhistory$(10)
global localdesc$=""

rem Globals for FPG handling
global currentSMFPGtype as integer : currentSMFPGtype=1
global currentSMFPG$ : currentSMFPG$="mygame.fpg"
global currentAMFPGtype as integer : currentAMFPGtype=2
global currentAMFPG$ : currentAMFPG$="myarena.fpg"
global currentFPGtype as integer : currentFPGtype=currentSMFPGtype
global currentFPG$ : currentFPG$=currentSMFPG$

rem Other structres
dim gunslots$ ( 10 )
dim listkey ( 32 )
dim list$( 100 )

rem Level handling
type leveltype
 fpm$ as string
 fpi$ as string
endtype

rem Project working on
global projectfilename$ : projectfilename$=""
global projectmodified : projectmodified=0

rem File List Buffer Array (multipurpose)
dim filelist$(0)

`
` Global Data and Arrays
`

rem Resource Banks
global meshbankmax=0
global meshbankoffset=1000
dim meshbank$(100)
global texturebankmax=0
global texturebankoffset=1000
dim texturebank$(100)
global effectbankmax=0
global effectbankoffset=1000
dim effectbank$(100)
dim soundbank$(10)
global soundbankmax=0
global soundbankoffset=1
global materialsoundoffset=10001
global materialsoundmax=0
global explodesoundoffset=11001
global explodesoundmax=0
dim prefabbank$(100)
dim prefabbanklocal$(100)
global prefabbankmax=100
dim selectionbank$(100)
dim selectionbanklocal$(100)
global entitybankmax=100
dim entitybank$(entitybankmax)
global particlebankmax=0
global particlebankoffset=1
global particlegunsmoke=0
global particlegrounddust=0
dim gunbank$(100)
global gunbankmax=0
dim muzzlebank$(100)
global muzzlebankmax=0
dim brassbank$(100)
global brassbankmax=0
dim smokebank$(100)
global smokebankmax=0
dim flakbank$(100)
global flakbankmax=0
`
rem Image order important for texture order
global imagebankmax=0
global attachmenticonimagestart=350
global x10effectmenuimagestart=400
`global newmuzzleimagestart=490
global muzzlebankoffset=500
global imagebankoffset=550
dim imagebank$(500)
`
rem Object Resource Offsets (COMMON)
global realviewobjectoffset=1000
global realviewobjectoffsetend=0
global entityattachmentsoffset=8900 : rem FPSCV104 - changed from 9900 - extra 1000 for guns/shadows
global entityattachmentindex=0
global entityworkobjectoffset=10099
global entityobjectoffset=10100
global entityprofileslotclonestartmaster=15000
global entityprofileslotclonestart=15000
global hudbankoffset=16050
global gunbankoffset=16100
global brassbankoffset=16150
global smokebankoffset=16200
global flakbankoffset=16300
global flakelementoffset=16350
global decalbankoffset=16450
global decalelementoffset=16500
global fragmentobjectoffset=17000
global fragmentobjectoffsetmax
global newmuzzleobjstart=17450
global explodedecalobjstart=17500
global explodedecalobjmax
global explosionscorch
global explosionscorchsolid
global explosionstressed
global editorwaypointoffset=18000
global editorwaypointoffsetmax=18499
global debugobjectoffset=18500 : rem no debug in map editor
global editorhighlightobjectsoffset=18500
global editormarkeroffset=19000
`global editormarkeroffsetmax=19999
global editormarkeroffsetmax=19200
global gamdebugobjoffset=19300
global selectionbankoffset=20000
global entitybankoffset=30000
global preclonedcorpseobjbase=40000
global gamehudimagesoffset=64500
global editorimagesoffset=65000
global physicsplayerborblephy=65532
global physicsuniverseobj=65533
global physicsplayerborble=65534
rem Universe Builing Object Resources for entire universe
global universebuildobjstartoffset=70001
global universebuildobjendoffset=166000
global endofallobjectsoffset=166001

`
` Segment Data
`

rem Segment Profile Data Structure
type segmentprofileheadertype
 partmax as integer
 lastmeshmax as integer
 preventai as integer
endtype
type segmentprofilevistype overlay f r wb wr wf wl owb owr owf owl ctl ctr cbr cbl octl octr ocbr ocbl endtype
type segmentprofileblueprinttype
 mode as integer
 symbol as integer
 floorsizey as integer
 sidesizex as integer
 sidesizey as integer
 sidesizez as integer
endtype
type segmentprofileproperties
 groundmode as integer
 kindof as integer
endtype
type materialtype
 index as integer
endtype
type segmentprofiletype
 partmode as integer
 meshname$ as string
 meshid as integer
 actuallimb as integer
 offx as float
 offy as float
 offz as float
 rotx as float
 roty as float
 rotz as float
 tex$ as string
 texd$ as string
 texn$ as string
 texs$ as string
 effect$ as string
 texid as integer
 texdid as integer
 texiid as integer
 texnid as integer
 texsid as integer
 effectid as integer
 transparency as integer
 colmode as integer
 vis as segmentprofilevistype
 blueprint as segmentprofileblueprinttype
 properties as segmentprofileproperties
 csgmesh$ as string
 csgmode as integer
 csgimmune as integer
 lightmode as integer
 multimeshmode as integer
 multimeshstart as integer
 material as materialtype
endtype
global segobjusedformapeditor=0
global segobjusedforsegeditor=0
global segidmastermax : segidmastermax=100
dim segmentprofileheader(segidmastermax) as segmentprofileheadertype
dim segmentprofile(segidmastermax,64) as segmentprofiletype

`
` Map Data
`

rem Prepare map data and texture
layermax=20 : maxx=40 : maxy=40
dim map(layermax,maxx,maxy)
mapid as DWORD
mapselection as DWORD
mapscaler as DWORD
mapground as DWORD
maprotate as DWORD
maporient as DWORD
mapsymbol as DWORD
maptile as DWORD

rem Visible-Col-Map used for per-cycle quick entity collision checks
viscolx=160 : viscoly=20 : viscolz=160
dim viscolmap(viscolx,viscoly,viscolz)

rem Prepare entity reference map (references entityelementlist indexes)
dim refmap(layermax,maxx,maxy) as DWORD
newptrbase as DWORD
refptrbase as DWORD
ptrbase as DWORD
refptr as DWORD
ptr as DWORD

rem Map Overlay (stacked segment list)
dim mapolay(layermax,maxx,maxy)
global olaylistmax : olaylistmax=100
dim olaylist(olaylistmax,50) as DWORD

rem Default settings
gridzoom#=1.0
shroudsize=5
gridground=0
gridselection=1
nogridsmart=-1
gridlayer=5
bufferlayer=-1
gridlayershowsingle=0
grideditartwidth=1
grideditartwidthx=1
grideditartwidthy=1
locallibrarysegidmaster=0
locallibraryentidmaster=0
locallibraryentindex=0
dim locallibraryent(locallibraryentindex)

rem Grid Entity globals
gridentitylight as entitylighttype
gridentitytrigger as entitytriggertype

rem Master Mesh Data Structure
type mapentriestype vertmax1 vertmax2 indexmax1 indexmax2 endtype
type mastermeshtype obj buffer layer worldx worldy endtype

rem Create master mesh array
mastermeshmax=0
mastermeshsize=1
mastermeshsets=1
firstmeshobject=101
currentmeshobject=firstmeshobject
dim mapentries(mastermeshsize,mastermeshsets,40,40) as mapentriestype
dim mastermesh(mastermeshsize,mastermeshsets) as mastermeshtype

`
` AI Subsystem Structures
`

rem Safe Spots Data Structure
type aisafetype
 x y z ry
 occupied
endtype
dim aisafe(1) as aisafetype
global gtotalobstaclecount : gtotalobstaclecount=0
`
` Entity Data
`

rem Entity Profile Data Structure
type entityprofileheadertype
 desc$ as string
endtype
type entityanimtype
 start as integer
 finish as integer
 speed as float
endtype
type entitylighttype
 index as integer
 islit as integer
 color as DWORD
 range as integer
endtype
type entitytriggertype
 areax1 as integer
 areax2 as integer
 areay1 as integer
 areay2 as integer
 areaz1 as integer
 areaz2 as integer
endtype
type entityprofileextrastype
 alignment as integer 
 initmode as integer 
 seemode as integer 
 trigmode as integer 
 hurtmode as integer 
 hurtvalue as integer 
 canstrafe as integer 
 canduck as integer 
 canhear as integer 
 loadedweapon as integer 
 attackrange as integer 
 viewrange as integer 
 maxrange as integer 
 texturearray as integer 
 showhealthbar as integer 
 lungcapacity as integer 
 glassstyle as integer 
 score as integer
 showallyicon as integer
 factor as integer
 impactforce as integer
 decaytime as integer
 jumpheight as integer
 autolodmed as integer
 autolodlow as integer
endtype
type entityprofiletype
 aiinit$ as string
 aimain$ as string
 aidestroy$ as string
 aishoot$ as string
 soundset$ as string
 soundset1$ as string
 usekey$ as string
 ifused$ as string
 ifusednear$ as string
 spawnatstart as integer
 spawnmax as integer
 spawnupto as integer
 spawnafterdelay as integer
 spawnwhendead as integer
 spawndelay as integer
 spawnqty as integer
 spawndelayrandom as integer
 spawnqtyrandom as integer
 spawnvel as integer
 spawnvelrandom as integer
 spawnangle as integer
 spawnanglerandom as integer
 spawnlife as DWORD
 model$ as string
 offx as float
 offy as float
 offz as float
 rotx as float
 roty as float
 rotz as float
 scale as float
 fixnewy as float
 forwardfacing as integer
 defaultheight as float
 defaultstatic as integer
 collisionmode as integer
 materialindex as integer
 debrisshapeindex as integer
 coneheight as float
 coneangle as float
 hurtfall as integer
 texpath$ as string
 texd$ as string
 texdid as integer
 texaltd$ as string
 texaltdid as integer
 tex1id as integer
 tex2id as integer
 tex3id as integer
 tex4id as integer
 texidmax as integer
 effect$ as string
 usingeffect as integer
 castshadow as integer
 transparency as integer
 reducetexture as integer
 strength as integer
 lives as integer
 speed as integer
 isimmobile as integer
 ischaracter as integer
 cantakeweapon as integer
 isweapon$ as string
 isweapon as integer
 isammo as integer
 hasweapon$ as string
 hasweapon as integer
 ishealth as integer
 isflak as integer
 limbmax as integer
 headlimb as integer
 firespotlimb as integer
 animmax as integer
 quantity as integer
 ismarker as integer
 markerindex as integer
 isobjective as integer
 light as entitylighttype
 trigger as entitytriggertype
 decalmax as integer
 bloodscorch as integer
 rateoffire as integer
 damage as integer
 accuracy as integer
 reloadqty as integer
 fireiterations as integer
 lifespan as integer
 throwspeed as float
 throwangle as float
 bounceqty as integer
 explodeonhit as integer
 weaponisammo as integer
 spare1 as DWORD
 physics as integer
 phyalways as integer
 phyweight as integer
 phyfriction as integer
 phyforcedamage as integer
 rotatethrow as integer
 explodable as integer
 explodedamage as integer
 objattachmentmaster as integer
 slotcloneobj as integer
 ex as entityprofileextrastype
 characterinstancingmode as integer
 usetexturearrayforentity as integer
 hardscalex as integer
 hardscaley as integer
 hardscalez as integer
 noragdoll as integer
endtype
global animmax=200
global entidmastermax=100
dim entitybodypart(100,100) as integer
dim entityanim(100,animmax) as entityanimtype
dim entityprofileheader(100) as entityprofileheadertype
dim entityprofile(100) as entityprofiletype
dim entitydecal$(100,100) as string
dim entitydecal(100,100) as integer
dim lastentityraycast(100)
dim lastentityraycast2#(100)  
dim lastentityshadowlength#(100)

rem X10 entity profile extras
global entityprofileslotclonequantity : entityprofileslotclonequantity=6
dim entityprofileslot(entityprofileslotclonequantity) : rem X10 holds type of animation playing in slot
dim entityprofileslotref(entityprofileslotclonequantity) : rem X10 holds number of animations playing in this slot

rem Waypoint Component of entity element
type aiwaypointtype
 state as integer
 current as integer
 tracker as integer
 direction as integer
 timefrom as DWORD
 xstart as float
 ystart as float
 zstart as float
 xinc as float
 yinc as float
 zinc as float
 timeslice as DWORD
endtype

rem AI Component of entity element
type aistatustype
 libinit as integer
 libmain as integer
 libdestroy as integer
 libshoot as integer
 libindex as integer
 state as integer
 alphafade as integer
 destalphafade as integer
 alphafadeupdate as integer
 headangle as float
 headdestangle as float
 waypoint as aiwaypointtype
 usinginternalai as integer
 oldstate as integer
 oldalphafade as integer
 oldwaypointstate as integer
 headshot as integer
 oldanimframe as float
 olddestanimframe as float
endtype

rem SPAWN Component of entity element
type spawntype
 atstart as integer
 max as integer
 delay as integer
 qty as integer
 upto as integer
 afterdelay as integer
 whendead as integer
 delayrandom as integer
 qtyrandom as integer
 vel as integer
 velrandom as integer
 angle as integer
 anglerandom as integer
 life as DWORD
 leader as integer
 leadercount as integer
 leaderid as integer
 x as float
 y as float
 z as float
endtype

rem FORCE Component of entity element
type forcetype
 active as integer
 ix as float
 iy as float
 iz as float
 originx as float
 originy as float
 originz as float
endtype

rem MOVEMENT Component of entity element
type movertype
 moved as integer
 stepcount as float
 dx as float
 dy as float
 dz as float
 da as float
 ix as float
 iy as float
 iz as float
 grav as float
 gravlasty as float
 inmotion as integer
 viewconeused as float
 run as integer
 strafe as integer
 slidevel as float
endtype

rem AISUBSYSTEM Component of entity element
type aisstype
 actionmode as integer
 lastactionmode as integer
 actioncount as integer
 shoottimer as integer
 lastanimstate as integer
 stateresting as integer
 thinkingprompt as integer
 thinkingcount as integer
 corpsecontainer as integer
 corpsex as float
 corpsez as float
 beenhurt as integer
 knockbackx as float
 knockbackz as float
 savedpatrolpoint as integer
 timeoflastmeleeattack as integer
endtype

rem Entity Element Custom Profile Data
type entityeleproftype
 name$ as string
 aiinit$ as string
 aiinit as integer
 aimain$ as string
 aimain as integer
 aidestroy$ as string
 aidestroy as integer
 aishoot$ as string
 aishoot as integer
 usekey$ as string
 ifused$ as string
 ifusednear$ as string
 scale as float
 coneheight as float
 coneangle as float
 uniqueelement as integer
 texd$ as string
 texdid as integer
 texaltd$ as string
 texaltdid as integer
 tex1id as integer
 tex2id as integer
 tex3id as integer
 tex4id as integer
 texidmax as integer
 texarrayindex as integer
 effect$ as string
 usingeffect as integer
 transparency as integer
 strength as integer
 isimmobile as integer
 cantakeweapon as integer
 hasweapon$ as string
 hasweapon as integer
 quantity as integer
 isobjective as integer
 lives as integer
 markerindex as integer
 light as entitylighttype
 trigger as entitytriggertype
 basedecal$ as string
 soundset$ as string
 soundset1$ as string
 spawnatstart as integer
 spawnmax as integer
 spawnupto as integer
 spawnafterdelay as integer
 spawnwhendead as integer
 spawndelay as integer
 spawnqty as integer
 spawndelayrandom as integer
 spawnqtyrandom as integer
 spawnvel as integer
 spawnvelrandom as integer
 spawnangle as integer
 spawnanglerandom as integer
 spawnlife as DWORD
 hurtfall as integer
 castshadow as integer
 reducetexture as integer
 speed as integer
 rateoffire as integer
 damage as integer
 accuracy as integer
 reloadqty as integer
 fireiterations as integer
 lifespan as integer
 throwspeed as float
 throwangle as float
 bounceqty as integer
 explodeonhit as integer
 weaponisammo as integer
 spare1 as DWORD
 physics as integer
 phyalways as integer
 phyweight as integer
 phyfriction as integer
 phyforcedamage as integer
 rotatethrow as integer
 explodable as integer
 explodedamage as integer
 aiss as aisstype
 uniquetimer as DWORD
 phydw2 as DWORD
 startx as float
 starty as float
 startz as float
 ex as entityprofileextrastype
endtype

rem Entity Elements Data
type entitytype
 editorfixed as integer
 servercontrolled as integer
 fakeplrindex as integer
 active as integer
 dormant as integer
 eleprof as entityeleproftype
 mover as movertype
 ai as aistatustype
 spawn as spawntype
 force as forcetype
 maintype as integer
 bankindex as integer
 profileobj as integer
 staticflag as integer
 obj as integer
 attachmentobj as integer
 attachmentbaseobj as integer
 attachmentweapontype as integer
 attachmentobjfirespotlimb as integer
 attachmentblobobj as integer
 x as float
 y as float
 z as float
 rx as float
 ry as float
 rz as float
 norotate as integer
 nogravity as integer
 dry as float
 floorposy as float
 colr as integer
 colg as integer
 colb as integer
 limbslerp as integer
 logiccount as float
 logiccountburst as integer
 logictimestamp as DWORD
 priorityai as integer
 priorityduration as integer
 raycastcount as integer
 raycastlaststate as integer
 nofloorlogic as integer
 crouchprofile as integer
 plrdist as float
 decalindex as integer
 decalmode as integer
 decalloop as integer
 decalslotused as integer
 decalsizex as float
 decalsizey as float
 animset as integer
 animdir as integer
 animdo as integer
 animtime as integer
 animframe as float
 animspeed as float
 animonce as integer
 destanimframe as float
 animframeupdate as integer
 spinrate as integer
 spinvalue as float
 floatrate as integer
 floatvalue as float
 possibletarget as integer
 actualtarget as integer
 losttargetcount as integer
 actualtargetx as float
 actualtargety as float
 actualtargetz as float
 plrtrailindex as integer
 fakeplayerid as integer
 strafemode as integer
 currentweapon as integer
 currentclipammo as integer
 currentammo as integer
 fireweapon as integer
 firesoundloop as integer
 firesoundloopremote as integer
 firesoundlooptime as DWORD
 firestrength as integer
 health as integer
 lifecode as integer
 beenkilled as integer
 timekilled as DWORD
 shotdamage as integer
 shotdamagesource as integer
 delaydamagecount as integer
 delaydamagesource as integer
 delaydamage as integer
 delayimpact as integer
 delaydamagex# as float
 delaydamagey# as float
 delaydamagez# as float
 delaydir as integer
 collected as integer
 activated as integer
 collisionactive as integer
 invincibleactive as integer
 blockedby as integer
 blockedtox as integer
 blockedtoy as integer
 blockedtoz as integer
 soundset as integer
 soundset1 as integer
 soundlooping as integer
endtype
rem Entity Breadcrumbs Data
type entitybreadcrumbstype
 x as float
 y as float
 z as float
endtype
global entityelementlist=0
global entityelementmax=100
grideleprof as entityeleproftype
dim entityelement(entityelementmax) as entitytype
dim entitybreadcrumbs(entityelementmax,50) as entitybreadcrumbstype
dim entitydebug$(entityelementmax)

rem X10 special global to hold a soft-particle shader (used for soft decals)
global gsoftdecalshader : gsoftdecalshader=0
global gskinningforagdolleffect : gskinningforagdolleffect=0
global gsimpleinstancevweapeffect : gsimpleinstancevweapeffect=0
global gsimplevweapeffect : gsimplevweapeffect=0

rem X10 entity element extras
global noslots : noslots=0
global grefractionelementused : grefractionelementused=0
global glastrefractionelementused : glastrefractionelementused=0
global goriginalglassobject : goriginalglassobject=0
dim entityelementwhichslot(entityelementmax) : rem holds which slot is being used by the element
dim entityelementusingode(entityelementmax) : rem holds whether clone used for ODE rag doll
dim entityelementwhichobj(entityelementmax) : rem holds which object controls anim for this element (parent or cloned self)
dim entityelementtexarrayindex(entityelementmax) : rem holds texture array index choice for element
dim entityelementusingrefraction(entityelementmax) : rem holds whether element is using refraction
dim lastentityraycast(entityelementmax)
dim lastentityraycast2#(entityelementmax)  
dim lastentityshadowlength#(entityelementmax)
global ragdollcountingame : ragdollcountingame=0 
global ragdollcounttimetick as DWORD : ragdollcounttimetick=0

rem Segment and EntityProfile/EntityelementList Vars
global preidmaster : preidmaster=0
global segidmaster : segidmaster=0
global entidmaster : entidmaster=0
global entityelementlist : entityelementlist=0
global aiindexmaster : aiindexmaster=0
global waypointmax : waypointmax=0
global wayppointoneonlyflaw : wayppointoneonlyflaw=0

`
` Artificial Intelegence Data
`

rem AI constants
#constant AICONDNEVER 1
#constant AICONDALWAYS 2
#constant AICONDSTATE 3
#constant AICONDRANDOM 4
#constant AICONDHEALTH 5
#constant AICONDHEALTHLESS 6
#constant AICONDQUANTITY 7
#constant AICONDSPEED 8
#constant AICONDRATEOFFIRE 9
#constant AICONDPLRHEALTHLESS 21
#constant AICONDPLRHEALTHGREATER 22
#constant AICONDASSOCIATED 51
#constant AICONDPLRDISTWITHIN 101
#constant AICONDPLRDISTFURTHER 102
#constant AICONDPLRHIGHER 103
#constant AICONDANYWITHIN 104
#constant AICONDANYFURTHER 105
#constant AICONDPLRELEVWITHIN 106
#constant AICONDPLRELEVFURTHER 107
#constant AICONDPLRALIVE 111
#constant AICONDSHOTDAMAGE 121
#constant AICONDIFWEAPON 122
#constant AICONDCANTAKE 131
#constant AICONDPLRCANBESEEN 151
#constant AICONDPLRCANNOTBESEEN 152
#constant AICONDPLRHASKEY 153
#constant AICONDPLRUSINGACTION 154
#constant AICONDACTIVATED 155
#constant AICONDPLRWITHINZONE 156
#constant AICONDENTITYWITHINZONE 157
#constant AICONDPLRINGUNSIGHT 158
#constant AICONDNEARACTIVATABLE 159
#constant AICONDNEWWEAPONCANBESEEN 161
#constant AICONDNOISEHEARD 171
#constant AICONDANYWITHINZONE 191
#constant AICONDANYKEYWITHINZONE 192
#constant AICONDRAYCAST 201
#constant AICONDRAYCASTUP 202
#constant AICONDRAYCASTBACK 203
#constant AICONDNORAYCASTUP 204
#constant AICONDFRAMEATEND 301
#constant AICONDFRAMEATSTART 302
#constant AICONDFRAMEWITHIN 303
#constant AICONDFRAMEBEYOND 304
#constant AICONDANIMATIONOVER 305
#constant AICONDREACHTARGET 351
#constant AICONDLOSETARGET 352
#constant AICONDHEADANGLEGREATER 401
#constant AICONDHEADANGLELESS 402
#constant AICONDALPHAFADEEQUAL 471
#constant AICONDWAYPOINTSTATE 501
#constant AICONDIFMARKER 551
#constant AICONDIFPLRTRAIL 552
#constant AICONDISDARKAISEEING 701
#constant AICONDISDARKAIHURT 702
#constant AICONDISDARKAIFIRING 703
#constant AICONDHUDSELECTIONMADE 801
#constant AICONDTIMERGREATER 811
#constant AICONDESCAPEKEYPRESSED 821
#constant AICONDHUDEDITDONE 822
#constant AICONDHUDHAVENAME 823
#constant AICONDSCANCODEKEYPRESSED 824
#constant AICONDEFFECTAMBIENCELESS 851
#constant AICONDEFFECTAMBIENCEGREATER 852
#constant AICONDEFFECTBLOOMSIZELESS 853
#constant AICONDEFFECTBLOOMSIZEGREATER 854
#constant AICONDEFFECTBLOOMSTRLESS 855
#constant AICONDEFFECTBLOOMSTRGREATER 856
#constant AICONDEFFECTWATERSPEEDLESS 857
#constant AICONDEFFECTWATERSPEEDGREATER 858
#constant AICONDEFFECTWATERSMOOTHLESS 859
#constant AICONDEFFECTWATERSMOOTHGREATER 860
#constant AICONDEFFECTWATERREFLECTIONLESS 861
#constant AICONDEFFECTWATERREFLECTIONGREATER 862
#constant AICONDEFFECTWATERREFRACTIONLESS 863
#constant AICONDEFFECTWATERREFRACTIONGREATER 864
#constant AICONDEFFECTWATERFRESNELLESS 865
#constant AICONDEFFECTWATERFRESNELGREATER 866
#constant AICONDEFFECTWATERLEVELLESS 867
#constant AICONDEFFECTWATERLEVELGREATER 868
#constant AICONDEFFECTSHADOWSTRLESS 869
#constant AICONDEFFECTSHADOWSTRGREATER 870
#constant AICONDEFFECTSHADOWQTYLESS 871
#constant AICONDEFFECTSHADOWQTYGREATER 872
#constant AICONDEFFECTWINDOWREFRACTIONLESS 873
#constant AICONDEFFECTWINDOWREFRACTIONGREATER 874
#constant AICONDVOLUMEINGAMEMUSICLESS 875
#constant AICONDVOLUMEINGAMEMUSICGREATER 876
#constant AICONDVOLUMEPLAYERSOUNDSLESS 877
#constant AICONDVOLUMEPLAYERSOUNDSGREATER 878
#constant AICONDVOLUMEINGAMESOUNDSLESS 879
#constant AICONDVOLUMEINGAMESOUNDSGREATER 880
#constant AICONDLAST 900

#constant AIACTNONE 0
#constant AIACTDESTROY 1
#constant AIACTSUSPEND 2
#constant AIACTRAGDOLL 3
#constant AIACTFLOORLOGIC 11
#constant AIACTNOGRAVITY 12
#constant AIACTSNAPSHOTMODE 21
#constant AIACTRUNFPIDEFAULT 51
#constant AIACTRUNFPI 52
#constant AIACTSTATE 101
#constant AIACTINCSTATE 102
#constant AIACTMOVEUP 201
#constant AIACTMOVEFORE 202
#constant AIACTMOVEBACK 203
#constant AIACTFREEZE 204
#constant AIACTRUNFORE 205
#constant AIACTROTATEY 226
#constant AIACTROTATETOPLR 227
#constant AIACTROTATEIY 228
#constant AIACTNOROTATE 229
#constant AIACTRESETHEAD 231
#constant AIACTROTATEHEAD 232
#constant AIACTROTATEHEADRANDOM 233
#constant AIACTFORCEBACK 251
#constant AIACTFORCEFORE 252
#constant AIACTFORCELEFT 253
#constant AIACTFORCERIGHT 254
#constant AIACTFORCEBOUNCE 255
#constant AIACTSPINRATE 281
#constant AIACTFLOATRATE 282
#constant AIACTSETFRAME 301
#constant AIACTINCFRAME 302
#constant AIACTDECFRAME 303
#constant AIACTANIMATE 304
#constant AIACTADVFRAME 305
#constant AIACTPOSEMODE 311
#constant AIACTSETTARGET 351
#constant AIACTROTATETOTARGET 352
#constant AIACTLOOKATTARGET 353
#constant AIACTMOVETOTARGET 354
#constant AIACTCOLLECTTARGET 355
#constant AIACTCHOOSESTRAFE 356
#constant AIACTSTRAFE 357
#constant AIACTPIVOTRANDOM 358
#constant AIACTLOOKATPLR 359
#constant AIACTSETTARGETNAME 360
#constant AIACTPLRASS 401
#constant AIACTPLRNOASS 402
#constant AIACTPLRMOVEUP 403
#constant AIACTPLRMOVEDOWN 404
#constant AIACTPLRMOVEEAST 405
#constant AIACTPLRMOVEWEST 406
#constant AIACTPLRMOVENORTH 407
#constant AIACTPLRMOVESOUTH 408
#constant AIACTPLRMOVETO 409
#constant AIACTPLRMOVEIFUSED 410
#constant AIACTACTIVATEIFUSED 421
#constant AIACTACTIVATEIFUSEDNEAR 422
#constant AIACTACTIVATETARGET 423
#constant AIACTACTIVATE 424
#constant AIACTACTIVATEALLINZONE 425
#constant AIACTPLRADDHEALTH 431
#constant AIACTPLRADDAIR 432
#constant AIACTSOUND 451
#constant AIACT3DSOUND 452
#constant AIACTLOOPSOUND 453
#constant AIACTSTOPSOUND 454
#constant AIACTALTTEXTURE 461
#constant AIACTSETALPHAFADE 471
#constant AIACTINCALPHAFADE 472
#constant AIACTDECALPHAFADE 473
#constant AIACTRUNDECAL 481
#constant AIACTSHAPEDECAL 482
#constant AIACTTRIGGERFORCE 491
#constant AIACTWAYPOINTSTART 501
#constant AIACTWAYPOINTSTOP 502
#constant AIACTWAYPOINTREVERSE 503
#constant AIACTWAYPOINTNEXT 504
#constant AIACTWAYPOINTPREV 505
#constant AIACTWAYPOINTRANDOM 506
#constant AIACTDROPMARKER 551
#constant AIACTNEXTMARKER 552
#constant AIACTRESETMARKERS 553
#constant AIACTFOLLOWPLR 554
#constant AIACTPLRTAKE 601
#constant AIACTPLRDROP 602
#constant AIACTSHOOTPLR 701
#constant AIACTUSEWEAPON 711
#constant AIACTRELOADWEAPON 712
#constant AIACTDODARKAI 721
#constant AIACTDODARKAIANIM 722
#constant AIACTCOLOFF 751
#constant AIACTCOLON 752
#constant AIACTSPAWNON 761
#constant AIACTSPAWNOFF 762
#constant AIACTAMBIENCE 821
#constant AIACTAMBIENCERED 822
#constant AIACTAMBIENCEGREEN 823
#constant AIACTAMBIENCEBLUE 824
#constant AIACTFOG 831
#constant AIACTFOGRED 832
#constant AIACTFOGGREEN 833
#constant AIACTFOGBLUE 834
#constant AIACTSKY 841
#constant AIACTSKYSCROLL 842
#constant AIACTEFFECTAMBIENCE 851
#constant AIACTEFFECTINCAMBIENCE 852
#constant AIACTEFFECTDECAMBIENCE 853
#constant AIACTEFFECTFOGRANGE 854
#constant AIACTEFFECTINCFOGRANGE 855
#constant AIACTEFFECTDECFOGRANGE 856
#constant AIACTEFFECTBLOOMSIZE 857
#constant AIACTEFFECTINCBLOOMSIZE 858
#constant AIACTEFFECTDECBLOOMSIZE 859
#constant AIACTEFFECTBLOOMSTR 860
#constant AIACTEFFECTINCBLOOMSTR 861
#constant AIACTEFFECTDECBLOOMSTR 862
#constant AIACTEFFECTWATERSPEED 863
#constant AIACTEFFECTINCWATERSPEED 864
#constant AIACTEFFECTDECWATERSPEED 865
#constant AIACTEFFECTWATERSMOOTH 866
#constant AIACTEFFECTINCWATERSMOOTH 867
#constant AIACTEFFECTDECWATERSMOOTH 868
#constant AIACTEFFECTWATERCOLORR 869
#constant AIACTEFFECTWATERCOLORG 870
#constant AIACTEFFECTWATERCOLORB 871
#constant AIACTEFFECTUNDERWATERCOLORR 872
#constant AIACTEFFECTUNDERWATERCOLORG 873
#constant AIACTEFFECTUNDERWATERCOLORB 874
#constant AIACTEFFECTWATERREFLECTION 875
#constant AIACTEFFECTINCWATERREFLECTION 876
#constant AIACTEFFECTDECWATERREFLECTION 877
#constant AIACTEFFECTWATERREFRACTION 878
#constant AIACTEFFECTINCWATERREFRACTION 879
#constant AIACTEFFECTDECWATERREFRACTION 880
#constant AIACTEFFECTWATERFRESNEL 881
#constant AIACTEFFECTINCWATERFRESNEL 882
#constant AIACTEFFECTDECWATERFRESNEL 883
#constant AIACTEFFECTWATERLEVEL 884
#constant AIACTEFFECTINCWATERLEVEL 885
#constant AIACTEFFECTDECWATERLEVEL 886
#constant AIACTEFFECTSHADOWSTR 887
#constant AIACTEFFECTINCSHADOWSTR 888
#constant AIACTEFFECTDECSHADOWSTR 890
#constant AIACTEFFECTSHADOWQTY 891
#constant AIACTEFFECTINCSHADOWQTY 892
#constant AIACTEFFECTDECSHADOWQTY 893
#constant AIACTEFFECTWINDOWREFRACTION 894
#constant AIACTEFFECTINCWINDOWREFRACTION 895
#constant AIACTEFFECTDECWINDOWREFRACTION 896
#constant AIACTVOLUMEINGAMEMUSIC 897
#constant AIACTVOLUMEINCINGAMEMUSIC 898
#constant AIACTVOLUMEDECINGAMEMUSIC 899
#constant AIACTVOLUMEPLAYERSOUNDS 900
#constant AIACTVOLUMEINCPLAYERSOUNDS 901
#constant AIACTVOLUMEDECPLAYERSOUNDS 902
#constant AIACTVOLUMEINGAMESOUNDS 903
#constant AIACTVOLUMEINCINGAMESOUNDS 904
#constant AIACTVOLUMEDECINGAMESOUNDS 905
#constant AIACTBACKDROP 1001
#constant AIACTMUSIC 1011
#constant AIACTMUSICVOLUME 1012
#constant AIACTSOUNDSCALE 1013
#constant AIACTVIDEO 1021
#constant AIACTLIGHTON 1051
#constant AIACTLIGHTOFF 1052
#constant AIACTLIGHTRED 1053
#constant AIACTLIGHTGREEN 1054
#constant AIACTLIGHTBLUE 1055
#constant AIACTLIGHTRANGE 1056
#constant AIACTHUDRESET 1100
#constant AIACTHUDX 1101
#constant AIACTHUDY 1102
#constant AIACTHUDZ 1103
#constant AIACTHUDSIZEX 1104
#constant AIACTHUDSIZEY 1105
#constant AIACTHUDSIZEZ 1106
#constant AIACTHUDRED 1107
#constant AIACTHUDGREEN 1108
#constant AIACTHUDBLUE 1109
#constant AIACTHUDIMAGE 1110
#constant AIACTHUDIMAGEFINE 1111
#constant AIACTHUDFONT 1112
#constant AIACTHUDSIZE 1113
#constant AIACTHUDTEXT 1114
#constant AIACTHUDTYPE 1115
#constant AIACTHUDHIDE 1116
#constant AIACTHUDSHOW 1117
#constant AIACTHUDUNSHOW 1118
#constant AIACTHUDNAME 1119
#constant AIACTHUDANIM 1120
#constant AIACTHUDFADEOUT 1121
#constant AIACTHUDMAKE 1199
#constant AIACTNEWGAME 1201
#constant AIACTLOADGAME 1202
#constant AIACTSAVEGAME 1203
#constant AIACTCONTINUEGAME 1204
#constant AIACTQUITGAME 1205
#constant AIACTPAUSEGAME 1206
#constant AIACTRESUMEGAME 1207
#constant AIACTHOSTGAME 1208
#constant AIACTJOINGAME 1209
#constant AIACTREPEATGAME 1210
#constant AIACTTIMERSTART 1211
#constant AIACTQUICKLOADGAME 1212
#constant AIACTQUICKSAVEGAME 1213
#constant AIACTLAST 1300

rem AI Counters
global actstringmax=0
global conindexcount=0
global aicondseqcount=0
global actindexcount=0
global aiactseqcount=0
global hudmax=0
global hudfadeoutoneatatime=0
global internalloaderhud=0
global internaleyehud=0
global internalfaderhud=0

rem AI BC Sound
global bcsoundstrength#
global bcsoundx#
global bcsoundy#
global bcsoundz#

rem AI actions
type aiactiontype
 type as integer
 value as float
 filename as string
endtype
dim aiactionseq(10000) as aiactiontype
type aiactionitemtype
 first last
endtype
dim aiaction(500) as aiactionitemtype
dim actstring$(actstringmax)

rem AI conditions
type aiconditiontype
 type as integer
 valuea as float
 valueb as float
 valuec as float
endtype
dim aiconditionseq(10000) as aiconditiontype
type aiconditionitemtype
 first last
 action as integer
endtype
dim aicond(500) as aiconditionitemtype

rem AI Library List
type ailiblisttype
 loaded as integer
 file$ as string
 desc$ as string
 conditionfirst as integer
 conditionlast as integer
endtype
dim ailist(200) as ailiblisttype

rem AI Library Count
if leavegamedataalone=0
 dim scriptbank$(100)
 aiindexmaster=0
endif

`
` Waypoint Data Structures
`

rem Waypoint data structure
type waypointtype
 count as integer
 start as integer
 finish as integer
endtype
type waypointcoordtype
 x as float
 y as float
 z as float
 link as integer
 index as integer
endtype
dim waypointcoord(1000) as waypointcoordtype
dim waypoint(10) as waypointtype
global waypointeditheight#=0
global waypointcoordmax=0
global waypointmax=0
`
` Global Particle and Debris Data Structures
`
dim debris(32)


`
` Gun Data Structures
`

rem Gun Sounds Data Structure
type gunsoundbanktype
 name$ as string
 soundid as integer
endtype
type gunsoundbankcompaniontype
 soundid as integer
endtype
type gunsounditemtype
 keyframe as integer
 playsound as integer
 lastplay as integer
endtype
type gunsoundstype
 soundframes as integer
 fireloopend as integer
endtype

rem Gun Settings Data Structure
type gunsettingstype
 muzzleflash as integer
 muzzlex# as float
 muzzley# as float
 muzzlez# as float
 muzzlesize# as float
 muzzlecolorr as integer
 muzzlecolorg as integer
 muzzlecolorb as integer
 brass as integer
 smoke as integer
 flashlimb as integer
 brasslimb as integer
 smokelimb as integer
 flashlimb2 as integer
 brasslimb2 as integer
 smokelimb2 as integer
 handlimb as integer
 flashimg as integer
 newflashimg as integer
 muzzlelasertype as integer
 brassobjmaster as integer
 smokeimg as integer
 crosshairimg as integer
 flakname$ as string
 flakindex as integer
 seconduse as integer
 damage as integer
 damagetype as integer
 impactforce as integer
 scorchtype as integer
 reloadqty as integer
 weaponisammo as integer
 iterate as integer
 accuracy as integer
 zoommode as integer
 zoomaccuracy as integer
 range as integer
 smokespeed as integer
 smokedecal$ as string
endtype

rem Gun Actions Data Structure
type gunanimtype
 s as integer
 e as integer
endtype
type gunactionstype
 show as gunanimtype
 idle as gunanimtype
 move as gunanimtype
 start as gunanimtype
 automatic as gunanimtype
 finish as gunanimtype
 startreload as gunanimtype
 reloadloop as gunanimtype
 endreload as gunanimtype
 cock as gunanimtype
 hide as gunanimtype
endtype

rem Gun Data Structure (is 10 our maximum for the entire game, ie weapon slots max?)
type guntype
 activeingame as integer
 obj as integer
 secondobj as integer
 name$ as string
 weapontype as integer
 texd$ as string
 effect$ as string
 zoomscope$ as string
 zoomscope as integer
 decal$ as string
 decalid as integer
 effectidused as integer
 transparency as integer
 settings as gunsettingstype
 sound as gunsoundstype
 action as gunactionstype
 hudimage as integer
 horiz# as float
 vert# as float
 forward# as float
endtype
dim gun(100) as guntype
dim gunsound(100,5) as gunsoundbanktype
dim gunsoundcompanion(100,5,2) as gunsoundbankcompaniontype
dim gunsounditem(100,50) as gunsounditemtype
dim brassfallcount(30)
global autoloadgun=0
global gunslotmax=0
global gunmax
global gunflashcount as float

rem Flak Profile Structure
type flakprofiletype
 lifespan as integer
 xinc as float
 yinc as float
 zinc as float
 xspeed as float
 yspeed as float
 zspeed as float
 weight as float
 spinx as float
 bounceonhit as integer
 explodeonhit as integer
 damage as integer
endtype

rem Flak Sound Data Structure
type flaksoundtype
 sndbounce$ as string
 sndbounceid as integer
 sndexplode$ as string
 sndexplodeid as integer
endtype

rem Flak Data Structure
type flaktype
 obj as integer
 name$ as string
 usedsoload as integer
 exponfloor$ as string
 exponfloorid as integer
 expinair$ as string
 expinairid as integer
 profile as flakprofiletype
 sound as flaksoundtype
 throwangle as integer
 throwforward as integer
 throwheight as integer
endtype
dim flak(10) as flaktype
global flakmax=0

rem Flak Elements Data Structure
type flakelementtype
 flakid as integer
 profile as flakprofiletype
 active as integer
 range as integer
 obj as integer
 xpos as float
 ypos as float
 zpos as float
 owner as integer
 noimpactdelay as float
 abovewater as integer
endtype
global flakelementmax=100
dim flakelement(flakelementmax) as flakelementtype

rem NewMuzzle Flash Data Structures
global muzzlecycle=1
global newmuzzlemax=30
dim newmuzzle(newmuzzlemax)

rem Decal Structure (explosions, lightdlare, smoke, steam, plasma)
type decaltype
 active as integer
 imageid as integer
 name$ as string
 across as integer
 down as integer
 offsety as float
 framemax as integer
 scale as integer
endtype
global decalmax=10
dim decal(decalmax) as decaltype

rem Decal Element Structure (reusable instances)
type decalelementtype
 decalid as integer
 active as integer
 obj as integer
 xpos as float
 ypos as float
 zpos as float
 frame as integer
 framedelay as integer
 orient as integer
 originator as integer
 scalemodx as float
 scalemody as float
 looping as integer
 keepalivefornextloop as integer
 alphafactor as integer
endtype
global decalelementmax=100
dim decalelement(decalelementmax) as decalelementtype

`
` Players Data
`

rem Input Command Structure
type inputcommandtype
 take drop newweapon
endtype
type playerstatetype
 moving firingmode
endtype

rem Weapon Data Structure
type weaponslottype
 pref got invpos
endtype
if leavegamedataalone=0
 dim weaponslot(10) as weaponslottype
 dim weaponammo(10) as integer
 dim weaponclipammo(10) as integer
 for ws=1 to 10 : weaponslot(ws).pref=0 : next ws
endif
dim weaponhud(10) as integer

rem Inventory Data Structure
type inventorytype
 new as integer
 drop as integer
 index as integer
endtype

rem Players Data Structure
type playertype
 serverplayer as integer
 command as inputcommandtype
 state as playerstatetype
 x as float
 y as float
 z as float
 envstate as integer
 envassociatedentity as integer
 recovershield as integer
 health as integer
 healthmax as integer
 lives as integer
 livesmax as integer
 air as integer
 airmax as integer
 inventorymax as integer
 usingaction as integer
 score as integer
 scoremax as integer
 jumpheight as integer
endtype
type playertrailtype
 time as DWORD
 x as float
 y as float
 z as float
endtype
global playermax=1
global playertrailmax=0
dim player(playermax) as playertype
dim playersound(playermax,520) as integer
dim playersoundtimeused(playermax,520) as DWORD
dim playersoundset$(playermax) as string
dim playersoundsetindex(playermax) as integer
global soundsetlistmax : soundsetlistmax=0
dim soundsetlist$(soundsetlistmax)
dim soundsetlist(soundsetlistmax)
dim soundvolumes(2) as integer
dim playermovementstep(playermax) as float
dim playerinventory(playermax,100) as inventorytype
dim playertrial(100) as playertrailtype
playersoundset$(1)=""
global playerairtimer as DWORD : playerairtimer=0
global playerairloss as float : playerairloss=0

rem Player Mission
global missiongoaltotal as integer
dim playerobjective(99) as integer

rem Player+Multiplayer Related Data
global multiplayeridlinkmax : multiplayeridlinkmax=0
dim multiplayeridlink(16) as DWORD
dim multiplayername$(16) as string
dim multiplayerisnew(16) as integer
dim multiplayerplrindex(16) as integer
dim multiplayeri(16) as integer

rem Infini-Light Data Structure
type colrgbtype
 r g b
endtype
type infinilighttype
 used as integer
 type as integer
 x as float
 y as float
 z as float
 range as float
 id as integer
 dist as float
 colrgb as colrgbtype
 islit as integer
endtype
dim infinilight(0) as infinilighttype
empty array infinilight(0)
dim infinilightshortlist(0)
empty array infinilightshortlist(0)
global avlightposx# as float
global avlightposy# as float
global avlightposz# as float

rem Shadow Lights Data Structure
type shadowlighttype
 x# y# z# range#
endtype
dim shadowlight(0) as shadowlighttype

rem Light Table used to accelerate lighting of entities
type lighttabletype
 r as float
 g as float
 b as float
 x as float
 y as float
 z as float
endtype
dim lighttable(viscolx,viscoly,viscolz) as lighttabletype

rem Material settings
type materialsettingstype
 name$ as string
 tred0$ as string
 tred1$ as string
 tred2$ as string
 tred3$ as string
 noise as integer
 scrape$ as string
 scrapeid as integer
 impact$ as string
 impactid as integer
 destroy$ as string
 destroyid as integer
 freq as integer
 decal$ as string
 decalid as integer
endtype
dim material(100) as materialsettingstype
global gmaterialmax=0

rem Data structure for Bit-Fragments
type bitdetailstype
 max as integer
 file$ as string
 collisionmode as integer
 fragmentobjstart as integer
 choice as integer
 sizex as float
 sizey as float
 sizez as float
endtype
type bitoffsettype
 x# y# z#
endtype
dim bitdetails(10) as bitdetailstype
dim bitoffset(10,8) as bitoffsettype

rem Explosion Data Structure
type explodetype
 obj as integer
 explode as integer
 explodesound as integer
 dist# as float
 smoke# as float
 fade# as float
 x as float
 y as float
 z as float
endtype
global explodermax=4
dim exploder(explodermax) as explodetype

rem GUI Visual Settings
type guivisualsettingstype
 updateflag as integer
 ambience as integer
 shadows as integer
 shadowstrength as integer
 shadowshades as integer
 dynamiclightcount as integer
endtype
guivisualsettings as guivisualsettingstype

rem HUD structure
type hudtype
 name$ as string
 maintype as integer
 typemode as integer
 posx as float
 posy as float
 posz as float
 sizex as integer
 sizey as integer
 sizez as integer
 red as integer
 green as integer
 blue as integer
 fadeout as float
 baseanim as integer
 image as integer
 font$ as string
 fontsize as integer
 text$ as string
 hide as integer
 hidedelay as float
 highlighted as integer
 width as integer
 height as integer
endtype
dim hud(10) as hudtype

rem gun counters
global gunbrasscount as float
global gunsmokecount as float
global guntimercount as float

rem Setup work floats (for HUD decimal detail)
value1 as float
value2 as float
value3 as float
workhudx as float
workhudy as float
workhudz as float

rem FPSCV104 Fog globals
global hudfogon as integer
global hudfoglaston as integer
global dim hudfognear(2) as float : hudfognear(0)=4000 : hudfognear(1)=100
global hudfogfar as float
global dim hudfogred(2) as float : hudfogred(1)=0
global dim hudfoggreen(2) as float : hudfoggreen(1)=0
global dim hudfogblue(2) as float : hudfogblue(1)=255

rem X10 hud values ( X10 effects menu values )
dim hudcolorbar(100)
global sky$ as string : sky$=""
global hudskyvalue as integer : hudskyvalue=0
global hudskymax as integer : hudskymax=0
global dim hudbloomwidth(2) as float : hudbloomwidth(0)=25 : hudbloomwidth(1)=50
global dim hudbloomstrength(2) as float : hudbloomstrength(0)=5 : hudbloomstrength(1)=15
global hudbloomfromhurtcounter : hudbloomfromhurtcounter=0
global hudwaterspeed as float : hudwaterspeed=30
global hudwaterdepth as float : hudwaterdepth=50
global hudwatercolor as float : hudwatercolor=255
global hudunderwatercolor as float : hudunderwatercolor=255
global hudwaterrefl as float : hudwaterrefl=100
global hudwaterrefr as float : hudwaterrefr=100
global hudwaterrefrupdate as integer : hudwaterrefrupdate=0
global hudwaterfresnel as float : hudwaterfresnel=50
global hudshadowstrength as float : hudshadowstrength=50
global hudshadowquantity as float : hudshadowquantity=10
global hudglassrefr as float : hudglassrefr=50
global grefractionshadereffect : grefractionshadereffect=0
global waterisbelowplayer as integer : waterisbelowplayer=1
global watertransitionbyrestart as integer : watertransitionbyrestart=0
global hudupdateeffects as integer : hudupdateeffects=1
global hudmusicvolume as integer : hudmusicvolume=50

rem X10 water globals
global tchangethewaterclipping as integer : tchangethewaterclipping=2
global oldwaterlevel# as float : oldwaterlevel#=-1.0
global waterlevel# as float : waterlevel#=-1.0
global usewaterlevelfromprevioussession# as float : usewaterlevelfromprevioussession#=-1
global waterdecalripplemaster  waterdecalripplemaster=0
global waterdecalripple : waterdecalripple=0

rem X10 crosshair HUD
global hudcrosshair : hudcrosshair=0

rem World Physics Settings
global physicson=1
global physicsdebug=0 : rem gdebugphysicsstate will set this to one!
global physicsgravx#=0.0
global physicsgravy#=0 : physicsgravy#=-40.0
global physicsgravz#=0.0
global physicsplayerweight# : physicsplayerweight#=500.0
global grav# as float : grav#=0
global camerapositionx as float : camerapositionx=0
global camerapositiony as float : camerapositiony=0
global camerapositionz as float : camerapositionz=0
global cameraspeed as float : cameraspeed=0
global camerapickup as integer : camerapickup=1
global cameraholding as integer : cameraholding=0
global camerapickupkeyrelease : camerapickupkeyrelease=0
global camerareach# as float : camerareach#=0
global camerareachatrun# as float : camerareachatrun#=0
global camerareachmax# as float : camerareachmax#=75
global camerapickedangle# as float : camerapickedangle#=0
global camerapicked as integer : camerapicked=0
global camerapickede as integer : camerapickede=0
global camerapickeddrop as integer : camerapickeddrop=0
global camerapickedthrown as integer : camerapickedthrown=0
global camerathrow# as float : camerathrow#=100.0
global camerathrowelev# as float : camerathrowelev#=0.0
global cameradampen# : cameradampen#=1.0
global cameradampenactive : cameradampenactive=0
global cameracarryweight# : cameracarryweight#=4000
dim phyobjvelocity#(1)
dim phylasttravelled#(1)
dim phylastfloorstop#(1)
dim phyobjsounding(1)
dim phyobjremove(1)
dim phyobjele(1)
dim phyobjelenudged(1)
dim shadowobj(1)

rem Respawn array for arena game
type respawntype
 e as integer
 x as float
 y as float
 z as float
 ry as float
endtype
dim respawn(16) as respawntype
global respawnmax : respawnmax=0
global singleplrspawnfreeze : singleplrspawnfreeze=0

rem Multiplayer globals and structures
global hudiplistmax : hudiplistmax=-1
dim hudiplist$(20,1)
global repeatsamelevel : repeatsamelevel=0
global winnersname$ as string : winnersname$=""
global servername$ : servername$="FPSC Creator Portal"
global ipaddress$
global multiplayerinitialised as integer
global createorjoin as integer
global lagmon# as float
global startofrecording as DWORD
global dwBurstTime as DWORD
global dwStartTime as DWORD
global dwStartJoinTime as DWORD
global dwPlayerID as DWORD
global timestampforlagtest as DWORD
global locallagtime as DWORD
global dwMessageCode as DWORD
global dwCode as DWORD
global dwLocalPlayerID as DWORD
global iLocalEL as integer
global PlayerCanStart as integer
global Servergameisfull as integer
global gterminationcountdown as integer
global tenminutetimer as DWORD
global cameratimeslice as DWORD
rem talktoaster arrays
dim talkscript$(10)
dim talkscriptcount(10)
dim talkscriptwho(10)
global talkindex as integer
global gtalkytoaster as integer
global talkpingsound as integer
rem Characters (chosen is indexed by iLocalEL, list is flaglist of used identities)
global multiplayermax : multiplayermax=16
dim characterchosen(multiplayermax)
dim characterchoiceentityindex(multiplayermax)
dim characterlist$(multiplayermax) as string
dim characterlist(multiplayermax)
dim characterlistentity(multiplayermax)
rem Dead reckoning temp arrays
dim cpx#(4)
dim cpy#(4)
dim cpz#(4)
dim stategetready(multiplayermax)
dim statex(multiplayermax)
dim statey(multiplayermax)
dim statez(multiplayermax)
dim statea(multiplayermax)
dim stateanim(multiplayermax)
dim stateanimdir(multiplayermax)
dim statecolmaterialtype(multiplayermax)
dim stateanimwait(multiplayermax)
dim statewhodidit(multiplayermax)
dim stateplayagain(multiplayermax)
dim stateviewy(multiplayermax) as float
dim statesviewdy(multiplayermax) as float
dim stateweapon(multiplayermax)
dim stateannounce(multiplayermax)
dim statesx(multiplayermax)
dim statesy(multiplayermax)
dim statesz(multiplayermax)
dim statesa(multiplayermax)
dim statesvel(multiplayermax) as float
dim statetx(multiplayermax)
dim statety(multiplayermax)
dim statetz(multiplayermax)
dim statedx(multiplayermax)
dim statedy(multiplayermax)
dim statedz(multiplayermax)
dim statemove(multiplayermax)
dim statelag(multiplayermax) as float
dim statemsgap(multiplayermax) as float
dim statemytimer(multiplayermax) as DWORD
dim statecodeupdate(multiplayermax,4)
dim stateraycastpace(multiplayermax)

rem Server Scores
dim frags(multiplayermax) as integer

rem End of FULL-DATA-INIT Subroutine
return


`
` Initialise using SETUP.INI
`

_FPSC_Setup:

rem Very first task is find and load BUILD.INI (if flagged)
global gcompilestandaloneexe : gcompilestandaloneexe=0
global gbuildpath$ as string
global gbuildname$ as string

rem Find and load SETUP.INI settings as global states
global grealgameviewstate : grealgameviewstate=0
global gskipuniversebuild : gskipuniversebuild=0
global gmultiplayergame : gmultiplayergame=0
global gdebugreportmodestate : gdebugreportmodestate=0
global gexitpromptreportmodestate : gexitpromptreportmodestate=0
global gdebugphysicsstate : gdebugphysicsstate=0
global gdebugreportstepthroughstate : gdebugreportstepthroughstate=0
global gshowentitygameinfostate : gshowentitygameinfostate=0
global gshowdebugtextingamestate : gshowdebugtextingamestate=0
global gincludeonlyvideo : gincludeonlyvideo=0
global gincludeonlyname$ : gincludeonlyname$=""
global gignorefastbone : gignorefastbone=0
global glightmappingstate : glightmappingstate=1
`global glightmapsize : glightmapsize=8 `preV104RC8
`global glightmapquality : glightmapquality=100
global glightmappingold : glightmappingold=0
global glightshadowsstate : glightshadowsstate=0
global glightambientr : glightambientr=0
global glightambientg : glightambientg=0
global glightambientb : glightambientb=0
global glightsunx : glightsunx=0
global glightsuny : glightsuny=-1
global glightsunz : glightsunz=0
global glightsunr : glightsunr=0
global glightsung : glightsung=0
global glightsunb : glightsunb=0
global glightzerorange : glightzerorange=100
global glightatten : glightatten=16
global glightmaxsize : glightmaxsize=-1
global glightboost : glightboost=4
global glighttexsize : glighttexsize=512
global glightquality : glightquality=10
global glightblurmode : glightblurmode=1
global glightthreadmax : glightthreadmax=0
global gdynamiclightingstate : gdynamiclightingstate=1
global gdefaultwaterlevelstate : gdefaultwaterlevelstate=1
global gdynamicshadowsstate : gdynamicshadowsstate=1
global guseeffectstate : guseeffectstate=0
global guseeffectongunsstate : guseeffectongunsstate=0
global guseeffectonscenesstate : guseeffectonscenesstate=0
global guseeffectonentitiesstate : guseeffectonentitiesstate=0
global gdividetexturesize : gdividetexturesize=0
global goptimizemode : goptimizemode=0
global ghsrmode : ghsrmode=0
global guseskystate : guseskystate=1
global gusefloorstate : gusefloorstate=0
global guseenvsoundsstate : guseenvsoundsstate=1
global guseweaponsstate : guseweaponsstate=1
global gindieditorstate : gindieditorstate=0
global gdisplaywidth : gdisplaywidth=screen width()
global gdisplayheight : gdisplayheight=screen height()
global gdisplaydepth : gdisplaydepth=screen depth()
global guniquesignature as DWORD : guniquesignature=0
global ggameobjectivetype : ggameobjectivetype=0
global ggameobjectivevalue : ggameobjectivevalue=0
global goneshotkills : goneshotkills=0
global numberofplayers : numberofplayers=8
global gspawnrandom : gspawnrandom=0
global guniquegamecode$ : guniquegamecode$=""
global guseuniquelynamedentities : guseuniquelynamedentities=0
global gexportassets : gexportassets=0
global gproducelogfiles : gproducelogfiles=0
global ggodmodestate : ggodmodestate=0
global glevelmax : glevelmax=1
global level : level=1
global glocalserveroverride$ : glocalserveroverride$=""
global bloodmode$ : bloodmode$=""
global gghostrunmode : gghostrunmode=0
global gautorefractionmode : gautorefractionmode=0
global gphysicshasbeeninitialised : gphysicshasbeeninitialised=0
global gfadeoutragdolls : gfadeoutragdolls=1
global gautoshadowreducer : gautoshadowreducer=0
global graphicscardtype : graphicscardtype=0
global graphicscardislow : graphicscardislow=0
global gdisablecamerasmoothing : gdisablecamerasmoothing=0
       
rem X10 - 291007 - determine which 3D card is being used
perform checklist for graphics cards
for c=1 to checklist quantity()
 card$=lower$(checklist string$(c))
 for n=0 to len(card$)-5
  rem NVIDIA
  if left$(right$(card$,len(card$)-n),4)="8400" then graphicscardtype=8400
  if left$(right$(card$,len(card$)-n),4)="8500" then graphicscardtype=8500
  if left$(right$(card$,len(card$)-n),7)="8500 gt" then graphicscardtype=8501
  if left$(right$(card$,len(card$)-n),4)="8600" then graphicscardtype=8600
  if left$(right$(card$,len(card$)-n),4)="8800" then graphicscardtype=8800
  rem ATI
  if left$(right$(card$,len(card$)-n),4)="2900" then graphicscardtype=2900
 next n
next c

rem X10 - 291007 - reduce default effects when graphics card is low end
if graphicscardtype=8400 or graphicscardtype=8500 or graphicscardtype=8501 or graphicscardtype=8600
 graphicscardislow=1
 hudwaterrefl=0
 hudwaterrefr=0
 hudshadowquantity=0
 hudglassrefr=0
else
 graphicscardislow=0
endif

rem Version Control - TEST GAME Mode
global gtestgamemodefromeditor : gtestgamemodefromeditor=0
global grestarttestgame : grestarttestgame=0
global gtestgamemodefromeditorokaypressed : gtestgamemodefromeditorokaypressed=0
gosub _version_commandlineprompt

rem The MYDOCS folder
global mydocumentsdir$ : mydocumentsdir$=mydocdir$()+"\"
global myfpscx10files$ : myfpscx10files$="FPSC X10 Files"
global myownrootdir$ : myownrootdir$=mydocumentsdir$+myfpscx10files$+"\"

rem Default, unless overridden by BUILD -B
global setupfilename$
setupfilename$=myownrootdir$+"setup.ini"

rem X10 Game Engine Exe resides in BIN folder during test/build
if path exist("Files")=0
 rem We are in the BIN folder - must be called from EDITOR
 backtolastdir$=get dir$()
 set dir ".."
 if path exist("Files")=0
  set dir backtolastdir$
 endif
else
 rem if a BIN file is not here..
 if path exist("Bin")=0
  rem This can only be the standalone game running, so modify myownroot
  rem uses Files\ folder first as we are in the root, then later setup.ini on its own
  myownrootdir$="" : setupfilename$="Files\setup.ini"
 endif
endif

rem Extract this to MYDOC if not exist (before SETUP read)
setupinitialisedforfirsttime=0
if myownrootdir$<>""
 `
 change registry hkey 1 : rem to HKEY_CURRENT_USER (1)
 told$=get dir$()
 tpath$="Files\FPSC X10 Files"
 fpscx10extractionlogfile$=mydocumentsdir$+"\FPSC X10 Extraction.log"
 if path exist(tpath$)=1
  rem X10 - 171007 - Extraction log
  reporttologfile$(fpscx10extractionlogfile$,"Extraction path exists")
  rem if registry shows this user running for first time, copy X10 files
  if get registry("Software\The Game Creators\FPS Creator X10","UsingForFirstTime")=0
   `
   rem reset registry
   reporttologfile$(fpscx10extractionlogfile$,"Writing once only to registy")
   write to registry "Software\The Game Creators\FPS Creator X10","UsingForFirstTime",1  
   `
   rem switch to documents
   reporttologfile$(fpscx10extractionlogfile$,"Switching to documents folder: "+mydocumentsdir$)
   set dir mydocumentsdir$
   `
   rem we copy over and extract these files to the MY DOCUMENTS area, copy zip file
   reporttologfile$(fpscx10extractionlogfile$,"Create FPSC X10 Files folder in documents")
   if path exist("FPSC X10 Files")=0 then make directory "FPSC X10 Files"
   `
   rem copy everything from ROOT to DOCUMENTS in 'FPSC X10 Files'
   set dir told$+"\Files"
   reporttologfile$(fpscx10extractionlogfile$,"Switching back to root for scan copy: "+told$+"\Files\")
   scancopy("FPSC X10 Files","",mydocumentsdir$+"FPSC X10 Files\",fpscx10extractionlogfile$)
   `
   rem restore folder and done
   reporttologfile$(fpscx10extractionlogfile$,"Restoring folder to '"+told$+"'.")
   set dir told$
   `
   rem Trigger SETUP.INI to be altered if gfx card low
   setupinitialisedforfirsttime=1
   `
  else
   if file exist(fpscx10extractionlogfile$)=1
    rem no need to have this file after successfil re-run
    delete file fpscx10extractionlogfile$
   endif
  endif
  `
  rem X10 - 040208 - Copy over ANY scripts from Program Files to MYDOC area (new model items logic)
  tstorebeforegoin$=get dir$()
  copyoveruniquescripts(told$+"\Files\scriptbank\",myownrootdir$+"scriptbank\")
  set dir tstorebeforegoin$
  `
 endif
endif

rem COMMANDLINE Info
if lower$(cl$())="-b"
 `
 rem BUILD settings
 gcompilestandaloneexe=1
 setupfilename$=myownrootdir$+"buildsetup.ini"
 tfile$=myownrootdir$+"build.ini"
 if file exist(tfile$)=1
  dim data$(99)
  load array tfile$,data$()
  for l=0 to 99
   line$=data$(l)
   if len(line$)>0
    if lower$(left$(line$,4))=";end" then exit
    if left$(line$,1)<>";"
     `
     rem take fieldname and values
     for c=0 to len(line$)
      if mid$(line$,c)="=" then mid=c : exit
     next c
     field$=lower$(removeedgespaces(left$(line$,mid-1)))
     value$=removeedgespaces(right$(line$,len(line$)-mid))
     for c=0 to len(value$)
      if mid$(value$,c)="," then mid=c : exit
     next c
     value1=val(removeedgespaces(left$(value$,mid-1)))
     value2$=removeedgespaces(right$(value$,len(value$)-mid))
     if len(value2$)>0 then value2=val(value2$) else value2=-1
     `
     rem collect data from fields in setup file
     tryfield$="path" : if field$=tryfield$ then gbuildpath$=value$
     tryfield$="name" : if field$=tryfield$ then gbuildname$=value$
     `
    endif
   endif
  next l
  undim data$()
 endif
 `
endif

rem RESTORE MAP Mode
global grestoreeditorsettings : grestoreeditorsettings=0
if lower$(cl$())="-r"
 grestoreeditorsettings=1
endif

rem SETUP Info`
tfile$=setupfilename$
if file exist(tfile$)=1
 `
 rem Load Data from file
 dim data$(999)
 load array tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem collect data from fields in setup file
    tryfield$="realgameview" : if field$=tryfield$ then grealgameviewstate=value1
    tryfield$="multiplayergame" : if field$=tryfield$ then gmultiplayergame=value1
    tryfield$="debugreport" : if field$=tryfield$ then gdebugreportmodestate=value1
    tryfield$="exitpromptreport" : if field$=tryfield$ then gexitpromptreportmodestate=value1
    tryfield$="debugphysics" : if field$=tryfield$ then gdebugphysicsstate=value1
    tryfield$="debugreportstepthrough" : if field$=tryfield$ then gdebugreportstepthroughstate=value1
    tryfield$="showentitygameinfo" : if field$=tryfield$ then gshowentitygameinfostate=value1
    tryfield$="showdebugtextingame" : if field$=tryfield$ then gshowdebugtextingamestate=value1
    tryfield$="includeonlyvideo" : if field$=tryfield$ then gincludeonlyvideo=value1
    tryfield$="includeonlyname" : if field$=tryfield$ then gincludeonlyname$=value$
    tryfield$="ignorefastbone" : if field$=tryfield$ then gignorefastbone=value1
    tryfield$="loadreport" : if field$=tryfield$ then gloadreportstate=value1
    `
    tryfield$="optimizemode" : if field$=tryfield$ then goptimizemode=value1
    tryfield$="hsrmode" : if field$=tryfield$ then ghsrmode=value1
    tryfield$="lightmapping" : if field$=tryfield$ then glightmappingstate=value1
    `tryfield$="lightmapsize" : if field$=tryfield$ then glightmapsize=value1
    `tryfield$="lightmapquality" : if field$=tryfield$ then glightmapquality=value1
    tryfield$="lightmapold" : if field$=tryfield$ then glightmappingold=value1
    tryfield$="lightmapshadows" : if field$=tryfield$ then glightshadowsstate=value1
    tryfield$="lightmapambientr" : if field$=tryfield$ then glightambientr=value1
    tryfield$="lightmapambientg" : if field$=tryfield$ then glightambientg=value1
    tryfield$="lightmapambientb" : if field$=tryfield$ then glightambientb=value1
    tryfield$="lightmapsunx" : if field$=tryfield$ then glightsunx=value1
    tryfield$="lightmapsuny" : if field$=tryfield$ then glightsuny=value1
    tryfield$="lightmapsunz" : if field$=tryfield$ then glightsunz=value1
    tryfield$="lightmapsunr" : if field$=tryfield$ then glightsunr=value1
    tryfield$="lightmapsung" : if field$=tryfield$ then glightsung=value1
    tryfield$="lightmapsunb" : if field$=tryfield$ then glightsunb=value1
    tryfield$="lightmapzerorange" : if field$=tryfield$ then glightzerorange=value1
    tryfield$="lightmapatten" : if field$=tryfield$ then glightatten=value1
    tryfield$="lightmapmaxsize" : if field$=tryfield$ then glightmaxsize=value1
    tryfield$="lightmapboost" : if field$=tryfield$ then glightboost=value1
    tryfield$="lightmaptexsize" : if field$=tryfield$ then glighttexsize=value1
    tryfield$="lightmapquality" : if field$=tryfield$ then glightquality=value1
    tryfield$="lightmapblurmode" : if field$=tryfield$ then glightblurmode=value1
    tryfield$="lightmapthreadmax" : if field$=tryfield$ then glightthreadmax=value1

    `x9tryfield$="dynamiclighting" : if field$=tryfield$ then gdynamiclightingstate=value1
    `x9tryfield$="dynamicshadows" : if field$=tryfield$ then gdynamicshadowsstate=value1
    tryfield$="defaultwaterlevel" : if field$=tryfield$ then gdefaultwaterlevelstate=value1
    rem X10 always have this flag one until we can edit the map editor to set flag
    tryfield$="dynamicshadows" : if field$=tryfield$ then gdynamicshadowsstate=value1
    
    tryfield$="useeffects" : if field$=tryfield$ then guseeffectstate=value1
    tryfield$="useeffectsonguns" : if field$=tryfield$ then guseeffectongunsstate=value1
    tryfield$="useeffectsonscene" : if field$=tryfield$ then guseeffectonscenesstate=value1
    tryfield$="useeffectsonentities" : if field$=tryfield$ then guseeffectonentitiesstate=value1
    tryfield$="dividetexturesize" : if field$=tryfield$ then gdividetexturesize=value1
    tryfield$="disablecamerasmoothing" : if field$=tryfield$ then gdisablecamerasmoothing=value1
    `
    tryfield$="usesky" : if field$=tryfield$ then guseskystate=value1
    tryfield$="usefloor" : if field$=tryfield$ then gusefloorstate=value1
    tryfield$="useenvsounds" : if field$=tryfield$ then guseenvsoundsstate=value1
    tryfield$="useweapons" : if field$=tryfield$ then guseweaponsstate=value1
    `
    tryfield$="indieditor" : if field$=tryfield$ then gindieditorstate=value1
    tryfield$="godmode" : if field$=tryfield$ then ggodmodestate=value1
    tryfield$="ghostrunmode" : if field$=tryfield$ then gghostrunmode=value1
    tryfield$="autorefractionmode" : if field$=tryfield$ then gautorefractionmode=value1
    `
    `x9tryfield$="width" : if field$=tryfield$ then gdisplaywidth=value1
    `tryfield$="height" : if field$=tryfield$ then gdisplayheight=value1
    `tryfield$="depth" : if field$=tryfield$ then gdisplaydepth=value1
    `
    rem new X10 fields
    tryfield$="capturecodec" : if field$=tryfield$ then gx10settingcapturecodec$=value$
    tryfield$="capturecompression" : if field$=tryfield$ then gx10settingcapturecompression=value1
    tryfield$="capturewidth" : if field$=tryfield$ then gx10settingcapturewidth=value1
    tryfield$="captureheight" : if field$=tryfield$ then gx10settingcaptureheight=value1
    tryfield$="capturefps" : if field$=tryfield$ then gx10settingcapturefps=value1
    tryfield$="capturethreaded" : if field$=tryfield$ then gx10settingcapturethreaded=value1
    tryfield$="capturewait" : if field$=tryfield$ then gx10settingcapturewait=value1
    `
    tryfield$="uniquesignature" : if field$=tryfield$ then guniquesignature=value1
    tryfield$="gameobjectivetype" : if field$=tryfield$ then ggameobjectivetype=value1
    tryfield$="gameobjectivevalue" : if field$=tryfield$ then ggameobjectivevalue=value1
    tryfield$="oneshotkills" : if field$=tryfield$ then goneshotkills=value1
    tryfield$="maxplayers" : if field$=tryfield$ then numberofplayers=value1
    tryfield$="spawnrandom" : if field$=tryfield$ then gspawnrandom=value1
    tryfield$="uniquegamecode" : if field$=tryfield$ then guniquegamecode$=value$
    `
    tryfield$="useuniquelynamedentities" : if field$=tryfield$ then guseuniquelynamedentities=value1
    tryfield$="producelogfiles" : if field$=tryfield$ then gproducelogfiles=value1
    tryfield$="exportassets" : if field$=tryfield$ then gexportassets=value1
    tryfield$="localserver" : if field$=tryfield$ then glocalserveroverride$=value$
    `
    rem all FPI screens
    tryfield$="title" : if field$=tryfield$ then titlefpi$=value$
    tryfield$="global" : if field$=tryfield$ then setupfpi$=value$
    tryfield$="gamewon" : if field$=tryfield$ then gamewonfpi$=value$
    tryfield$="gameover" : if field$=tryfield$ then gameoverfpi$=value$
    tryfield$="levelfpi1" : if field$=tryfield$ then loadingfpi$=value$
    `
    rem Levels
    if field$="levelmax" then glevelmax=value1
    if glevelmax>0
     for v=1 to glevelmax
      tryfield$="levelfpm"+str$(v)
      if field$=tryfield$ then levelfpm$=value$
      tryfield$="levelfpi"+str$(v)
      if field$=tryfield$
       levelfpi$=value$
       dim level$(v) as leveltype
       level$(v).fpm$=levelfpm$
       level$(v).fpi$=levelfpi$
      endif
     next l
    endif
    `
    rem all key actions
    for num=1 to 11
     tryfield$="key"+str$(num)
     if field$=tryfield$ then listkey(num)=value1
    next num
    `
    rem all gun slots
    for num=1 to 9
     tryfield$="slot"+str$(num)
     if field$=tryfield$ then gunslots$(num)=value$
    next num
    `
    rem localization data
    tryfield$="language" : if field$=tryfield$ then language$=value$
    `
   endif
  endif
 next l
 undim data$()
 `
else
 `
 rem no SETUP means running for first time
 rem Editor needs correct settings
 `x9 - now from above global declarations
 `grealgameviewstate=0
 `goptimizemode=1
 `gdefaultwaterlevelstate=1
 `gdynamiclightingstate=1
 `glightmappingstate=1
 `glightshadowsstate=1
 `guseeffectstate=0
 `guseeffectongunsstate=0
 `guseeffectonscenesstate=0
 `guseeffectonentitiesstate=0
 `guseskystate=1
 `gusefloorstate=0
 `guseenvsoundsstate=1
 `guseweaponsstate=1
 `
endif

rem Age Rating Code
gosub _agerating_init

rem USERDETAILS Info`
global language$ : language$=""
tfile$="userdetails.ini"
if file exist(tfile$)=1
 dim data$(999)
 load array tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem localization data
    tryfield$="language" : if field$=tryfield$ then language$=value$
    `
   endif
  endif
 next l
 undim data$()
endif

rem One flag that controls many
if guseeffectstate=0
 guseeffectongunsstate=0
 guseeffectonscenesstate=0
 guseeffectonentitiesstate=0
endif

rem for X10, all effect flags are switched on
if 1
 guseeffectstate=0
 guseeffectongunsstate=0
 guseeffectonscenesstate=1
 guseeffectonentitiesstate=0
endif

rem X10 - 301007 - first time in, set some values after SETUP.INI for low end cards
if graphicscardislow=1 and setupinitialisedforfirsttime=1
 setupinitialisedforfirsttime=0
 gdividetexturesize=4
endif

rem Physics debug mode (to see all collision shapes)
if gdebugphysicsstate=1 then physicsdebug=1

rem Forced switches
if gcompilestandaloneexe=1
 rem Cannot be real game, must optimize
 grealgameviewstate=0
 goptimizemode=1
 rem Wipe any imported unique code (generate when build EXE)
 guniquegamecode$=""
endif
if gtestgamemodefromeditor=1
 grealgameviewstate=0
endif

rem The MyGames folder precedes Files\
global exedir$ : exedir$=mydocumentsdir$+myfpscx10files$+"\X10 executables\"

rem First task for any program is to enter the Files Folder
tnopathprotomode=0
if path exist("Files")=1
 set dir "Files"
else
 tnopathprotomode=1
endif

rem Basic globals for all programs
global gmapeditmode : gmapeditmode=0

rem Establish global files and folders
global imgext$ : imgext$="png"
global rootdir$ : rootdir$=get dir$()+"\"
global browserexe$ : browserexe$="FPSC-Browser.exe"
global browsername$ : browsername$="FPSC TEST Browser"
global segeditexe$ : segeditexe$="FPSC-Segments.exe"
global segeditname$ : segeditname$="FPSC TEST Segment Editor"
global gameexe$ : gameexe$="FPSC-Game.exe"
global gamename$ : gamename$="FPSC Game"

rem However, if running real game executable
if grealgameviewstate=1
 rem my document folder is relocated to game-exe folder
 myownrootdir$="" : rem as the original EXE had the game-files
 setupfilename$="setup.ini"
endif

rem X10 the Common Effects are in effectbank
global commoneffects$ : commoneffects$="effectbank\common\"

rem Default directories
global currentmeshdir$ : currentmeshdir$=rootdir$+"meshbank\"
global currententitydir$ : currententitydir$=rootdir$+"entitybank\"
global currenttexdir$ : currenttexdir$=rootdir$+"texturebank\"
global currentfxdir$ : currentfxdir$=rootdir$+"effectbank\"
global currentpredir$ : currentpredir$=rootdir$+"prefabs\"
global currentsegdir$ : currentsegdir$=rootdir$+"segments\"

rem handle resolutions
gosub _version_setresolution

rem Calculate ratio
global gratiox# : gratiox#=gdisplaywidth : gratiox#=gratiox#/1024.0
global gratioy# : gratioy#=gdisplayheight : gratioy#=gratioy#/768.0

rem Indicate a time stamp for app start time
timestampactivity(0,"Time Stamp Activity Started")

rem Translation Component (load strarr data)
if tnopathprotomode=0
 stdir$=get dir$()
 if language$="" then language$="english"
 set dir "languagebank\"+language$+"\textfiles\"
 global wordlibmax
 if file exist("fpsc-050.ini")=1
  open to read 1,"fpsc-050.ini"
  read string 1,wordlibmax$ : wordlibmax=val(wordlibmax$)
  close file 1
  strarrmax=1
  dim strarr$(wordlibmax)
  dim wordlib$(wordlibmax)
  load array "fpsc-050.txt",wordlib$()
  for n=0 to wordlibmax
   for c=1 to len(wordlib$(n))
    if mid$(wordlib$(n),c)="="
     strarri=val(left$(wordlib$(n),c-1))
     strarr$(strarri)=right$(wordlib$(n),len(wordlib$(n))-c)
     if strarri>strarrmax then strarrmax=strarri
     exit
    endif
   next c
  next n
  undim wordlib$()
 else
  rem language file missing
  exit prompt "FAIL","CANNOT FIND LANGUAGE FILE!"
  end
 endif
 set dir stdir$
endif

rem Version control on EXE Building
gosub _version_endofinit

rem
rem GAME MAIN
rem

rem Create controls for debug view
global gamedebugrefresh : gamedebugrefresh=0
global gamedebugviewtime : gamedebugviewtime=0
global gamedebugviewmem : gamedebugviewmem=GET MEMORY AVAILABLE(0)
global gamedebugviewlastmem : gamedebugviewlastmem=0
global gamedebugview$ : debugviewactivate(1)
global testgametabtoggle : testgametabtoggle=0
global debugviewmode
global debugviewtog

rem Set editor fonts and text style and size
set text font "Calibri"
ink rgb(255,255,255),0
set text size 16

rem Init app
sync on : sync rate 30 : autocam off : disable systemkeys
hide mouse : backdrop off : disable escapekey

rem X10 - 011107 - removed expiry now bETA test over
`rem X10 - 230907 - kill game exe if used beyond spiry date
`td$=get date$() : tm=val(left$(td$,2)) : ty=val(right$(td$,2))
`if ty<>7 or tm=12
` exit prompt "This BETA version expires after the 30th November 2007!","BETA Expired"
` end
`endif

rem If Game is NOT IN TEST MODE, default is full screen shown
if gtestgamemodefromeditor=0 and gcompilestandaloneexe=0
 `
 rem Show window
 timestampactivity(0,"Start Fullscreen")
 gosub _main_game_showwindownow
 `
 `rem If FREEWARE PROMPT tampered, exit (EA ONLY VERSION)
 `if grealgameviewstate=1
 ` filename$="languagebank\"+language$+"\gamecore\huds\freeware.jpg"
 ` fsize=file size(filename$)
 ` if fsize=47319
 `  load image filename$,1
 `  if image exist(1)=1
 `   delete image 1
 `  else
 `   fsize=0
 `  endif
 ` endif
 ` if fsize<>47319
 `  screenprompt(img,strarr$(121))
 `  timestampactivity(0,strarr$(122))
 `  sleep 5000
 `  end
 ` endif
 `endif
 `
 rem splash check at start for splash.jpg existence and size (alter proof)
 dosplashdelay=0 : gosub _version_dosplash
 `
 rem get the actual server IP for information purposes
 if gmultiplayergame=1
  `
  rem connection check and IP gathering
  show mouse
  `
  rem FPSCV105 - 090307 - check FIREWALL
  rem FPSCV105RC2 - 100307 - AND puts the actual HOSTable IP address in serveripaddress$
  gosub _ai_gamelist_checkforfirewall
  `
  rem FPSCV105RC3 - 140307 - also gather the local IP (in case they want a LAN game) ;localipaddress$;
  MULTIPLAYER CREATE TCP SERVER servername$
  localipaddress$=MULTIPLAYER GET IP ADDRESS()
  if left$(localipaddress$,8)<>"192.168." then localipaddress$=""
  for c=1 to len(serveripaddress$)
   if mid$(localipaddress$,c)=":" then localipaddress$=left$(localipaddress$,c-1) : exit
  next c
  MULTIPLAYER DISCONNECT
  `
  rem done with network stuff for now
  hide mouse
  `
 endif
 if image exist(1)=1
  for f=255 to 0 step -20
   cls 0 : set sprite alpha 1,f : sync
  next f
  set sprite alpha 1,0
  cls 0 : sync : cls 0 : sync
  delete sprite 1
  delete image 1
 endif
 `
endif

rem Reset file collector
resetfilecollection()

rem Add localisation text to final game
if gcompilestandaloneexe=1
 addfiletocollection("languagebank\"+language$+"\textfiles\fpsc-050.ini")
 addfiletocollection("languagebank\"+language$+"\textfiles\fpsc-050.txt")
endif

rem Add ODE licenses text files to final game
if gcompilestandaloneexe=1
 rem freeware splash for standalone executable
 gosub _version_includesplashfile
 addfiletocollection("License\LICENSE-BSD.TXT")
endif

rem Add SAVELOAD mandatory media
if gcompilestandaloneexe=1
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\load-base.png")
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\areyousure.png")
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\save-base.png")
endif

rem Forced 'Shader Compatibility Warning' PROMPT
if gcompilestandaloneexe=1 or grealgameviewstate=1
 filename$="languagebank\"+language$+"\gamecore\huds\noshader.dds"
 img=loadinternalimagecompressquality(filename$,5,1)
endif
if grealgameviewstate=1
 tneed#=0.0
 if guseeffectstate=1
  tneed#=1.0
  if guseeffectonscenesstate=1
   tneed#=2.0
  endif
 endif
 tpsv#=get maximum pixel shader version()
 timestampactivity(0,"Shaders - Need:"+str$(tneed#)+" Got:"+str$(tpsv#))
 if tneed#>tpsv#
  screenprompt(img,strarr$(123))
 endif
endif

rem Run gameflow default screen path
timestampactivity(0,"Game Flow Started..")
gosub _gameflow_default

rem Export game as standalone if -B used
if gcompilestandaloneexe=1
 rem Generate unique code
 guniquegamecode$=genuniqueservercode(gbuildname$)
 rem Build Executable Game Mode
 gosub _main_game_buildexe
 rem close dialog (cannot reload data into it when RELOAD MAPEDITOR)
 open file map 1, "FPSBUILDGAME"
 set file map dword 1, 24, 1
 wait for file map event 1
 close file map 1
 rem call map editor back
 open file map 1, "FPSEXCHANGE"
 set file map string$ 1, 1000, "bin\FPSC-MapEditor.exe"
 set file map string$ 1, 1256, "-r"
 set file map dword 1, 994, 0
 set file map dword 1, 924, 1
 wait for file map event 1
 close file map 1
 rem FPSXV10X - time for CPU(FPSCreator.exe) to conduct filemap scan
 `if gexitpromptreportmodestate<>0
 ` backdrop off
 ` show window
 ` position camera 0,50000,0
 ` while shiftkey()=0
 `  cls 0
 `  ink rgb(rnd(255),rnd(255),rnd(255)),0
 `  center text screen width()/2,(screen height()/2)-20,"USE 'FPSCREATORDUMPMEM.EXE' NOW!"
 `  center text screen width()/2,(screen height()/2)+00,"USE PROCESS VIEW TO SEE IF FPSC-MAPEDITOR.EXE APPEARS (give it one minute)"
 `  center text screen width()/2,(screen height()/2)+20,"PRESS SHIFT WHEN TESTS COMPLETE"
 `  sleep 1
 `  sync
 ` endwhile
 `endif
endif

rem If Game is NOT IN TEST MODE, show end splash for final executable
if gtestgamemodefromeditor=0 and gcompilestandaloneexe=0
 dosplashdelay=3000 : gosub _version_dosplash
endif

rem End executable
if gexitpromptreportmodestate<>0 then exit prompt "Terminated Game Exe","FPSCV10X Debug Report"
timestampactivity(0,strarr$(125))
end

`
` EXE Building Subroutines
`

_main_game_buildexe:
 `
 rem Version control on EXE Building
 gosub _version_main_game_buildexe
 `
return

`
` MAIN GAME SUBROUTINES
`

_main_game_loadgamedata:
 `
 rem Display game loading/creating-game backdrop
 if gdebugreportmodestate=1
  if gtestgamemodefromeditor=0
   for s=0 to 1
    cls rgb(255,255,0)
    ink rgb(0,0,255),0 : center text screen width()/2,screen height()/2,"DEBUG REPORT MODE ACTIVE"
    ink rgb(255,255,255),0
    sync
   next s
  endif
 endif
 debugviewprogressmax(330)
 `
 rem Place camera faw away (effectively hide all 3D)
 realrange#=9000.0
 set camera range 2.0,realrange#
 position camera 0,-50000,50000,50000
 point camera 0,-50000,50010,50000
 `
 rem Load segment banks
 segobjusedforfinalgame=1 : segnoeffects=gsegnoeffectstate
 `
 rem Load AI Scripts (can be done in elements process-only load as needed)
 debugviewtext(30,strarr$(126)) : gosub _ai_loadallscripts
 debugviewtext(60,strarr$(127)) : gosub _decal_init
 if gmultiplayergame=0 then debugviewtext(70,strarr$(128)) : gosub _flak_init
 debugviewtext(75,strarr$(129)) : gosub _gun_init
 debugviewtext(80,strarr$(130)) : gosub _gun_setup
 `
return

_main_game_freeleveldata:
 `
 rem only for final game run ( not test game ) - uses leavegamedataalone in last part
 if grealgameviewstate=1 or gcompilestandaloneexe=1
  `
  rem X10 certain entity free-ups required
  for e=1 to entityelementlist
   if entityelement(e).firesoundloop>0
    if sound exist(entityelement(e).firesoundloop)=1
     stop sound entityelement(e).firesoundloop
    endif
    entityelement(e).firesoundloop=0
   endif
  next e
  `
  rem X10 free AI resouces
  gosub _aiss_free
  `
  rem X10 end camera sync sequence
  if gcompilestandaloneexe=0
   gosub _sync_deletecameras
  endif
  `
  rem Free multiplayer resources
  gosub _multi_free
  `
  rem Free fragments
  if gmultiplayergame=0 then gosub _part_free
  `
  rem Free the old gun
  gosub _gun_freeafterlevel
  `
  rem Place camera faw away (effectively hide all 3D)
  position camera 0,-50000,50000,50000
  point camera 0,-50000,50010,50000
  `
  rem Remove universe (so camera can reset to no-3D-view)
  gosub _universe_destruct
  `
  rem Physics cleanup
  gosub _physics_cleanup
  `
  rem X10 - 041007 - free entities (objects, shadows and physics ties)
  rem Delete ALL game objects
  delete objects entityattachmentsoffset,66635
  entityprofileslotclonestart=entityprofileslotclonestartmaster
  `
  rem Remove all images
  deleteallinternalimages()
  `
  rem FREE REST OF GAME RESOURCES
  for p=1 to 65535 : if particles exist(p)=1 : delete particles p : endif : next p
  for e=1 to 65535 : if effect exist(e)=1 : delete effect e : endif : next e
  for s=1 to 65535 : if sound exist(s)=1 : delete sound s : endif : next s
  delete objects 1,endofallobjectsoffset
  `
  rem FREE ANY DATA
  undim undoredolist()
  undim meshbank$()
  undim texturebank$()
  undim effectbank$()
  undim soundbank$()
  undim prefabbank$()
  undim selectionbank$()
  undim entitybank$()
  undim gunbank$()
  undim muzzlebank$()
  undim brassbank$()
  undim smokebank$()
  undim flakbank$()
  undim decalbank$()
  undim imagebank$()
  undim segmentprofileheader()
  undim segmentprofile()
  undim map()
  undim viscolmap()
  undim lighttable()
  undim refmap()
  undim mapolay()
  undim olaylist()
  undim mapentries()
  undim mastermesh()
  undim entitybodypart()
  undim entityanim()
  undim entityprofileheader()
  undim entityprofile()
  undim entityelement()
  undim entityelementwhichslot()
  undim entityelementusingode()
  undim entityelementwhichobj()
  undim entityelementtexarrayindex()
  undim entityelementusingrefraction()
  undim entitydebug$()
  undim aiactionseq()
  undim aiaction()
  undim aiconditionseq()
  undim aicond()
  undim ailist()
  undim waypointcoord()
  undim waypoint()
  undim debris()
  undim gun()
  undim gunsound()
  undim gunsoundcompanion()
  undim gunsounditem()
  undim flak()
  undim flakelement()
  undim decal()
  undim decalelement()
  undim player()
  undim playersound()
  undim playerinventory()
  undim infinilight()
  undim infinilightshortlist()
  undim shadowlight()
  undim hud()
  `
  rem Ensure loader HUD is not used if resources removed
  internalloaderhud=0
  `
  rem Special exception as only arrays that need carrying to new levels
  if leavegamedataalone=0
   undim scriptbank$()
   undim weaponslot()
   undim weaponammo()
   undim weaponclipammo()
  endif
  undim weaponhud()
  `
  rem Recreate all data for new level (uses leavegamedataalone)
  gosub _FPSC_Full_Data_Init
  `
 endif
 `
return

_main_game_core:
 `
 rem Transition
 if gamewarmupcount=0
  if gametransitionscreen=1
   dec gametransitionscreencount,30
   if gametransitionscreencount<=0
    set camera view 0,0,0,screen width(),screen height()
    gametransitionscreen=0 : gametransitionscreencount=0
    rem Handle Hosting/Joining (multiplayer) when 3D starts
    if gmultiplayergame=1 and multiplayerinitialised=0 then gosub _multi_start
   else
    if gametransitionscreencount<(screen height()/2)-30
     position camera playercam,lastcamx#,lastcamy#,lastcamz#
     color backdrop rgb(0,0,64)
    endif
    set camera view 0,0,gametransitionscreencount,screen width(),gametransitionscreencount+(screen height()-(gametransitionscreencount*2))
   endif
  endif
 else
  rem the warmup allows decals to form, player start gravity to settle, etc
  cls 0 : dec gamewarmupcount : if gamewarmupcount<0 then gamewarmupcount=0
  if gamewarmupcount=0
   rem warm-up over, clear mouse deltas
   cleardelta=mousemovex() : cleardelta=mousemovey()
   rem start physics gravity now
   gosub _physics_startgravityafterwarmup
   rem record time at startup (used in AI to allow plrtriggers after 1 second)
   gamewarmupstarttime=timer()
  endif
 endif
 `
 rem Sky stays with camera
 gosub _sky_positionsky
 `
 rem Control main game
 gosub _main_game_corecontrol
 `
 rem Get time from last sample to SYNC command (rest)
 inc gameperfresttosync, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
 rem Update physics
 gosub _physics_update
 `
 rem Count physics time
 inc gameperfphysics, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
 rem Measure overall performance counts
 inc gameperftotalcount, perftimer()-gameperftotalcountTOP
 gameperftotalcountTOP=perftimer()
 `
 rem Parent Slot management readout debug
 if 0
  set cursor 0,0
  print "parent slots debug"
  for s=0 to entityprofileslotclonequantity-1
   print s;"s=";entityprofileslot(s);" ref=";entityprofileslotref(s)
  next s
  if noslots=1
   print "no more slots available"
  endif
 endif
 `
 rem AI Update
 AI Update
 gameperfai=gameperfai+(perftimer()-gameperftimestamp)
 gameperftimestamp=perftimer() 
 `
 rem X9 Update screen sync
 rem X10 sync sequence control (bloom, reflection, refract, etc)
 gosub _sync_sequence
 `
 rem Sync Performance check
 gameperfsync=gameperfsync+(perftimer()-gameperftimestamp)
 gameperftimestamp=perftimer()
 gamedebugviewtime=timer()
 `
 rem Exit Conditions for test game
 if grealgameviewstate=0
  if escapekey()=1 then continueokay=1 : levelwon=2 : rem QUIT
 endif
 `
 rem Logo compliance
 if terminate()=1 then continueokay=1 : levelwon=2 : rem TERMINATE - RESTART MANAGER
 `
return



rem
rem LEES Game Runner Code
rem

_load_game_scene:

rem Loading Screen
if gdebugreportmodestate=0 then set camera view 0,0,0,1,1

rem Direct to realgame or testgame
if grealgameviewstate=1
 `
 rem Set realgame level path
 levelmapptah$=myownrootdir$+"levelbank\testlevel\"
 `
 rem load the FPL file which populates testlevel for current level to play (level var)
 gosub _mapfile_load_fpl
 `
else
 `
 rem During test map this path can be used (map edit files)
 levelmapptah$=myownrootdir$+"mapbank\testmap\"
 `
 rem Load the FPM data to mapbank\testmap (level var)
 if gcompilestandaloneexe=1
  gosub _mapfile_loadgamemap_fpm
  elementsfilename$=""
 endif
 `
endif

rem Free any old player resources
debugviewtext(120,strarr$(131)) : gosub _player_free
debugviewtext(120,strarr$(131)) : gosub _particles_free

rem Flush video for new graphics usages
debugviewtext(130,strarr$(132)) : flush video memory

rem Free old resources first
debugviewtext(140,strarr$(133)) : gosub _entity_deleteelements

rem Load waypoints
if gshowdebugtextingamestate=0 then gdontcreatewaypointobjects=1
debugviewtext(150,strarr$(134)) : gosub _waypoint_loaddata
if gshowdebugtextingamestate=1 then gosub _waypoint_createallobjs

rem Ensure segments are loaded (not for final game though - universe dbo does this)
if grealgameviewstate=0 then debugviewtext(160,strarr$(135)) : gosub _segment_loadbank

rem Ensure segments and entities are up to date
debugviewtext(170,strarr$(136)) : gosub _entity_loadbank

rem Load individual-elements
debugviewtext(180,strarr$(137)) : gosub _entity_loadelementsdata
debugviewtext(185,strarr$(137)) : gosub _entity_switchtostaticformultiplayer

rem 290607 - AI inits here just before 'static entities' are added as AI obstacle
gosub _aiss_init

rem Load map (with any segment entitiy-elements)
debugviewtext(200,strarr$(138)) : gosub _game_loadmap

rem Finally create and attach elements to map
debugviewtext(299,strarr$(626)) : gosub _particles_init
if gmultiplayergame=0 then debugviewtext(299,strarr$(626)) : gosub _part_init
debugviewtext(300,strarr$(139)) : gosub _entity_createelements
debugviewtext(310,strarr$(140)) : gosub _entity_attachelementstogame
debugviewtext(311,strarr$(141)) : gosub _ai_createentityreferences

rem Load material list and sounds
debugviewtext(312,strarr$(142)) : gosub _physics_loadmateriallist

rem Entities can intropduce fake players, init all
debugviewtext(312,strarr$(142)) : gosub _player_startgun
debugviewtext(313,strarr$(143)) : gosub _gun_loadonlypresent
debugviewtext(313,strarr$(143)) : gosub _flak_loadonlypresent
debugviewtext(314,strarr$(144)) : gosub _decal_loadonlyactivedecals
debugviewtext(314,strarr$(144)) : gosub _muzzle_createall

rem Entities can intropduce fake players, init all
debugviewtext(318,strarr$(145)) : gosub _player_init : gosub _player_resetobjectives
debugviewtext(320,strarr$(146)) : gosub _entity_startentitiesoff

rem X10 start camera sync sequence
gosub _sync_createcameras

rem Okay for start of game, can skip for exe construction
if gcompilestandaloneexe=1
 `
 rem 240907 - these two are called insied universe_construct just before zip is built! 
 `gosub _aiss_setup : gosub _aiss_free
 `
else
 `
 rem Physics init of universe and entities (321,322,323)
 debugviewtext(321,strarr$(627)) : gosub _physics_init
 `
 rem Setup camera (player)
 debugviewtext(324,strarr$(628)) : gosub _player_setup
 `
 rem X10 AI Call after assets loaded, before game starts
 gosub _aiss_setup
 prepareentitiesmode=0 : gosub _aiss_prepareentities
 `
 rem Reset multiplayer state (multiplayer)
 if gmultiplayergame=1
  gosub _multi_restartprepare
  multiplayerinitialised=0
 endif
 `
 rem Starting main loop
 debugviewtext(329,strarr$(629))
 `
endif

rem TestGameFromEditor Mode
if gtestgamemodefromeditor=1
 `
 rem Activate OK button
 open file map 1, "FPSTESTGAMEDIALOG"
 set file map dword 1, 12, 1
 set file map string$ 1, 1000, strarr$(147)
 set file map dword 1, 8, 100
 wait for file map event 1
 close file map 1
 while 1
  open file map 1, "FPSEXCHANGE"
  wait for file map event 1
  rem Wait for Test Game Dialog OK button pressed
  if get file map dword( 1, 974 ) = 1 then exit
  if get file map dword( 1, 994 ) = 1
   rem terminate test game mid-build
   set file map string$ 1, 1000, "bin\FPSC-MapEditor.exe"
   set file map string$ 1, 1256, "-r"
   set file map dword 1, 994, 2
   set file map dword 1, 924, 1
   wait for file map event 1
   close file map 1
   rem Terminate
   end
  else
   close file map 1
  endif
  sync
 endwhile
 close file map 1
 `
 rem make sure the cancel code is not detected for anymore in debug function
 gtestgamemodefromeditorokaypressed=1
 `
 rem Version Control - possible logo use
 gosub _version_onscreenlogos
 `
 rem Show Test Game Window
 gosub _main_game_showwindownow
 `
endif

rem Sample transition IN
gametransitionscreen=1 : gametransitionscreencount=600/2

return

_main_game_showwindownow:
 window to back
 set window layout 0,0,0
 sleep 100
 window to front "FPSC Game"
 show window
 maximize window
return

_main_game_corecontrol:

rem Stamp time for performance meter
if showgamemenu=0
 if debugviewmode=0
  rem X10 also uses mouse when in TAB debug X10 effecte menu 'debugviewmode'
  position mouse screen width()/2,screen height()/2
 endif
endif

rem STATUS AND HUD GRAPHICS
if gamewarmupcount=0
 gosub _screen_control
endif

rem X10 - 240907 - calculate a constant global time for pacing by timer, not counter
timebasepercycle#=(1.0/30.0)*(timer()-timebasepercyclestamp) : timebasepercyclestamp=timer()

rem FPSCV104RC4 - i want to see this
`if grealgameviewstate=0
if gdebugreportmodestate=1 or grealgameviewstate=0
 `
 rem Debug info
 debuggameoverlaysystem(0)
 inc gameperfdebug, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
else
 `
 rem X10 handles effects in here (when flag set to 1 we ignore profiling)
 debuggameoverlaysystem(1)
 `
 rem Ingame debug FPS
 if keystate(15)=0 then keystate15pressed=0
 if keystate(15)=1 and keystate15pressed=0
  inc showfpsinrealgame
  if ggodmodestate=0
   if showfpsinrealgame>1 then showfpsinrealgame=0
  else
   if showfpsinrealgame>2 then showfpsinrealgame=0
  endif
  keystate15pressed=1
 endif
 if showfpsinrealgame=1 then set cursor 0,0 : print screen fps()
 `
 rem suicide key
 if gmultiplayergame=1
  if lower$(inkey$())="i" and gtalkytoaster=0
   tdamage=10 : e=characterchoiceentityindex(iLocalEL)
   if entityelement(e).health>0
    gosub _multi_dealentityedamage
   endif
  endif
 endif
 `
 rem Talk system
 if gmultiplayergame=1
  tylinevalue=screen height()-20
  if lower$(inkey$())="t" and gtalkytoaster=0
   gtalkytoaster=1 : clear entry buffer
  endif
  if gtalkytoaster=1
   set cursor 0,tylinevalue
   print "TALK>";entry$();
  endif
  if returnkey()=1 and gtalkytoaster=1
   rem send message to all
   gtalkytoaster=0
   tmessage$=entry$()
   MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
   MULTIPLAYER SEND MESSAGE STRING ">>"+tmessage$,0x0080
   clear entry buffer
   rem see own message (only if server)
   if createorjoin=1
    talkscript$(talkindex)=">>"+tmessage$
    talkscriptcount(talkindex)=200
    talkscriptwho(talkindex)=iLocalEL
    inc talkindex : if talkindex>10 then talkindex=0
   endif
  endif
 endif
 `
 rem Ingame debug SPEEDTESTS
 if showfpsinrealgame=2
  rem multiplayer data
  if gmultiplayergame=1
   if timer()-totalbytestime>1000
    totalbytestime=timer()
    totalguarenteedbytes=guarenteedbytes
    totalunreliablebytes=unreliablebytes
    guarenteedbytes=0
    unreliablebytes=0
   endif
   tt$="GD="+str$(totalguarenteedbytes)
   text (screen width()/2)-75,screen height()-80,tt$
   tt$="UD="+str$(totalunreliablebytes)
   text (screen width()/2)+00,screen height()-80,tt$
   tt$="QUEUE="+str$(multiplayer get queue size(0))+","+str$(multiplayer get queue size(1))
   text (screen width()/2)+75,screen height()-80,tt$
  endif
  rem regular stats
  debugviewmode=0
  debuggameoverlaysystem(0)
  inc gameperfdebug, perftimer()-gameperftimestamp
  gameperftimestamp=perftimer()
 endif
 `
endif

rem Dynamic lighting control
gosub _lighting_ambientcontrol
if (gdynamiclightingstate=1 and lightingsystemdisabled=0) or forceambientlightsetting>0
 gosub _lighting_control
 gosub _lighting_managedynamiclights
 rem the following three are not required in X10
 `gosub _lighting_managegloballighting
 `gosub _lighting_applyplayerlighting
 `gosub _lighting_applytoscene
endif
gosub _lighting_controlupdate
inc gameperflighting, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Game Active
if gamewarmupcount=0
 `
 rem Skip input (if not multiplayer ready or talkmode on)
 tokay=1
 if gmultiplayergame=1 and PlayerCanStart=0 then tokay=0
 if gtalkytoaster=1 then tokay=0
 if tokay=1
  `
  rem Player management
  gosub _player_input
  gosub _player_manager
  gosub _player_itemmanager
  gosub _player_mission
  `
  rem The Player Camera
  gosub _player_camera
  gosub _gun_update_hud
  `
 endif
 `
endif

rem X10 new water control
gosub _sync_controlwater

rem Measure plr calcs time
inc gameperfplayer, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Entity Control Handling Here
gosub _entity_controlelements
gosub _muzzle_control
inc gameperfentities, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem X10 AI control of entities
`gosub _aiss_control `moved to controlelements

rem X10 AI Control Player and Team controls
gosub _aiss_playercontrol

rem Control multiplayer communicaions (multiplayer)
if gmultiplayergame=1 and multiplayerinitialised=1 and multiplayersystemdisabled=0
 gosub _multi_control
endif

rem Game Active
if gamewarmupcount=0
 `
 rem After AutoCol (after plr move and entity push-back, use autocol so stay in walls)
 gosub _physics_playeraftermove
 gosub _physics_playerpickup
 `
 rem The Gun Manager after new camera pos/rot
 gosub _gun_manager
 inc gameperfgun, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
endif

rem Flak in-game handling
gosub _particles_control
if gmultiplayergame=0 then gosub _flakelement_control
if supportsystemdisabled=0
 gosub _decalelement_control
endif
gosub _part_controlexploders
gosub _gun_update_overlay
inc gameperfmisc, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

return

function screenprompt(img,desc$)
 backdrop off : position camera 0,-50000,-50000,-50000 : point camera 0,-550000,-550000,-550000
 ink rgb(255,255,255),0 : set text font "Verdana" : set text size 24
 cls 0 : sync : cls 0 : sync
 for s=1 to 20
  center text screen width()/2,(screen height()/2)-16,desc$
  if img>0
   if image exist(img)=1
    paste image img,(screen width()-512)/2,(screen height()-384)/2
   endif
  endif
  sync : sleep 200
 next s
endfunction

function timestampactivity(i,desc$)
 if gproducelogfiles=1
  if i=0
   inc timestampactivityindex
   timestampactivityflagged=1
   i=timestampactivityindex
  else
   timestampactivityindex=i
  endif
  if i>timestampactivitymax
   timestampactivitymax=i
  endif
  dim timestampactivity$(timestampactivitymax)
  timestampactivity$(i)=str$(timer())+" : "+desc$
  file$="..\FPSC-Game.log" : if file exist(file$)=1 then delete file file$
  open to write 1,file$
   for t=1 to timestampactivitymax
    write string 1,timestampactivity$(t)
   next t
  close file 1
 endif
endfunction

rem Function to use anywhere
function genuniqueservercode(name$)
 date$=get date$()
 time$=get time$()
 code$=""
 for index=0 to 10
  ci1=index mod len(name$) : c1$=mid$(name$,1+ci1) : if c1$="," then c1$="."
  ci2=index mod len(date$) : c2$=mid$(date$,1+ci2) : if c2$="," then c2$="."
  ci3=index mod len(time$) : c3$=mid$(time$,1+ci3) : if c3$="," then c3$="."
  code$=code$+c1$+c2$+c3$
 next index
 code$=right$(code$,32)
endfunction code$

`
` TO resolve share issue with new version attachment
`

_interface_openbuildgame:
_interface_handlebuildgame:
_interface_closebuildgame:
return

`
` X10 SYNC SEQUENCE CONTROL
`

_sync_createcameras:
 `
 rem Default master camera
 cammainscene=5
 `
 rem create cameras (need to have them all created so render chain still works - bug?)
 dim camname$(15)
 rem refract/reflect/shadow
 makecamera(1,"REDUNDANT",0,screen width(),screen height(),"",0,0,0,0,1,0)
 makecamera(4,"reflect scene 3D",0,screen width(),screen height(),"",0,0,0,0,2,0)
 makecamera(5,"game with water 3D",0,screen width(),screen height(),"",0,0,0,0,0,1)
 makecamera(2,"shadow scene 3D",0,screen width(),screen height(),"",0,0,0,5,0,0)
 makecamera(3,"soft shadow QUAD",1,screen width()/2,screen height()/2,"blur10.fx",2,0,0,0,0,0)
 rem bloom chain
 makecamera(8,"bloom downsize 1 QUAD",1,screen width()/2,screen height()/2,"bloomtone10.fx",cammainscene,0,0,0,0,0)
 makecamera(6,"bloom downsize 2 QUAD",1,screen width()/4,screen height()/4,"bloomtone10.fx",8,0,0,0,0,0)
 makecamera(9,"bloom blur QUAD",1,screen width()/8,screen height()/8,"bloomblurH10.fx",6,0,0,0,0,0)
 makecamera(7,"bloom blur QUAD",1,screen width()/8,screen height()/8,"bloomblurV10.fx",9,0,0,0,0,0)
 rem final render 
 makecamera(0,"backbuffer QUAD",1,screen width(),screen height(),"finalrender10.fx",cammainscene,7,3,0,0,0)
 rem image render targets
 copy camera to image 5,19876 : rem initialise (for texture commands below)
 copy camera to image 5,19877 : rem initialise (for texture commands below)
 `
 rem Set flags
 if camera exist(2)=0 then gpuload2=1
 if camera exist(3)=0 then gpuload3=1
 if camera exist(4)=0 then gpuload4=1
 if camera exist(5)=0 then gpuload5=1
 if camera exist(6)=0 then gpuload6=1
 if camera exist(7)=0 then gpuload7=1
 `
 rem align FOV and RANGE to all sync cameras
 if camera exist(1)=1 then set camera fov 1,75.0 : set camera aspect 1,gdisplayratio#
 if camera exist(2)=1 then set camera fov 2,75.0 : set camera aspect 2,gdisplayratio#
 if camera exist(4)=1 then set camera fov 4,75.0 : set camera aspect 4,gdisplayratio#
 if camera exist(5)=1 then set camera fov 5,75.0 : set camera aspect 5,gdisplayratio#
 realrange#=9000.0
 if camera exist(1)=1 then set camera range 1,2.0,realrange#
 if camera exist(2)=1 then set camera range 2,2.0,realrange#
 if camera exist(4)=1 then set camera range 4,2.0,realrange#
 if camera exist(5)=1 then set camera range 5,2.0,realrange# 
 `
 rem default water position
 if gdefaultwaterlevelstate=1
  `waterlevel#=515.0 `260907 - move water below default layer floor
  waterlevel#=490.0
 else
  waterlevel#=-50000.0
 endif
 waterisbelowplayer=1
 `
 rem Trigger calc on whether player above or below water
 tchangethewaterclipping=2
 `
 rem setup basic defaults (before we change X10 shader effects)
 if gpuload4=0
  if camera exist(4)=1 then set camera clip 4,2,0,waterlevel#+1,0,0,1,0
 else
  if camera exist(4)=1 then set camera clip 4,0,0,0,0,0,0,0
 endif
 `
 rem water plane (we can have one for each water zone)
 `x10-021107 - if gpuload3=0 or gpuload4=0
 obj=11 : watereffectid=11
 make object plain obj,80*100,80*100
 position object obj,0,waterlevel#,0
 scale object texture obj,80,80
 set object mask obj,%100000,%0,%0
 xrotate object obj,90
 set object cull obj,0
 dirbefore$=get dir$() : set dir commoneffects$
 tfile$="basepool.fx" : addfiletocollection(commoneffects$+tfile$)
 tfile$="Water10.fx" : addfiletocollection(commoneffects$+tfile$)
 load effect tfile$,watereffectid,0
 tfile$="Water_N.dds" : addfiletocollection(commoneffects$+tfile$)
 load image tfile$,obj
 set dir dirbefore$
 texture object obj,0,obj
 texture object obj,1,19876 : rem from IMAGE 19876 refraction source
 texture object obj,2,4
 set object effect obj,watereffectid
 set effect technique watereffectid,"DrawRefractReflect"
 `endif
 `
 rem apply camera source to refractive entities
 for entid=1 to entidmastermax
  entobj=entitybankoffset+entid
  if object exist(entobj)=1
   if right$(lower$(entityprofile(entid).effect$),10)="cubeent.fx"
    texture object entobj,2,19877 : rem from IMAGE 19877 refraction source
   endif
  endif
 next entid
 `
 rem set main camera
 playercam=5 : set current camera playercam
 `
return

_sync_controlwater:
 `
 rem X10 - 031107 - if flag is off
 if gdefaultwaterlevelstate=0
  rem ignore all water level code and remove it
  waterlevel#=-50000.0
 endif 
 `
 rem water level
 position object 11,0,waterlevel#,0
 `
 rem water transition
 if camera position y(playercam)>waterlevel#+1.0
  if waterisbelowplayer=2
   rem player is above water
   waterisbelowplayer=1
   r=make vector4(1) : set vector4 1, 0.0, 0.0, 0.0, 0
   set effect constant vector 6,"g_fBloomColor",1 : r=delete vector4(1)
   rem leave water sound
   if watertransitionbyrestart=0
    rem only if did no during game, not through restart transition 
    playinternal3dsound(playersound(1,17),camera position x(playercam),camera position y(playercam),camera position z(playercam))
    rem also play gasp sound if in water for too long
    if timer()-wateroccupiedtimer>4000
     playinternal3dsound(playersound(1,19),camera position x(playercam),camera position y(playercam),camera position z(playercam))
     set sound volume playersound(1,19),soundvolumes(0)
    endif
   endif
   rem stop underwater atmos sound
   if waterunderwatersoundid>0 then stopsound(waterunderwatersoundid)
   rem subdued sound back to normal
   `tmp#=25.0 : tmp#=tmp#/100.0 : scale listener tmp#
   rem normal camera clip
   tcameraclippingmode=1 : tchangethewaterclipping=1
   rem refresh fog and bloom settings (aided in debug by waterisbelowplayer-1)
   hudupdateeffects=1 : rem tupdatefog=1 : tupdatebloom=1
   rem flags
   triggersplash=2
  endif
 endif
 if camera position y(playercam)<waterlevel#-1.0
  if waterisbelowplayer=1
   rem player is underwater
   waterisbelowplayer=2
   rem subdued sound
   `tmp#=5.0 : tmp#=tmp#/100.0 : scale listener tmp#
   rem enter water sound
   if watertransitionbyrestart=0
    rem only if did no during game, not through restart transition 
    playinternal3dsound(playersound(1,18),camera position x(playercam),camera position y(playercam),camera position z(playercam))
   endif
   rem loop underwater atmos sound
   if waterunderwatersoundid>0 then loopsound(waterunderwatersoundid)
   rem reverse camera clip
   tcameraclippingmode=2 : tchangethewaterclipping=1
   rem start timer on how long in water
   wateroccupiedtimer=timer()
   rem refresh fog and bloom settings (aided in debug by waterisbelowplayer-1)
   hudupdateeffects=1 : rem tupdatefog=1 : tupdatebloom=1
   rem flags
   triggersplash=1
  endif
  rem change bloom tint color if in water
  fullyinwater#=0.53
  if camera position y(playercam)>waterlevel#-50.0
   perc#=abs(waterlevel#-camera position y(playercam))/50.0
   fullyinwater#=0.2+(perc#/3.0)
  endif
  r=make vector4(1)
  set vector4 1,(rgbr(hudunderwatercolor)/255.0)*fullyinwater#,(rgbg(hudunderwatercolor)/255.0)*fullyinwater#,(rgbb(hudunderwatercolor)/255.0)*fullyinwater#,1
  set effect constant vector 6,"g_fBloomColor",1
  r=delete vector4(1)
 endif
 `
 rem Reset this value when reach this subroutine
 watertransitionbyrestart=0
 `
 rem X10 trigger some ripples using the decal system
 if waterdecalripple>0
  ripplex=camera position x(playercam)+rnd(4)-2
  ripplez=camera position z(playercam)+rnd(4)-2
  if (plrkeyC)=1
   rem crouch causes ripples in water
   theightofplrcamforripple#=22.0
  else
   rem waling in water causes ripples
   theightofplrcamforripple#=57.0
  endif
  if camera position y(playercam)<waterlevel#+theightofplrcamforripple# and camera position y(playercam)>waterlevel# 
   if abs(lastripplex-ripplex)>5 or abs(lastripplez-ripplez)>5
    lastripplex=ripplex : lastripplez=ripplez
    ripplequantity=70
   else
    ripplequantity=5000
   endif
   if timer()-rippleplayermakes>ripplequantity
    rippleplayermakes=timer()
    decalid=waterdecalripple
    decalorient=0
    decalx=ripplex
    decaly=waterlevel#+1.0
    decalz=ripplez
    decalorient=2
    decalscalemodx=50 : decalscalemody=decalscalemodx
    decalalpha=25
    originatore=0 : gosub _decalelement_create
   endif 
  endif
 endif
 `
 rem X10 water splash
 if splashdecalid>0 and triggersplash<>0
  if timer()-splashsplash>500
   splashsplash=timer()
   decalid=splashdecalid
   decalorient=0
   if triggersplash=2
    decalx=newxvalue(camera position x(playercam),camera angle y(playercam),40.0)
    decalz=newzvalue(camera position z(playercam),camera angle y(playercam),40.0)
    decaly=waterlevel#-50.0
    decalscalemodx=50
   else
    decalx=camera position x(playercam)
    decalz=camera position z(playercam)
    decaly=waterlevel#
    decalscalemodx=100
   endif
   decalscalemody=decalscalemodx
   decalalpha=100
   originatore=0 : gosub _decalelement_create
  endif 
  triggersplash=0
 endif
 `
 rem If remotely trigger clipping update (ie form X10 effect menu)
 if tchangethewaterclipping=2
  if camera position y(playercam)>waterlevel#
   tcameraclippingmode=1
  else
   tcameraclippingmode=2
  endif
  tchangethewaterclipping=1
 endif
 `
 rem X10 refraction used by windows
 if grefractionelementused=1
  glastrefractionelementused=grefractionelementused
  tchangethewaterclipping=1
 endif
 `
 rem Set new water clipping level
 if tchangethewaterclipping=1
  tchangethewaterclipping=0
  `if grefractionelementused=1
  ` if gpuload5=0
  `  if camera exist(1)=1 then set camera clip 1,1,0,100000,0,0,-1,0
  ` endif
  `else
  ` if tcameraclippingmode=1
  `  if gpuload5=0
  `   if camera exist(1)=1 then set camera clip 1,1,0,waterlevel#+4,0,0,-1,0
  `  endif
  ` endif
  `` if tcameraclippingmode=2
  `  if gpuload5=0
  `   if camera exist(1)=1 then set camera clip 1,1,0,waterlevel#-4,0,0,1,0
  `  endif
  ` endif
  `endif
  if tcameraclippingmode=1
   if gpuload4=0
    if camera exist(4)=1 then set camera clip 4,2,0,waterlevel#+1,0,0,1,0
   endif
  endif
  if tcameraclippingmode=2
   if gpuload4=0
    if camera exist(4)=1 then set camera clip 4,2,0,waterlevel#-1,0,0,-1,0
   endif
  endif
 endif 
 `
return

_sync_deletecameras:
 `
 rem delete cameras
` instead we keep the cameras existing, and use them after creation
` for c=1 to 7 : delete camera c : next c
 `
return

_sync_sequence:
 `
 rem X10 - 171007 - auto water refraction 
 if gautorefractionmode=1
  tperc#=camera position y(playercam)-waterlevel#
  lasthudwaterrefr=hudwaterrefr
  if abs(tperc#)<=100
   hudwaterrefr=100.0-abs(tperc#)
  else
   hudwaterrefr=0
  endif
  if lasthudwaterrefr<>hudwaterrefr
   hudwaterrefrupdate=1
  endif
 endif
 `
 rem X10 - 220807 - Control which processes are active based on effect values
 if hudwaterrefl=0 then gpuload4=1 else gpuload4=0
 if hudwaterrefr=0 then gpuload1=1 else gpuload1=0
 if hudshadowstrength=0 : gpuload2=1 : gpuload3=1 : else : gpuload2=0 : gpuload3=0 : endif
 if hudshadowquantity=0 : gpuload2=1 : gpuload3=1 : else : gpuload2=0 : gpuload3=0 : endif
 if hudbloomstrength(waterisbelowplayer-1)=0 : gpuload6=1 : gpuload7=1 : else : gpuload6=0 : gpuload7=0 : endif
 `
 rem If detect change in render processes, clear out old camera renders
 `tchanged=(gpuload1<<1)+(gpuload2<<2)+(gpuload3<<3)+(gpuload4<<4)+(gpuload5<<5)+(gpuload6<<6)
 tchanged=(gpuload2<<2)+(gpuload3<<3)+(gpuload4<<4)+(gpuload5<<5)+(gpuload6<<6)
 if tchanged<>tlastchanged
  tlastchanged=tchanged
  if gpuload2=1 then position camera 2,50000,50000,50000 : point camera 2,50000,60000,50000
  if gpuload3=1 then clear camera view 3,0
  if gpuload4=1 then position camera 4,50000,50000,50000 : point camera 4,50000,60000,50000
  if gpuload6=1 then clear camera view 6,0
  if gpuload7=1 then clear camera view 7,0
  sync mask camask(2) : fastsync
  sync mask camask(3) : fastsync
  sync mask camask(4) : fastsync
  sync mask camask(6) : fastsync
  sync mask camask(7) : fastsync
 endif
 `
 rem SYNC performance meters
 gamesyncperftimestamp=perftimer()
 `
 rem Simple Or Sophisticated
 if playercam<>0
  `
  rem Align sync cameras to main camera
  if camera exist(2)=1
   position camera 2,camera position x(playercam),camera position y(playercam),camera position z(playercam)
   rotate camera 2,camera angle x(playercam),camera angle y(playercam),camera angle z(playercam)
  endif
  if camera exist(4)=1
   position camera 4,camera position x(playercam),camera position y(playercam),camera position z(playercam)
   rotate camera 4,camera angle x(playercam),camera angle y(playercam),camera angle z(playercam)
  endif
  `280807 - no more camera one
  `if camera exist(5)=1
  ` position camera 5,camera position x(playercam),camera position y(playercam),camera position z(playercam)
  ` rotate camera 5,camera angle x(playercam),camera angle y(playercam),camera angle z(playercam)
  `endif
  `
  rem Render Reflection first
  if gpuload4=0 then sync mask camask(4) : fastsync : rem FOR REFLECTION
  `
  rem Stat1
  gamesyncperfsync(1)=gamesyncperfsync(1)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem After FIRST FASTSYNC, animation/transform Update will have taken place
  rem which means we can use the new world positions/transforms/etc for things
  rem like gun placement, pseudo-glued objects, etc 
  gosub _sync_align_pseudoglued_objects
  rem But we need to update any instance buffers holding instance positions
  rem like guns more than 10 so we can see them aligned correctly (in sync)
  rem this is achieved within the engine with a piece of code before each
  rem FASTSYNC which checks if there have been any instance buffer changes
  rem since the main UPDATE (SYNC) work and update accordingly (using a global flag)
  `
  rem Stat2
  gamesyncperfsync(2)=gamesyncperfsync(2)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem If no glass found in sequence, we scan skip the glass slicing render in camera 5
  tindexofclosestglassifany=0
  `
  rem [5] part A
  if gpuload5=0
   `
   rem Just camrea 5
   sync mask camask(5)
   `
   rem Hide water (while we render under the water)
   hide object 11
   if currentgunobj>0 then hide object currentgunobj
   `
   rem Glass should not refract under water
   if grefractionshadereffect>0
    if effect exist(grefractionshadereffect)=1
     set effect technique grefractionshadereffect,"DrawInstNoRefraction"
    endif
   endif
   `
   rem [5] UNDER - clip to render only below water
   if tcameraclippingmode=1
    set camera clip 5,1,0,waterlevel#+4,0,0,-1,0
   else
    set camera clip 5,1,0,waterlevel#-4,0,0,1,0
   endif
   `
   rem [5] If refraction enabled, render scene for refr source
   if gpuload1=0
    fastsync : copy camera to image 5,19876 : rem store for water refraction
   endif
   `
   rem Stat3
   gamesyncperfsync(3)=gamesyncperfsync(3)+(perftimer()-gamesyncperftimestamp)
   gamesyncperftimestamp=perftimer()
   `
   rem Show water (while we render refraction beyond window)
   show object 11
   if hudwaterrefl>0 or hudwaterrefr>0
    set effect technique watereffectid,"DrawRefractReflect"
    set object transparency 11,1
   else
    set effect technique watereffectid,"DrawColor"
    set object transparency 11,2
   endif
   `
   rem Hide windows (while we render refraction beyond window)
   if grefractionshadereffect>0 and hudglassrefr>0
    rem X10 - 131007 - only if we have a window in the level that refracts
    tglassdirection=-1
    tclosestglass#=999999.99
    for e=1 to entityelementlist
     obj=entityelement(e).obj
     if obj>0 and entityelement(e).active=1
      entid=entityelement(e).bankindex
      if object exist(obj)=1
       if entityprofile(entid).usingeffect=grefractionshadereffect
        rem must still be calculating which one
        if tindexofclosestglassifany<>-1
         rem must also be facing it (obj must be in screen and visible)
         if object in screen(obj)=1 and object visible(obj)=1
          rem and must be the first OR only glass facing this direction (RY)
          if tglassdirection=-1 or entityelement(e).ry=tglassdirection
           rem if facing same direction, must be on same plane otherwise player can stand between 
           rem the windows which may create a two planes running into distance with plr in middle problem
           tokay=1
           if tindexofclosestglassifany>0
            if tglassdirection=0 or tglassdirection=180
             if abs(entityelement(tindexofclosestglassifany).z-entityelement(e).z)>10
              rem horizontal plane direction with vertical span between windows
              tokay=0
             endif
            else
             if abs(entityelement(tindexofclosestglassifany).x-entityelement(e).x)>10
              rem vertical plane direction with horizontal span between windows
              tokay=0
             endif
            endif
            if tokay=0
             rem more than one glass plane in scene (cannot slice this scene)
             tindexofclosestglassifany=-1
            endif
           endif
           if tokay=1          
            rem must be nearest
            tthisglassdistance#=entityelement(e).plrdist
            if tthisglassdistance#<tclosestglass#
             tglassdirection=entityelement(e).ry
             tclosestglass#=tthisglassdistance#
             tindexofclosestglassifany=e
            endif
           endif
          else
           rem more than one glass, and they face different ways
           tindexofclosestglassifany=-1
          endif
         endif
        endif
        hide object obj
       endif
      endif
     endif
    next e
   endif
   `
   rem [5] BEYOND WINDOW - clip behind nearest window
   if tindexofclosestglassifany>0
    rem found glass closest to player, create ONE clip at window
    nearestwindowx#=entityelement(tindexofclosestglassifany).x
    nearestwindowy#=entityelement(tindexofclosestglassifany).y
    nearestwindowz#=entityelement(tindexofclosestglassifany).z
    nearestwindowpx#=newxvalue(0,entityelement(tindexofclosestglassifany).ry,-1.0)
    nearestwindowpz#=newzvalue(0,entityelement(tindexofclosestglassifany).ry,-1.0)
    nearestwindowpy#=0.0
    viewanglex#=nearestwindowx#-camera position x(playercam)
    viewanglez#=nearestwindowz#-camera position z(playercam)
    viewangle#=atanfull(viewanglex#,viewanglez#)
    viewangle#=abs(entityelement(tindexofclosestglassifany).ry-viewangle#)
    if viewangle#>90 and viewangle#<270
     rem facing front of glass
     tdirectionofnormal#=-1.0
    else
     rem facing back of glass
     tdirectionofnormal#=1.0
    endif
    tobj=entityelement(tindexofclosestglassifany).obj
    nearestwindowpx#=newxvalue(0,entityelement(tindexofclosestglassifany).ry,tdirectionofnormal#)
    nearestwindowpz#=newzvalue(0,entityelement(tindexofclosestglassifany).ry,tdirectionofnormal#)
    set camera clip 5,1,nearestwindowx#,nearestwindowy#,nearestwindowz#,nearestwindowpx#,nearestwindowpy#,nearestwindowpz#
    fastsync
    copy camera to image 5,19877 : rem store for glass refraction
   else
    if tindexofclosestglassifany=-1
     rem too much glass, FULL refraction no clip required
     set camera clip 5,0,0,0,0,0,0,0
     fastsync
     copy camera to image 5,19877 : rem store for glass refraction
    else
     rem no glass no refraction no clip required
    endif
   endif
   `
  endif
  `
  rem Stat4
  gamesyncperfsync(4)=gamesyncperfsync(4)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem [5] part B (allows time for refraction images to finish async GPU copyresource
  if gpuload5=0
   `
   rem Just camrea 5
   sync mask camask(5)
   `
   rem Add windows back (while we render rest including windows)
   for e=1 to entityelementlist
    obj=entityelement(e).obj
    if obj>0 and entityelement(e).active=1
     entid=entityelement(e).bankindex
     if object exist(obj)=1
      if entityprofile(entid).usingeffect=grefractionshadereffect
       show object obj
      endif
     endif
    endif
   next e
   `
   rem also allow glass to use refraction now we have some
   if grefractionshadereffect>0
    if effect exist(grefractionshadereffect)=1
     if hudglassrefr=0
      rem X10 - 131007 - if set refraction value to zero, use non refraction technique
      set effect technique grefractionshadereffect,"DrawInstNoRefraction"
     else
      set effect technique grefractionshadereffect,"DrawInst"
     endif
    endif
   endif
   `
   rem X10 - 231007 - Show gun in main camera scene (no zdepth disabled) if capturing
   if gpuload5=0 and snapshotmodeframebyframe>0
    if showgamemenu=0 and currentgunobj>0 then show object currentgunobj
   endif
   `
   rem Render entire scene as final scene
   rem 260807 - note - rendering 'rest' problem is hiding ALL except what we missed
   rem and the fact windows/water must be rendered into the scene (not just after clip)
   rem plus clip rendering costs VS performance hit
   set camera clip 5,0,0,0,0,0,0,0
   fastsync
   `
  endif
  `
  rem Stat5
  gamesyncperfsync(5)=gamesyncperfsync(5)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem Render shadows using depths of main Game Scene (5)
  if gpuload2=0 then sync mask camask(2) : fastsync : rem Shadow Scene
  if gpuload3=0 then sync mask camask(3) : fastsync : rem Soft Shadow
  `
  rem [5] part C (draw nozdepth objects)
  if gpuload5=0 and snapshotmodeframebyframe=0
   rem X10 250907 - do not draw gun manually if in game menu (flickers)
   if showgamemenu=0
    rem Can render gun now shadows taken care of (gun wipes zdepth above!)
    if currentgunobj>0
     sync mask camask(5)
     show object currentgunobj
     draw object currentgunobj,5
    endif
   endif
  endif
  `
  rem Stat6
  gamesyncperfsync(6)=gamesyncperfsync(6)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem Now compose the final bloom blurs
  if gpuload6=0 then sync mask camask(8) : fastsync : rem Bloom DOWNSIZE 1
  if gpuload6=0 then sync mask camask(6) : fastsync : rem Bloom DOWNSIZE 2
  if gpuload7=0 then sync mask camask(9) : fastsync : rem Bloom BLUR H and V
  if gpuload7=0 then sync mask camask(7) : fastsync : rem Bloom BLUR H and V
  `
  rem Stat7
  gamesyncperfsync(7)=gamesyncperfsync(7)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem Post process final render
  sync mask %1
  `
  rem update main/last screen
  sync
  `
  rem X10 - 231007 - frame by frame snpshot feature
  if snapshotmodeframebyframe>0
   if snapshotmodeframebyframe=1
    t1$=get date$() : t2$=get time$()
    snapshotmodeframebyframe$="snapshots_"+left$(t1$,2)+left$(right$(t1$,5),2)+right$(t1$,2)+left$(t2$,2)+left$(right$(t2$,5),2)+right$(t2$,2)
    tolddir$=get dir$()
    set dir myownrootdir$
    make directory snapshotmodeframebyframe$
    set dir tolddir$
   endif
   rem take a snapshot immediately
   save screenshot myownrootdir$+"\"+snapshotmodeframebyframe$+"\shot-"+right$(str$(1000+snapshotmodeframebyframe),3)+".bmp"
   inc snapshotmodeframebyframe
   if spacekey()=1
    rem exit snapshot feature
    snapshotmodeframebyframe=0
   endif
  endif
  `
  rem 302007 - study frame by frame mode (set leeleepause to 1)
  `if leeleepause>0
  ` if leeleepause=1 then sleep 4000
  ` if leeleepause=2 then sleep 3000
  ` if leeleepause=3 then sleep 2000
  ` if leeleepause=4 then sleep 1000
  ` if leeleepause=5 then leeleepause=-1
  ` leeleepause=leeleepause+1
  `endif
  `
 else
  `
  rem Update screen
  sync
  `
 endif
 `
 rem Stat8
 gamesyncperfsync(8)=gamesyncperfsync(8)+(perftimer()-gamesyncperftimestamp)
 gamesyncperftimestamp=perftimer()
 `
 rem Call any video or screenshot capture code now backbuffer is complete
 capturesession()
 `
 rem Stat9
 gamesyncperfsync(9)=gamesyncperfsync(9)+(perftimer()-gamesyncperftimestamp)
 gamesyncperftimestamp=perftimer()
 `
return

_sync_align_pseudoglued_objects:
 `
 rem Go through all entities for POST-VISUAL ALIGNMENTS (guns attached to enemies)
 for e=1 to entityelementlist
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  if entityelement(e).active=1 and entityelement(e).dormant=0
   if obj>0
    if object exist(obj)=1 and entityelement(e).plrdist<2000
     if object visible(obj)=1
      gosub _entity_controlattachments 
     endif
    endif
   endif
  endif
 next e
 `
return

function camask(camid)
 mask = %1 << camid
endfunction mask

function makecamera(camid,name$,mode,width,height,shader$,tex0,tex1,tex2,depthsteal,reflectmode,usestencil)
 camname$(camid)=name$
 if camid=0
  rem main backbuffer
  make object plain 1,2,2,1 : set object mask 1,%1
  texture object 1,0,tex0
  if tex1>0 then texture object 1,1,tex1
  if tex2>0 then texture object 1,2,tex2
  tfile$=shader$ : addfiletocollection(commoneffects$+tfile$)
  dirbefore$=get dir$() : set dir commoneffects$
  load effect tfile$,1,0 : set object effect 1,1
  set dir dirbefore$
 else
  rem pipeline cameras
  if camera exist(camid)=0 
   make camera camid : color backdrop camid,rgb(0,0,0)
  endif
  if name$="REDUNDANT"
   rem camera not used for anything any more
   color backdrop camid,0
   set camera view camid,0,0,1,1
  else
   set camera to image camid,camid,width,height,usestencil
   if reflectmode>0
    if reflectmode=1
     rem clip only - refract
     color backdrop camid,rgb(32,32,32)
     set camera clip camid,1,0,-10,0,0,-1,0
    endif
    if reflectmode=2
     rem mirror and clip - reflect
     color backdrop camid,rgb(32,32,32)
     set camera clip camid,2,0,-10,0,0,1,0
    endif
   endif
   if mode=1
    make object plain camid,2,2,2
    cammask=%1 : if camid>0 then cammask=cammask<<camid
    set object mask camid,cammask
    texture object camid,0,tex0
    if tex1>0 then texture object camid,1,tex1
    if tex2>0 then texture object camid,2,tex2
    tfile$=shader$ : addfiletocollection(commoneffects$+tfile$)
    dirbefore$=get dir$() : set dir commoneffects$
    load effect tfile$,camid,0
    set dir dirbefore$
    set object effect camid,camid
   endif
   if depthsteal>0
    color backdrop camid,rgb(0,0,0)
    set camera depth camid,depthsteal
   endif
  endif
 endif
endfunction

rem
rem GAME
rem

`
` Game Core Functions
`
_game_loadmap:

rem Load map data (in real mode, we ignore what the header gmultiplayergame flag is)
storegmultiplayergame=gmultiplayergame : gosub _mapfile_loadmap
if grealgameviewstate=1 then gmultiplayergame=storegmultiplayergame

rem Setup lighting
gosub _lighting_init

rem X10 Can skip universe construction if flagged
rem do not call skip code if real game or build game
rem compare MAP arrays with last saved copy
rem compare static lights to last saved copy
rem compare static entities to last saved copy
if gcompilestandaloneexe=1 or grealgameviewstate=1
 if grealgameviewstate=1 then tperformuniverseconstruction=0
 if gcompilestandaloneexe=1 then tperformuniverseconstruction=1
else
 rem only in test game scenario should this check be made
 tperformuniverseconstruction=1
 gosub _universe_construct_skip : rem sets universeconstructskip flag
 if universeconstructskip=1 then tperformuniverseconstruction=0
endif

rem If universe.dbo not present, construct it
universefile$=myownrootdir$+"levelbank\testlevel\universe.dbo"
if tperformuniverseconstruction=0
 `
 rem sneak automatic floor texture into data!
 thorizonplanes$=""
 `
 rem Load effects (as some scene geometry needs setting changes)
 debugviewtext(195,strarr$(115))
 filename$=myownrootdir$+"levelbank\testlevel\universe.eff"
 open to read 1,filename$
  read file 1,teffectbankmax
  for eff=1 to teffectbankmax
   read string 1,tfile$
   teffectid=loadinternaleffect(tfile$)
  next eff
  read string 1,thorizonplanes$
 close file 1
 `
 rem load pre-created universe for level
 debugviewtext(200,strarr$(116))
 load static objects universefile$,gdividetexturesize
 `
 rem Load elements list (that includes scene dynamic entities)
 if grealgameviewstate=1 or gcompilestandaloneexe=1
  `
  rem V106 RC4 only for final game loading and construction
  debugviewtext(201,strarr$(117))
  elementsfilename$=myownrootdir$+"levelbank\testlevel\universe.ele" : gosub _entity_loadelementsdata
  `
  rem Load infinity lights data
  debugviewtext(202,strarr$(118))
  filename$=myownrootdir$+"levelbank\testlevel\universe.lgt"
  open to read 1,filename$
   read file 1,tinfinimax
   dim infinilight(tinfinimax) as infinilighttype
   for i=0 to tinfinimax
    read file 1,infinilight(i).used
    read file 1,infinilight(i).type
    read float 1,infinilight(i).x
    read float 1,infinilight(i).y
    read float 1,infinilight(i).z
    read float 1,infinilight(i).range
    read file 1,infinilight(i).id
    read float 1,infinilight(i).dist
    read file 1,infinilight(i).colrgb.r
    read file 1,infinilight(i).colrgb.g
    read file 1,infinilight(i).colrgb.b
    read file 1,infinilight(i).islit
   next i
  close file 1
  `
 else
  `
  rem V110 - 130110 - from X9 code (V109 BETA3 - 210408 - TEST GAME recreates LGT data as it is not consistent with quick rebuild which has different entities!)
  gosub _universe_recreateinfinilights
  tinfinimax=infinilightindex
  `
  rem V110 - 130110 - solve some code issues with zery sized array
  if array count(infinilight())=-1 then dim infinilight(0) as infinilighttype
  `
 endif
 `
 rem count dynamic lights for the counter that controls this activity
 activatedynamiclightscount=0
 if gdynamiclightingstate=1
  for i=0 to tinfinimax
   if infinilight(i).type=1
    inc activatedynamiclightscount
   endif
  next i
 endif
 `
 rem create horizon planes (for final game only)
 if grealgameviewstate=1
  segobjstart=universebuildobjstartoffset
  segobj=segobjstart
  if gusefloorstate=1
   rem load in the texture used by the horizon polys (from filename got from above)
   mapselection=1 : dim segmentprofile(mapselection,64) as segmentprofiletype
   if thorizonplanes$="" then thorizonplanes$="texturebank\common\ground_D2.tga"
   segmentprofile(mapselection,0).texdid=loadinternalimage(thorizonplanes$)
   rem create the edge of universe polys
   gosub _universe_createhorizonplanes
  endif
  lastsegobj=segobj
 endif
 `
else
 `
 rem construct universe for level
 segobjstart=universebuildobjstartoffset
 gosub _universe_construct
 `
endif

rem X10 - 200907 - submit all lights for this level to universe system
rem for use in new areabox-local-lighting for bump shaders that use light zero
reset static lights
for i=0 to tinfinimax
 if infinilight(i).islit=1
  add static light i,infinilight(i).x,infinilight(i).y,infinilight(i).z,infinilight(i).range
 endif
next i
update static lights

rem X10 If universe has no effect load on, and apply it
if guniverseeffectindex=0
 guniverseeffectindex=loadinternaleffectunique("effectbank\universe\universe.fx",1)
 set static objects effect guniverseeffectindex
endif

rem Opportunity for ambience to be adjusted based on number of lights
gosub _lighting_postdefaults

rem Use mapdata to build viscolmap data
gosub _entity_fillviscolmap

rem setup scorch texture
if guseweaponsstate=1
 debugviewtext(280,strarr$(119))
 if bloodmode$="off"
  tbullethole=loadinternalimage("gamecore\Bulletholes\kidbulletholes.tga")
 else
  tbullethole=loadinternalimage("gamecore\Bulletholes\bulletholes.tga")
 endif
 debugviewtext(290,strarr$(120))
 set static scorch tbullethole,4,4
endif

return

`
` SUPPORT SUBROUTINES FOR GRIDEDIT CODE
`

_gridedit_getmapvalues:
 `
 rem mapid in
 mapselection    = ( mapid && %11111111111100000000000000000000 ) >> 20
 mapscaler       = ( mapid && %00000000000011110000000000000000 ) >> 16
 mapground       = ( mapid && %00000000000000001100000000000000 ) >> 14
 maprotate       = ( mapid && %00000000000000000011000000000000 ) >> 12
 maporient       = ( mapid && %00000000000000000000110000000000 ) >> 10
 mapsymbol       = ( mapid && %00000000000000000000001111110000 ) >> 4
 maptile         = ( mapid && %00000000000000000000000000001111 )
 `
return

_gridedit_makemapvalues:
 `
 mapid = 0
 mapid = mapid + ( ( mapselection && %111111111111 ) << 20 )
 mapid = mapid + ( ( mapscaler && %1111 ) << 16 )
 mapid = mapid + ( ( mapground && %11 ) << 14 )
 mapid = mapid + ( ( maprotate && %11 ) << 12 )
 mapid = mapid + ( ( maporient && %11 ) << 10 )
 mapid = mapid + ( ( mapsymbol && %111111 ) << 4 )
 mapid = mapid + ( ( maptile && %1111 ) )
 rem mapid out
 `
return


rem
rem SEGMENTS
rem

_segment_validatearraysize:
 `
 rem ensure enough space in arrays
 if segidmaster+32>segidmastermax
  segidmastermax=segidmaster+32
  dim selectionbank$(segidmastermax)
  dim selectionbanklocal$(segidmastermax)
  dim segmentprofileheader(segidmastermax) as segmentprofileheadertype
  dim segmentprofile(segidmastermax,64) as segmentprofiletype
 endif
 `
return

_segment_shufflebank:

rem FPSCV104RC6 - scan entire map data, delete all segment entries not used
if segidmaster>0
 dim segmentbankused(segidmaster)
 for tttsegid=1 to segidmaster
  segmentbankused(tttsegid)=0
 next tttsegid
 rem segs in map
 for tttl=0 to layermax
  for tttx=0 to maxx
   for ttty=0 to maxy
    tttmapid=map(tttl,tttx,ttty)
    if tttmapid>0
     tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
     if tttsegid>0 then segmentbankused(tttsegid)=1
    endif
    rem segs in olay
    ttto=mapolay(tttl,tttx,ttty)
    if ttto>0
     for tt=0 to 50
      tttmapid=olaylist(ttto,tt)
      if tttmapid>0
       tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
       if tttsegid>0 then segmentbankused(tttsegid)=1
      endif
     next tt
    endif
   next ttty
  next tttx
 next tttl
 for tttsegid=1 to segidmaster
  if segmentbankused(tttsegid)=0
   selectionbank$(tttsegid)=""
  endif
 next tttsegid
 rem shuffle to remove empties
 for tttsegid=1 to segidmaster
  segmentbankused(tttsegid)=0
 next tttsegid
 treadsegid=1 : tlargest=0
 for tttsegid=1 to segidmaster
  if treadsegid<=segidmaster
   while selectionbank$(treadsegid)=""
    inc treadsegid : if treadsegid>segidmaster then exit
   endwhile
   if treadsegid<=segidmaster
    selectionbank$(tttsegid)=selectionbank$(treadsegid)
    selectionbanklocal$(tttsegid)=selectionbanklocal$(treadsegid)
    segmentprofileheader(tttsegid)=segmentprofileheader(treadsegid)
    for tt=0 to 64 : segmentprofile(tttsegid,tt)=segmentprofile(treadsegid,tt) : next tt
    segmentbankused(treadsegid)=tttsegid
    tlargest=tttsegid
   else
    selectionbank$(tttsegid)=""
   endif
  else
   selectionbank$(tttsegid)=""
  endif
  inc treadsegid
 next tttsegid
 rem new list size
 if segidmaster<>tlargest
  segidmaster=tlargest
  entityorsegmententrieschanged=1
 endif
 rem update bank index numbers in mapdata
 for tttl=0 to layermax
  for tttx=0 to maxx
   for ttty=0 to maxy
    tttmapid=map(tttl,tttx,ttty)
    if tttmapid>0
     tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
     if tttsegid>0
      rem new segment entry place index
      newtttsegid = segmentbankused(tttsegid)
      tttmapid = tttmapid && %00000000000011111111111111111111
      tttmapid = tttmapid || ( newtttsegid << 20 )
      map(tttl,tttx,ttty)=tttmapid
     endif
    endif
    rem segs in olay
    ttto=mapolay(tttl,tttx,ttty)
    if ttto>0
     for tt=0 to 50
      tttmapid=olaylist(ttto,tt)
      if tttmapid>0
       tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
       if tttsegid>0
        newtttsegid = segmentbankused(tttsegid)
        tttmapid = tttmapid && %00000000000011111111111111111111
        tttmapid = tttmapid || ( newtttsegid << 20 )
        olaylist(ttto,tt)=tttmapid
       endif
      endif
     next tt
    endif
   next ttty
  next tttx
 next tttl
 undim segmentbankused()
endif

return

_segment_savebank:

rem Save segment bank
if file exist(myownrootdir$+"mapbank\testmap\map.seg")=1 then delete file myownrootdir$+"mapbank\testmap\map.seg"
open to write 1,myownrootdir$+"mapbank\testmap\map.seg"
 write file 1,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   write string 1,selectionbank$(segid)
  next segid
 endif
close file 1

return

_segment_deletebank:

rem Destroy old segments
if segidmastermax>0
 rem changed from segidmaster
 for segid=1 to segidmastermax
  segobj=selectionbankoffset+segid
  if object exist(segobj)=1 then delete object segobj
  selectionbank$(segid)=""
 next segid
endif
segidmaster=0

return

_segment_loadbank:

rem If seg file exists
if file exist(myownrootdir$+"mapbank\testmap\map.seg")=1

rem Destroy old segments
gosub _segment_deletebank

rem Load segment bank
open to read 1,myownrootdir$+"mapbank\testmap\map.seg"
 read file 1,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   read string 1,selectionbank$(segid)
  next segid
 endif
close file 1

rem Load segments specified by bank
segdir$="segments\"
if segidmaster>0
 for segid=1 to segidmaster
  seg$=selectionbank$(segid)
  if seg$<>""
   segcategory$=getfirstdir(seg$)
   segpath$=getseconddir(seg$)
   gosub _segment_load
   if segmentprofileheader(segid).partmax=-1
    selectionbank$(segid)=""
   endif
  else
   segmentprofileheader(segid).partmax=-1
  endif
 next segid
endif

rem No file
endif

return

_segment_updatebank:

rem If seg file exists
if file exist(myownrootdir$+"mapbank\testmap\map.seg")=1

rem Clear non-present entries
for segid=segidmaster+1 to segidmastermax
 selectionbank$(segid)=""
next segid

rem Update segment bank
segdir$="segments\"
open to read 2,myownrootdir$+"mapbank\testmap\map.seg"
 read file 2,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   read string 2,tseg$
   if tseg$<>selectionbank$(segid)
    selectionbank$(segid)=tseg$
    seg$=selectionbank$(segid)
    segcategory$=getfirstdir(seg$)
    segpath$=getseconddir(seg$)
    gosub _segment_load
   endif
  next segid
 endif
close file 2

rem No file
endif

return

_segment_preloadtextures:

rem Load textures for segment
segmeshpartmax=segmentprofileheader(segid).lastmeshmax
for p=0 to segmeshpartmax
 `
 rem RADICAL change - D2 only required texture - rest generated here D.I.N.S
 `
 rem Can use multi-texture
 if segobjusedforfinalgame=1
  if segmentprofile(segid,p).multimeshmode=1
   extralimbp=segmentprofile(segid,p).multimeshstart
   if extralimbp>0
    rem points to two new meshes which may have _02 and _03 textures associated
    ttfile$=segmentprofile(segid,p).tex$
    tfilecheck$=left$(ttfile$,len(ttfile$)-4)
    rem X10 - 220807 - can handle D2 or D as texture file end
    thasmultipletextures=0 : ttexend$=""
    if lower$(right$(tfilecheck$,5))="_01_d" then thasmultipletextures=5 : ttexend$="D"
    if lower$(right$(tfilecheck$,6))="_01_d2" then thasmultipletextures=6 : ttexend$="D2"
    if thasmultipletextures>0
     rem generate _02 and _03 textures in correct part of segment (mesh)
     tfile$=ttfile$ : tfile$=left$(tfile$,len(tfile$)-len("_NN_"+ttexend$+".TGA"))
     segmentprofile(segid,extralimbp+0).tex$=tfile$+"_02_"+ttexend$+".TGA"
     if file exist(segmentprofile(segid,extralimbp+0).tex$)=0
      segmentprofile(segid,extralimbp+0).tex$=tfile$+"_02_"+ttexend$+".DDS"
      if file exist(segmentprofile(segid,extralimbp+0).tex$)=0
       segmentprofile(segid,extralimbp+0).tex$=ttfile$
      endif
     endif
     segmentprofile(segid,extralimbp+1).tex$=tfile$+"_03_"+ttexend$+".TGA"
     if file exist(segmentprofile(segid,extralimbp+1).tex$)=0
      segmentprofile(segid,extralimbp+1).tex$=tfile$+"_03_"+ttexend$+".DDS"
      if file exist(segmentprofile(segid,extralimbp+1).tex$)=0
       segmentprofile(segid,extralimbp+1).tex$=ttfile$
      endif
     endif
    endif
   endif
  endif
 endif
 `
 rem Load actual textures based on effect requirements
 segmentprofile(segid,p).texid=0
 segmentprofile(segid,p).texdid=0
 segmentprofile(segid,p).texnid=0
 segmentprofile(segid,p).texsid=0
 texdir$=segmentprofile(segid,p).tex$
 if texdir$<>""
  `
  rem Effect or No
  tfile$=segmentprofile(segid,p).effect$
  teffectuseslightmapstage=1 : gosub _common_makeeffecttextureset
  if tfile$<>"" and guseeffectonscenesstate=1
   `
   rem Load and apply MAIN texture directly
   tstage=0
   for tlayer=0 to 3
    if tlayer=0 then texfiletouse$=texdir1$
    if tlayer=1 then texfiletouse$=texdir2$
    if tlayer=2 then texfiletouse$=texdir3$
    if tlayer=3 then texfiletouse$=texdir4$
    if tlayer=4 then texfiletouse$=texdir5$
    texuseid=loadinternaltexture(texfiletouse$)
    if texuseid=0
     rem some effects need a blank texture if no file available
     if tlayer<=ensureclearlayermax
      rem black texture if no texture
      texuseid=loadinternalimagecompressquality("texturebank\common\black.tga",1,0)
     endif
    endif
    if texuseid>0
     if tstage=0 then segmentprofile(segid,p).texdid=texuseid : segmentprofile(segid,p).texid=texuseid
     rem hardcodedtexturestages from _common_makeeffecttextureset
     if hardcodedtexturestages=2
      rem bump.fx
      if tstage=1 then segmentprofile(segid,p).texdid=texuseid
      if tstage=2 then segmentprofile(segid,p).texsid=texuseid
      if tstage=3 then segmentprofile(segid,p).texnid=texuseid
     else
      rem illumination.fx
      if tstage=1 then segmentprofile(segid,p).texdid=texuseid
      if tstage=2 then segmentprofile(segid,p).texsid=texuseid
     endif
     inc tstage
    endif
   next tlayer
   `
  else
   rem Basic Texture (D2)
   tfile$=segmentprofile(segid,p).tex$
   segmentprofile(segid,p).texid=loadinternaltexture(tfile$)
   if segmentprofile(segid,p).multimeshmode=1
    textralimbp=segmentprofile(segid,p).multimeshstart
    if textralimbp>0
     segmentprofile(segid,textralimbp+0).texid=loadinternaltexture(segmentprofile(segid,textralimbp+0).tex$)
     segmentprofile(segid,textralimbp+1).texid=loadinternaltexture(segmentprofile(segid,textralimbp+1).tex$)
    endif
   endif
  endif
 endif
 `
next p

return

_segment_preloadeffects:

rem Load effect for segment
segmeshpartmax=segmentprofileheader(segid).lastmeshmax
for p=0 to segmeshpartmax
 if segmentprofile(segid,p).effect$<>"" and segnoeffects=0 and guseeffectonscenesstate=1
  tfile$=segmentprofile(segid,p).effect$
  gosub _common_wipeeffectifnotexist
  if tfile$<>""
   debugfilename(tfile$,"effect:"+seg$)
   segmentprofile(segid,p).effectid=loadinternaleffect(tfile$)
  else
   segmentprofile(segid,p).effectid=0
  endif
 else
  segmentprofile(segid,p).effectid=0
 endif
next p

return

_segment_load:

rem Segment Object Index
segobj=selectionbankoffset+segid

rem debug info
mytimer=timer()

rem Load segment profile data
segmentprofileheader(segid).partmax=-1
segmentprofileheader(segid).preventai=0
gosub _segment_loaddata
segpartmax=segmentprofileheader(segid).partmax

rem Only if profile exists
if segpartmax<>-1
 `
 rem Check if DBO version of segment obj exists
 tsegobjpreloaded=0
 if segobjusedforfinalgame=0
  tsegobjfile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".dbo"
  if file exist(tsegobjfile$)=1 and segobjusedformapeditor=0
   load object tsegobjfile$,segobj
   tsegobjpreloaded=1
  endif
 endif
 `
 rem segment mesh max
 segmeshpartmax=segmentprofileheader(segid).lastmeshmax
 `
 rem Load meshes for segment
 if tsegobjpreloaded=0
  for p=0 to segmeshpartmax
   if segmentprofile(segid,p).partmode=0
    tmeshname$=segmentprofile(segid,p).meshname$
    if segmentprofile(segid,p).csgmesh$<>"" then tmeshname$=segmentprofile(segid,p).csgmesh$
    if tmeshname$<>""
     tfile$=tmeshname$
     debugfilename(tfile$,"mesh:"+seg$)
     segmentprofile(segid,p).meshid=loadinternalmesh(tfile$)
    endif
   endif
  next p
 endif
 `
 rem Load multi-meshes for segment
 originalsegmeshpartmax=-1
 if segobjusedforfinalgame=1
  dim tempsegmentprofile(64) as segmentprofiletype
  tempp=0
  rem place where new limbs will be located (extralimbp) - we will move things like entitys/csgs to end
  extralimbp=segmeshpartmax+1
  for p=0 to segmeshpartmax
   if segmentprofile(segid,p).partmode=0
    ttmeshname$=segmentprofile(segid,p).meshname$
    if segmentprofile(segid,p).multimeshmode=1
     if segmentprofile(segid,p).csgmesh$="" and ttmeshname$<>""
      if lower$(right$(ttmeshname$,3))="a.x"
       for ttwo=0 to 1
        tmeshname$=ttmeshname$
        tmeshname$=left$(tmeshname$,len(tmeshname$)-3)
        if ttwo=0 then tmeshname$=tmeshname$+"b.x"
        if ttwo=1 then tmeshname$=tmeshname$+"c.x"
        tfile$=tmeshname$
        debugfilename(tfile$,"mesh:"+seg$)
        tempsegmentprofile(tempp)=segmentprofile(segid,p)
        if ttwo=0 then tempsegmentprofile(tempp).meshid=loadinternalmesh(tfile$)
        if ttwo=1 then tempsegmentprofile(tempp).meshid=loadinternalmesh(tfile$)
        inc tempp
       next ttwo
      else
       rem not a.x, but can still habe multi-texture so use base mesh instead
       tempsegmentprofile(tempp)=segmentprofile(segid,p)
       tempsegmentprofile(tempp).meshid=loadinternalmesh(ttmeshname$)
       inc tempp
       tempsegmentprofile(tempp)=segmentprofile(segid,p)
       tempsegmentprofile(tempp).meshid=loadinternalmesh(ttmeshname$)
       inc tempp
      endif
      segmentprofile(segid,p).multimeshstart=extralimbp
      inc extralimbp,2
     endif
    endif
   endif
  next p
  rem multimesh entries made
  if tempp>0
   rem first copy non-mesh parts (entity/csg) to new end
   for p=segpartmax to segmeshpartmax+1 step -1
    segmentprofile(segid,p+tempp)=segmentprofile(segid,p)
   next p
   rem now copy accumilated multi-meshes to updated segment profile
   temppmax=tempp : tempp=0
   for p=segmeshpartmax+1 to segmeshpartmax+temppmax
    segmentprofile(segid,p)=tempsegmentprofile(tempp) : inc tempp
   next p
   rem update max values
   segmentprofileheader(segid).partmax=segpartmax+temppmax
   segpartmax=segmentprofileheader(segid).partmax
   originalsegmeshpartmax=segmeshpartmax
   segmentprofileheader(segid).lastmeshmax=segmeshpartmax+temppmax
   segmeshpartmax=segmentprofileheader(segid).lastmeshmax
  endif
 endif
 `
 rem Load textures for segment
 gosub _segment_preloadtextures
 `
 rem Load effect for segment
 gosub _segment_preloadeffects
 `
 rem Build segment in object from segment profile
 if tsegobjpreloaded=0
  segmeshpartmax=segmentprofileheader(segid).lastmeshmax
  tpstart=0 : tpend=segmeshpartmax
  for p=tpstart to tpend
   if object exist(segobj)=0
    make object segobj,segmentprofile(segid,p).meshid,0
   else
    add limb segobj,p,segmentprofile(segid,p).meshid
   endif
   offset limb segobj,p,segmentprofile(segid,p).offx,segmentprofile(segid,p).offy,segmentprofile(segid,p).offz
   rotate limb segobj,p,0,segmentprofile(segid,p).roty,0
  next p
 endif
 `
 rem load csg meshes for scene building
 if tsegobjpreloaded=0
  for tp=0 to segpartmax
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=segmentprofile(segid,tp).meshname$
    if tmeshname$<>""
     tfile$=tmeshname$
     debugfilename(tfile$,"mesh:"+seg$)
     segmentprofile(segid,tp).meshid=loadinternalmesh(tfile$)
     add limb segobj,p,segmentprofile(segid,tp).meshid
     offset limb segobj,p,segmentprofile(segid,tp).offx,segmentprofile(segid,tp).offy,segmentprofile(segid,tp).offz
     rotate limb segobj,p,0,segmentprofile(segid,tp).roty,0
     color limb segobj,p,rgb(0,255,0)
     segmentprofile(segid,tp).actuallimb=p
     inc p
    endif
   endif
  next tp
 else
  rem still need actuallimb data for CSG meshes
  p=segmeshpartmax+1
  for tp=0 to segpartmax
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=segmentprofile(segid,tp).meshname$
    if tmeshname$<>"" then segmentprofile(segid,tp).actuallimb=p : inc p
   endif
  next tp
 endif
 `
 rem Save DBO of segment if not exist
 if segobjusedforfinalgame=0
  if file exist(tsegobjfile$)=0
   save object tsegobjfile$,segobj
  endif
 endif
 `
 rem Texture segment in object from segment profile
 segmeshpartmax=segmentprofileheader(segid).lastmeshmax
 for p=0 to segmeshpartmax
  if segmentprofile(segid,p).effectid=0
   texture limb segobj,p,segmentprofile(segid,p).texid
  else
   if segmentprofile(segid,p).texdid=0
    texture limb segobj,p,segmentprofile(segid,p).texid
   else
    rem multi-layered texture
    texture limb segobj,p,0,segmentprofile(segid,p).texdid
    texture limb segobj,p,1,segmentprofile(segid,p).texdid
    if segmentprofile(segid,p).texsid<>0 then texture limb segobj,p,2,segmentprofile(segid,p).texsid
    if segmentprofile(segid,p).texnid<>0 then texture limb segobj,p,3,segmentprofile(segid,p).texnid
   endif
   rem X10 do NOT apply effect now as universe shader acts on lightmapped FVF only
   rem but the above texture settings will help universe apply
   rem ulluminationmap.fx automatically (hard coded as technique setter at 280307)
   `set limb effect segobj,p,segmentprofile(segid,p).effectid
  endif
 next p
 `
 rem Set any segment transparenct (always uses transparency TGA=alpha)
 set object transparency segobj,1
 `
 rem Hide object away
 position object segobj,100000,100000,100000
 `
 rem Ensure multimeshes are hidden from segment handling (only used in node tree creation)
 if segobjusedforfinalgame=1 and originalsegmeshpartmax<>-1
  segmentprofileheader(segid).lastmeshmax=originalsegmeshpartmax
  segmeshpartmax=originalsegmeshpartmax
 endif
 `
rem no profile exists endif
endif

rem debug info and timestamp (if logged)
debugviewtext(-1,"Built "+seg$+" in "+str$(timer()-mytimer)+"ms")
timestampactivity(0,"Loaded "+str$(segid)+":"+seg$)

return

_segment_cleardata:

rem Default mesh settings
segpartmax=64
for q=0 to segpartmax
 segmentprofile(segid,q).partmode=0
 segmentprofile(segid,q).tex$=""
 segmentprofile(segid,q).texid=0
 segmentprofile(segid,q).texdid=0
 segmentprofile(segid,q).texiid=0
 segmentprofile(segid,q).texnid=0
 segmentprofile(segid,q).texsid=0
` segmentprofile(segid,q).texd$=""
` segmentprofile(segid,q).texn$=""
` segmentprofile(segid,q).texs$=""
 segmentprofile(segid,q).effect$=""
 segmentprofile(segid,q).effectid=0
 segmentprofile(segid,q).csgmesh$=""
 segmentprofile(segid,q).csgmode=0
 segmentprofile(segid,q).csgimmune=0
 segmentprofile(segid,q).transparency=0
next q

rem Default hidden parts
segmentprofile(segid).vis.overlay=0
segmentprofile(segid).vis.f=-1
segmentprofile(segid).vis.r=-1
segmentprofile(segid).vis.wb=-1
segmentprofile(segid).vis.wr=-1
segmentprofile(segid).vis.wf=-1
segmentprofile(segid).vis.wl=-1
segmentprofile(segid).vis.owb=-1
segmentprofile(segid).vis.owr=-1
segmentprofile(segid).vis.owf=-1
segmentprofile(segid).vis.owl=-1
segmentprofile(segid).vis.ctl=-1
segmentprofile(segid).vis.ctr=-1
segmentprofile(segid).vis.cbr=-1
segmentprofile(segid).vis.cbl=-1
segmentprofile(segid).vis.octl=-1
segmentprofile(segid).vis.octr=-1
segmentprofile(segid).vis.ocbr=-1
segmentprofile(segid).vis.ocbl=-1

rem Default blueprint data
segmentprofile(segid).blueprint.mode=0
segmentprofile(segid).blueprint.symbol=0
segmentprofile(segid).blueprint.floorsizey=-1
segmentprofile(segid).blueprint.sidesizex=100
segmentprofile(segid).blueprint.sidesizey=100
segmentprofile(segid).blueprint.sidesizez=100

rem Default properties data
segmentprofile(segid).properties.groundmode=0
segmentprofile(segid).properties.kindof=0

return

_segment_loaddata:

rem Default Segment Data
gosub _segment_cleardata

rem Fill this last if not in filedata
segmentprofileheader(segid).lastmeshmax=-1
segmentprofileheader(segid).preventai=0

rem Ensure segment profile still exists
if file exist(segdir$+seg$)=1

rem Export entity FPE file if flagged
if gexportassets=1
 tthumbbmpfile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".bmp"
 addfiletocollection(segdir$+seg$) : addfiletocollection(tthumbbmpfile$)
endif

rem Check if binary version of segment profile exists
tprofile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".bin"
tprofile$=turnfilenameuserlocal(tprofile$)
if isbinaryfileolderthantxtfile(tprofile$,segdir$+seg$)=1 then delete file tprofile$

rem X10 - 021107 - submit BIN file as relative (not absolute which filecollection ignores)
trelativeprofile$=right$(tprofile$,len(tprofile$)-len(myownrootdir$))
addfiletocollection(trelativeprofile$)

if file exist(tprofile$)=0
 `
 rem Load Segment Data from file
 dim data$(999)
 load array segdir$+seg$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem HEADER
    if field$="partmax" then segmentprofileheader(segid).partmax=value1
    if field$="lastmeshmax" then segmentprofileheader(segid).lastmeshmax=value1
    if field$="preventai" then segmentprofileheader(segid).preventai=value1
    `
    rem SEGMENT PARTS
    segpartmax=segmentprofileheader(segid).partmax
    for p=0 to segpartmax
     tryfield$="partmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).partmode=value1
     tryfield$="meshname"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).meshname$=value$
     tryfield$="offx"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offx=value1
     tryfield$="offy"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offy=value1
     tryfield$="offz"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offz=value1
     tryfield$="rotx"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).rotx=value1
     tryfield$="roty"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).roty=value1
     tryfield$="rotz"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).rotz=value1
     tryfield$="texture"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).tex$=value$
`     tryfield$="textured"+str$(p)
`     if field$=tryfield$ then segmentprofile(segid,p).texd$=value$
`     tryfield$="texturen"+str$(p)
`     if field$=tryfield$ then segmentprofile(segid,p).texn$=value$
`     tryfield$="textures"+str$(p)
`     if field$=tryfield$ then segmentprofile(segid,p).texs$=value$
     tryfield$="transparency"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).transparency=value1
     tryfield$="effect"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).effect$=value$
     tryfield$="colmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).colmode=value1
     tryfield$="csgmesh"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgmesh$=value$
     tryfield$="csgmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgmode=value1
     tryfield$="csgimmune"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgimmune=value1
     tryfield$="lightmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).lightmode=value1
     tryfield$="multimeshmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).multimeshmode=value1
     tryfield$="materialindex"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).material.index=value1
    next p
    `
    rem SEGMENT VISIBILITY
    if field$="visoverlay" then segmentprofile(segid).vis.overlay=value1
    if field$="visfloor" then segmentprofile(segid).vis.f=value1
    if field$="visroof" then segmentprofile(segid).vis.r=value1
    if field$="viswallb" then segmentprofile(segid).vis.wb=value1 : segmentprofile(segid).vis.owb=value2
    if field$="viswallr" then segmentprofile(segid).vis.wr=value1 : segmentprofile(segid).vis.owr=value2
    if field$="viswallf" then segmentprofile(segid).vis.wf=value1 : segmentprofile(segid).vis.owf=value2
    if field$="viswalll" then segmentprofile(segid).vis.wl=value1 : segmentprofile(segid).vis.owl=value2
    if field$="viscornertl" then segmentprofile(segid).vis.ctl=value1 : segmentprofile(segid).vis.octl=value2
    if field$="viscornertr" then segmentprofile(segid).vis.ctr=value1 : segmentprofile(segid).vis.octr=value2
    if field$="viscornerbr" then segmentprofile(segid).vis.cbr=value1 : segmentprofile(segid).vis.ocbr=value2
    if field$="viscornerbl" then segmentprofile(segid).vis.cbl=value1 : segmentprofile(segid).vis.ocbl=value2
    `
    rem SEGMENT BLUEPRINT
    if field$="mode" then segmentprofile(segid).blueprint.mode=value1
    if field$="symbol" then segmentprofile(segid).blueprint.symbol=value1
    if field$="floorsizey" then segmentprofile(segid).blueprint.floorsizey=value1
    if field$="sidesizex" then segmentprofile(segid).blueprint.sidesizex=value1
    if field$="sidesizey" then segmentprofile(segid).blueprint.sidesizey=value1
    if field$="sidesizez" then segmentprofile(segid).blueprint.sidesizez=value1
    `
    rem SEGMENT PROPERTIES
    if field$="groundmode" then segmentprofile(segid).properties.groundmode=value1
    if field$="kindof" then segmentprofile(segid).properties.kindof=value1
    `
   endif
  endif
 next l
 undim data$()
 `
 rem Save segment profile as binary (and strings tagged to end)
 dim temp(64) as segmentprofiletype
 open to write 1,tprofile$
 write file 1,segmentprofileheader(segid).partmax
 write file 1,segmentprofileheader(segid).lastmeshmax
 write file 1,segmentprofileheader(segid).preventai
 segpartmax=segmentprofileheader(segid).partmax
 for p=0 to segpartmax : temp(p)=segmentprofile(segid,p) : next p
 if memblock exist(1)=1 then delete memblock 1
 for p=0 to segpartmax
  temp(p).meshname$=free string()
  temp(p).tex$=free string()
`  temp(p).texd$=free string()
`  temp(p).texn$=free string()
`  temp(p).texs$=free string()
  temp(p).effect$=free string()
  temp(p).csgmesh$=free string()
 next p
 make memblock from array 1,temp(0)
 write memblock 1,1
 for p=0 to segpartmax
  write string 1,segmentprofile(segid,p).meshname$
  write string 1,segmentprofile(segid,p).tex$
 ` write string 1,segmentprofile(segid,p).texd$
 ` write string 1,segmentprofile(segid,p).texn$
 ` write string 1,segmentprofile(segid,p).texs$
  write string 1,segmentprofile(segid,p).effect$
  write string 1,segmentprofile(segid,p).csgmesh$
 next p
 close file 1
 delete memblock 1
 undim temp(0)
 `
else
 `
 rem load binary version of segment profile file
 dim temp(64) as segmentprofiletype
 open to read 1,tprofile$
 read file 1,tval : segmentprofileheader(segid).partmax=tval
 read file 1,tval : segmentprofileheader(segid).lastmeshmax=tval
 read file 1,tval : segmentprofileheader(segid).preventai=tval
 segpartmax=segmentprofileheader(segid).partmax
 read memblock 1,1
 make array from memblock temp(0),1
 for p=0 to segpartmax : segmentprofile(segid,p)=temp(p) : next p
 for p=0 to segpartmax
  read string 1,tstr$ : segmentprofile(segid,p).meshname$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).tex$=tstr$
`  read string 1,tstr$ : segmentprofile(segid,p).texd$=tstr$
`  read string 1,tstr$ : segmentprofile(segid,p).texn$=tstr$
`  read string 1,tstr$ : segmentprofile(segid,p).texs$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).effect$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).csgmesh$=tstr$
 next p
 close file 1
 delete memblock 1
 undim temp(0)
 `
endif

rem If lastmesh not there, use partmax
if segmentprofileheader(segid).lastmeshmax=-1
 segmentprofileheader(segid).lastmeshmax=segmentprofileheader(segid).partmax
endif

rem File not exist endif
else
 rem File not exist, provide debug information
 debugfilename(segdir$+seg$,"")
endif

return

_segment_savedata:

rem Create seg file in string array (segid to savesegfile$)
dim data$(999) : l=-1

rem SEGMENT HEADER
inc l : data$(l)=";Segment Spec"
inc l : data$(l)=""
inc l : data$(l)=";Header"
inc l : data$(l)=""
inc l : data$(l)="partmax = "+str$(segmentprofileheader(segid).partmax)
inc l : data$(l)="lastmeshmax = "+str$(segmentprofileheader(segid).lastmeshmax)
inc l : data$(l)="preventai = "+str$(segmentprofileheader(segid).preventai)

rem SEGMENT PARTS
inc l : data$(l)=""
inc l : data$(l)=";Segment Parts"
inc l : data$(l)=""
for p=0 to segmentprofileheader(segid).partmax
 tryfield$=minstring("partmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).partmode)
 tryfield$=minstring("meshname"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).meshname$
 tryfield$=minstring("offx"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offx)
 tryfield$=minstring("offy"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offy)
 tryfield$=minstring("offz"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offz)
 tryfield$=minstring("rotx"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).rotx)
 tryfield$=minstring("roty"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).roty)
 tryfield$=minstring("rotz"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).rotz)
 tryfield$=minstring("texture"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).tex$
` tryfield$=minstring("textured"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texd$
` tryfield$=minstring("texturen"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texn$
` tryfield$=minstring("textures"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texs$
 tryfield$=minstring("transparency"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).transparency)
 tryfield$=minstring("effect"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).effect$
 tryfield$=minstring("colmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).colmode)
 tryfield$=minstring("csgmesh"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).csgmesh$
 tryfield$=minstring("csgmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).csgmode)
 tryfield$=minstring("csgimmune"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).csgimmune)
 tryfield$=minstring("lightmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).lightmode)
 tryfield$=minstring("multimeshmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).multimeshmode)
 tryfield$=minstring("materialindex"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).material.index)
 inc l : data$(l)=""
 `
 rem Ensure we never run out of array space
 if l>100 then array insert at bottom data$(),11
 `
next p

rem SEGMENT VISIBILITY
inc l : data$(l)=";Segment Visibility"
inc l : data$(l)=""
inc l : data$(l)=minstring("visoverlay",15)+" = "+str$(segmentprofile(segid).vis.overlay)
inc l : data$(l)=minstring("visfloor",15)+" = "+str$(segmentprofile(segid).vis.f)
inc l : data$(l)=minstring("visroof",15)+" = "+str$(segmentprofile(segid).vis.r)
try=segmentprofile(segid).vis.owb : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallb",15)+" = "+str$(segmentprofile(segid).vis.wb)+extra$
try=segmentprofile(segid).vis.owr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallr",15)+" = "+str$(segmentprofile(segid).vis.wr)+extra$
try=segmentprofile(segid).vis.owf : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallf",15)+" = "+str$(segmentprofile(segid).vis.wf)+extra$
try=segmentprofile(segid).vis.owl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswalll",15)+" = "+str$(segmentprofile(segid).vis.wl)+extra$
try=segmentprofile(segid).vis.octl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornertl",15)+" = "+str$(segmentprofile(segid).vis.ctl)+extra$
try=segmentprofile(segid).vis.octr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornertr",15)+" = "+str$(segmentprofile(segid).vis.ctr)+extra$
try=segmentprofile(segid).vis.ocbr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornerbr",15)+" = "+str$(segmentprofile(segid).vis.cbr)+extra$
try=segmentprofile(segid).vis.ocbl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornerbl",15)+" = "+str$(segmentprofile(segid).vis.cbl)+extra$

rem SEGMENT BLUEPRINT
inc l : data$(l)=""
inc l : data$(l)=";Segment Blueprint"
inc l : data$(l)=""
inc l : data$(l)=minstring("mode",15)+" = "+str$(segmentprofile(segid).blueprint.mode)
inc l : data$(l)=minstring("symbol",15)+" = "+str$(segmentprofile(segid).blueprint.symbol)
inc l : data$(l)=minstring("floorsizey",15)+" = "+str$(segmentprofile(segid).blueprint.floorsizey)
inc l : data$(l)=minstring("sidesizex",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizex)
inc l : data$(l)=minstring("sidesizey",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizey)
inc l : data$(l)=minstring("sidesizez",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizez)

rem SEGMENT PROPERTIES
inc l : data$(l)=minstring("groundmode",15)+" = "+str$(segmentprofile(segid).properties.groundmode)
inc l : data$(l)=minstring("kindof",15)+" = "+str$(segmentprofile(segid).properties.kindof)

rem END MARKER
inc l : data$(l)=""
inc l : data$(l)=";end"

rem Shorten array based on L
dim newdata$(l+1) : for t=0 to l : newdata$(t)=data$(t) : next t

rem Delet the short-load BIN and DBO files
tprofile$=left$(savesegfile$,len(savesegfile$)-4)+".bin"
if file exist(tprofile$)=1 then delete file tprofile$
tprofile$=left$(savesegfile$,len(savesegfile$)-4)+".dbo"
if file exist(tprofile$)=1 then delete file tprofile$

rem Save Segment Data to file
if file exist(savesegfile$)=1 then delete file savesegfile$
save array savesegfile$,newdata$()

rem Free usages
undim newdata$()
undim data$()

return

_segment_showallsegmentlimbs:

rem segment and segment rotayion used
seg=mapselection : segmaprot=maprotate-maporient
if segmaprot<0 then inc segmaprot,4

rem force show all limbs for overlay
for tl=1 to 99
 if limb exist(obj,tl)=1
  show limb obj,tl
 endif
next tl

rem rotate object ro rotation
yrotate object obj,maporient*90

`rem Set any segment transparenct - many transparency values - use profileobj
`set object transparency obj,segmentprofile(seg).transparency

return

_segment_customisesinglesegment:

rem segment and segment rotayion used
seg=mapselection : segmaprot=maprotate-maporient
if segmaprot<0 then inc segmaprot,4

rem scale any walls to scaler value (if any)
if segmentprofile(seg).blueprint.sidesizex>100
 if segmentprofile(seg).vis.wb<>-1
  if (mapscaler && %0001)
   show limb obj,segmentprofile(seg).vis.wb
   if segmentprofile(seg).vis.owb<>-1 then show limb obj,segmentprofile(seg).vis.owb
  else
   hide limb obj,segmentprofile(seg).vis.wb
   if segmentprofile(seg).vis.owb<>-1 then hide limb obj,segmentprofile(seg).vis.owb
  endif
 endif
 if segmentprofile(seg).vis.wr<>-1
  if (mapscaler && %0010)
   show limb obj,segmentprofile(seg).vis.wr
   if segmentprofile(seg).vis.owr<>-1 then show limb obj,segmentprofile(seg).vis.owr
  else
   hide limb obj,segmentprofile(seg).vis.wr
   if segmentprofile(seg).vis.owr<>-1 then hide limb obj,segmentprofile(seg).vis.owr
  endif
 endif
 if segmentprofile(seg).vis.wf<>-1
  if (mapscaler && %0100)
   show limb obj,segmentprofile(seg).vis.wf
   if segmentprofile(seg).vis.owf<>-1 then show limb obj,segmentprofile(seg).vis.owf
  else
   hide limb obj,segmentprofile(seg).vis.wf
   if segmentprofile(seg).vis.owf<>-1 then hide limb obj,segmentprofile(seg).vis.owf
  endif
 endif
 if segmentprofile(seg).vis.wl<>-1
  if (mapscaler && %1000)
   show limb obj,segmentprofile(seg).vis.wl
   if segmentprofile(seg).vis.owl<>-1 then show limb obj,segmentprofile(seg).vis.owl
  else
   hide limb obj,segmentprofile(seg).vis.wl
   if segmentprofile(seg).vis.owl<>-1 then hide limb obj,segmentprofile(seg).vis.owl
  endif
 endif
else
 if segmentprofile(seg).vis.wb<>-1
  show limb obj,segmentprofile(seg).vis.wb
  if segmentprofile(seg).vis.owb<>-1 then show limb obj,segmentprofile(seg).vis.owb
 endif
 if segmentprofile(seg).vis.wr<>-1
  show limb obj,segmentprofile(seg).vis.wr
  if segmentprofile(seg).vis.owr<>-1 then show limb obj,segmentprofile(seg).vis.owr
 endif
 if segmentprofile(seg).vis.wf<>-1
  show limb obj,segmentprofile(seg).vis.wf
  if segmentprofile(seg).vis.owf<>-1 then show limb obj,segmentprofile(seg).vis.owf
 endif
 if segmentprofile(seg).vis.wl<>-1
  show limb obj,segmentprofile(seg).vis.wl
  if segmentprofile(seg).vis.owl<>-1 then show limb obj,segmentprofile(seg).vis.owl
 endif
endif

rem default limbs states
if segmentprofile(seg).vis.f<>-1 then show limb obj,segmentprofile(seg).vis.f
if segmentprofile(seg).vis.r<>-1 then show limb obj,segmentprofile(seg).vis.r
if segmentprofile(seg).vis.ctl<>-1 then hide limb obj,segmentprofile(seg).vis.ctl
if segmentprofile(seg).vis.ctr<>-1 then hide limb obj,segmentprofile(seg).vis.ctr
if segmentprofile(seg).vis.cbr<>-1 then hide limb obj,segmentprofile(seg).vis.cbr
if segmentprofile(seg).vis.cbl<>-1 then hide limb obj,segmentprofile(seg).vis.cbl
if segmentprofile(seg).vis.octl<>-1 then hide limb obj,segmentprofile(seg).vis.octl
if segmentprofile(seg).vis.octr<>-1 then hide limb obj,segmentprofile(seg).vis.octr
if segmentprofile(seg).vis.ocbr<>-1 then hide limb obj,segmentprofile(seg).vis.ocbr
if segmentprofile(seg).vis.ocbl<>-1 then hide limb obj,segmentprofile(seg).vis.ocbl

rem apply side-maprotation for walls
twb=segmentprofile(seg).vis.wb : twr=segmentprofile(seg).vis.wr
twf=segmentprofile(seg).vis.wf : twl=segmentprofile(seg).vis.wl
towb=segmentprofile(seg).vis.owb : towr=segmentprofile(seg).vis.owr
towf=segmentprofile(seg).vis.owf : towl=segmentprofile(seg).vis.owl
if segmaprot=1
 twb=segmentprofile(seg).vis.wl :  twr=segmentprofile(seg).vis.wb
 twf=segmentprofile(seg).vis.wr :  twl=segmentprofile(seg).vis.wf
 towb=segmentprofile(seg).vis.owl :  towr=segmentprofile(seg).vis.owb
 towf=segmentprofile(seg).vis.owr :  towl=segmentprofile(seg).vis.owf
endif
if segmaprot=2
 twb=segmentprofile(seg).vis.wf :  twr=segmentprofile(seg).vis.wl
 twf=segmentprofile(seg).vis.wb :  twl=segmentprofile(seg).vis.wr
 towb=segmentprofile(seg).vis.owf :  towr=segmentprofile(seg).vis.owl
 towf=segmentprofile(seg).vis.owb :  towl=segmentprofile(seg).vis.owr
endif
if segmaprot=3
 twb=segmentprofile(seg).vis.wr :  twr=segmentprofile(seg).vis.wf
 twf=segmentprofile(seg).vis.wl :  twl=segmentprofile(seg).vis.wb
 towb=segmentprofile(seg).vis.owr :  towr=segmentprofile(seg).vis.owf
 towf=segmentprofile(seg).vis.owl :  towl=segmentprofile(seg).vis.owb
endif

rem eliminate external walls if blocked
if maprotate=0
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towr
endif
if maprotate=1
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towr
endif
if maprotate=2
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towr
endif
if maprotate=3
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towr
endif

rem inner wall to hide
if twr<>-1
 if maptile>=2 then hide limb obj,twr
endif
if twb<>-1
 if maptile=3 or maptile>=5 then hide limb obj,twb
endif
if twl<>-1
 if maptile>=4 and maptile<=14 then hide limb obj,twl
endif
if twf<>-1
 if maptile>=6 and maptile<=11 then hide limb obj,twf
endif

rem outer wall to hide
if towr<>-1
 if maptile>=2 then hide limb obj,towr
endif
if towb<>-1
 if maptile=3 or maptile>=5 then hide limb obj,towb
endif
if towl<>-1
 if maptile>=4 and maptile<=14 then hide limb obj,towl
endif
if towf<>-1
 if maptile>=6 and maptile<=11 then hide limb obj,towf
endif

rem symbol no floor hides floor/roof
if mapsymbol=1
 if segmentprofile(seg).vis.f<>-1 then hide limb obj,segmentprofile(seg).vis.f
 if segmentprofile(seg).vis.r<>-1 then hide limb obj,segmentprofile(seg).vis.r
endif

rem calculate actual corner before whole seg is rotated
ttoctl=segmentprofile(seg).vis.octl
ttoctr=segmentprofile(seg).vis.octr
ttocbr=segmentprofile(seg).vis.ocbr
ttocbl=segmentprofile(seg).vis.ocbl
toctl=-1 : toctr=-1 : tocbr=-1 : tocbl=-1
if segmaprot=0
 tctl=segmentprofile(seg).vis.ctl
 tctr=segmentprofile(seg).vis.ctr
 tcbr=segmentprofile(seg).vis.cbr
 tcbl=segmentprofile(seg).vis.cbl
 toctl=ttoctl
 toctr=ttoctr
 tocbr=ttocbr
 tocbl=ttocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then toctl=segmentprofile(seg).vis.octl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then toctr=segmentprofile(seg).vis.octr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then tocbr=segmentprofile(seg).vis.ocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then tocbl=segmentprofile(seg).vis.ocbl
endif
if segmaprot=1
 tctl=segmentprofile(seg).vis.ctr
 tctr=segmentprofile(seg).vis.cbr
 tcbr=segmentprofile(seg).vis.cbl
 tcbl=segmentprofile(seg).vis.ctl
 toctl=ttoctr
 toctr=ttocbr
 tocbr=ttocbl
 tocbl=ttoctl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then toctl=segmentprofile(seg).vis.octr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then toctr=segmentprofile(seg).vis.ocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then tocbr=segmentprofile(seg).vis.ocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then tocbl=segmentprofile(seg).vis.octl
endif
if segmaprot=2
 tctl=segmentprofile(seg).vis.cbr
 tctr=segmentprofile(seg).vis.cbl
 tcbr=segmentprofile(seg).vis.ctl
 tcbl=segmentprofile(seg).vis.ctr
 toctl=ttocbr
 toctr=ttocbl
 tocbr=ttoctl
 tocbl=ttoctr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then toctl=segmentprofile(seg).vis.ocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then toctr=segmentprofile(seg).vis.ocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then tocbr=segmentprofile(seg).vis.octl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then tocbl=segmentprofile(seg).vis.octr
endif
if segmaprot=3
 tctl=segmentprofile(seg).vis.cbl
 tctr=segmentprofile(seg).vis.ctl
 tcbr=segmentprofile(seg).vis.ctr
 tcbl=segmentprofile(seg).vis.cbr
 toctl=ttocbl
 toctr=ttoctl
 tocbr=ttoctr
 tocbl=ttocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then toctl=segmentprofile(seg).vis.ocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then toctr=segmentprofile(seg).vis.octl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then tocbr=segmentprofile(seg).vis.octr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then tocbl=segmentprofile(seg).vis.ocbr
endif

rem remove external corners if not needed
ttoctl=-1 : ttoctr=-1 : ttocbr=-1 : ttocbl=-1
if maprotate=0
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttocbl=tocbl
endif
if maprotate=1
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttocbl=tocbl
endif
if maprotate=2
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttocbl=tocbl
endif
if maprotate=3
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttocbl=tocbl
endif

rem inner corner limbs to show
if tctl<>-1
 if maptile>=7 and maptile<=11 then show limb obj,tctl
endif
if tctr<>-1
 if maptile=8 or maptile=10 or maptile=11 then show limb obj,tctr
endif
if tcbr<>-1
 if maptile=9 or maptile=10 or maptile=11 or maptile>=13 then show limb obj,tcbr
endif
if tcbl<>-1
 if maptile=11 or maptile=12 or maptile=14 then show limb obj,tcbl
endif

rem outer corner limbs to show
if ttoctl<>-1
 if maptile=1 then show limb obj,ttoctl
 if maptile=2 then show limb obj,ttoctl
 if maptile=3 then show limb obj,ttoctl
 if maptile=15 then show limb obj,ttoctl
endif
if ttoctr<>-1
 if maptile=1 then show limb obj,ttoctr
endif
if ttocbr<>-1
 if maptile=1 then show limb obj,ttocbr
endif
if ttocbl<>-1
 if maptile=1 then show limb obj,ttocbl
 if maptile=2 then show limb obj,ttocbl
endif

rem rotate object ro rotation
yrotate object obj,maporient*90

return

`
` Special Function for finding GROUNDMODE from NEIGHBOR MAP TILE (external wall removal)
`

function getgroundmodefrommap(mapatl,mapatx,mapaty)
 mapground=3
 if mapatx>=0
  if mapaty>=0
   if mapatx<=49
    if mapaty<=49
     mapid=map(mapatl,mapatx,mapaty)
     if mapid<>0
      mapground = ( mapid && %00000000000000001100000000000000 ) >> 14
     else
      mapground = 3
     endif
    endif
   endif
  endif
 endif
endfunction mapground

_segment_scanfornewsegments:

rem Scan for segments
segdir$="segments\"
empty array filelist$()
buildfilelist(segdir$,"")

rem If segments exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem Segment name from folder
  seg$=filelist$(chkfile)
  if right$(seg$,4)=".fps"
  `
  rem Check segment exists in bank
  tokay=1
  if segidmaster>0
   for segid=1 to segidmaster
    if selectionbank$(segid)=seg$ then tokay=0
   next segid
  endif
  if tokay=1
   `
   rem Find Free Segment Index
   freesegid=-1
   if segidmaster>0
    for segid=1 to segidmaster
     if segmentprofileheader(segid).partmax=-1 then freesegid=segid : exit
    next segid
   endif
   `
   rem New Segment or Free One
   if freesegid=-1
    inc segidmaster : gosub _segment_validatearraysize
    segid=segidmaster
   else
    segid=freesegid
   endif
   `
   rem Extract firstdir and path from seg$
   segcategory$=getfirstdir(seg$)
   segpath$=getseconddir(seg$)
   `
   rem Load Segment
   selectionbank$(segid)=seg$
   gosub _segment_load
   `
  endif
  `
  endif
 next chkfile
endif

return

_segment_addtoworkspace:

rem If type valid
segnewloaded=0
if right$(seg$,4)=".fps"
 `
 rem Check segment exists in bank
 tokay=1
 if segidmaster>0
  for segid=1 to segidmaster
   if selectionbank$(segid)=seg$ then tokay=0 : tfoundid=segid : exit
  next segid
 endif
 if tokay=1
  `
  rem Find Free Segment Index
  freesegid=-1
  if segidmaster>0
   for segid=1 to segidmaster
    if segmentprofileheader(segid).partmax=-1 then freesegid=segid : exit
   next segid
  endif
  `
  rem New Segment or Free One
  if freesegid=-1
   inc segidmaster : gosub _segment_validatearraysize
   segid=segidmaster
   segnewloaded=1
  else
   segid=freesegid
  endif
  `
  rem Extract firstdir and path from seg$
  segcategory$=getfirstdir(seg$)
  segpath$=getseconddir(seg$)
  `
  rem Load Segment
  selectionbank$(segid)=seg$
  gosub _segment_load
  `
  rem Localization Extra
  if localdesc$<>""
   selectionbanklocal$(segid)=localdesc$
  endif
  `
 else
  `
  rem already got, assign ID from existing
  segid=tfoundid
  `
 endif
 `
endif

return

_segment_addtoselection:

rem Load segment from file requester
set dir currentsegdir$
seg$=browseropen$(6)
segdir$="segments\"
seg$=right$(seg$,len(seg$)-len(rootdir$+segdir$))
currentsegdir$=get dir$()
set dir rootdir$

rem Add selected to workspace selection
gosub _segment_addtoworkspace

return

_segment_createnewselection:

rem Create new segment using SEGEDIT (indi-tool)
set dir currentsegdir$
segedit$(1)
set dir rootdir$

return

rem Add selected to workspace selection
_prefab_addtoworkspace:

rem If type valid
prenewloaded=0
if lower$(right$(prefab$,4))=".fpp"
 `
 rem Check prefab exists in bank
 tokay=1
 if preidmaster>0
  for preid=1 to preidmaster
   if prefabbank$(preid)=prefab$ then tokay=0 : exit
  next preid
 endif
 if tokay=1
  `
  rem Find Free prefab Index
  freepreid=-1
  if preidmaster>0
   for preid=1 to preidmaster
    if prefabbank$(preid)="" then freepreid=preid : exit
   next preid
  endif
  `
  rem New prefab or Free One
  if freepreid=-1
   inc preidmaster
   if preidmaster>=100
    dim prefabbank$(preidmaster)
    dim prefabbanklocal$(preidmaster)
   endif
   preid=preidmaster
  else
   preid=freepreid
  endif
  `
  rem Extract firstdir and path from prefab$
  preategory$=getfirstdir(prefab$)
  prepath$=getseconddir(prefab$)
  `
  rem Load Prefab
  prefabbank$(preid)=prefab$
  prenewloaded=1
  `
  rem Localization Extra
  if localdesc$<>""
   prefabbanklocal$(preid)=localdesc$
  endif
  `
 endif
 `
endif

return

_prefab_addtoselection:

rem Load segment from file requester
set dir currentpredir$
prefab$=browseropen$(7)
predir$="prefabs\"
prefab$=right$(prefab$,len(prefab$)-len(rootdir$+predir$))
currentpredir$=get dir$()
set dir rootdir$

rem Add selected to workspace selection
gosub _prefab_addtoworkspace

return


rem
rem SUBROUTINES AND FUNCTIONS FOR DEBUG ONLY
rem

rem FUNCTIONS

function hide3d()
 backdrop off : sync off
 set current bitmap 0
 for o=1 to 50000
  if object exist(o)=1
   hide object o
  endif
 next o
endfunction

function show3d()
 backdrop on : sync on
 for o=1 to 50000
  if object exist(o)=1
   show object o
  endif
 next o
endfunction

function debugfilename(tfile$,desc$)
 texit=0
 tryfile$=tfile$
 if lower$(right$(tfile$,3))="tga" then tryfile$=left$(tryfile$,len(tryfile$)-3)+imgext$
 if file exist(tfile$)=0 and file exist(tryfile$)=0
  timestampactivity(0,strarr$(53)+tfile$+") info:"+desc$)
  timestampactivityflagged=1
 endif
endfunction

function debugstring(tfile$,desc$)
 timestampactivity(0,strarr$(54)+tfile$+" - "+desc$+")")
endfunction

function debugseevar(var)
 timestampactivity(0,strarr$(55)+str$(var)+")")
endfunction

function debugpeek(desc$)
 set text opaque
 ink rgb(255,255,255),0
 while spacekey()=0
  text 100,150,desc$
  sync
 endwhile
 while spacekey()=1 : sync : endwhile
 set text transparent
endfunction

`
` Progress Report Debug Function
`

function debugviewactivate(mode)
 `
 if gdebugreportmodestate=1
  if mode=1
   if bitmap exist(1)=0 then create bitmap 1,screen width(),150
  else
   if bitmap exist(1)=1 then delete bitmap 1
  endif
  set current bitmap 0
 endif
 `
endfunction

function debugviewprogressmax(progressmax)
 dim mshot(progressmax)
 lastmshotmem=0
 gprogressmax=progressmax
 gprogresscounter=0
endfunction

function debugviewtext(progress,gamedebugviewtext$)
 `
 rem leave immediately if mapeditor
 if gmapeditmode=1 then exitfunction
 `
 rem FPSCV104RC9 - loading time readout to file
 if gloadreportstate=1
  rem get time, distance from last time, description, etc..
  if gloadreporttime=0 then gloadreporttime=timer()
  thetime=timer()-gloadreporttime
  thetime$=right$(str$(1000000+thetime),6)
  thediff=timer()-gloadreportlasttime
  thediff$=right$(str$(1000000+thediff),6)
  gloadreportlasttime=timer()
  loadreport$(gloadreportindex)=thetime$+" : "+thediff$+" : "+gamedebugviewtext$
  inc gloadreportindex : if gloadreportindex>10000 then gloadreportindex=10000
  if progress>gprogressmax-10
   rem only save in last 10 counts before end of progress bar
   save array rootdir$+"\loadreport.txt",loadreport$()
  endif
 endif
 `
 rem progress bar based on progress/gprogressmax (some white and black)
 if progress<>-1
  rem Memory counters
  mshoti=progress
  `x9gamedebugviewtext$="["+right$(str$(1000+mshoti),3)+"] "+gamedebugviewtext$
  gamedebugviewtext$=gamedebugviewtext$
  mshotmem=GET MEMORY AVAILABLE(0)
  if lastmshotmem=0 then lastmshotmem=mshotmem : mshotfirst=GET MEMORY AVAILABLE(0)
  mshot(mshoti)=lastmshotmem-mshotmem
  if mshot(mshoti)>mshotmemlargest then mshotmemlargest=mshot(mshoti)
  if mshoti>lastmshoti
   rem deposit memory use result to report
   timestampactivity(0,strarr$(56)+str$(mshot(mshoti))+"K  "+gamedebugviewtext$)
   lastmshoti=mshoti
   lastmshotmem=mshotmem
  endif
  rem Game GUI Readout
  if progress>gprogressmax then progress=gprogressmax
  progress#=progress
  progress#=progress#/(gprogressmax+0.0001)
  if internalloaderhud>0 and internalloaderhud<=array count(hud())
   rem Image Expand Bar Progress
   `t1=hud(internalloaderhud).width*progress# 130907
   t1=(hud(internalloaderhud).width*gratiox#)*progress#
   size sprite internalloaderhud,t1,hud(internalloaderhud).height
   paste sprite internalloaderhud,hud(internalloaderhud).posx,hud(internalloaderhud).posy
  else
   rem Default Bar Progress
   if gdebugreportmodestate=1
    progressx=54 : progressy=392 : progressh=18
    progressw=screen width()-100.0001
    if screen width()=800 then progressw=693
    t1=progressw*progress# : t2=progressx+t1
    ty=(screen height()-150)-(screen height()/10)
    if screen height()=600 then ty=progressy
    if t2>progressx then ink rgb(255,255,255),0 : box progressx,ty,t2,ty+progressh
    if t2<progressx+progressw then ink rgb(0,0,0),0 : box t2,ty,progressx+progressw,ty+progressh
   endif
  endif
 endif
 `
 rem This could be expensive
 `x9if gdebugreportmodestate=0 then sync mask 0x1 : sync
 rem X10 keep the loading bar refreshed if final game
 if grealgameviewstate=1
  if gdebugreportmodestate=0 then sync mask 0x1 : sync
 endif
 `
 rem Report On Progress Percentage
 if progress<>-1
  if progress>gprogressmax then progress=gprogressmax
  progress#=progress : progress#=progress#/(gprogressmax+0.0001)
  progress#=progress#*100.0
 endif
 `
 rem TestGameFromEditor Mode
 if gtestgamemodefromeditor=1
  rem detect if CANCEL early (while building)
  if gtestgamemodefromeditorokaypressed=0
   open file map 2, "FPSEXCHANGE"
   wait for file map event 2
   if get file map dword( 2, 994 ) = 1
    `
    rem As can take time, tell user can take time
    open file map 3, "FPSTESTGAMEDIALOG"
    set file map dword 3, 12, 1
    set file map string$ 3, 1000, strarr$(630)
    wait for file map event 3
    while get file map dword ( 3, 12 ) = 1
     wait for file map event 3
    endwhile
    close file map 3
    `
    rem terminate test game mid-build
    set file map string$ 2, 1000, "bin\FPSC-MapEditor.exe"
    set file map string$ 2, 1256, "-r"
    set file map dword 2, 994, 2
    set file map dword 2, 924, 1
    wait for file map event 2
    close file map 2
    rem Terminate
    if 1 then timestampactivity(0,strarr$(57))
    end
   else
    rem Update Test Game Dialog progress and status text
    open file map 1, "FPSTESTGAMEDIALOG"
    if progress<>-1
     set file map dword 1, 8, int(progress#)
    endif
    rem Display Status Text
    set file map string$ 1, 1000, gamedebugviewtext$
    set file map dword 1, 12, 1
    wait for file map event 1
    close file map 1
   endif
   close file map 2
  endif
 endif
 rem Build Executable Game Mode
 if gcompilestandaloneexe=1
  rem check if build cancelled
  tokay=0
  open file map 2, "FPSEXCHANGE"
  wait for file map event 2
  if get file map dword( 2, 994 ) = 1 then tokay=1
  close file map 2
  if tokay=1
   rem terminate build early
   open file map 1, "FPSBUILDGAME"
   set file map dword 1, 108, 1
   set file map dword 1, 112, 0
   rem close dialog (cannot reload data into it when RELOAD MAPEDITOR)
   set file map dword 1, 24, 1
   wait for file map event 1
   close file map 1
   rem call map editor back
   open file map 2, "FPSEXCHANGE"
   set file map string$ 2, 1000, "bin\FPSC-MapEditor.exe"
   set file map string$ 2, 1256, "-r"
   set file map dword 2, 994, 0
   set file map dword 2, 924, 1
   wait for file map event 2
   close file map 2
   rem terminate
   if 1 then timestampactivity(0,strarr$(58))
   end
  else
   rem game build progress bar and text
   open file map 1, "FPSBUILDGAME"
   if progress<>-1
    set file map dword 1, 108, 1
    set file map dword 1, 112, int(progress#)
   endif
   set file map dword 1, 40, 12
   set file map dword 1, 44, 1
   if level>0 and level<=glevelmax
    set file map string$ 1, 1000, strarr$(59)+str$(level)+"\"+str$(glevelmax)+" : "+gamedebugviewtext$
   else
    set file map string$ 1, 1000, gamedebugviewtext$
   endif
   wait for file map event 1
   close file map 1
  endif
 endif
 `
 rem debug view text
 if gdebugreportmodestate=1 and gmapeditmode=0
  `
  thetime=timer()-gamedebugviewtime
  thetime$=right$(str$(1000000+thetime),6)
  themem=gamedebugviewmem-GET MEMORY AVAILABLE(0)
  themem$=right$(str$(10000000+themem),7)
  themem$=" [ "+themem$+" ] ("
  if (themem-gamedebugviewlastmem)>0 then themem$=themem$+"+"
  themem$=themem$+str$(themem-gamedebugviewlastmem)+")  :  "
  gamedebugview$=thetime$+themem$+gamedebugviewtext$+chr$(13)+chr$(10)+gamedebugview$
  gamedebugviewlastmem=themem
  gosub _gamemain_writetexttodebugview
  debugviewupdate(1)
  if gdebugreportstepthroughstate=1
   rem step through debugging
   wait key
  endif
  `
 endif
 exitfunction
 `
 _gamemain_writetexttodebugview:
  if gdebugreportmodestate=1
   if bitmap exist(1)=1
    set current bitmap 1
    cls rgb(0,48,0)
    ink rgb(255,255,255),0
    print gamedebugview$
    ink rgb(0,255,0),0
    gosub _gamemain_updatedebugviewstats
    set current bitmap 0
   endif
   gamedebugrefresh=1
  endif
 return
 `
 _gamemain_updatedebugviewstats:
  for stat=1 to 9
   if stat=1 then stat$=strarr$(60)
   if stat=2 then stat$=strarr$(61) : stat2=segidmaster
   if stat=3 then stat$=strarr$(62) : stat2=entidmaster
   if stat=4 then stat$=strarr$(63) : stat2=entityelementlist
   if stat=5 then stat$=strarr$(64) : stat2=aiindexmaster
   if stat=6 then stat$=strarr$(65) : stat2=texturebankmax
   if stat=7 then stat$=strarr$(66) : stat2=imagebankmax
   if stat=8 then stat$=strarr$(67) : stat2=effectbankmax
   if stat=9 then stat$=strarr$(68) : stat2=waypointmax
   if stat>1
    stat2$=str$(stat2) : stat3$="" : for st=1 to stat2 step 2 : stat3$=stat3$+"|" : next st
    stat1$=stat$ : stat2$=stat2$+space$(3-len(stat2$))+stat3$
   else
    stat1$=stat$ : stat2$=""
   endif
   text screen width()-(screen width()/4),(stat-1)*14,stat1$
   text screen width()-(screen width()/8),(stat-1)*14,stat2$
  next stat
 return
 `
endfunction

function debugviewupdate(doisync)
 `
 if gdebugreportmodestate=1 and gmapeditmode=0
  if gamedebugrefresh=1
   gamedebugrefresh=0
   if bitmap exist(1)=1
    set current bitmap 1
    get image editorimagesoffset+1,0,0,screen width(),150,1
   endif
  endif
  set current bitmap 0
  if doisync=0 and image exist(editorimagesoffset+1)=1 then paste image editorimagesoffset+1,0,screen height()-150
  if doisync=1 and image exist(editorimagesoffset+1)=1 then paste image editorimagesoffset+1,0,screen height()-150
  if doisync=1 then sync
 endif
 `
endfunction

function debuggameoverlaysystem(justhandlex10effects)
`
rem collect perf data
perf(1) = statistic(1)
perf(2) = screen fps()
if scancode()<>15
 inc wshoti : if wshoti>400 then wshoti=0
endif
wshot(wshoti,0)=perf(1) : if wshot(wshoti,0)>wshotmax(0) then wshotmax(0)=wshot(wshoti,0)
wshot(wshoti,1)=perf(2) : if wshot(wshoti,1)>wshotmax(1) then wshotmax(1)=wshot(wshoti,1)
wshot(wshoti,2)=statistic(8) : if wshot(wshoti,2)>wshotmax(2) then wshotmax(2)=wshot(wshoti,2)
wshot(wshoti,3)=perf(6) : if wshot(wshoti,3)>wshotmax(3) then wshotmax(3)=wshot(wshoti,3)
wshot(wshoti,4)=perf(7) : if wshot(wshoti,4)>wshotmax(4) then wshotmax(4)=wshot(wshoti,4)
`
rem uses perftimer now for cycle accuracy (once a second so I can read changes)
av#=20.0
inc gameperftimetracker
if gameperftimetracker>av#
 gameperftimetracker=0
 i=3 : perf(i) = gameperftotalcount/av# : gameperftotalcount=0
 i=4 : perf(i) = gameperflighting/av# : gameperflighting=0
 i=5 : perf(i) = gameperfplayer/av# : gameperfplayer=0
 i=6 : perf(i) = gameperfentities/av# : gameperfentities=0
 i=7 : perf(i) = gameperfgun/av# : gameperfgun=0
 i=8 : perf(i) = gameperfmisc/av# : gameperfmisc=0
 i=9 : perf(i) = gameperfdebug/av# : gameperfdebug=0
 i=10 : perf(i) = gameperfphysics/av# : gameperfphysics=0
 i=11 : perf(i) = gameperfsync/av# : gameperfsync=0
 i=12 : perf(i) = gameperfentities1/av# : gameperfentities1=0
 i=13 : perf(i) = gameperfentities2/av# : gameperfentities2=0
 i=14 : perf(i) = gameperfentities3/av# : gameperfentities3=0
 i=15 : perf(i) = gameperfentities4/av# : gameperfentities4=0
 i=16 : perf(i) = gameperfentities5/av# : gameperfentities5=0
 i=17 : perf(i) = gameperfai/av# : gameperfai=0 
 for i=1 to 9 : perfsync(i)=gamesyncperfsync(i)/av# : gamesyncperfsync(i)=0 : next i
endif

rem X10 effect change flags
tupdatefog=0 : tupdatebloom=0 : tupdatewater=0 : tupdateshadow=0 : tupdaterefractivity=0
tupdatewaterlevel=0
teffectschanged=-1
tvolchanged=0

rem X10 if asked to retain states (moved from within debugmode=1)
if x10effectmenu(19)<>1
 if hudskyvalue<=1 or hudskymax<=1
  x10effectmenu(0)=0
 else
  if hudskyvalue=hudskymax
   x10effectmenu(0)=100
  else
   x10effectmenu(0)=(100/(hudskymax-1))*(hudskyvalue-1)
  endif
 endif
 x10effectmenu(1)=guivisualsettings.ambience
 x10effectmenu(2)=getnearestposincolorbarRGB(hudfogred(waterisbelowplayer-1),hudfoggreen(waterisbelowplayer-1),hudfogblue(waterisbelowplayer-1))
 x10effectmenu(3)=(4000-hudfognear(waterisbelowplayer-1))/40.0
 x10effectmenu(4)=hudbloomwidth(waterisbelowplayer-1)
 x10effectmenu(5)=hudbloomstrength(waterisbelowplayer-1)
 x10effectmenu(6)=hudwaterspeed
 x10effectmenu(7)=hudwaterdepth
 x10effectmenu(8)=getnearestposincolorbar(hudwatercolor)
 x10effectmenu(9)=getnearestposincolorbar(hudunderwatercolor)
 x10effectmenu(10)=hudwaterrefl
 x10effectmenu(11)=hudwaterrefr
 x10effectmenu(12)=hudwaterfresnel
 `x10effectmenu(13)=50 : oldwaterlevel#=waterlevel# `done outside of TAB (tab session relative changes)
 x10effectmenu(14)=hudshadowstrength
 x10effectmenu(15)=hudshadowquantity
 x10effectmenu(16)=hudglassrefr
else
 rem values retained from previous session
 rem also trigger volume to update
 hudupdateeffects=1
 tupdatefog=1 : tupdatebloom=1 : tupdatewater=1 : tupdateshadow=1 : tupdaterefractivity=1
 tupdatewaterlevel=1
 teffectschanged=0
 tvolchanged=1
endif
rem [19] 0-first test game, 1-repeat test game (retain settings), 2-normal operation
x10effectmenu(19)=2

rem Optional additional statistics
if justhandlex10effects=0 and ghidehudgraphics=0
if debugviewmode=0
 `
 rem Appreviated for game scene (temp)
 t$="" : t2$="" : t3$=""
 tverbosedebug=0
 if testgametabtoggle=2 then tverbosedebug=1
 if tverbosedebug=1
  if 0 : rem SET TO ONE TO GET TIMING DETAILS
   for i=1 to 11
    if i=1 then t$=t$+"PO"
    if i=2 then t$=t$+"FR"
    if i=3 then t$=t$+"##"
    if i=4 then t$=t$+"LG"
    if i=5 then t$=t$+"PL"
    if i=6 then t$=t$+"EN"
    if i=7 then t2$=t2$+"GU"
    if i=8 then t2$=t2$+"MI"
    if i=9 then t2$=t2$+"DB"
    if i=10 then t2$=t2$+"PH"
    if i=11 then t2$=t2$+"SY"
    if i<=6
     t$=t$+":"+str$(perf(i))
    else
     t2$=t2$+":"+str$(perf(i))
    endif
    if i=1 then t$=t$+" ("+str$(statistic(5))+")"
    rem X10 optional debug readout of entity processing - legacy entity speed issues
    if 1
     if i=6
      rem extra entity display
      if 0
       rem Entity investigation
       t3$="Entity Logic 1:"+str$(perf(12))+" 2:"+str$(perf(13))+" 3:"+str$(perf(14))+" 4:"+str$(perf(15))+" 5:"+str$(perf(16))+" OBS:"+str$(gtotalobstaclecount)
      else
       rem Sync investigation
       t3$="SYNC Timing 1:"+str$(perfsync(1))+" 2:"+str$(perfsync(2))+" 3:"+str$(perfsync(3))+" 4:"+str$(perfsync(4))+" 5:"+str$(perfsync(5))+" 6:"+str$(perfsync(6))+" 7:"+str$(perfsync(7))+" 8:"+str$(perfsync(8))+" 9:"+str$(perfsync(9))
      endif
     endif
    endif
    if i<=6
     t$=t$+"   "
    else
     t2$=t2$+"   "
    endif
   next i
   t2$=t2$+" AI:"+str$(perf(17))
   ink rgb(255,255,0),0
   `gun blocks text now
   `center text screen width()/2,screen height()-64,t3$
   `center text screen width()/2,screen height()-48,t$
   `center text screen width()/2,screen height()-32,t2$
   center text screen width()/2,200-64,t3$
   center text screen width()/2,200-48,t$
   center text screen width()/2,200-32,t2$
  endif
 else
  `have resource meter now
  `t$="polygons : "+str$(perf(1))+"   framerate : "+str$(perf(2))
  `ink rgb(255,255,0),0
  `center text screen width()/2,screen height()-32,t$
 endif
 `
 rem hide Mouse
 hide mouse
 `
 rem TAB relative means while the TAB is opened, the slide reflects an offset change
 x10effectmenu(13)=50-((abs(camera position y(playercam))-waterlevel#)/3)
 if x10effectmenu(13)<0 then x10effectmenu(13)=0
 if x10effectmenu(13)>100 then x10effectmenu(13)=100
 oldwaterlevel#=abs(camera position y(playercam))
 `
else
 `
 rem Mouse is used
 show mouse
 `
 rem X10 Effects Menu
 tnumoptions=17
 tmarginy=30-16
 twidth=238
 teffectitemyspacing=40
 if screen height()<=600 then teffectitemyspacing=34
 theight=(tnumoptions*teffectitemyspacing)+(tmarginy*2)
 tsliderwidth=100
 tstatschanged=0
 `
 rem Control of mouse
 if x10effectmenudata.tmouselook=0
  tmx=mousex() : tmy=mousey()-x10effectmenudata.ttop
  tdlta=mousemovex() : tdlta=mousemovey() : tdlta=mousemovez()
  if x10effectmenudata.thighlight=-1
   rem not dragging
   thighlight=0
   if tmy>x10effectmenudata.ttop and tmy<x10effectmenudata.ttop+theight
    if tmx>x10effectmenudata.tleft and tmx<x10effectmenudata.tleft+twidth
     for t=0 to tnumoptions-1
      tcony=ttop+tmarginy+(t*teffectitemyspacing)
      if tmy>tcony and tmy<tcony+teffectitemyspacing
       thighlight=1+t
      endif
     next t
    endif
   endif
   if mouseclick()=0 and x10effectmenudata.tclick=2 then x10effectmenudata.tclick=0
   if mouseclick()=1 and x10effectmenudata.tclick=0 then x10effectmenudata.tclick=1
   if x10effectmenudata.tclick=1
    rem if click out of menu for mouselook
    if tmx<x10effectmenudata.tleft-16 or tmx>x10effectmenudata.tleft+twidth+16
     rem AND clicking outside of volume menu
     if tmx<x10volumemenudata.tleft or tmy>x10volumemenudata.ttop+255
      rem and not dragging volume
      if x10volumemenudata.thighlight=-1
       x10effectmenudata.tmouselook=1
       x10effectmenudata.tclick=0
      endif
     endif
    else
     x10effectmenudata.tclick=2
     if thighlight>0
      rem highlight an item
      t=thighlight-1
      tval=x10effectmenu(t)
      tsliderpos=tval
      twidthperc#=(tsliderwidth/50)
      tconx=x10effectmenudata.tleft+(twidth/2)
      tblobx=tconx-tsliderwidth+(tsliderpos*twidthperc#)
      if tmx<tblobx-10
       rem step left
       if t=0 and hudskymax>1
        tperc#=(100/(hudskymax-1)) : x10effectmenu(t)=x10effectmenu(t)-tperc#
       else
        x10effectmenu(t)=x10effectmenu(t)-1
       endif
       if x10effectmenu(t)<0 then x10effectmenu(t)=0
       tstatschanged=1+t
       if tstatschanged=14 then usewaterlevelfromprevioussession#=-1 : rem manual water change
      else
       if tmx>tblobx+10
        rem step right
        if t=0 and hudskymax>1
         tperc#=(100/(hudskymax-1)) : x10effectmenu(t)=x10effectmenu(t)+tperc#
        else
         x10effectmenu(t)=x10effectmenu(t)+1
        endif
        if x10effectmenu(t)>100 then x10effectmenu(t)=100
        tstatschanged=1+t
        if tstatschanged=14 then usewaterlevelfromprevioussession#=-1 : rem manual water change
       else
        rem click to drag
        x10effectmenudata.thighlight=t
        x10effectmenudata.tdrag=(tblobx-tmx)/2.0
       endif
      endif
     else
      rem toggle menu position
      if tmy<x10effectmenudata.ttop+tmarginy
       if x10effectmenudata.tleft=0
        x10effectmenudata.tleft=screen width()-238
        x10effectmenudata.ttop=0
       else
        x10effectmenudata.ttop=screen height()-theight
        x10effectmenudata.tleft=0
       endif
      endif
     endif
    endif
   endif
  else
   rem dragging
   thighlight=1+x10effectmenudata.thighlight
   if mouseclick()=0 and x10effectmenudata.thighlight<>-1 then x10effectmenudata.thighlight=-1
   if x10effectmenudata.thighlight<>-1
    t=x10effectmenudata.thighlight
    tconx=x10effectmenudata.tleft+(twidth/2)
    tnewblobx=(tmx-(tconx-tsliderwidth))/2.0
    x10effectmenu(t)=tnewblobx+x10effectmenudata.tdrag
    if x10effectmenu(t)<0 then x10effectmenu(t)=0
    if x10effectmenu(t)>100 then x10effectmenu(t)=100
    tstatschanged=1+t
    if tstatschanged=14 then usewaterlevelfromprevioussession#=-1 : rem manual water change
   endif
  endif
 else
  rem release mouselook when release button
  if mouseclick()=0 then x10effectmenudata.tmouselook=0
 endif
 `
 rem Border
 paste sprite x10effectmenuimagestart+0,x10effectmenudata.tleft,x10effectmenudata.ttop
 size sprite x10effectmenuimagestart+0,238,705
 `
 rem Sliders
 for t=0 to tnumoptions-1
  `
  rem color
  if thighlight=1+t
   ink rgb(255,255,255),0
   set sprite alpha x10effectmenuimagestart+1,255
   set sprite alpha x10effectmenuimagestart+2,255
  else
   ink rgb(192,192,192),0
   set sprite alpha x10effectmenuimagestart+1,230
   set sprite alpha x10effectmenuimagestart+2,230
  endif
  `
  rem control line
  tconx=x10effectmenudata.tleft+(twidth/2)
  tcony=x10effectmenudata.ttop+tmarginy+(t*teffectitemyspacing)
  `
  rem title
  ttype=0
  if 1
   if t=2 then ttype=1
   if t=8 then ttype=1
   if t=9 then ttype=1
   paste sprite x10effectmenuimagestart+5+t,tconx-100,tcony+6
  else
   if t=0 then t$="SKY VALUE"
   if t=1 then t$="AMBIENT LIGHT"
   if t=2 then t$="FOG COLOR" : ttype=1
   if t=3 then t$="FOG RANGE"
   if t=4 then t$="BLOOM SIZE"
   if t=5 then t$="BLOOM STRENGTH"
   if t=6 then t$="WATER SPEED"
   if t=7 then t$="WATER SMOOTHNESS"
   if t=8 then t$="WATER COLOR" : ttype=1
   if t=9 then t$="UNDERWATER COLOR" : ttype=1
   if t=10 then t$="WATER REFLECTIVITY"
   if t=11 then t$="WATER REFRACTIVITY"
   if t=12 then t$="WATER FRESNEL TERM"
   if t=13 then t$="WATER LEVEL"
   if t=14 then t$="SHADOW STRENGTH"
   if t=15 then t$="SHADOW QUANTITY"
   if t=16 then t$="WINDOW REFRACTIVITY"
   center text tconx,tcony,t$
  endif
  `
  rem slider
  tslidery=tcony+25
  if ttype=1
   paste sprite x10effectmenuimagestart+2,tconx-tsliderwidth,tslidery
  else
   paste sprite x10effectmenuimagestart+1,tconx-tsliderwidth,tslidery
  endif
  `
  rem value or color
  tval=x10effectmenu(t)
  if ttype=1
   rem color
   tcolboxx=tconx+tsliderwidth
   tcolboxy=tslidery
   col=hudcolorbar(tval)
   cr=(col && 0xFF0000)>>16
   cg=(col && 0x00FF00)>>8
   cb=(col && 0x0000FF)
   set sprite diffuse x10effectmenuimagestart+4,cr,cg,cb
   if thighlight=1+t
    set sprite alpha x10effectmenuimagestart+4,255
   else
    set sprite alpha x10effectmenuimagestart+4,230
   endif
   size sprite x10effectmenuimagestart+4,16,16
   paste sprite x10effectmenuimagestart+4,tcolboxx-26,tcolboxy-20
  else
   rem values
   `center text tconx+tsliderwidth-22,tslidery-20,str$(tval)
   rem 210807 - override sky value with actual sky value
   storetval=tval
   if t=0 then tval=hudskyvalue
   printvalue(tconx+tsliderwidth-16,tslidery-20,tval)
   tval=storetval
  endif
  `
  rem draggable blob
  tsliderpos=tval
  twidthperc#=(tsliderwidth/50)
  paste sprite x10effectmenuimagestart+3,tconx-tsliderwidth+(tsliderpos*twidthperc#)-8,tslidery-6
  `
 next t
 `
 rem X10 change globals related to stats above
 if tstatschanged>0
  teffectschanged=tstatschanged
 endif
 `
 rem X10 Volume Menu
 rem control volume sliders
 tmx=mousex() : tmy=mousey()-x10volumemenudata.ttop
 tmargin=50 : twidth=238 : theight=255 : tnumoptions=5
 tconx=x10volumemenudata.tleft+17
 if x10volumemenudata.thighlight=-1
  rem not dragging
  thighlight=0
  if tmy>x10volumemenudata.ttop and tmy<x10volumemenudata.ttop+theight
   if tmx>x10volumemenudata.tleft and tmx<x10volumemenudata.tleft+twidth
    for t=0 to tnumoptions-1
     tcony=ttop+tmargin+(t*38)
     if tmy>tcony and tmy<tcony+38
      thighlight=1+t
     endif
    next t
   endif
  endif
  if mouseclick()=0 and x10volumemenudata.tclick=2 then x10volumemenudata.tclick=0
  if mouseclick()=1 and x10volumemenudata.tclick=0 then x10volumemenudata.tclick=1
  if x10volumemenudata.tclick=1
   x10volumemenudata.tclick=2
   if thighlight>0
    rem highlight an item
    t=thighlight-1
    tpos#=volumemeter(t) : tpos#=(188.0/100.0)*tpos#
    tblobx=tconx+tpos#
    if tmx<tblobx-10
     rem step left
     volumemeter(t)=volumemeter(t)-10
     if volumemeter(t)<0 then volumemeter(t)=0
     tvolchanged=1
    else
     if tmx>tblobx+10
      rem step right
      volumemeter(t)=volumemeter(t)+10
      if volumemeter(t)>100 then volumemeter(t)=100
      tvolchanged=1
     else
      rem click to drag
      x10volumemenudata.thighlight=t
      x10volumemenudata.tdrag=(tblobx-tmx)/2.0
     endif
    endif
   else
    rem toggle menu position
    `if tmy<x10volumemenudata.ttop+tmargin
    ` if x10volumemenudata.tleft=0
    `  x10volumemenudata.tleft=screen width()-twidth
    ` else
    `  x10volumemenudata.tleft=0
    ` endif
    `endif
   endif
  endif
  rem when not dragging, no title or loading music
  if gvolumetitlemusic>0
   if sound looping(gvolumetitlemusic)=1
    stop sound gvolumetitlemusic
   endif
  endif
  if gvolumeloadingmusic>0
   if sound looping(gvolumeloadingmusic)=1
    stop sound gvolumeloadingmusic
   endif
  endif
 else
  rem dragging volume slider
  thighlight=1+x10volumemenudata.thighlight
  if mouseclick()=0 and x10volumemenudata.thighlight<>-1 then x10volumemenudata.thighlight=-1
  if x10volumemenudata.thighlight<>-1
   t=x10volumemenudata.thighlight
   tnewblobx=((tmx-tconx)/188.0)*100.0
   tnewvol=tnewblobx+x10volumemenudata.tdrag
   if volumemeter(t)<>tnewvol then tvolchanged=1
   volumemeter(t)=tnewvol
   if volumemeter(t)<0 then volumemeter(t)=0
   if volumemeter(t)>100 then volumemeter(t)=100
  endif
  rem while dragging, can play highlighted title or loading
  if t=0 or t=1
   if t=0 and gvolumetitlemusic>0
    if sound looping(gvolumetitlemusic)=0
     loop sound gvolumetitlemusic
    endif
   endif
   if t=1 and gvolumeloadingmusic>0
    if sound looping(gvolumeloadingmusic)=0
     loop sound gvolumeloadingmusic
    endif
   endif
  endif
 endif
 rem draw volume menu
 img=x10effectmenuimagestart+56
 rmposx=x10volumemenudata.tleft
 rmposy=x10volumemenudata.ttop
 paste sprite img+1,rmposx,rmposy
 for rmi=0 to 4
  paste sprite img+2+(rmi*3)+0,rmposx+19,rmposy+50+(rmi*38) : rem label
  paste sprite img+2+(rmi*3)+1,rmposx+17,rmposy+70+(rmi*38) : rem bar
  tpos#=volumemeter(rmi) : tpos#=(188.0/100.0)*tpos#
  paste sprite img+2+(rmi*3)+2,rmposx+15+tpos#,rmposy+64+(rmi*38) : rem handle
 next rmi
 `
endif

rem Debug lines
`text 100,100,str$(hudwatercolor)+" = "+str$(rgbr(hudwatercolor))+" "+str$(rgbg(hudwatercolor))+" "+str$(rgbb(hudwatercolor))
`text screen width()-24,screen height()-20,str$(scancode())

rem Portal Control
if scancode()=26 then g_iPortal = 1 : set static objects wireframe on
if scancode()=27 then g_iPortal = 0 : set static objects wireframe off

rem Restoration key
`x9if k$="t" then sync rate 30 : entitysystemdisabled=0 : lightingsystemdisabled=0

rem Disable parts of engin
`x9if k$="-" then entitysystemdisabled=1
`x9if k$="=" then lightingsystemdisabled=1

rem Sync control
`x9if k$="x" then sync rate 0
`x9if k$="u" then sync rate 5

rem Collision control
`x9if k$="m" then deactivatecollision=0
`x9if k$="n" then deactivatecollision=1

rem glide for floating
if player(1).health>0
 if k$="z" then grav#=-2.0 : jumpaction=0
endif

rem Mouse control/pointer (press TAB to toggle menu view)
if (scancode()<>15) and debugviewtog=1 then debugviewtog=0
if (scancode()=15 or triggerdebugview>0) and debugviewtog=0
 if triggerdebugview>0
  debugviewmode=triggerdebugview-1
  triggerdebugview=0
 else
  testgametabtoggle=testgametabtoggle+1
  if testgametabtoggle=3 then testgametabtoggle=0
  if testgametabtoggle=0 then debugviewmode=0
  if testgametabtoggle=1 then debugviewmode=1
  if testgametabtoggle=2 then debugviewmode=0
  debugviewtog=1
 endif
endif

rem endif related to 'justhandlex10effects' (310707 - moved from further below)
endif

rem X10 act on effects changed
if teffectschanged<>-1
 for t=1 to 17
  rem one or all
  if teffectschanged=0 then tstatschanged=t
  if teffectschanged>0 then tstatschanged=teffectschanged
  rem update actual value
  if tstatschanged=1
   rem sky as a percentage
   if x10effectmenu(0)=0 or hudskymax<=1
    hudskyvalue=1
   else
    if x10effectmenu(0)=100
     hudskyvalue=hudskymax
    else
     tperc#=100/(hudskymax-1)
     hudskyvalue=1+(x10effectmenu(tstatschanged-1)/tperc#)
    endif
   endif 
   gosub _sky_loadbyvalue
  endif
  if tstatschanged=2 then guivisualsettings.ambience=x10effectmenu(tstatschanged-1) : guivisualsettings.updateflag=1
  if tstatschanged=3
   col=hudcolorbar(x10effectmenu(tstatschanged-1))
   hudfogred(waterisbelowplayer-1)=(col && 0xFF0000)>>16
   hudfoggreen(waterisbelowplayer-1)=(col && 0x00FF00)>>8
   hudfogblue(waterisbelowplayer-1)=(col && 0x0000FF)
   tupdatefog=1
  endif
  if tstatschanged=4
   hudfognear(waterisbelowplayer-1)=4000-(x10effectmenu(tstatschanged-1)*40) : tupdatefog=1
   if x10effectmenu(tstatschanged-1)>0
    hudfogon=1
   else
    hudfogon=0
   endif
  endif
  if tstatschanged=5 then hudbloomwidth(waterisbelowplayer-1)=x10effectmenu(tstatschanged-1) : tupdatebloom=1
  if tstatschanged=6
   hudbloomstrength(waterisbelowplayer-1)=x10effectmenu(tstatschanged-1) : tupdatebloom=1
   if hudbloomstrength(waterisbelowplayer-1)<1 then hudbloomstrength(waterisbelowplayer-1)=1
  endif
  if tstatschanged=7 then hudwaterspeed=x10effectmenu(tstatschanged-1) : tupdatewater=1
  if tstatschanged=8 then hudwaterdepth=x10effectmenu(tstatschanged-1) : tupdatewater=1
  if tstatschanged=9 then hudwatercolor=hudcolorbar(x10effectmenu(tstatschanged-1)) : tupdatewater=1
  if tstatschanged=10 then hudunderwatercolor=hudcolorbar(x10effectmenu(tstatschanged-1)) : tupdatewater=1
  if tstatschanged=11 then hudwaterrefl=x10effectmenu(tstatschanged-1) : tupdatewater=1
  if tstatschanged=12 then hudwaterrefr=x10effectmenu(tstatschanged-1) : tupdatewater=1
  if tstatschanged=13 then hudwaterfresnel=x10effectmenu(tstatschanged-1) : tupdatewater=1
  if tstatschanged=14
   if usewaterlevelfromprevioussession#<>-1
    rem by not changing this value, we retain from previous session
    waterlevel#=usewaterlevelfromprevioussession#
    rem we keep this level until 'manually' changed!
    `usewaterlevelfromprevioussession#=-1
   else
    waterlevel#=abs(oldwaterlevel#+((x10effectmenu(tstatschanged-1)-50)*3))
   endif
   tchangethewaterclipping=2
   tupdatewaterlevel=1
  endif
  if tstatschanged=15 then hudshadowstrength=x10effectmenu(tstatschanged-1) : tupdateshadow=1
  if tstatschanged=16 then hudshadowquantity=x10effectmenu(tstatschanged-1)
  if tstatschanged=17 then hudglassrefr=x10effectmenu(tstatschanged-1) : tupdaterefractivity=1
  rem if just one change, leave not
  if teffectschanged>0 then t=20 : exit
 next t
endif

rem X10 act on volume states
if tvolchanged=1 or lastmusicplayedinit=0
 rem title
 if gvolumetitlemusic=0 and gvolumetitlemusic$<>""
  gvolumetitlemusic=loadinternalsoundcore(rootdir$+gvolumetitlemusic$,0)
 endif
 if gvolumetitlemusic>0
  if volumemeter(0)=0
   set sound volume gvolumetitlemusic,0
  else
   set sound volume gvolumetitlemusic,67+(volumemeter(0)/3)
  endif
 endif
 rem loading
 if gvolumeloadingmusic=0 and gvolumeloadingmusic$<>""
  gvolumeloadingmusic=loadinternalsoundcore(rootdir$+gvolumeloadingmusic$,0)
 endif
 if gvolumeloadingmusic>0
  if volumemeter(1)=0
   set sound volume gvolumeloadingmusic,0
  else
   set sound volume gvolumeloadingmusic,67+(volumemeter(1)/3)
  endif
 endif
 rem ingame
 hudmusicvolume=volumemeter(2)
 if lastmusicplayed>0
  set sound volume lastmusicplayed,67+(hudmusicvolume/3)
  lastmusicplayedinit=1
 endif
endif
rem player volume
if volumemeter(3)>0
 soundvolumes(0)=80+(volumemeter(3)/5)
else
 soundvolumes(0)=0
endif
rem game volume
if volumemeter(4)>0
 soundvolumes(1)=80+(volumemeter(4)/5)
else
 soundvolumes(1)=0
endif

rem X10 Resource Meter Panel
if testgametabtoggle=2
 `
 rem place statistics in resource meter values
 resourcemeterdest#(0)=((perf(11)+0.0)/300000.0)*192.0 : rem syncs
 resourcemeterdest#(1)=((perf(10)+0.0)/50000.0)*192.0 : rem physics
 resourcemeterdest#(2)=((perf(17)+0.0)/75000.0)*192.0 : rem ai
 resourcemeterdest#(3)=((perf(6)+0.0)/20000.0)*192.0 : rem entitylogic
 memoryused#=entidmaster+segidmaster
 resourcemeterdest#(4)=(memoryused#/100.0)*192.0 : rem memory
 `
 rem control resource meters
 for rmi=0 to 4
  resourcemeter#(rmi)=curvevalue(resourcemeterdest#(rmi),resourcemeter#(rmi),10.0)
  if resourcemeter#(rmi)<0 then resourcemeter#(rmi)=0
  if resourcemeter#(rmi)>192 then resourcemeter#(rmi)=192
  resourcemeter(rmi)=resourcemeter#(rmi)
 next rmi
 `
 rem draw resource meter
 img=x10effectmenuimagestart+33 : rmposx=0 : rmposy=screen height()-335
 paste sprite img+1,rmposx,rmposy
 for rmi=0 to 4
  paste sprite img+3+(rmi*4)+0,rmposx+19,rmposy+60+(rmi*53) : rem label
  paste sprite img+3+(rmi*4)+1,rmposx+17,rmposy+80+(rmi*53) : rem start
  t=resourcemeter(rmi) : if t<10 : t=10 : endif : size sprite img+3+(rmi*4)+2,t,10
  paste sprite img+3+(rmi*4)+2,rmposx+22,rmposy+80+(rmi*53) : rem filler
  paste sprite img+3+(rmi*4)+3,rmposx+22+t,rmposy+80+(rmi*53) : rem end
  paste sprite img+2,rmposx+15,rmposy+78+(rmi*53) : rem glass
 next rmi
 `
 rem FPS reading in resource meter panel
 printvalue(rmposx+199,rmposy+19,screen fps())
 `
endif

rem X10 240707 - Freeze spawning if physics overload
if perf(10)>45000
 singleplrspawnfreeze=1
else
 singleplrspawnfreeze=0
endif

rem Current keypress
if gtalkytoaster=0
 k$=inkey$()
else
 k$=""
endif

rem X10 if water changed
if tupdatewaterlevel=1
 rem when water level changes, rejig entities so they trigger floating
 gosub _entity_rejigifwaterlevelchanges
endif

rem X10 effects are changed here (either from init or changes above)
if hudupdateeffects=1
 `
 rem flag set on init
 tupdatefog=1 : tupdatebloom=1 : tupdatewater=1
 tupdateshadow=1 : tupdaterefractivity=1
 hudupdateeffects=0
 `
 rem ensure the water colors are valid (from hudcolorbar by default)
` hudwatercolor=hudcolorbar(x10effectmenu(8))
` hudunderwatercolor=hudcolorbar(x10effectmenu(9))
 ` 
endif

rem when player hurt (hud hurt), use bloom to increase effective distortion
taddhurtbloomeffect=0
if hudbloomfromhurtcounter>0
 dec hudbloomfromhurtcounter,10
 if hudbloomfromhurtcounter<0 then hudbloomfromhurtcounter=0
 taddhurtbloomeffect=hudbloomfromhurtcounter
 tupdatebloom=1
endif

rem trigger an update of certain elements
if 1
 if tupdatefog=1
  if hudfogon=1
   fog on
   hudfogfar=hudfognear(waterisbelowplayer-1)+(hudfognear(waterisbelowplayer-1)*2)
   fog distance hudfognear(waterisbelowplayer-1),hudfogfar
   fog color hudfogred(waterisbelowplayer-1),hudfoggreen(waterisbelowplayer-1),hudfogblue(waterisbelowplayer-1) 
  else
   fog off
  endif
 endif
 if tupdatebloom=1
  `set effect constant float 7,"Brightness",((hudbloomstrength(waterisbelowplayer-1)+taddhurtbloomeffect)/10.0)
  `set effect constant float 7,"blurWidth",((hudbloomwidth(waterisbelowplayer-1)+taddhurtbloomeffect)/20000.0)
  set effect constant float 1,"BloomBrightness",((hudbloomstrength(waterisbelowplayer-1)+taddhurtbloomeffect)/10.0)
  set effect constant float 7,"blurWidth",0.1+((hudbloomwidth(waterisbelowplayer-1)+taddhurtbloomeffect)/10.0)
  set effect constant float 9,"blurWidth",0.1+((hudbloomwidth(waterisbelowplayer-1)+taddhurtbloomeffect)/10.0)
 endif
 if tupdatewater=1 or hudwaterrefrupdate=1
  set effect constant float 11,"g_fWaterSpeed",(hudwaterspeed/25.0)
  set effect constant float 11,"g_fWaterBump",(hudwaterdepth/1000.0)
  set effect constant float 11,"g_fWaterRefl",(hudwaterrefl/100.0)
  set effect constant float 11,"g_fWaterRefr",(hudwaterrefr/100.0) : hudwaterrefrupdate=0
  r=make vector4(1)
  set vector4 1,rgbr(hudwatercolor)/2550.0,rgbg(hudwatercolor)/2550.0,rgbb(hudwatercolor)/2550.0,1
  set effect constant vector 11,"g_vWaterColor",1
  r=delete vector4(1)
  set effect constant float 11,"g_fFresnelPower",(hudwaterfresnel/2.0)
  `
  rem X10 - 230907 - Switch off ripple if water smooth - marble trick
  if hudwaterdepth>0
   waterdecalripple=waterdecalripplemaster
  else
   waterdecalripple=0
  endif
  `
 endif
 if tupdateshadow=1
  set effect constant float 3,"Brightness",(hudshadowstrength/300.0)
 endif
 if tupdaterefractivity=1
  if grefractionshadereffect>0
   tvalue#=(hudglassrefr/500.0)
   set effect constant float grefractionshadereffect,"g_fRefractionStrength",tvalue#
  endif
 endif
endif

endfunction

function printvalue(x,y,value)
 `
 rem prepare sprite for text printing
 sid=x10effectmenuimagestart+4
 sprite sid,-10000,-10000,x10effectmenuimagestart+31
 set sprite diffuse sid,255,255,255
 set sprite alpha sid,255
 size sprite sid,10,10
 `
 rem print value
 text$=str$(value)
 tactualtextwidth=10
 tcenterx#=(len(text$)*tactualtextwidth)/2
 for tt=1 to len(text$)
  ttnum=-1
  if mid$(text$,tt)="." then ttnum=10
  if mid$(text$,tt)="\" then ttnum=11
  if ttnum=-1 then ttnum=asc(mid$(text$,tt))-asc("0")
  if ttnum<>-1
   ttnumy=ttnum/4 : ttnum=ttnum-(ttnumy*4)
   ttbitx#=(1.0/64.0)*16 : ttbity#=(1.0/64.0)*16
   set sprite texture coord sid,0,(ttbitx#*ttnum),(ttbity#*ttnumy)
   set sprite texture coord sid,1,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)
   set sprite texture coord sid,2,(ttbitx#*ttnum),(ttbity#*ttnumy)+ttbity#
   set sprite texture coord sid,3,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)+ttbity#
   paste sprite sid,(x-tcenterx#)+((tt-1)*tactualtextwidth),y
  endif
 next tt
 `
 rem restore sprite image
 sprite sid,-10000,-10000,sid
 `
endfunction

function capturesession()

rem X10 video footage capture
`scforcapture=scancode() `170807 - use keystate instead so can crouch & capture same time
if keystate(67)=1 or keystate(68)=1 : rem scforcapture=67 or scforcapture=68
 if gvideofootagecapture=0
  gvideofootagecapture=1
  rem command will remove the illegal characters in the get date part of the string
  set capture name myownrootdir$+"videobank\X10Video-"+get date$()+"_"+get time$()+".avi"
  set capture codec gx10settingcapturecodec$
  set capture settings gx10settingcapturecompression,gx10settingcapturefps,gx10settingcapturewidth,gx10settingcaptureheight,gx10settingcapturethreaded,gx10settingcapturewait
  set capture mode 1
  rem if press F10, we hide the HUDS so story clips can be made
  `if scforcapture=68 then ghidehudgraphics=1
  if keystate(68)=1 then ghidehudgraphics=1
 endif
 if gvideofootagecapture=2
  gvideofootagecapture=3
  set capture mode 0
  ghidehudgraphics=0
 endif
else
 if gvideofootagecapture=1 then gvideofootagecapture=2
 if gvideofootagecapture=3 then gvideofootagecapture=0
endif
rem F11 snapshot
`scforcapture=scancode() `170807 - use keystate instead so can crouch & capture same time
`if scforcapture<>87 then gtakesnapshot=0
`if scforcapture=87 and gtakesnapshot=0
if keystate(87)=0 then gtakesnapshot=0
if keystate(87)=1 and gtakesnapshot=0
 save screenshot myownrootdir$+"X10Screen-"+get date$()+"_"+get time$()+".bmp"
 gtakesnapshot=1
endif
if gvideofootagecapture=2
 paste sprite x10effectmenuimagestart+32,0,0
endif

endfunction

function getnearestposincolorbarRGB(r,g,b)
 bestt=0
 for t=0 to 100
  col as dword
  col=hudcolorbar(t)
  cr=(col && 0xFF0000)>>16
  cg=(col && 0x00FF00)>>8
  cb=(col && 0x0000FF)
  if cr=r and cg=g and cb=b
   bestt=t
  endif
 next t
endfunction bestt

function getnearestposincolorbar(col as dword)
 r=(col && 0xFF0000)>>16
 g=(col && 0x00FF00)>>8
 b=(col && 0x0000FF)
 bestt=0
 for t=0 to 100
  col=hudcolorbar(t)
  cr=(col && 0xFF0000)>>16
  cg=(col && 0x00FF00)>>8
  cb=(col && 0x0000FF)
  if cr=r and cg=g and cb=b
   bestt=t
  endif
 next t
endfunction bestt

rem
rem ENTITY (Control)
rem

_entity_startentitiesoff:
 `
 rem Prepare entities for logical usage
 for e=1 to entityelementlist
  if entityelement(e).active=1 and entityelement(e).spawn.leader=0
   entityelement(e).logiccount=0
   entityelement(e).logictimestamp=timer()
   entityelement(e).dormant=1
   rem check if entity starts inside geometry
   entid=entityelement(e).bankindex
   if entityprofile(entid).ischaracter=1
    tettry=0 : tskip=0
    ttryy#=entityelement(e).y
    ellipseheight#=1.0
    if entityelement(e).obj
     if object exist(entityelement(e).obj)=1
      if object size y(entityelement(e).obj)<50
       tskip=1
      endif
     endif
    endif
    if tskip=0
     while tettry<25
      if static volume(entityelement(e).x,ttryy#+33,entityelement(e).z,entityelement(e).x,ttryy#+32,entityelement(e).z,ellipseheight#)=0 then exit
      ttryy#=ttryy#+1.0
      inc tettry
     endwhile
     if tettry>=25
      rem entity stuck - so make it immobile to shut down struggle!
      entityelement(e).eleprof.isimmobile=1
     else
      rem entities can find floor initially (not playerstart,trigger,light,emission)
      entityelement(e).y=ttryy#
      entityelement(e).mover.inmotion=1
      entityelement(e).mover.grav=0.0
     endif
    endif
   endif
  endif
  `
  rem X10 - 210807 - record starting coordinates (for AISS max range limit)
  entityelement(e).eleprof.startx=entityelement(e).x
  entityelement(e).eleprof.starty=entityelement(e).y
  entityelement(e).eleprof.startz=entityelement(e).z
  `
 next e
 timestamp=timer()
 `
 rem Overwrite any GUN or FLAK settings with mods-from-entity-weapons
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  tgunid$=entityprofile(entid).isweapon$
  gosub _entity_getgunidandflakid
  if tgunid>0
   gun(tgunid).settings.accuracy=entityelement(e).eleprof.accuracy
   gun(tgunid).settings.reloadqty=entityelement(e).eleprof.reloadqty
   gun(tgunid).settings.iterate=entityelement(e).eleprof.fireiterations
   gun(tgunid).settings.impactforce=entityelement(e).eleprof.ex.impactforce
   if tflakid=0
    gun(tgunid).settings.damage=entityelement(e).eleprof.damage
   else
    flak(tflakid).profile.damage=entityelement(e).eleprof.damage
    flak(tflakid).profile.lifespan=entityelement(e).eleprof.lifespan
    flak(tflakid).profile.bounceonhit=entityelement(e).eleprof.bounceqty
    flak(tflakid).profile.explodeonhit=entityelement(e).eleprof.explodeonhit
    `
    rem some assumptions over how FLAK settings affect flak itself
    flak(tflakid).profile.zinc=entityelement(e).eleprof.throwspeed
    flak(tflakid).profile.yinc=entityelement(e).eleprof.throwangle/10.0
    flak(tflakid).profile.yspeed=1+((entityelement(e).eleprof.throwangle/2.0)/1000.0)
    flak(tflakid).throwangle=entityelement(e).eleprof.throwangle
    if entityelement(e).eleprof.throwangle>0
     flak(tflakid).profile.weight=0.5
    else
     flak(tflakid).profile.weight=0.0
    endif
    `
   endif
  endif
 next e
 `
 rem also ensure entity characters have switched to their weapon (gundata not avail at createelements)
 for e=1 to entityelementlist
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  if obj>0 and entid>0
   if entityprofile(entid).ischaracter=1
    if object exist(obj)=1
     if entityprofile(entid).firespotlimb>-1
      rem spawn leaders do not require attached weapon
      if entityelement(e).spawn.leader=0
       tobj=obj : gosub _entity_switchattachment
       rem V110 - 130110 - as we now have the gundata, ensure its loaded if flagged
       if entityelement(e).eleprof.ex.loadedweapon=1
        tgunid=entityelement(e).currentweapon
        if tgunid>0
         entityelement(e).currentammo=gun(tgunid).settings.reloadqty
        endif
       endif 
      endif
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_resetentitiestorestartstates:
 `
 rem uses tcopyorrestart (1-resttart)
 rem copy start-data-entity-backup to real entityelements
 if tcopyorrestart=0
  dim copyofentityelement(entityelementmax) as entitytype
  for e=1 to entityelementmax
   copyofentityelement(e)=entityelement(e)
  next e
 else
  for e=1 to entityelementmax
   entityelement(e)=copyofentityelement(e)
  next e
 endif
 `
return

_entity_resetentitiesifplrleaps:
 `
 rem Reset logic if player leaps from one location to another
 for e=1 to entityelementlist
  if entityelement(e).active=1
   entityelement(e).logiccount=0
   entityelement(e).logictimestamp=timer()
   entityelement(e).dormant=1
  endif
 next e
 `
return

_entity_rejigifwaterlevelchanges:
 `
 rem Prepare entities for logical usage
 for e=1 to entityelementlist
  if entityelement(e).active=1 and entityelement(e).spawn.leader=0
   entid=entityelement(e).bankindex
   if entityelement(e).obj
    if object exist(entityelement(e).obj)=1
     if object position y(entityelement(e).obj)<waterlevel#
      if entityelement(e).eleprof.physics=1
       rem regular physics objects only (not pseudo static entities like windows)
       ttx#=0 : tty#=2.5 : ttz#=0
       ttobj=entityelement(e).obj : gosub _physics_setvelocity
      endif
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_addetoprioritylist:
 `
 rem add entity to prority status
 if entityelement(e).priorityai=0
  entityelement(e).priorityai=1
  inc logicprioritycount
 endif
 `
return

_entity_removeefromprioritylist:
 `
 rem remove entity from prority status
 if entityelement(e).priorityai=1
  if entityelement(e).priorityduration=0
   entityelement(e).losttargetcount=99999
   entityelement(e).priorityai=0
   if logicprioritycount>0
    dec logicprioritycount
   endif
  endif
 endif
 `
return

_entity_stealpriorityandgivetoe:
 `
 rem Steal from furthest, give to this one (E)
 if lastlogicpriorityfurtheste>0
  if entityelement(e).priorityai=0
   if entityelement(lastlogicpriorityfurtheste).priorityai=1
    if entityelement(lastlogicpriorityfurtheste).priorityduration=0
     tste=e : e=lastlogicpriorityfurtheste : gosub _entity_removeefromprioritylist
     e=tste : entityelement(e).logiccount=0
     gosub _entity_addetoprioritylist
    endif
   endif
  endif
 endif
 `
return

_entity_blastinitentities:
 `
 rem give entities a 10 cycle blast of logic (to set up things like decals and floating collectables)
 for tencycles=1 to 10
  for e=1 to entityelementlist
   if entityelement(e).active=1 and entityelement(e).spawn.leader=0
    entid=entityelement(e).bankindex
    if entid>0
     obj=entityelement(e).obj
     entityelement(e).logictimestamp=timer()
     gosub _entity_controlsingleai
     tdx#=entityelement(e).x-mex# : tdz#=entityelement(e).z-mez# : tdy#=entityelement(e).y-mey#
     entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     rem if too far away to see properly
     if entityelement(e).plrdist<1000.0
      entityelement(e).logiccount=0
      entityelement(e).dormant=0
     else
      entityelement(e).logiccount=0
      entityelement(e).dormant=1
     endif
     rem X10 if visible, also not dormant
     if obj>0
      if object visible(obj)=1
       entityelement(e).logiccount=0
       entityelement(e).dormant=0
      endif
     endif
    endif
   endif
  next e
 next tencycles
 `
 rem Bring all entities alive quickly
 allentsfulllogicatstartcount=100
 `
 rem 030805 - and once call to entity control to start off visuals/decals/etc
 gosub _entity_controlelements
 `
return

_entity_showdebugstringinfo:
 `
 if e>0 and obj>0
  if entityelement(e).priorityai<>0 then ink rgb(255,255,255),0
  if entityelement(e).plrdist<500
   rem V109 - 140109 - added leader=0 to aviod showing invisible spawn entities (corrupt visible text output)
   if object in screen(obj)=1 and entityelement(e).spawn.leader=0
    `
    rem Entity Name and Debug string
    center text object screen x(obj),object screen y(obj)-80,"ID:"+str$(e)+" OBJ:"+str$(obj)+" DIST:"+str$(int(entityelement(e).plrdist))+" POS:"+str$(int(entityelement(e).x))+","+str$(int(entityelement(e).y))+","+str$(int(entityelement(e).z))
    center text object screen x(obj),object screen y(obj)-60,entityelement(e).eleprof.name$
    center text object screen x(obj),object screen y(obj)-40,entitydebug$(e)
    `
    rem Entity Status Info
    tentid=entityelement(e).bankindex
    if entityprofile(tentid).ischaracter<>0
     if entityelement(e).ai.libindex>=1 and entityelement(e).ai.libindex<=array count(scriptbank$(0))
      tainame$=scriptbank$(entityelement(e).ai.libindex)
     else
      tainame$=str$(entityelement(e).ai.libindex)
     endif
     `150110center text object screen x(obj),object screen y(obj)-20,"A:"+tainame$+" S:"+str$(entityelement(e).ai.state)+" WS:"+str$(entityelement(e).ai.waypoint.state)+" L:"+str$(entityelement(e).eleprof.lives)+" H:"+str$(entityelement(e).health)+" LT:"+str$(entityelement(e).losttargetcount)+"("+str$(int(entityelement(e).actualtargetx))+","+str$(int(entityelement(e).actualtargety))+","+str$(int(entityelement(e).actualtargetz))+") RCC:"+str$(entityelement(e).raycastcount)+" AF:"+str$(entityelement(e).animframe)+" AOBJ:"+str$(entityelementwhichobj(e))+" SLOT:"+str$(entityelementwhichslot(e))+" ACT:"+str$(entityelement(e).activated)
     center text object screen x(obj),object screen y(obj)-20,"A:"+tainame$+" S:"+str$(entityelement(e).ai.state)+" WS:"+str$(entityelement(e).ai.waypoint.state)+" L:"+str$(entityelement(e).eleprof.lives)+" H:"+str$(entityelement(e).health)+" AIMODE:"+str$(entityelement(e).eleprof.aiss.lastactionmode)+" AF:"+str$(entityelement(e).animframe)+" AOBJ:"+str$(entityelementwhichobj(e))+" SLOT:"+str$(entityelementwhichslot(e))+" ACT:"+str$(entityelement(e).activated)
     if entityelement(e).currentweapon>0
      center text object screen x(obj),object screen y(obj),"W:"+str$(entityelement(e).currentweapon)+" WA:"+str$(entityelement(e).currentammo)+"\"+str$(entityelement(e).currentclipammo)
     else
      center text object screen x(obj),object screen y(obj),"HAS W:"+str$(entityelement(e).eleprof.hasweapon)
     endif
    else
     if entityprofile(tentid).isweapon<>0
      tgunid=entityprofile(tentid).isweapon
      center text object screen x(obj),object screen y(obj)-20," AI:"+str$(entityelement(e).ai.libindex)+" S:"+str$(entityelement(e).ai.state)+strarr$(99)+str$(gun(tgunid).settings.damage)+" H:"+str$(entityelement(e).health)
     else
      center text object screen x(obj),object screen y(obj)-20," AI:"+str$(entityelement(e).ai.libindex)+" S:"+str$(entityelement(e).ai.state)+" H:"+str$(entityelement(e).health)+" AF:"+str$(entityelement(e).animframe)
     endif
    endif
    `
   endif
  endif
  if entityelement(e).priorityai<>0 then ink rgb(255,255,0),0
 endif
 `
return

_entity_controlelements:

rem FPSCV10X - solve slow life for entities at distance
if allentsfulllogicatstartcount>0
 dec allentsfulllogicatstartcount
endif

rem Entity Performance
gameperftimestamplocal=perftimer()

rem General data for control management
mex#=camerapositionx : mey#=camerapositiony : mez#=camerapositionz
meheight#=(ellipsevolumesize#-0.25)*30.0

rem handle AI sound
managebroadcastsound()
gosub _aiss_broadcastsound

rem maintain constant game speed
timeelapsed#=(1.0/50.0)*(timer()-timestamp) : timestamp=timer()

rem Debug entire AI logic
if gshowdebugtextingamestate=1
 if debugviewtog=1
  set cursor 0,100
  ink rgb(128,255,128),0
  print strarr$(98)
  print
 endif
endif

rem X10 - Global ragdoll timing (can use 5 at a time, 3 seconds decay per ragdoll usage)
if timer()>ragdollcounttimetick
 ragdollcounttimetick=timer()+3000
 rem ragdoll limit based on the dynamic moving ones, not the static
 rem ones which freeze after about three seconds
 if ragdollcountingame>0 then dec ragdollcountingame
endif

rem Go through all entities for LOGIC
superstealpriority=0
tonestealperaiphase=0
tonestealperaiphasedist#=99999
logicpriorityfurthest#=0
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 obj=entityelement(e).obj
 if entityelement(e).active=1 and entityelement(e).dormant=0
  `
  rem only non-spawn-masters with valid profile indexes
  if entid>0 and entityelement(e).spawn.leader=0
   `
   rem reset kill flag
   tkillentitynow=0
   `
   rem always fade entity to lifespan no matter logic slice
   if entityelement(e).spawn.life>0
    if timer()>entityelement(e).spawn.life
     entityelement(e).spawn.life=0
     tkillentitynow=1
    endif
   endif
   `
   rem always kill an entity falling out of universe
   if entityelement(e).y<-100
    tkillentitynow=1
   endif
   `
   rem kill now
   if tkillentitynow=1
    tdamage=entityelement(e).health
    tdamagesource=0 : timpacttype=1
    tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
    ttodestroyevenifimmune=entityelement(e).eleprof.strength : rem store for later return
    if entityelement(e).eleprof.strength=0 then entityelement(e).eleprof.strength=1
    gosub _entity_deducthealth : entityelement(e).eleprof.strength=ttodestroyevenifimmune
    tkillentitynow=0
   endif
   `
   rem logic timeslice
   tlogic#=entityelement(e).logiccount-timeelapsed#
   entityelement(e).logiccount=tlogic#
   if entityelement(e).eleprof.phyalways<>0 then entityelement(e).logiccount=0
   if entityelement(e).logiccountburst>0 then entityelement(e).logiccountburst=entityelement(e).logiccountburst-1 : entityelement(e).logiccount=0
   `
   rem X10 full AI - performance gains in other ways
   entityelement(e).logiccount=0
   if entityelement(e).logiccount<=0
    `
    rem time slice of logic (..since entity last thought..)
    timeslice#=(1.0/50.0)*(timer()-entityelement(e).logictimestamp)
    entityelement(e).logictimestamp=timer()
    `
    rem logic control
    gosub _entity_controlsingleai
    `
    rem when move, sounds might also need moving
    if entityelement(e).eleprof.physics<=2
     for tsnd=0 to 2
      if tsnd=0 then ttsnd=entityelement(e).soundset
      if tsnd=1 then ttsnd=entityelement(e).soundset1
      if tsnd=2 then ttsnd=entityelement(e).soundlooping
      if ttsnd>0
       if sound exist(ttsnd)=1
        if sound looping(ttsnd)=1
         posinternal3dsound(ttsnd,entityelement(e).x,entityelement(e).y,entityelement(e).z)
        endif
       endif
      endif
     next tsnd
    endif
    `
    rem free up a counter for a new AI character to be selected
    if entityelement(e).priorityai=1
     tokay=0
     if entityelement(e).active=0 or entityelement(e).plrdist>1000
      entityelement(e).priorityduration=0
      tokay=1
     endif
     if tokay=1
      gosub _entity_removeefromprioritylist
     else
      rem work out which E is the furthest back
      tpridist#=entityelement(e).plrdist
      if tpridist#>logicpriorityfurthest#
       logicpriorityfurthest#=tpridist#
       logicpriorityfurtheste=e
      endif
     endif
     rem priority duration protects from being lost or stolen for a while (running away)
     if entityelement(e).priorityduration>0
      entityelement(e).priorityduration=entityelement(e).priorityduration-1
     else
      entityelement(e).priorityduration=0
     endif
    endif
    `
    rem calculate player activity distance
    tdx#=entityelement(e).x-mex# : tdz#=entityelement(e).z-mez#
    entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
    `
    rem can I see checkpoints here
    if entityprofile(entid).ismarker=1 and entityprofile(entid).lives=0
     if entityelement(e).plrdist<120.0
      if checkpointentity<>e
       playinternal3dsound(entityelement(e).soundset,mex#,mey#,mez#)
       checkpointentity=e
      endif
     endif
    endif
    `
    rem logic count based on distance (cancelled for important AI above)
    if allentsfulllogicatstartcount>0
     rem FPSCV10X - all entities should have immediate burst of logic to get started
     entityelement(e).logiccount=0
    else
     entityelement(e).logiccount=entityelement(e).plrdist/5.0
    endif
    `
   endif
   `
  endif
  `
 else
  `
  rem only if not dormant
  if entityelement(e).dormant=0
   `
   rem Inactive entity, however characters have logic even when dead
   if entityprofile(entid).ischaracter=1
    if entityelement(e).eleprof.cantakeweapon=1
     tgunid=entityelement(e).currentweapon
     if tgunid>0
      rem X10 follow ode influenced dropped attached weapon
      tdropobj=entityelement(e).attachmentobj
      if tdropobj>0
       x1#=object position x(tdropobj)
       y1#=object position y(tdropobj)
       z1#=object position z(tdropobj)
      else
       x1#=entityelement(e).x
       y1#=entityelement(e).y
       z1#=entityelement(e).z
      endif
      tdx#=x1#-mex# : tdy#=y1#-(mey#-40) : tdz#=z1#-mez#
      entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
      rem X10 weapon can also disappear after X seconds
      tremoveweaponfromgame=0
      if entityelement(e).eleprof.ex.decaytime>0
       if timer()-entityelement(e).timekilled>(entityelement(e).eleprof.ex.decaytime*1000)
        tremoveweaponfromgame=1
       endif
      endif
      if entityelement(e).plrdist<35
       rem player collects weapon from enemy (stores takeweaponammo in Quantity)
       weaponindex=tgunid
       weaponinvposition=pi : tgunid=weaponindex
       tqty=rnd(gun(tgunid).settings.reloadqty)
       gosub _player_addweapon
       rem for weapnisammo collections, add required ammo
       if gotweapon>0
        if gun(tgunid).settings.weaponisammo=0
         tqty=gun(tgunid).settings.reloadqty*entityelement(e).eleprof.quantity
         weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
        else
         if tqty=0 then tqty=1
         if weaponammo(gotweapon)=0
          weaponammo(gotweapon)=tqty
         else
          weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
         endif
        endif
       endif
       rem and play a reload sound from the gun (collection sound=reload)
       if gunsound(tgunid,2).soundid>0
        if sound exist(gunsound(tgunid,2).soundid)=1
         if sound playing(gunsound(tgunid,2).soundid)=0
          playinternalBC3dsound(gunsound(tgunid,2).soundid,camera position x(),camera position y(),camera position z(),1)
         endif
        endif
       endif
       rem and remove weapon from dead entity
       tremoveweaponfromgame=1
      endif
      if tremoveweaponfromgame=1
       rem remove weapon from game
       entityelement(e).currentweapon=0
       rem remove attached weapon from entity also
       tobj=entityelement(e).attachmentobj
       rem X10 and remove ode influence of dropped weapon
       if phyobjele(tobj)=-1
        gosub _physics_deleteentity
        phyobjele(tobj)=0
       endif
       if tobj>0
        hide object tobj
        rem move the parent gun as cannot hide it while being used as an instance
        position object tobj,-50000,-50000,-50000
       endif
      endif
     endif
    endif
   endif
  else
   `
   rem calculate distance from player even if dormant
   tdx#=entityelement(e).x-mex# : tdy#=entityelement(e).y-mey# : tdz#=entityelement(e).z-mez#
   entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   `
   rem X10 objects are not dormant if they are near player
   rem moved entityelement(e).eleprof.phyalways flag use to ODE UPDATE code
   if entityelement(e).plrdist<500.0 or entityprofile(entid).ischaracter=1
    entityelement(e).dormant=0
   endif
   `
  endif
  `
 endif
next e

rem Entity Performance
inc gameperfentities1, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem end of debug entire AI logic
if gshowdebugtextingamestate=1
 if debugviewtog=1
  ink rgb(255,255,0),0
 endif
endif

rem Steal priority if new entity closer
if tonestealperaiphase>0
 e=tonestealperaiphase : gosub _entity_stealpriorityandgivetoe
endif

rem Drop a priority entity if need to get some AI speed back
if logicpriorityfurtheste>0
 lastlogicpriorityfurthest#=logicpriorityfurthest#
 lastlogicpriorityfurtheste=logicpriorityfurtheste
 if logicprioritycount>int(logicprioritymax#)
  e=logicpriorityfurtheste
  gosub _entity_removeefromprioritylist
 endif
endif

rem Entity Performance
inc gameperfentities2, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem Go through all entities for MOVEMENT
for e=1 to entityelementlist
 if entityelement(e).dormant=0
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  gosub _entity_controlspawn
  if entityelement(e).spawn.leader=0
   if entityelement(e).active=1
    gosub _entity_controlwaypoints
    gosub _entity_controlforce
    gosub _entity_controlcollision
    gosub _entity_controlmovements
    gosub _entity_controldelayeddamage
   endif
  endif
 endif
next e

rem Entity Performance
inc gameperfentities3, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem Calculate any logic drop increments/decrements
if screen fps()>=30
 if logicprioritymax#<10.0
  logicprioritymax#=logicprioritymax#+0.02
 endif
else
 logicprioritymax#=2.0
endif

rem X10 flag is set if a refraction element used
grefractionelementused=0

rem X10 timer based speed - machine independent
incspeed#=(1.0/40.0)*(timer()-lastincrementspeedtime) : lastincrementspeedtime=timer()

rem Go through all entities for VISUAL
for e=1 to entityelementlist
 obj=entityelement(e).obj
 entid=entityelement(e).bankindex
 rem V109 - 140109 - added allentsfulllogicatstartcount>0 so all level entities could sort themselves out (weapon pickups)
 if entityelement(e).active=1 and (entityelement(e).dormant=0 or allentsfulllogicatstartcount>0)
  if obj>0
   `
   if object exist(obj)=1
    `
    rem DEBUGENT 
    `text object screen x(obj),object screen y(obj),str$(entityelement(e).x)+" "+str$(entityelement(e).y)+" "+str$(entityelement(e).z)
    `text object screen x(obj),object screen y(obj)+30,str$(object position x(obj))+" "+str$(object position y(obj))+" "+str$(object position z(obj))
    `
    rem Operate spin and float system
    tspin#=0.0 : thover#=0.0
    if entityelement(e).spinrate<>0
     entityelement(e).spinvalue=entityelement(e).spinvalue+(entityelement(e).spinrate*incspeed#)
     tspin#=wrapvalue(entityelement(e).spinvalue)
    endif
    if entityelement(e).floatrate<>0
     entityelement(e).floatvalue=entityelement(e).floatvalue+(4*incspeed#)
     thover#=entityelement(e).floatrate+(cos(wrapvalue(entityelement(e).floatvalue))*entityelement(e).floatrate)
    endif
    `
    rem update entity object position (keep position for univese vis-culling)
    if entityelement(e).eleprof.physics=1
     rem regular physics driven
     entityelement(e).x=object position x(obj)
     entityelement(e).y=object position y(obj)
     entityelement(e).z=object position z(obj)
     entityelement(e).ry=object angle y(obj)
    else
     if entityelement(e).eleprof.physics=2
      rem entity driven physics (character)
      todee=e : gosub _physics_entitydrivenphysics
     else
      if entityelement(e).eleprof.physics=3
       rem entity is typically immobile (door/window)
       todee=e : gosub _physics_entitydrivenstaticphysics
      else
       rem no physics influences
       position object obj,entityelement(e).x,entityelement(e).y+thover#,entityelement(e).z
      endif
     endif
    endif
    `
    rem Animations need consistency when suddenly obj is visible
    gosub _entity_controlanim
    `
    rem if actually visible to camera
    if object visible(obj)=1
     `
     rem Only need decal creation if an existing obj is visible
     gosub _entity_controldecals
     `
     rem handle object rotation
     if entityelement(e).norotate=0
      yrotate object obj,entityelement(e).ry+tspin#
     endif
     `
     rem update animation frame of entity
     if entityelement(e).animframeupdate=1
      rem X10 actual object may be parent slot managed
      actualobj=entityelementwhichobj(e)
      if actualobj=0 then actualobj=obj
      stop object actualobj : set object interpolation actualobj,100
      rem X10 parent slot set elsewhere, when frame was initialised
      set object frame actualobj,entityelement(e).animframe
      entityelement(e).animframeupdate=0
     endif
     `
     rem Update head if available
     if entityprofile(entid).headlimb<>-1
      if limb exist(obj,entityprofile(entid).headlimb)=1
       rotate limb obj,entityprofile(entid).headlimb,curveangle(entityelement(e).ai.headangle,limb angle x(obj,entityprofile(entid).headlimb),3.0),limb angle y(obj,entityprofile(entid).headlimb),limb angle z(obj,entityprofile(entid).headlimb)
      endif
     endif
     `
     rem any visual overlay info
     if gshowentitygameinfostate=1 then gosub _entity_showdebugstringinfo
     `
     rem update alpha fade value
     if gmultiplayergame=1 and entityprofile(entid).ischaracter=1
      rem multiplayer - bug in 5.8, characters cannot control alpha (seem to be influenced by other objects)
      `x10 has no such bug (and interferes with char fade) set alpha mapping on obj,100
      `if entityprofile(entid).ischaracter<>0
      ` if entityelement(e).invincibleactive<>0
      `  ghost object on obj
      ` else
      `  ghost object off obj
      ` endif
      `endif
      rem find out which player
      ttplrindex=0 : ttplrel=0
      for ttel=1 to multiplayeridlinkmax
       if multiplayeridlink(ttel)<>1
        if characterchoiceentityindex(ttel)=e and ttplrel=0 then ttplrindex=multiplayerplrindex(ttel) : ttplrel=el
       endif
      next ttel
      if ttplrel>0 and player(ttplrindex).health>0
       rem X10 - 081107 - ensure healthy entities have full alpha (for now)
       set object transparency obj,2
       if entityelement(e).invincibleactive<>0
        set alpha mapping on obj,50
       else
        set alpha mapping on obj,100
       endif
       entityelement(e).ai.alphafade=100
      else
       rem X10 - 081107 - in multiplayer, fade out characters when they die
       `rem for the 12+ TEEN rating mode
       `if entityelement(e).ai.alphafade>0
       ` if entityelement(e).ai.alphafade>50 then entityelement(e).ai.alphafade=50
       ` entityelement(e).ai.alphafade=entityelement(e).ai.alphafade-2
       ` if entityelement(e).ai.alphafade<0 then entityelement(e).ai.alphafade=0
       ` entityelement(e).ai.destalphafade=entityelement(e).ai.alphafade
       `endif
       `set alpha mapping on obj,entityelement(e).ai.alphafade
       `X10-141107 - instant disappear (the fall back thing is still too 16+)
       entityelement(e).ai.alphafade=0
       entityelement(e).ai.destalphafade=0
       set alpha mapping on obj,entityelement(e).ai.alphafade
      endif
     else
      rem keep for single player
      if entityelement(e).invincibleactive<>0
       set alpha mapping on obj,50+rnd(25)
      else
       if entityelement(e).ai.alphafadeupdate=1
        set alpha mapping on obj,entityelement(e).ai.alphafade
        entityelement(e).ai.alphafadeupdate=0
       endif
      endif
     endif
     `
     rem X10 flag is set if a refraction element used
     if object in screen(obj)=1
      if entityelementusingrefraction(e)=1
       grefractionelementused=1
      endif
     endif
     `
     rem blob shadow control (all other non local plrs) (might be performance issue here)
     if entityelement(e).attachmentblobobj>0 and entityelement(e).beenkilled=0
      if object exist(entityelement(e).attachmentblobobj)=1
       rem override blob shadow for per-entity 'prompt icon'
       rem only if showallyicon flag is set to YES
       if entityelement(e).eleprof.aiss.thinkingprompt>0 and entityelement(e).eleprof.ex.showallyicon=1
        entityelement(e).eleprof.aiss.thinkingcount=entityelement(e).eleprof.aiss.thinkingcount-1
        if entityelement(e).eleprof.aiss.thinkingcount>0
         rem use blob shadow to create order-icon above entity
         `tmvszy#=(object size y(obj)/2) X10 V109 - 090309 - apply scale
         tmvszy#=((object size y(obj)/2)*entityprofile(entid).scale)/100.0
         tmvy#=object position y(obj)+tmvszy#
         position object entityelement(e).attachmentblobobj,camera position x(playercam),camera position y(playercam),camera position z(playercam)
         point object entityelement(e).attachmentblobobj,object position x(obj),tmvy#,object position z(obj)
         tmvy#=tmvy#+(entityelement(e).eleprof.aiss.thinkingcount/3.0)
         position object entityelement(e).attachmentblobobj,object position x(obj),tmvy#,object position z(obj)
         set object cull entityelement(e).attachmentblobobj,0
         show object entityelement(e).attachmentblobobj
         texture object entityelement(e).attachmentblobobj,attachmenticonimagestart+entityelement(e).eleprof.aiss.thinkingprompt
         scale object entityelement(e).attachmentblobobj,50,50,50
         if entityelement(e).eleprof.aiss.thinkingcount<20
          set alpha mapping on entityelement(e).attachmentblobobj,entityelement(e).eleprof.aiss.thinkingcount*5
         else
          if entityelement(e).eleprof.aiss.thinkingcount>40
           set alpha mapping on entityelement(e).attachmentblobobj,(50-entityelement(e).eleprof.aiss.thinkingcount)*10.0
          else
           set alpha mapping on entityelement(e).attachmentblobobj,100
          endif
         endif
         set object mask entityelement(e).attachmentblobobj,%100000,%0000,%00
        else
         rem restore blob shadow
         set object cull entityelement(e).attachmentblobobj,1
         set alpha mapping on entityelement(e).attachmentblobobj,100
         texture object entityelement(e).attachmentblobobj,attachmenticonimagestart+0
         rotate object entityelement(e).attachmentblobobj,90,0,0
         scale object entityelement(e).attachmentblobobj,100,100,100
         set object mask entityelement(e).attachmentblobobj,%110010,%0100,%10 : rem shadow in game
         entityelement(e).eleprof.aiss.thinkingcount=0
         entityelement(e).eleprof.aiss.thinkingprompt=0
        endif
       else
        rem blob shadow use
        if shadowobj(entityelement(e).obj)=0
         if (gmultiplayergame=0 and entityelement(e).health>0) or (gmultiplayergame=1 and entityelement(e).collisionactive<>0)
          `dst#=static raycast(entityelement(e).x,entityelement(e).y+5,entityelement(e).z,entityelement(e).x,entityelement(e).y-50,entityelement(e).z)
          dst#=AI RAY CAST(entityelement(e).x,entityelement(e).y+5,entityelement(e).z,entityelement(e).x,entityelement(e).y-50,entityelement(e).z)
          if dst#<>-1
           dst#=dst#*55.0
          else
           dst#=0
          endif
         else
          dst#=0.0
         endif
        else
         dst#=0.0
        endif
        if dst#>0
         dst#=dst#-5.0
         `tmvszy#=(object size y(obj)/2) X10 V109 - 090309 - apply scale
         tmvszy#=((object size y(obj)/2)*entityprofile(entid).scale)/100.0
         tmvy#=object position y(obj)-tmvszy#
         position object entityelement(e).attachmentblobobj,object position x(obj),(tmvy#-dst#)+0.5,object position z(obj)
         show object entityelement(e).attachmentblobobj
         tsc#=(100.0-dst#) : scale object entityelement(e).attachmentblobobj,tsc#,tsc#,tsc#
        else
         hide object entityelement(e).attachmentblobobj
        endif
       endif
      endif
      rem 011007 - added object exist(entityelement(e).attachmentblobobj+1+1)=1
      if object exist(entityelement(e).attachmentblobobj+1)=1 and object exist(entityelement(e).attachmentblobobj+1+1)=1
       if entityelement(e).eleprof.ex.showhealthbar=0 or gmultiplayergame=1
        rem arena has no helth bar, and nor do entities that have it switched off
       else
        rem health bar blob border and bar
        for t=0 to 1
         tattachmentblobobj2=entityelement(e).attachmentblobobj+1+t
         `tmvszy#=(object size y(obj)/2) X10 V109 - 090309 - apply scale
         tmvszy#=((object size y(obj)/2)*entityprofile(entid).scale)/100.0
         tmvy#=object position y(obj)+tmvszy#
         tmvy#=tmvy#+(tmvszy#*0.1)
         position object tattachmentblobobj2,object position x(obj),tmvy#,object position z(obj)
         set object to camera orientation tattachmentblobobj2
         set object cull tattachmentblobobj2,0
         if t=1
          rem move health bar
          if entityelement(e).eleprof.strength>0
           thealthperc#=entityelement(e).health
           thealthperc#=thealthperc#/(entityelement(e).eleprof.strength+0.0)
          else
           thealthperc#=1.0
          endif
          scale object tattachmentblobobj2,100*thealthperc#,100,100
         endif
         if entityelement(e).plrdist<300
          set alpha mapping on tattachmentblobobj2,100
          show object tattachmentblobobj2
         else
          if entityelement(e).plrdist<400
           set alpha mapping on tattachmentblobobj2,(400-entityelement(e).plrdist)
           show object tattachmentblobobj2
          else
           hide object tattachmentblobobj2
          endif
         endif
        next t
       endif
      endif
     endif
     `
    else
     `
     rem Limited debug info view of entities not visible (for spawn debugging)
     if gshowentitygameinfostate=1 then gosub _entity_showdebugstringinfo
     `
    endif
    `
   endif
   `
  else
   `
   rem entity has no OBJ
   if entityprofile(entid).ismarker=4
    rem emission markers can emit decals of course
    gosub _entity_controldecals
   endif
   `
  endif
 endif
 `
 rem 060807 - monitor entity for splash (dead or alive, or not facing at the time)
 if entityelement(e).dormant=0
  if obj>0
   if object exist(obj)=1
    gosub _entity_monitorforsplash
   endif
  endif
 endif
 `
next e

rem Display vis col map (as radar test)
`if (debugviewmode<>0 or showfpsinrealgame=2) and entitysystemdisabled=0 and 0
if 0
 lock pixels
 thorizpos=64
 metx=camerapositionx/25 : mety=camerapositiony/100 : metz=camerapositionz/-25
 line thorizpos,470,thorizpos+82,470 : line thorizpos,553,thorizpos+82,553
 line thorizpos,470,thorizpos,553 : line thorizpos+82,470,thorizpos+82,553
 for tx=metx-20 to metx+20
  for ty=mety to mety
   for tz=metz-20 to metz+20
    tdot=0
    if tx>=0 and tx<=160 and ty>=0 and ty<=5 and tz>=0 and tz<=160
     if viscolmap(tx,ty,tz)<>0
      tdot=1
     endif
    else
     if (tx=-1 or tx=161) and tz>=0 and tz<=160
      tdot=1
     endif
     if (tz=-1 or tz=161) and tx>=0 and tx<=160
      tdot=1
     endif
    endif
    if tdot=1
     dot thorizpos+41+((tx-metx)*2),511+((tz-metz)*2)
     dot thorizpos+41+((tx-metx)*2),512+((tz-metz)*2)
     dot thorizpos+42+((tx-metx)*2),511+((tz-metz)*2)
     dot thorizpos+42+((tx-metx)*2),512+((tz-metz)*2)
    endif
   next tz
  next ty
 next tx
 unlock pixels
endif

rem Entity Performance
inc gameperfentities4, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem X10 AI control of entities
gosub _aiss_control

rem Entity Performance
inc gameperfentities5, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

return

_entity_monitorforsplash:
 `
 rem X10 entity can have a splash if they enter the water at force
 if (entityelement(e).eleprof.physics=1 or entityelement(e).eleprof.physics=2) and splashdecalid>0
  rem if regular physics obj or character obj
  waterlevelforsplash#=waterlevel#
  if entityelement(e).eleprof.physics=2
   rem character/ragdoll center
   tactualbaseofobject#=object position y(entityelement(e).obj)
  else
   tactualbaseofobject#=object position y(entityelement(e).obj)-(object size y(entityelement(e).obj)/2.0)
  endif
  if tactualbaseofobject#<waterlevelforsplash#
   if entityelement(e).decalloop=0
    rem measure velocity on impact with water
    velocity#=0.0
    if entityelement(e).obj>0 and entityelement(e).obj<array count(phyobjele())
     ttobj=entityelement(e).obj : gosub _physics_getvelocityy
    endif
    if entityelement(e).eleprof.physics=2
     velocity#=velocity#*5.0
    endif
    if velocity#>25.0
     rem set so only do one splash per entry into water
     if waterdecalripple<>0
      rem and only if water does ripple
      entityelement(e).decalloop=1
      decalx=object position x(entityelement(e).obj)
      decalz=object position z(entityelement(e).obj)
      if camera position y(playercam)<waterlevel#
       decaly=waterlevel#
      else
       decaly=(waterlevel#-50)+(velocity#/2.0)
      endif
      if decaly>waterlevel# then decaly=waterlevel#
      gosub _entity_makeasplash
     endif
    endif
   else
    rem entity in IN water
    rem if entity disturbing surface, fire off random rippe now and then
    if rnd(150)=0 and waterdecalripple<>0
     rem and only if water does ripple
     if abs(object position y(entityelement(e).obj)-waterlevel#)<25.0
      decalid=waterdecalripple
      decalorient=0
      decalx=object position x(entityelement(e).obj)
      decaly=waterlevel#+1.0
      decalz=object position z(entityelement(e).obj)
      decalorient=2
      decalscalemodx=20+(abs(entityelement(e).eleprof.phyweight)/50.0) : decalscalemody=decalscalemodx
      decalalpha=15
      originatore=0 : gosub _decalelement_create     
     endif
    endif
   endif
  else
   rem if entity leaves water, reset splash flag
   if entityelement(e).decalloop=1
    if tactualbaseofobject#>waterlevelforsplash#
     rem completely out of water, gravity back on
     entityelement(e).decalloop=0
    endif
   endif
  endif
 endif
 `
return

_entity_fillviscolmap:
 `
 rem Fill empty map tiles with no-walk id
 for tmx=0 to 39
  for tmz=0 to 39
   for tml=0 to 4
    for tx=0 to 3
     for tz=0 to 3
      viscolmap((tmx*4)+tx,tml,(tmz*4)+tz)=0
     next tz
    next tx
   next tml
  next tmz
 next tmx
 `
 rem use map data to determine where layer holes are (so characters cannot fall off ledges)
 for tmx=0 to 39
  for tmz=0 to 39
   for tml=0 to 19
    if map(tml,tmx,tmz)=0
     for tx=0 to 3
      for tz=0 to 3
       viscolmap((tmx*4)+tx,tml,(tmz*4)+tz)=-2
      next tz
     next tx
    endif
   next tml
  next tmz
 next tmx
 `
return

_entity_shotbygun:

rem need gunid, e, bulletraytype, x#, x1#
tix#=x#-x1# : tiy#=y#-y1# : tiz#=z#-z1#
tnorm#=(abs(tix#)+abs(tiy#)+abs(tiz#))/3.0
tix#=tix#/tnorm# : tiy#=tiy#/tnorm# : tiz#=tiz#/tnorm#
`
rem bulletraytype (1-pierce, 2-shotgun)
tentid=entityelement(e).bankindex
if gmultiplayergame=0
 rem impact force property is 75 is norma0 for mild blast
 tforce#=0.01*(gun(gunid).settings.impactforce*gun(gunid).settings.impactforce)
 rem entity prone to force
 if entityelement(e).eleprof.isimmobile=0
  rem apply force
  rem X10 also, if a ragdoll when shot, also apply force
  rem X10 or it is a character (soon to be ragdoll)
  if entityelement(e).eleprof.physics=1
   rem using advanced physics (force is soft if entity destroyed in hit)
   todee=e : tdx#=tix# : tdy#=tiy# : tdz#=tiz# : todefalloff#=0.0
   todeforce#=tforce# : tpx#=x# : tpy#=y# : tpz#=z# : gosub _physics_applypointforce
  else
   if entityprofile(tentid).ischaracter=1
    rem X10 240907 - used now for brief knock back effect
    if useknockbackasplayershotcharacter=1
     entityelement(e).eleprof.aiss.knockbackx=tix#*15
     entityelement(e).eleprof.aiss.knockbackz=tiz#*15
    else
     entityelement(e).eleprof.aiss.knockbackx=0
     entityelement(e).eleprof.aiss.knockbackz=0
    endif
    rem X10 and used later when convert to ragdoll
    if entityelement(e).health<=0
     rem if health low
     entityelement(e).force.active=1+tforce#
     entityelement(e).force.ix=tix#
     entityelement(e).force.iy=tiy#
     entityelement(e).force.iz=tiz#
     rem 040707 - provide origin of force (for later use in ragdoll velocity)
     entityelement(e).force.originx=x1#
     entityelement(e).force.originy=y1#
     entityelement(e).force.originz=z1#
    endif
   else
    rem using regular force calc
    entityelement(e).force.active=1
    entityelement(e).force.ix=tix#*tforce#
    entityelement(e).force.iy=tiy#*tforce#
    entityelement(e).force.iz=tiz#*tforce#
    rem 040707 - provide origin of force
    entityelement(e).force.originx=x1#
    entityelement(e).force.originy=y1#
    entityelement(e).force.originz=z1#
   endif
  endif
 endif
endif

return

_entity_controlsingleai:

rem get functional overview
gosub _entity_controlrecalcdist

rem before any point of logic, if no health in main AI, die
if entityelement(e).ai.libindex=entityelement(e).ai.libmain
 if entityelement(e).health<=0
  entityelement(e).ai.libindex=entityelement(e).ai.libdestroy
  entityelement(e).ai.waypoint.state=0
  entityelement(e).ai.headangle=0
  entityelement(e).ai.state=0
 endif
endif

rem New AI Script flag
trundefaultscript=0
taddforcesphere=0

rem Get AI Script for Entity Element
aiindex=entityelement(e).ai.libindex
gosub _ai_control
`
rem X10 special force sphere (subtle enough not to move anything, but nudge physics)
if entityelement(e).obj>0
 if phyobjelenudged(entityelement(e).obj)<>0
  rem send vibrations to nudge other entites in area
  taddforcesphere=1
 endif
endif
`
rem Apply force if actioned
if taddforcesphere>0
 spherex#=entityelement(e).x
 spherey#=entityelement(e).y
 spherez#=entityelement(e).z
 sphereforce#=taddforcesphere/100.0
 gosub _entity_addforcesphere
endif
`
rem Weapon Control for entities
if entityelement(e).fireweapon=1
 tgunid=entityelement(e).currentweapon
 if tgunid>0
  `
  rem WEAPON USAGE
  `
  rem start of shot pos
  if entityprofile(entid).firespotlimb>-1
   x1#=limb position x(obj,entityprofile(entid).firespotlimb)
   y1#=limb position y(obj,entityprofile(entid).firespotlimb)
   z1#=limb position z(obj,entityprofile(entid).firespotlimb)
  else
   x1#=entityelement(e).x
   y1#=entityelement(e).y+45.0
   z1#=entityelement(e).z
  endif
  `
  rem weapon type
  flakid=gun(tgunid).settings.flakindex
  if flakid=0
   `
   rem BULLET
   rem initial shot creates light flash
   if spotmultiplier#<>5.0
    spotflash=100 : spotmultiplier#=1.0
    tx#=x1# : ty#=y1# : tz#=z1#
    tcolr=gun(tgunid).settings.muzzlecolorr/3
    tcolg=gun(tgunid).settings.muzzlecolorg/3
    tcolb=gun(tgunid).settings.muzzlecolorb/3
    gosub _lighting_spotflash
   endif
   `
   rem X10 gunsmoke effect (only if not laser)
   if gun(tgunid).settings.muzzlelasertype=0
    if particlegunsmoke<>0
     inc particlegunsmoke
     if particlegunsmoke>5 then particlegunsmoke=1
     rem emissions are switched off, can create them individually using new command
     emit particle particlegunsmoke,x1#,y1#,z1#
    endif
   endif
   `
   rem discharge sound (single fire, or automatic loop sound)
   tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
   if tsndid>0
    set sound volume tsndid,soundvolumes(1)
    if gun(tgunid).action.automatic.s>0
     if entityelement(e).firesoundloop=0
      play sound tsndid,gun(tgunid).sound.fireloopend : rem some sound bug
      loop sound tsndid,0,gun(tgunid).sound.fireloopend
      entityelement(e).firesoundloop=tsndid
     endif
    else
     play sound tsndid
    endif
    posinternal3dsound(tsndid,x1#,y1#,z1#)
    broadcast3dsound(x1#,y1#,z1#,100.0)
   endif
   `
   rem gun data for accuracy
   trayaccuracy=gun(tgunid).settings.accuracy
   `
   rem project gun-line-for-shot (from raw-calc or target)
   if entityelement(e).actualtarget<>0
    rem no accuracy drift if close
    x2#=entityelement(e).actualtargetx
    y2#=entityelement(e).actualtargety
    z2#=entityelement(e).actualtargetz
    tdx#=abs(x2#-x1#)
    tdy#=abs(y2#-y1#)
    tdz#=abs(z2#-z1#)
    tdd#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
    rem greater than 200 units add drift
    if tdd#>200.0
     rem add a basic distance drift to enemy shooing (human error)
     trayaccuracy=(trayaccuracy*5)+rnd((tdd#-200)*2)
     rem Work out final trajectory of shot
     x2#=entityelement(e).actualtargetx+trayaccuracy-rnd(trayaccuracy*2)
     y2#=entityelement(e).actualtargety+trayaccuracy-rnd(trayaccuracy*2)
     z2#=entityelement(e).actualtargetz+trayaccuracy-rnd(trayaccuracy*2)
    endif
   else
    position object hudbankoffset+3,x1#,y1#,z1#
    rotate object hudbankoffset+3,0,entityelement(e).mover.da,0
    move object hudbankoffset+3,gun(tgunid).settings.range
    disable object zdepth hudbankoffset+3
    x2#=object position x(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
    y2#=object position y(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
    z2#=object position z(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
   endif
   `
   rem had bulletray hit anything solid
   tbullethit=0 : tbullethitstatic=0
   tbullethitmaterial=0 : tbullethitflesh=0
   entityelement(e).raycastcount=0
   rem X10 new ray cast quicker
   if 1
    dst#=AI ray cast(x1#,y1#,z1#,x2#,y2#,z2#) `but we need info coming back for material
    if dst#<>-1
     dstx#=(x2#-x1#)*dst#
     dsty#=(y2#-y1#)*dst#
     dstz#=(z2#-z1#)*dst#
     dst#=sqrt(abs(dstx#*dstx#)+abs(dsty#*dsty#)+abs(dstz#*dstz#))
     if dst#<>0
      x#=x1#+dstx# : x2#=x#
      y#=y1#+dsty# : y2#=y#
      z#=z1#+dstz# : z2#=z#
      tbullethitstatic=1 : tbullethit=1
      tcolmaterial=0 : tbullethitmaterial=tcolmaterial
     endif
    endif
   else
    dst#=static raycast(x1#,y1#,z1#,x2#,y2#,z2#)
    if dst#<>0
     x#=checklist fvalue a(6) : x2#=x#
     y#=checklist fvalue b(6) : y2#=y#
     z#=checklist fvalue c(6) : z2#=z#
     tbullethitstatic=1 : tbullethit=1
     tcolmaterial=get static collision value()-1
     if tcolmaterial>=0 and tcolmaterial<=99 then tbullethitmaterial=tcolmaterial
    endif
   endif
   `
   rem if it hits player before wall, hurt player
   if entityelement(e).actualtarget=1
    dst#=intersect object(hudbankoffset+2,x1#,y1#,z1#,x2#,y2#,z2#)
    if dst#<>0 or tdd#<125.0
     tbullethitstatic=0
    endif
   endif
   `
   rem where wall not hit, must be a hit
   if tbullethitstatic=0
    trange#=gun(tgunid).settings.range
    tperc#=(trange#-dst#)/trange#
    if dst#<200 then tperc#=1.0
    bulletdamage#=gun(tgunid).settings.damage : dec bulletdamage#,rnd(bulletdamage#/5)
    if gun(tgunid).settings.damage>5
     rem enemy fire always one half the players effectiveness after first few points
     tperc#=tperc#*0.5
    endif
    tdamage#=bulletdamage#*tperc# : tdamage=tdamage#
    if entityelement(e).actualtarget=1
     rem player was the target
     if tdamage>0 then gosub _player_takedamage
     if player(1).health<=0
      rem hear the full sound of what killed you
      if tsndid>0
       playinternal3dsound(tsndid,camera position x(),camera position y(),camera position z())
      endif
     endif
    else
     rem entity was the target (store E while leap to other entity for damage control)
     if entityelement(e).actualtarget>1 and tdamage>0
      tdamagesource=0 : timpacttype=1
      tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
      stte=e : e=entityelement(e).actualtarget-1
      gosub _entity_deducthealth
      stgunid=gunid : gunid=tgunid
      bulletraytype=gun(gunid).settings.damagetype
      x#=x2# : y#=y2# : z#=z2# : rem destination of target is point of impact here
      useknockbackasplayershotcharacter=0
      gosub _entity_shotbygun
      gunid=stgunid
      e=stte
      tentid=entityelement(e).bankindex
      entid=entityelement(e).bankindex
     endif
    endif
    tbullethitstatic=0 : tbullethit=1
    tbullethitflesh=1
   endif
   `
   rem bullet result
   if tbullethit=1
    `x9rem debris where the bullet struck
    `for p=1 to 32
    ` if debris(p)=0
    `  rem debris where the bullet struck
    `  position particles p,x#,0,z#
    `  position particle emissions p,0,y#/20.0,0
    `  set particle emissions p,10
    `  debris(p)=40
    `  exit
    ` endif
    `next p
    `x9 rem add scorch if hit universe static polygons
    rem scorch from 50 shots too intense, do not scorch from enemy shots
    `if tbullethitstatic=1
    ` tscorchtype=gun(tgunid).settings.scorchtype
    ` gosub _entity_doscorch
    `endif    
   endif
   `
  else
   `
   rem FLAK (grenames, rockets)
   tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
   playinternal3dsound(tsndid,x1#,y1#,z1#)
   broadcast3dsound(x1#,y1#,z1#,15.0)
   `
   rem determine if need to pitch the launch based on direction and distance
   flakpitch=0
   if flak(flakid).throwangle=0
    rem LAUNCH
    tdx#=mex#-entityelement(e).x
    tdz#=mez#-entityelement(e).z
    tdy#=(mey#-50)-entityelement(e).y
    flakpitch=atanfull(tdy#,sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)))*-1
   else
    rem LOB
    if entityelement(e).actualtarget<>0
     y2#=entityelement(e).actualtargety
     if y2#>entityelement(e).y-100.0
      x2#=entityelement(e).actualtargetx
      z2#=entityelement(e).actualtargetz
      tdx#=abs(x2#-entityelement(e).x)
      tdy#=abs(y2#-entityelement(e).y)
      tdz#=abs(z2#-entityelement(e).z)
      tdd#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
      flakpitch=22.0+((45.0/500.0)*tdd#)
      if flakpitch>80 then flakpitch=80
      if flakpitch<22.0 then flakpitch=22.0
      flakpitch=flakpitch*-1.0
     endif
    endif
   endif
   `
   rem launch the flak
   flakangle=entityelement(e).mover.da : flakowner=e
   flakx=x1#+newxvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
   flaky=y1#+flak(flakid).throwheight
   flakz=z1#+newzvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
   flakspeed#=2.0
   gosub _flakelement_create
   `
  endif
  rem a pause while guns cools down (fingers of shooter release trigger and repress)
  entityelement(e).fireweapon=2
 else
  rem fired but no weapon carried
 endif
else
 if entityelement(e).fireweapon=101
  `
  rem NON-WEAPON MELEE USAGE
  rem is called at end of melee strike animation, so hurt target (allies can melee enemies too)
  `
  tdamage=entityprofile(entid).strength/5
  if tdamage=0 then tdamage=1
  if entityelement(e).actualtarget=1
   rem player was the target
   if tdamage>0 then gosub _player_takedamage
   if player(1).health<=0
    rem hear the full sound of what killed you
    if tsndid>0
     playinternal3dsound(tsndid,camera position x(),camera position y(),camera position z())
    endif
   endif
  else
   rem entity was the target (store E while leap to other entity for damage control)
   if entityelement(e).actualtarget>1 and tdamage>0
    tdamagesource=0 : timpacttype=1
    tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
    stte=e : e=entityelement(e).actualtarget-1
    gosub _entity_deducthealth
    e=stte
   endif
  endif
  `  
  rem completed melee strike, withdraw arm ready to hit again (cool down)
  entityelement(e).fireweapon=102
  `
 else
  `
  rem WEAPON COOL DOWN
  if entityelement(e).fireweapon>0 and entityelement(e).fireweapon<100
   if entityelement(e).fireweapon>0
    tgunid=entityelement(e).currentweapon
    entityelement(e).fireweapon=entityelement(e).fireweapon+1
    if gun(tgunid).action.automatic.s>0
     if entityelement(e).currentammo<=0 and entityelement(e).firesoundloop>0
      stop sound entityelement(e).firesoundloop
      entityelement(e).firesoundloop=0
     endif
     if entityelement(e).fireweapon>6
      entityelement(e).fireweapon=0
     endif
    else
     if entityelement(e).fireweapon>30 then entityelement(e).fireweapon=0
    endif
   endif
  endif
  `
  rem MELEE COOL DOWN
  if entityelement(e).fireweapon>100 and entityelement(e).fireweapon<200
   entityelement(e).fireweapon=entityelement(e).fireweapon+1
   if entityelement(e).fireweapon>130 then entityelement(e).fireweapon=0
  endif  
  `
 endif
endif
`
rem If firing over, but fire loop still going, stop it
if entityelement(e).fireweapon=0
 if entityelement(e).firesoundloop>0
  stop sound entityelement(e).firesoundloop
  entityelement(e).firesoundloop=0
 endif
endif
`
rem Switch to FPI AI Scripts
if trundefaultscript>0
 `
 rem About to leave main?
 tleavingmain=0
 if entityelement(e).ai.libindex=entityelement(e).ai.libmain then tleavingmain=1
 `
 rem Switch to specified AI scripts
 entityelement(e).ai.libindex=trundefaultscript-1
 trundefaultscript=0
 `
 rem If returning from internal AI switch
 if entityelement(e).ai.usinginternalai=1
  rem restore old state values
  entityelement(e).ai.waypoint.state=entityelement(e).ai.oldwaypointstate
  entityelement(e).ai.alphafade=entityelement(e).ai.oldalphafade
  entityelement(e).ai.state=entityelement(e).ai.oldstate
  entityelement(e).ai.usinginternalai=0
 else
  if trundefaultscriptinternal=1 and tleavingmain=1
   gosub _entity_storemainai
  endif
  entityelement(e).ai.waypoint.state=0
  entityelement(e).ai.state=0
 endif
 `
 rem Always reset these after AI script switch
 entityelement(e).ai.headdestangle=0
 entityelement(e).ai.headangle=0
 `
endif

return

_entity_doscorch:
 rem material damage
 if tbullethitmaterial>0
  tscorchsize2#=4.0+(rnd(10)/10.0) : tscorchtype2=11+tbullethitmaterial
  if tscorchtype2>15 then tscorchtype2=12 : rem FPSCV101 - fix
  add static scorch tscorchsize2#,tscorchtype2
 endif
 if tbullethitflesh>0
  rem blood splat
  tscorchtype3=8+rnd(3)
  tscorchsize3#=10.0+((tbullethitflesh/100.0)*(20.0+rnd(20)))
  add static scorch tscorchsize3#,tscorchtype3
 else
  rem bullethole
  tscorchsize#=2.0+(rnd(10)/10.0)
  if tscorchtype>=2 then tscorchsize#=3.0+(rnd(10)/10.0)
  add static scorch tscorchsize#,tscorchtype
 endif
return

_entity_controlspawn:

rem Only leaders control spawn events (activated is automatic for spawn switch on)
if entityelement(e).spawn.leader=1 and entityelement(e).spawn.atstart=0 and entityelement(e).activated=1 then entityelement(e).spawn.atstart=1
if entityelement(e).spawn.leader=1 and entityelement(e).spawn.atstart=1
 rem Count down to next spawn
 if entityelement(e).spawn.afterdelay=1
  entityelement(e).spawn.leadercount=entityelement(e).spawn.leadercount-1
 endif
 rem If count goes to zero (and have some left 'upto')
 tpermitaspawn=0
 if entityelement(e).spawn.upto>0
  if entityelement(e).spawn.leadercount<=0 then tpermitaspawn=1
  if entityelement(e).spawn.whendead=1
   for te=1+e to e+entityelement(e).spawn.max
    tobj=entityelement(te).obj
    if tobj>0
     if object exist(tobj)=1 and entityelement(te).active=0
      if entityelement(te).beenkilled=1
       rem X10 and not still in ragdoll decent
       if entityelementusingode(te)<=1
        rem X10 - 101007 - flag would be reset and no allow a respawn here, so remove reset (it is not further down duting recreation)
        `entityelement(te).beenkilled=0
        tpermitaspawn=1 : exit
       endif
      endif
     endif
    endif
   next te
  endif
 endif
 rem X10 240707 - singleplrspawnfreeze used when physics tops 100,000 (prevent physics penetration via more spawning)
 if tpermitaspawn=1 and singleplrspawnfreeze=0
  rem Restart spawn cycle
  entityelement(e).spawn.leadercount=entityelement(e).spawn.delay+rnd(entityelement(e).spawn.delayrandom)
  rem Find child of this leader to spawn
  tproduceqty=0
  tnumbertospawn=entityelement(e).spawn.qty+rnd(entityelement(e).spawn.qtyrandom)
  for te=1+e to e+entityelement(e).spawn.max
   tobj=entityelement(te).obj
   if tobj>0
    if object exist(tobj)=1 and entityelement(te).active=0 and entityelementusingode(te)<=1
     `
     rem only if the entity to spawn is not still a ragdoll
     `
     rem find place not occupied if entity driven object
     if entityelement(te).eleprof.physics=0 or entityelement(te).eleprof.physics=2
      `
      tentid=entityelement(e).bankindex
      if entityprofile(tentid).ischaracter=0
       `
       rem non-characters do not deviate from spawn position
       entityelement(te).x=entityelement(e).spawn.x
       entityelement(te).y=entityelement(e).spawn.y
       entityelement(te).z=entityelement(e).spawn.z
       tokay=1
       `
      else
       `
       rem X10 suggest only spawn when spawn area free of all entities :)
       entityelement(te).x=entityelement(e).spawn.x+rnd(50)-25
       entityelement(te).y=entityelement(e).spawn.y
       entityelement(te).z=entityelement(e).spawn.z+rnd(50)-25
       tokay=1
       `
       rem X10 - 101007 - scan spawn buddies and move this spawner if someone already at origin
       tscanradius=0
       while tscanradius<360
        tcannostandhere=0
        for scane=e+1 to e+entityelement(e).spawn.max
         tscanobj=entityelement(scane).obj
         if tscanobj>0 and scane<>te
          if object exist(tscanobj)=1 and entityelement(scane).active=1
           tscandx#=entityelement(te).x-entityelement(scane).x
           tscandy#=entityelement(te).y-entityelement(scane).y
           tscandz#=entityelement(te).z-entityelement(scane).z
           tscandist#=sqrt(abs(tscandx#*tscandx#)+abs(tscandy#*tscandy#)+abs(tscandz#*tscandz#))
           if tscandist#<25
            tcannostandhere=1
           endif
          endif
         endif
        next scane
        inc tscanradius,45
        if tcannostandhere=1
         entityelement(te).x=newxvalue(entityelement(e).spawn.x,tscanradius,30.0)   
         entityelement(te).z=newzvalue(entityelement(e).spawn.z,tscanradius,30.0)   
        else
         tscanradius=370
        endif
       endwhile
       `
      endif
      `
     else
      entityelement(te).x=entityelement(e).spawn.x
      entityelement(te).y=entityelement(e).spawn.y
      entityelement(te).z=entityelement(e).spawn.z
      tokay=1
     endif
     `
     rem if space, init entity with AIINIT
     if tokay=1
      `
      entityelement(te).active=1
      entityelement(te).dormant=1
      entityelement(te).beenkilled=0 : rem X10 - 101007 - seems flag not always reset!
      entityelement(te).ai.libindex=entityelement(te).ai.libinit
      entityelement(te).ai.waypoint.state=0
      entityelement(te).ai.waypoint.tracker=0
      entityelement(te).ai.waypoint.current=0
      entityelement(te).ai.state=0
      entityelement(te).ai.headangle=0
      entityelement(te).ai.headdestangle=0
      entityelement(te).ai.usinginternalai=0
      entityelement(te).ai.oldstate=0
      entityelement(te).ai.oldwaypointstate=0
      entityelement(te).actualtarget=0
      entityelement(te).losttargetcount=0
      `
      rem X10 - V109 - 180309 - defaults to fading in spawned objects
      entityelement(te).ai.alphafade=0
      entityelement(te).ai.oldalphafade=0
      entityelement(te).ai.destalphafade=100      
      `
      entityelement(te).rx=entityelement(e).rx
      entityelement(te).ry=entityelement(e).ry
      entityelement(te).rz=entityelement(e).rz
      entityelement(te).mover.da=entityelement(e).ry
      `
      entitybreadcrumbs(te,0).x=0
      entityelement(te).mover.grav=1.0
      entityelement(te).mover.moved=0
      entityelement(te).mover.inmotion=0
      entityelement(te).mover.ix=0
      entityelement(te).force.ix=0
      entityelement(te).mover.iy=0
      entityelement(te).force.iy=0
      entityelement(te).mover.iz=0
      entityelement(te).force.iz=0
      entityelement(te).force.active=0
      entityelement(te).logiccount=0
      entityelement(te).blockedby=0
      `
      entityelement(te).delaydamagecount=0
      entityelement(te).delaydamagesource=0
      entityelement(te).delaydamage=0
      entityelement(te).delayimpact=0
      entityelement(te).delaydamagex#=0
      entityelement(te).delaydamagey#=0
      entityelement(te).delaydamagez#=0
      entityelement(te).delaydir=0
      `
      rem reset entity that reappears in game
      if entityelement(te).eleprof.strength>0
       entityelement(te).health=entityelement(e).eleprof.strength
      else
       entityelement(te).health=1
      endif
      entityelement(te).eleprof.lives=entityelement(e).eleprof.lives
      entityelement(te).shotdamage=0
      entityelement(te).shotdamagesource=0
      `
      rem clear out dake player info
      tplrid=entityelement(e).fakeplayerid
      player(tplrid).inventorymax=0
      `
      rem put weapon back in character hands
      entityelement(te).currentweapon=entityelement(e).eleprof.hasweapon
      entityelement(te).currentclipammo=9999
      entityelement(te).firesoundloop=0
      entityelement(te).currentammo=0
      entityelement(te).fireweapon=0
      `
      rem clear this so entity can fall and make a splash again
      entityelement(te).decalloop=0
      `
      rem give entity infinite or finite life
      if entityelement(e).spawn.life>0
       entityelement(te).spawn.life=timer()+(entityelement(e).spawn.life*1000)
      else
       entityelement(te).spawn.life=0
      endif
      `
      rem X10 170807 - all spawned entities are always active (otherwise distance physics all wrong)
      entityelement(te).eleprof.phyalways=1
      `
      rem X10 if entity was cloned for ragdoll, destroy it and recreate
      if entityelementwhichslot(te)=-1
       rem entitiy has no slot (clone), so destroy
       if entityelementusingode(te)>0
        gosub _physics_destroyragdoll
        entityelementusingode(te)=0
        if ragdollcountingame>0 then dec ragdollcountingame
       endif
       rem as we have to reuse the ragdoll when this respawned entity dies, we
       rem need to recreate it fully (performance drain should be negligable)
       preclonedcorpseobj=preclonedcorpseobjbase+te
       if preclonedcorpseobj=tobj
        if 1
         rem X10 - 101007 - need to reset 'preclonedcorpseobj' for new ragdoll use
         ttobj=preclonedcorpseobj : gosub _physics_destroyjustragdoll
        else
         delete object preclonedcorpseobj
         clone object preclonedcorpseobj,entitybankoffset+entid,2
         set object effect preclonedcorpseobj,gskinningforagdolleffect
         rem X10 - 251007 - ensure ragdoll corpses also use transparency (so render after sky)
         tentid=entityelement(te).bankindex
         tmintransmode=entityprofile(tentid).transparency
         if tmintransmode<2 then tmintransmode=2
         set object transparency preclonedcorpseobj,tmintransmode         
        endif
        position object preclonedcorpseobj,0,0,0
        hide object preclonedcorpseobj
       endif
       rem restore actual entity object (previously ragdoll stored 40000+)
       entityelement(te).obj=entityobjectoffset+te
       tobj=entityelement(te).obj
       rem now recreate as regular entity
       tentid=entityelement(te).bankindex
`       gosub _entity_createdynamicentityobj
      endif
      `
      rem X10 - 101007 - do not recvreate for respawn, just use old one
      attach object to static tobj
      `
      rem X10 remove physics dropped attachment when respawn (so entity can carry it again)
      tdropobj=entityelement(te).attachmentobj
      if tdropobj>0
       if phyobjele(tdropobj)=-1
        tobj=tdropobj : gosub _physics_deleteentity
        phyobjele(tdropobj)=0
       endif
      endif
      `
      rem object setting
      if entityelement(te).eleprof.physics=1 or entityelement(te).eleprof.physics=2
       ste=e : e=te : gosub _physics_switchoffe : e=ste
      endif
      tentid=entityelement(te).bankindex
      tsizey#=0 : if entityprofile(tentid).ischaracter=0 then tsizey#=object size y(tobj)/2
      position object tobj,entityelement(te).x,entityelement(te).y+tsizey#,entityelement(te).z
      set alpha mapping on tobj,entityelement(te).ai.alphafade
      rotate object tobj,0,0,0
      show object tobj
      if entityelement(te).eleprof.physics=1 or entityelement(te).eleprof.physics=2
       ste=e : stentid=entid : e=te : entid=entityelement(e).bankindex
       gosub _physics_setupewithphysics
       tvel=entityelement(e).spawn.vel+rnd(entityelement(e).spawn.velrandom)
       tangle=entityelement(e).spawn.angle+rnd(entityelement(e).spawn.anglerandom)
       gosub _physics_pushusingtvelandangle
       e=ste : entid=stentid
      endif
      `
      rem X10 - 101007 - settle physics from any previous activity
      tobj=entityelement(te).obj
      gosub _physics_stopvelocity
      `
      rem reset visuals
      entid=entityelement(te).bankindex
      rem X10 actual object may be parent slot managed
      actualobj=entityelementwhichobj(e)
      if actualobj=0 then actualobj=tobj
      if total object frames(actualobj)>0
       set object frame actualobj,0
       if entityprofile(entid).ischaracter=1
        if entityprofile(entid).animmax>=1
         teai=0 : if entityanim(entid,1).start>0 then teai=1
         tbaseframe=teai : gosub _entity_getactualframestart : tfstart=tactualframe
         tbaseframe=teai : gosub _entity_getactualframefinish : tffinish=tactualframe
         loop object actualobj,tfstart,tffinish
        else
         loop object actualobj : stop object actualobj
        endif
       endif
      endif
      `
      rem set spawned entity collision
      if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
       entityelement(te).collisionactive=0
       set object collision off tobj
      else
       entityelement(te).collisionactive=1
       set object collision on tobj
      endif
      `
      rem X10 reestablish this entity association with the AI
      if entityprofile(entityelement(te).bankindex).ischaracter=1
       aiobjid=tobj : storee=e : e=te
       gosub _aiss_createaientity
       entityelement(e).eleprof.aiss.actionmode=entityelement(e).eleprof.ex.initmode
       e=storee
      endif
      rem V110 - 080110 - ensure respawns on starting spot
      if AI Entity Exist(tobj)=1
       AI Set Entity Position tobj,entityelement(te).x,object position y(tobj),entityelement(te).z
      endif
      `
      rem write entity to viscolmap if space available, else find new place
      `x9if entityelement(te).eleprof.physics=0 or entityelement(te).eleprof.physics=2
      ` tx=entityelement(te).x/25
      ` ty=entityelement(te).y/100
      ` tz=entityelement(te).z/-25
      ` if tx>=0 and ty>=0 and tz>=0
      `  if tx<=viscolx and ty<=viscoly and tz<=viscolz
      `   viscolmap(tx,ty,tz)=te
      `  endif
      ` endif
      `endif
      `      `
      rem reduce overall UPTO count
      entityelement(e).spawn.upto=entityelement(e).spawn.upto-1
      if entityelement(e).spawn.upto<=0
       entityelement(e).spawn.upto=0
       exit
      endif
      `
      rem go to end if no more to produce
      inc tproduceqty
      if tproduceqty>=tnumbertospawn
       te=e+entityelement(e).spawn.max
       exit
      endif
      `
     endif
     `
    endif
   endif
  next te
 endif
endif

return

_entity_controlwaypoints:

rem waypoint behaviour substatesystem
if entityelement(e).ai.waypoint.state>0
 w=entityelement(e).ai.waypoint.current
 if entityelement(e).ai.waypoint.state=1
  `
  rem before set-off make sure can see destination
  tokay=0
  telex#=entityelement(e).x
  teley#=entityelement(e).y+35.0
  telez#=entityelement(e).z
  tdistx#=telex#-waypointcoord(w).x
  tdisty#=teley#-waypointcoord(w).y+35.0
  tdistz#=telez#-waypointcoord(w).z
  tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
  if tdist#<1000.0
   tmpx#=waypointcoord(w).x
   tmpy#=waypointcoord(w).y+35.0
   tmpz#=waypointcoord(w).z
   entityelement(e).raycastcount=0
   if static raycast(telex#,teley#,telez#,tmpx#,tmpy#,tmpz#)=0
    tokay=1
   endif
  endif
  `
  rem setup walk to get to next waypoint
  entityelement(e).mover.dx=waypointcoord(w).x
  entityelement(e).mover.dy=waypointcoord(w).y
  entityelement(e).mover.dz=waypointcoord(w).z
  entityelement(e).mover.moved=1
  entityelement(e).mover.run=0
  entityelement(e).ai.waypoint.state=2
  `
  rem characters animate when waypoint is followed, if alive
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1 and entityelement(e).health>0
   if entityelement(e).animdo<>entityelement(e).animset-1
    entityelement(e).animset=3
   endif
  endif
  `
 endif
 if entityelement(e).ai.waypoint.state=2
  rem walking along wayppoint
  entityelement(e).mover.dx=waypointcoord(w).x
  entityelement(e).mover.dy=waypointcoord(w).y
  entityelement(e).mover.dz=waypointcoord(w).z
  entityelement(e).mover.moved=1
  entityelement(e).mover.run=0
  tdx#=entityelement(e).mover.dx-entityelement(e).x
  tdz#=entityelement(e).mover.dz-entityelement(e).z
  entityelement(e).mover.da=atanfull(tdx#,tdz#)
  distx#=waypointcoord(w).x-entityelement(e).x
  distz#=waypointcoord(w).z-entityelement(e).z
  dist#=sqrt(abs(distx#*distx#)+abs(distz#*distz#))
  if dist#<7.0*(entityelement(e).eleprof.speed/100.0)
   rem decision on direction
   if entityelement(e).ai.waypoint.direction=1
    rem forward
    linkto=waypointcoord(w).link
    if linkto>0
     entityelement(e).ai.waypoint.state=4
    else
     if w>=waypoint(entityelement(e).ai.waypoint.tracker).finish
      entityelement(e).ai.waypoint.state=5
     else
      entityelement(e).ai.waypoint.state=3
     endif
    endif
   else
    rem backward
    linkto=waypointcoord(w).link
    if linkto>0
     entityelement(e).ai.waypoint.state=4
    else
     if w<=waypoint(entityelement(e).ai.waypoint.tracker).start
      entityelement(e).ai.waypoint.state=5
     else
      entityelement(e).ai.waypoint.state=3
     endif
    endif
   endif
   rem ensure action taken immediately
   entityelement(e).logiccount=0
  endif
 endif
 if entityelement(e).ai.waypoint.state=999
  rem internal state - wait for force to end in main AI
  if entityelement(e).ai.libindex=entityelement(e).ai.libmain
   if entityelement(e).force.active=0 and entityelement(e).ai.waypoint.tracker>0
    rem resume waypoint logic (only if alive and have waypoints)
    if entityelement(e).health>0
     entityelement(e).ai.waypoint.state=1
     entityelement(e).logiccount=0
    endif
   endif
  endif
 endif
endif

return

_entity_controlforce:

rem control force events via inertia values
if entityelement(e).force.active=1
 rem no force if entity immobile
 if entityelement(e).eleprof.isimmobile=1
  entityelement(e).force.active=0
 else
  rem degrade inertia values
  forceineffect=0
  if entityelement(e).force.ix<>0.0 then forceineffect=1 : entityelement(e).force.ix=entityelement(e).force.ix/1.1
  if entityelement(e).force.iz<>0.0 then forceineffect=1 : entityelement(e).force.iz=entityelement(e).force.iz/1.1
  rem apply gravity constant only when above ground
  entityelement(e).force.iy=entityelement(e).force.iy-1.0
  rem update entity position with inertia values if in effect
  if forceineffect=1
   rem restrict by active raycast collision
   tmpx1#=entityelement(e).x
   tmpz1#=entityelement(e).z
   tmpheight#=entityelement(e).y+40
   tnorm#=abs(entityelement(e).force.ix)+abs(entityelement(e).force.iz)
   tmpx2#=tmpx1#+entityelement(e).force.ix+((entityelement(e).force.ix/tnorm#)*20.0)
   tmpz2#=tmpz1#+entityelement(e).force.iz+((entityelement(e).force.iz/tnorm#)*20.0)
   entityelement(e).raycastcount=0
   if static raycast(tmpx1#,tmpheight#,tmpz1#,tmpx2#,tmpheight#,tmpz2#)=0
    rem move the element if no collision or collision too far away
    entityelement(e).mover.stepcount=1
    entityelement(e).mover.ix=entityelement(e).force.ix
    entityelement(e).mover.iy=entityelement(e).force.iy
    entityelement(e).mover.iz=entityelement(e).force.iz
    entityelement(e).ai.waypoint.state=999
    entityelement(e).mover.inmotion=1
   endif
   rem so small we can make them zero
   if entityprofile(entid).ischaracter=1
    rem characters regain themselves quicker
    if abs(entityelement(e).force.ix)<2 then entityelement(e).force.ix=0.0
    if abs(entityelement(e).force.iz)<2 then entityelement(e).force.iz=0.0
   else
    rem inanimate objects slide to a stop
    if abs(entityelement(e).force.ix)<0.1 then entityelement(e).force.ix=0.0
    if abs(entityelement(e).force.iz)<0.1 then entityelement(e).force.iz=0.0
   endif
  else
   entityelement(e).force.active=0
  endif
 endif
endif

return

_entity_controlanim:

rem entity with an object
if obj>0
 `
 rem X10 actual object may be parent slot managed
 actualobj=entityelementwhichobj(e)
 if actualobj=0 then actualobj=obj
 `
 rem animation and slerp handling
 if entityelement(e).animset>0
  entityelement(e).animdo=entityelement(e).animset-1
  entityelement(e).animtime=4
  entityelement(e).animset=0
  rem X10 - play frame through parentslot manager
  playframeanimset=entityelement(e).animdo : gosub _slot_playframe
  actualobj=entityelementwhichobj(e)
  if actualobj=0 then actualobj=obj
  rem X10 - play animation in parent slot immediately (and only once when parent slot created for this type of animation)
  if entityelementwhichobj(e)>0
   rem using parent slots
   if parentslotjustcreated=1
    rem go straight to loop object command
    entityelement(e).animtime=1
    parentslotjustcreated=0
   else
    rem skip loop object command (parent already doing it)
    entityelement(e).animtime=0
   endif  
  else
   rem not using parent slots
   stop object actualobj : set object interpolation actualobj,25
   tbaseframe=entityelement(e).animdo : gosub _entity_getactualframestart
   set object frame actualobj,tactualframe
   entityelement(e).animtime=4
  endif
 endif
 if entityelement(e).animdo>=0
  rem handle transition into loop anim
  if entityelement(e).animtime=1
   tbaseframe=entityelement(e).animdo : gosub _entity_getactualframestart : tfstart=tactualframe
   tbaseframe=entityelement(e).animdo : gosub _entity_getactualframefinish : tffinish=tactualframe
   rem hack as we know the anims (die anims) (multiplayer)
   if gmultiplayergame=1
    if entityelement(e).animdo=11 then entityelement(e).animonce=1
    if entityelement(e).animdo=14 then entityelement(e).animonce=1
    if entityelement(e).animdo=17 then entityelement(e).animonce=1
    if entityelement(e).animdo=20 then entityelement(e).animonce=1
   endif
   set object interpolation actualobj,100
   if entityelement(e).animonce=1
    loop object actualobj,tffinish-0.001,tffinish
    set object frame actualobj,tfstart
    entityelement(e).animonce=0
    set object speed actualobj,100
   else
    loop object actualobj,tfstart,tffinish
    if entityelement(e).animdir=1
     set object speed actualobj,-125
    else
     set object speed actualobj,125
    endif
   endif
  endif
  if entityelement(e).animtime>0 then entityelement(e).animtime=entityelement(e).animtime-1
  rem monitor any animation
  if 1
   rem downside is different entities have different speeds,
   rem but instances of the parent entity must all animate the same speed - doh!
   tbaseframe=entityelement(e).animdo
   eachanimhasmovespeed#=1.0
   entid=entityelement(e).bankindex
   if entityprofile(entid).ischaracter=1
    if entityelement(e).attachmentweapontype>0 and tbaseframe>0
     eachanimhasmovespeed#=entityanim(entid,50+tbaseframe).speed
    else
     eachanimhasmovespeed#=entityanim(entid,tbaseframe).speed
    endif
   endif
   rem copy character speed to entity (so inc frame and dec frame work same speed)
   entityelement(e).animspeed=2*eachanimhasmovespeed#
   eachcharacterhasspeed#=entityelement(e).eleprof.speed/100.0
   tanimspeednow#=200*eachanimhasmovespeed#
   tanimspeednow#=tanimspeednow#*eachcharacterhasspeed#
   tanimspeednow#=tanimspeednow#*timeelapsed#
   `trestcenter text object screen x(obj),object screen y(obj),str$(eachanimhasmovespeed#)+"+"+str$(eachcharacterhasspeed#)+" = "+str$(tanimspeednow#)
   if entityelement(e).animdir=1
    set object speed actualobj,tanimspeednow#*-1
   else
    set object speed actualobj,tanimspeednow#
   endif
  endif
 endif
 `
 rem slerp limbs back into place
 if entityelement(e).limbslerp>0
  rem x9 noew anim system
  `tlcount=0
  `for tl=0 to entityelement(e).limbslerp-1
  ` if tl>0
  `  if limb exist(entityelement(e).obj,tl)=1
  `   tlx#=limb angle x(entityelement(e).obj,tl)/1.1
  `   tly#=limb angle y(entityelement(e).obj,tl)/1.1
  `   tlz#=limb angle z(entityelement(e).obj,tl)/1.1
  `   rotate limb entityelement(e).obj,tl,tlx#,tly#,tlz#
  `   if tlx#=0 and tly#=0 and tlz#=0 then inc tlcount
  `  endif
  ` else
  `  inc tlcount
  ` endif
  `next tl
  `if tlcount>=entityelement(e).limbslerp
  entityelement(e).limbslerp=0
  `endif
 endif
 `
endif

return

_entity_makeasplash:
 `
 rem takes DECAL X Y Z, velocity#
 if waterdecalripple<>0
  ` 
  rem show splash
  decalid=splashdecalid
  decalorient=0
  decalscalemodx=100
  decalscalemody=decalscalemodx
  decalalpha=velocity# : if decalalpha>50 then decalalpha=50
  originatore=0 : gosub _decalelement_create
  `
  rem play splash sound
  tmatindex=9 : tsoundtrigger=material(tmatindex).impactid
  tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
  tsx#=decalx : tsy#=decaly : tsz#=decalz
  tvol#=velocity# : if tvol#>100 then tvol#=100
  gosub _physics_triggermaterialsound
  `
 endif
 `
return

_entity_controldecals:

rem decal effects from entity element
tindex=entityelement(e).decalindex
if tindex<>0
 if tindex<0
  decalid=abs(tindex)
 else
  decalid=entitydecal(entid,tindex-1)
 endif
 if decalid>0
  rem entityelement(e).decalmode
  rem 0-once face player
  rem 1-once keep angle
  rem 2-loop face player
  rem 3-loop keep angle
  rem 4-once face up
  rem 5-loop face up
  rem 6-character-spot-decal (at end of entity characters gun if available)
  rem new for X10
  rem 7-character-spot-newmuzzleflash (at end of entity characters gun if available)
  decalorient=0 : decalalpha=100
  decalx=entityelement(e).x : decalz=entityelement(e).z
  if entityelement(e).decalmode>=4 and entityelement(e).decalmode<=5
   decaly=entityelement(e).y+0.5
  else
   decaly=entityelement(e).y
  endif
  if entityelement(e).decalmode=1
   rem used for windows, where glass smash decal must exactly match
   if entityelement(e).obj>0
    decalx=decalx+object collision center x(entityelement(e).obj)
    decaly=decaly+object collision center y(entityelement(e).obj)
    decalz=decalz+object collision center z(entityelement(e).obj)
   endif
  endif
  if entityelement(e).decalmode=1 or entityelement(e).decalmode=3
   decalorient=1 : decalorientx#=entityelement(e).rx : decalorienty#=entityelement(e).ry : decalorientz#=entityelement(e).rz
  endif
  if entityelement(e).decalmode=4 or entityelement(e).decalmode=5
   decalorient=2
  endif
  decalscalemodx=entityelement(e).decalsizex
  decalscalemody=entityelement(e).decalsizey
  if entityelement(e).decalmode=6 or entityelement(e).decalmode=7
   if entityprofile(entid).ischaracter=1
    tobj=entityelement(e).attachmentobj
    if tobj>0
     tobjlimb=entityelement(e).attachmentobjfirespotlimb
     decalx=limb position x(tobj,tobjlimb)
     decaly=limb position y(tobj,tobjlimb)
     decalz=limb position z(tobj,tobjlimb)
     rem X10 correct by moving decal forward to 'end' of gun
     tdx#=(camera position x(playercam)-decalx)
     tdy#=(camera position y(playercam)-decaly)
     tdz#=(camera position z(playercam)-decalz)
     tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)+abs(tdy#*tdy#))
     tdx#=(tdx#/tdd#)*5.0
     tdy#=(tdy#/tdd#)*5.0
     tdz#=(tdz#/tdd#)*5.0
     decalx=decalx+tdx#
     decaly=decaly+tdy#
     decalz=decalz+tdz#
     decalscalemodx=25
     decalscalemody=25
    endif
   endif
   decalorient=3
  endif
  if entityelement(e).decalmode=0 or entityelement(e).decalmode=1 or entityelement(e).decalmode=4 or entityelement(e).decalmode=6 or entityelement(e).decalmode=7
   rem play decal once
   entityelement(e).decalindex=0
   if entityelement(e).decalmode=7
    rem X10 new 3D muzzle flash
    muzzlex#=decalx : muzzley#=decaly : muzzlez#=decalz
    muzzlerx#=0 : muzzlery#=0 : muzzlerz#=0
    tmobj=entityelement(e).attachmentobj
    rem V109 - 280109 - stopped working, replaced with entity angle variable
    `if tmobj>0
    ` if object exist(tmobj)=1
    `  muzzlerx#=object angle x(tmobj)
    `  muzzlery#=object angle y(tmobj)
    `  muzzlerz#=object angle z(tmobj)
    ` endif
    `endif
    muzzlerx#=0 : muzzlery#=entityelement(e).ry+180 : muzzlerz#=0
    muzzlegunid=entityelement(e).currentweapon
    rem work out distance from gun to target 
    muzzlelaserdistance#=300.0 : rem default if no target
    if entityelement(e).actualtarget<>0
     x2#=entityelement(e).actualtargetx
     y2#=entityelement(e).actualtargety
     z2#=entityelement(e).actualtargetz
     tdx#=abs(x2#-muzzlex#)
     tdy#=abs(y2#-muzzley#)
     tdz#=abs(z2#-muzzlez#)
     muzzlelaserdistance#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
    endif
    muzzlescale#=3 : gosub _muzzle_placeflash
   else
    rem decal for gun flash in front of character
    originatore=e : gosub _decalelement_create  
   endif
  endif
  if entityelement(e).decalmode=2 or entityelement(e).decalmode=3 or entityelement(e).decalmode=5
   rem loop decal continually recreating it
   `x9entityelement(e).decalloop=entityelement(e).decalloop+1
   `if entityelement(e).decalloop>=15
   ` entityelement(e).decalloop=0
   rem X10 _coninue code relies on frame animation coming to an end (not decalloop counter)
   currentdecald=entityelement(e).decalslotused
   originatore=e : gosub _decalelement_continue
   entityelement(e).decalslotused=currentdecald
   `endif
  endif
 endif
endif

return

_entity_controlcollision:

rem no movement if entity immobile
if entityelement(e).mover.moved=1
 if entityelement(e).eleprof.isimmobile=1
  entityelement(e).mover.moved=0
 endif
endif

rem entity has moved, collision a consideration
if entityelement(e).mover.moved=1 and entityelement(e).force.active=0
 `
 rem tragectory of entity movement
 tdx#=entityelement(e).mover.dx-entityelement(e).x
 tdy#=entityelement(e).mover.dy-entityelement(e).y
 tdz#=entityelement(e).mover.dz-entityelement(e).z
 tdist#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))+30
 `
 rem ensure projected movement is free of large entity obstacles
 dstbest#=99999.9 : dstbestfound=0
 tblockedtox=entityelement(e).mover.dx
 tblockedtoy=entityelement(e).mover.dy
 tblockedtoz=entityelement(e).mover.dz
 `
 rem if blocked, a quicker check to see if collision disabled on it
 tusethisasweneeddoorstoblock=1
 if tusethisasweneeddoorstoblock=1
  if entityelement(e).blockedby>0
   if entityelement(e).blockedtox=tblockedtox and entityelement(e).blockedtoy=tblockedtoy and entityelement(e).blockedtoz=tblockedtoz
    te=entityelement(e).blockedby
    if entityelement(te).active=0 or entityelement(te).collisionactive=0
     entityelement(e).blockedby=0
    else
     dstbestfound=te
    endif
   else
    entityelement(e).blockedby=0
   endif
  endif
  rem obstacle detection removed for V1 (speed issue)
  if entityelement(e).blockedby=0 and entitysystemdisabled=0
   rem intensive scan for solid entity obstacles
   for te=1 to entityelementlist
    if te<>e
     if entityelement(te).active=1
      if entityelement(te).obj>0 and entityelement(te).collisionactive=1
       tentid=entityelement(te).bankindex
       if entityprofile(tentid).ischaracter=0
        rem ensure only entity with DOOR characteristics are rayscanned
        if entityelement(te).editorfixed<>0
         dst#=intersect object(entityelement(te).obj,entityelement(e).x,entityelement(e).y+40.0,entityelement(e).z,entityelement(e).mover.dx,entityelement(e).mover.dy+40.0,entityelement(e).mover.dz)
         if dst#>0 and dst#<tdist#-30
          if dst#<dstbest# then dstbest#=dst# : dstbestfound=te
         endif
        endif
       endif
      endif
     endif
    endif
   next te
   if dstbestfound>0
    rem if collide with close entity, recalc distance to move so we just touch it
    entityelement(e).blockedby=dstbestfound
    entityelement(e).blockedtox=tblockedtox
    entityelement(e).blockedtoy=tblockedtoy
    entityelement(e).blockedtoz=tblockedtoz
    tdist#=dstbest#-1.0 : dstbestfound=0
   endif
  endif
 endif
 `
 rem go ahead - can move or not move
 if dstbestfound=0
  `
  rem get angle from tragectory
  tda#=atanfull(tdx#,tdz#)
  tstepup#=0.0
  `
  rem strafe adjusts mover angle
  if entityelement(e).mover.strafe<>0
   tda#=tda#+entityelement(e).mover.strafe
   tdistold#=tdist#
   tdist#=50.0
  endif
  `
  rem When need to slide past other things
  if entityelement(e).mover.slidevel<>0
   tda#=tda#+entityelement(e).mover.slidevel
  endif
  `
  rem strafe dist over-shot so character not in wall, reduce back to real dist
  tdist#=tdist#-30.0
  `
  rem speed calc using timestamp
  tspeed#=tdist# : if tspeed#>3.0 then tspeed#=3.0
  `
  rem calculate mover inertias for per-cycle movement
  entityelement(e).mover.ix=newxvalue(0,tda#,tspeed#)
  entityelement(e).mover.iz=newzvalue(0,tda#,tspeed#)
  if entityelement(e).nogravity=1
   entityelement(e).mover.iy=tdy#/(tdist#/tspeed#)
  else
   entityelement(e).mover.iy=0.0
  endif
  if tdist#<1.0
   entityelement(e).mover.stepcount=0
  else
   entityelement(e).mover.stepcount=tdist#/tspeed#
  endif
  entityelement(e).mover.inmotion=1
  `
 else
  `
  rem if blocked, losing target
  entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
  `
 endif
 `
 rem checks over
 entityelement(e).mover.moved=0
 `
endif

return

_entity_move_removeref:
 tx=entityelement(e).x/25 : ttryx=tx
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25 : ttryz=tz
 if tx>=0 and ty>=0 and tz>=0
  if tx<=viscolx and ty<=viscoly and tz<=viscolz
   viscolmap(tx,ty,tz)=0
  endif
 endif
return

_entity_move_avoidentities:
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if ty>=0 and ty<=viscoly
  tnearest=0 : tnearestds#=9999
  for lsx=tx-2 to tx+2
   for lsz=tz-2 to tz+2
    if lsx>=0 and lsz>=0
     if lsx<=viscolx and lsz<=viscolz
      localscan=viscolmap(lsx,ty,lsz)
      if localscan>0
       rem touching entity
       tentid=entityelement(localscan).bankindex
       if entityprofile(tentid).ischaracter=1
        if entityelement(localscan).mover.inmotion=0 or e>localscan
         rem ensure this E does not enter cylinder of locally scanned E
         tldx#=entityelement(e).x-entityelement(localscan).x
         tldz#=entityelement(e).z-entityelement(localscan).z
         tlds#=sqrt(abs(tldx#*tldx#)+abs(tldz#*tldz#))
         if tlds#<36.0
          if tnearestds#>tlds# then tnearestds#=tlds# : tnearest=localscan
         endif
        endif
       endif
      endif
     endif
    endif
   next lsz
  next lsx
  if tnearest>0
   tldx#=entityelement(e).x-entityelement(tnearest).x
   tldz#=entityelement(e).z-entityelement(tnearest).z
   tlan#=atanfull(tldx#,tldz#)
   if (int(e/2.0)*2.0)=int((e/2.0)*2.0)
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel+1
    tlan#=tlan#+3
   else
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel-1
    tlan#=tlan#-3
   endif
   entityelement(e).x=newxvalue(entityelement(tnearest).x,tlan#,36.0)
   entityelement(e).z=newzvalue(entityelement(tnearest).z,tlan#,36.0)
   tavoidedentity=1
  endif
 endif
return

_entity_move_restoreref:
 rem get tile coord
 tputback=0
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 tslidearoundhole=0
 if tx>=0 and tx<=viscolx and ty>=0 and ty<=viscoly and tz>=0 and tz<=viscolz
  rem or an obstacle (entity, not player) either above or below
  if viscolmap(tx,ty,tz)>0 then tputback=1
  rem FPSCV105RC2 - added all voids as obstacles in VISCOLMAP (so characters canont run off ledges)
  if viscolmap(tx,ty,tz)=-2
   rem if following player..
   if entityelement(e).plrtrailindex>0
    rem default where character and player on same level
    rem MEY#=560
    rem entityelement(e).y=501
    if abs((mey#-59)-entityelement(e).y)<3
     rem do not allow movement if on exact same level as it is likely
     rem the player jumped or skimmed a hole, and the enemy would fall into it
     tputback=1
    else
     rem only allow movement into hole if the player is lower than entity
     rem only allow movement into higher place if the player is higher than entity
     tputback=0
    endif
    if tputback=1
     entityelement(e).losttargetcount=100
     tputback=1
    endif
   else
    rem if blocked, instantly lose target
    entityelement(e).losttargetcount=100
    tputback=1
   endif
  endif
  tryy = (entityelement(e).y+35)/100 : if tryy<=viscoly and viscolmap(tx,tryy,tz)>0 then tputback=1
  tryy = (entityelement(e).y-35)/100 : if tryy>=0 and viscolmap(tx,tryy,tz)>0 then tputback=1
 else
  tputback=1
 endif
 if tputback=1
  tkillfallingentity=0
  if entityelement(e).y<0
   rem entity left by falling off the universe, restore but remove all health and lives
   tkillfallingentity=1
  else
   rem restore by bouncing tragectory back
   if entityelement(e).mover.grav>1
    entityelement(e).mover.grav=entityelement(e).mover.grav*-1
   endif
  endif
  `  
  rem X10 if hit a hole, slide along its edge in the direction of the target
  remstart
  if tslidearoundhole=1
   rem if we reset the X, will we still hit the hole?
   storedx#=entityelement(e).x
   entityelement(e).x=toldx#
   tx=entityelement(e).x/25
   if viscolmap(tx,ty,tz)=-2
    rem no, so try using the old Z instead?
    entityelement(e).x=storedx#
    tx=entityelement(e).x/25
    entityelement(e).z=toldz#
    tz=entityelement(e).z/-25
    if viscolmap(tx,ty,tz)=-2
     rem ok, so basically tried to go into a corner, no way forward, step back
    else
     rem there is no hole here, so we use the old Z and move on!
     if entityelement(e).x<toldx#
      rem X-
      tslidearoundhole=2
     else
      rem X+
      tslidearoundhole=3
     endif
    endif    
   else
    rem there is no hole here, so we use the old X and move on!   
    if entityelement(e).z<toldz#
     rem Z-
     tslidearoundhole=4
    else
     rem Z+
     tslidearoundhole=5
    endif
   endif
   entityelement(e).x=toldx#
   entityelement(e).y=toldy#
   entityelement(e).z=toldz#
   if 1
    rem LEE, seems this slide past hole works, but enemy gets stuck at the
    rem very corner where the hole ends?? have not a clue why!!
    rem so use STRAFE trigger (losttarget for now)
    entityelement(e).losttargetcount=100
   else
    if tslidearoundhole=2 then entityelement(e).x=entityelement(e).x-1
    if tslidearoundhole=3 then entityelement(e).x=entityelement(e).x+1
    if tslidearoundhole=4 then entityelement(e).z=entityelement(e).z-1
    if tslidearoundhole=5 then entityelement(e).z=entityelement(e).z+1
    tx=entityelement(e).x/25
    ty=entityelement(e).y/100
    tz=entityelement(e).z/-25
    rem final check, if somehow in hole, use OLD values
    if tx>=0 and tx<=viscolx and ty>=0 and ty<=viscoly and tz>=0 and tz<=viscolz
     if viscolmap(tx,ty,tz)=-2
      entityelement(e).x=toldx#
      entityelement(e).y=toldy#
      entityelement(e).z=toldz#
     endif
    endif 
   endif
  else
  remend
  entityelement(e).x=toldx#
  entityelement(e).y=toldy#
  entityelement(e).z=toldz#
  `
  entityelement(e).mover.stepcount=tstep#
  if tkillfallingentity=1 and entityelement(e).health>0
   entityelement(e).eleprof.lives=1
   entityelement(e).eleprof.strength=1
   tdamage=entityelement(e).health
   entityelement(e).health=1
   tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
   gosub _entity_deducthealth
  endif
 endif
 rem place back in viscolmap
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if tx>=0 and ty>=0 and tz>=0
  if tx<=viscolx and ty<=viscoly and tz<=viscolz
   viscolmap(tx,ty,tz)=e
  endif
 endif
return

_entity_controlmovements:
 `
 rem V109 - 040708 - only DarkAI.FPI should use DarkAI
 tshoulduseAI=0
 if lower$(right$(entityelement(e).eleprof.aimain$,10))="darkai.fpi" then tshoulduseAI=1
 `
 rem Formerly commented out but needed for old script compatibility (copied from X9(v111))
 rem uses MOVER IX IY IZ and STEPCOUNT to move entity around the scene
 if entityelement(e).eleprof.isimmobile=0 and tshoulduseAI=0
  `
  rem server controlled entities never have motion
  tstep#=entityelement(e).mover.stepcount
  if entityelement(e).servercontrolled=1
   entityelement(e).mover.inmotion=0
  endif
  `
  rem clear viscolmap data if going to move
  rem V110 - 140110 - ensures antigrav platforms using nofloorlogic are not stopped by thin air
  if entityelement(e).mover.inmotion=1 and entityelement(e).nofloorlogic=0
   gosub _entity_move_removeref
  endif
  `
  rem control position movement
  toldx#=entityelement(e).x
  toldy#=entityelement(e).y
  toldz#=entityelement(e).z
  if tstep#>0.0
   `
   rem machine-independent inertia
   tbit#=(1.0*timeelapsed#)
   if tstep#>tbit#
    rem standard paced inertia movememt
    tix#=entityelement(e).mover.ix*timeelapsed#
    tiy#=entityelement(e).mover.iy*timeelapsed#
    tiz#=entityelement(e).mover.iz*timeelapsed#
    if entityelement(e).mover.run=1 then tix#=tix#*2.0 : tiy#=tiy#*2.0 : tiz#=tiz#*2.0
    if entityelement(e).eleprof.speed<>100
     tss#=entityelement(e).eleprof.speed/100.0
     tix#=tix#*tss# : tiy#=tiy#*tss# : tiz#=tiz#*tss#
    endif
   else
    rem ensure steps are taken to the last decimal bit
    tbit#=tstep#
    tix#=entityelement(e).mover.ix*tbit#
    tiy#=entityelement(e).mover.iy*tbit#
    tiz#=entityelement(e).mover.iz*tbit#
   endif
   rem movement
   entityelement(e).x=entityelement(e).x+tix#
   entityelement(e).y=entityelement(e).y+tiy#
   entityelement(e).z=entityelement(e).z+tiz#
   entityelement(e).mover.stepcount=tstep#-tbit#
   `
  endif
  `
  rem ensure entity characters do not croud each other
  tavoidedentity=0
  if entityelement(e).mover.inmotion=1
   if entityprofile(entid).ischaracter=1
    gosub _entity_move_avoidentities
   endif
  endif
  if tavoidedentity=0
   if entityelement(e).mover.slidevel<>0
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel/1.1
    if abs(entityelement(e).mover.slidevel)<1.0
     entityelement(e).mover.slidevel=0
    endif
   endif
  endif
  `
  rem simple volume check for free-moving entities
  if entityelement(e).mover.inmotion=1
   tokay=0 : tgravitydefeated=0
   if entityelement(e).nogravity=0
    if entityelement(e).nofloorlogic=0
     rem full gravity and volume handling of entities in motion
     if entitysystemdisabled=0
      rem can be a little heavy on CPU time (any ideas to speed up?)
      entityelement(e).y=entityelement(e).y-entityelement(e).mover.grav
      if static volume(toldx#,toldy#+30,toldz#,entityelement(e).x,entityelement(e).y+30,entityelement(e).z,1.0)=1
       entityelement(e).x=toldx#+get static collision x()
       entityelement(e).y=toldy#+get static collision y()
       entityelement(e).z=toldz#+get static collision z()
       colmaterialtype=-1
       if get static collision floor()=1
        tgravitydefeated=1 : colmaterialtype=get static collision value()-1
       endif
       tokay=1
      endif
     endif
    else
     rem quick no-vertical-no-gravity handling (always floor)
     entityelement(e).y=entityelement(e).y-entityelement(e).mover.grav
     if entityelement(e).y<entityelement(e).nofloorlogic-1
      entityelement(e).y=entityelement(e).nofloorlogic-1
      tgravitydefeated=1 : colmaterialtype=-1
      tokay=1
     endif
     rem allow physics to do this - no static geom detection for v1 (speed issue)
     rem V109 - BETA11 - reactivated this as it helps nofloorlogic characters keep out of walls!
     if 1
      tdx2#=entityelement(e).x-toldx#
      tdz2#=entityelement(e).z-toldz#
      tda2#=atanfull(tdx2#,tdz2#)
      tdforex#=newxvalue(0,tda2#,30.0)
      tdforez#=newzvalue(0,tda2#,30.0)
      if static raycast(toldx#,toldy#+30,toldz#,entityelement(e).x+tdforex#,entityelement(e).y+30,entityelement(e).z+tdforez#)<>0
       entityelement(e).x=toldx#
       entityelement(e).z=toldz#
       tokay=1
      else
       rem V109 BETA11 - 130508 - check change in floor height, if so do not go there (stairs and holes)
       ttddist#=static raycast(entityelement(e).x+tdforex#,entityelement(e).y+30,entityelement(e).z+tdforez#,entityelement(e).x+tdforex#,entityelement(e).y-30,entityelement(e).z+tdforez#)
       if abs(ttddist#-30.0)>2.0
        entityelement(e).x=toldx#
        entityelement(e).z=toldz#
        tokay=1
       endif
      endif
     endif
    endif
   endif
   if tokay=1
    plrid=entityelement(e).fakeplayerid
    `V109 - 040708 - not changing structure of X10 entity data
    `if entityprofile(entid).footfallmax>0 and plrid>1
    ` rem V110 BETA5 - 080608 - manually controlled footfalls (from FPE data)
    ` manuallycontrolledfootfallframe=1
    ` if obj>0
    `  tcurrentkeyframe=object frame(obj)
    `  for q=0 to entityprofile(entid).footfallmax-1
    `   if entityfootfall(entid,q).keyframe=tcurrentkeyframe then manuallycontrolledfootfallframe=1+tcurrentkeyframe : exit
    `  next q
    `  `entitydebug$(e)="footfallmax="+str$(entityprofile(entid).footfallmax)+" obj="+str$(obj)+" manuallycontrolledfootfallframe="+str$(manuallycontrolledfootfallframe)+"/"+str$(tcurrentkeyframe)
    `  if manuallycontrolledfootfallframe>1
    `   rem make a footfall sound for the entity
    `   movement=1 : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
    `   gosub _player_playfootfall
    `   `entitydebug$(e)="footfallmax="+str$(entityprofile(entid).footfallmax)+" obj="+str$(obj)+" manuallycontrolledfootfallframe="+str$(manuallycontrolledfootfallframe)+"/"+str$(tcurrentkeyframe)+"   PING!"
    `  endif
    ` endif
    ` manuallycontrolledfootfallframe=0
    `else
     rem default - timer based footfalls
     if tstep#>0.0
      if entityelement(e).mover.run=1
       basespeed#=55
      else
       basespeed#=35
      endif
      if entityelement(e).eleprof.speed<>100
       tss#=entityelement(e).eleprof.speed/100.0
       basespeed#=basespeed#*tss#
      endif
      movement=1 : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
      if plrid>1 then gosub _player_playfootfall
     `endif
    endif
    if entityelement(e).force.active=1
     if tgravitydefeated=1
      entityelement(e).force.iy=0
     else
      entityelement(e).force.ix=0 : entityelement(e).force.iz=0
     endif
    endif
   endif
   if tgravitydefeated=1
    rem determine if fall hurt character
    if entityelement(e).y<entityelement(e).mover.gravlasty-entityelement(e).eleprof.hurtfall
     rem level substantial different from last stood on ground
     tdamage=1+((abs(entityelement(e).y-entityelement(e).mover.gravlasty)-entityelement(e).eleprof.hurtfall)/5.0)
     tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
     tdamagesource=0 : timpacttype=1
     gosub _entity_deducthealth
    endif
    rem record last ground player stood on
    entityelement(e).mover.gravlasty=entityelement(e).y
    rem restore gravity
    entityelement(e).mover.grav=1
   else
    entityelement(e).mover.grav=entityelement(e).mover.grav+1
   endif
  endif
  `
  rem if not moving (colliding), increment losttarget counter
  if entityelement(e).mover.inmotion=1
   if abs(entityelement(e).x-toldx#)+abs(entityelement(e).z-toldz#)<(1.0*timeelapsed#)
    entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
   else
    entityelement(e).losttargetcount=0
   endif
  endif
  `
  rem restore entity viscolmap data
  rem V110 - 140110 - ensures antigrav platforms using nofloorlogic are not stopped by thin air
  if entityelement(e).mover.inmotion=1 and entityelement(e).nofloorlogic=0
   gosub _entity_move_restoreref
  endif
  `
  rem if gravity stops entity, and was in motion, and no-more-moving, deactivate motion
  if entityelement(e).mover.inmotion=1
   if tgravitydefeated=1 and tstep#=0
    rem entity stops moving
    entityelement(e).mover.inmotion=0
    rem stop animation too if logic count far from resolution
    if entityprofile(entid).animmax>=1
     if entityelement(e).animdo>=1 and entityelement(e).animdo<=5
      entityelement(e).animset=1+1
     endif
    endif
   endif
  endif
  `
 endif
 `
 rem control rotation movement
 entityelement(e).ry=curveangle(entityelement(e).mover.da,entityelement(e).ry,2.0/timeelapsed#)
 `
 rem control alpha level movement
 if entityelement(e).ai.destalphafade<>entityelement(e).ai.alphafade
  if entityelement(e).ai.alphafade<entityelement(e).ai.destalphafade
   entityelement(e).ai.alphafade=entityelement(e).ai.alphafade+(10.0*timeelapsed#)
   if entityelement(e).ai.alphafade>entityelement(e).ai.destalphafade
    entityelement(e).ai.alphafade=entityelement(e).ai.destalphafade
   endif
  else
   entityelement(e).ai.alphafade=entityelement(e).ai.alphafade-(10.0*timeelapsed#)
   if entityelement(e).ai.alphafade<entityelement(e).ai.destalphafade
    entityelement(e).ai.alphafade=entityelement(e).ai.destalphafade
   endif
  endif
  entityelement(e).ai.alphafadeupdate=1
 endif
 `
 rem update animation frame of entity
 if entityelement(e).animframe<>entityelement(e).destanimframe
  tss#=1.0 : if entityelement(e).eleprof.speed<>100 then tss#=entityelement(e).eleprof.speed/100.0
  if entityelement(e).animframe<entityelement(e).destanimframe
   entityelement(e).animframe=entityelement(e).animframe+(entityelement(e).animspeed*timeelapsed#*tss#)
   if entityelement(e).animframe>entityelement(e).destanimframe
    entityelement(e).animframe=entityelement(e).destanimframe
   endif
  else
   entityelement(e).animframe=entityelement(e).animframe-(entityelement(e).animspeed*timeelapsed#*tss#)
   if entityelement(e).animframe<entityelement(e).destanimframe
    entityelement(e).animframe=entityelement(e).destanimframe
   endif
  endif
  entityelement(e).animframeupdate=1
 endif
 `
 rem make sure head rotates and can restore itself (in proportion)
 if entityelement(e).ai.headangle<>entityelement(e).ai.headdestangle
  if entityelement(e).ai.headangle<entityelement(e).ai.headdestangle
   entityelement(e).ai.headangle=entityelement(e).ai.headangle+(10*timeelapsed#)
   if entityelement(e).ai.headangle>entityelement(e).ai.headdestangle
    entityelement(e).ai.headangle=entityelement(e).ai.headdestangle
   endif
  else
   entityelement(e).ai.headangle=entityelement(e).ai.headangle-(10*timeelapsed#)
   if entityelement(e).ai.headangle<entityelement(e).ai.headdestangle
    entityelement(e).ai.headangle=entityelement(e).ai.headdestangle
   endif
  endif
 else
  rem add subtle movements in headangle
  entityelement(e).ai.headangle=curvevalue(entityelement(e).ai.headdestangle-5.0+(rnd(100)/10.0),entityelement(e).ai.headangle,3.0)
 endif
 `
return

_entity_controlattachments:

rem ensure attachments are updated and visible
tobj=entityelement(e).attachmentobj
if tobj>0
 tentid=entityelement(e).bankindex
 if object exist(tobj)=1
  if entityelement(e).beenkilled=0
   rem manual position of gun attachment 
   `x9glue object to limb tvweapobj,tobj,entityprofile(tentid).firespotlimb
   `position object tobj,0,0,0
   limbpx#=object position x(entityelement(e).obj)
   limbpy#=object position y(entityelement(e).obj)
   limbpz#=object position z(entityelement(e).obj)
   if entityelement(e).obj>0
    if object exist(entityelement(e).obj)=1
     tentid=entityelement(e).bankindex
     if entityprofile(tentid).firespotlimb>=0
      rem X10 position of entity hand where gun rests
      limbpx#=limb position x(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      limbpy#=limb position y(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      limbpz#=limb position z(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      rem V109 - 070109 - replaced limb direction with orientation (fix weapon align bug)
      `limbax#=limb direction x(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      `limbay#=limb direction y(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      `limbaz#=limb direction z(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      set object to object orientation tobj,entityelement(e).obj,entityprofile(tentid).firespotlimb,0
     endif
    endif
   endif  
   rem X10 new flag for position object which updates frame abs world matrix immediately
   rem in cases where this subroutine is called AFTER the main update() call inside the 
   rem first FASTSYNC after the main SYNC command
   `rotate object tobj,limbax#,limbay#,limbaz# `070109 - above orientation solves this
   position object tobj,limbpx#,limbpy#,limbpz#,1
  else
   rem attachment free of entity, using physics to settle in scene
  endif
  `
  rem X10 - 141107 - hide weapon if character totally invisible
  `131107 - was this : show object tobj
  if gmultiplayergame=1 and entityelement(e).ai.alphafade=0
   hide object tobj
  else
   show object tobj
  endif
  `
 endif
 
endif

return

_entity_controllighting:

rem handle entity lighintg
gosub _lighting_applyentitycolor

return

_entity_storemainai:
 `
 rem store old behaviour (for internal AI changes such as HURT)
 if entityelement(e).ai.usinginternalai=0
  entityelement(e).ai.oldwaypointstate=entityelement(e).ai.waypoint.state
  entityelement(e).ai.oldalphafade=entityelement(e).ai.alphafade
  entityelement(e).ai.oldstate=entityelement(e).ai.state
  entityelement(e).ai.usinginternalai=1
  entityelement(e).logiccount=0
 endif
 `
return

_entity_setnewai:
 rem store old behaviour
 gosub _entity_storemainai
 rem setting waypoint state to 1 causes animation to retriger on return
 if entityelement(e).health<=0
  entityelement(e).ai.oldwaypointstate=999
 else
  if entityelement(e).ai.waypoint.state>0 and entityelement(e).ai.waypoint.state<99
   entityelement(e).ai.oldwaypointstate=1
  else
   entityelement(e).ai.oldwaypointstate=0
  endif
 endif
 rem trigger entity behaviour (aifile$)
 gosub _ai_findlibindex
 entityelement(e).ai.libindex=libindex
 entityelement(e).ai.waypoint.state=0
 entityelement(e).ai.alphafade=100
 entityelement(e).ai.state=0
 rem some resets to prevent cross-code
 entityelement(e).animframe=entityelement(e).destanimframe
 entityelement(e).animtime=0
 rem ensure it is immediate
 entityelement(e).logiccount=0
return

_entity_hasbulletrayhit:
 `
 rem optimise : only entities with range of the players range (of gun)
 `
 rem bulletray is x1#,y1#,z1#,x2#,y2#,z2#=bulletrayhit,gunrange#
 brayx1#=x1# : brayy1#=y1# : brayz1#=z1#
 brayx2#=x2# : brayy2#=y2# : brayz2#=z2#
 bulletrayhit=0 : bulletrayhitdist#=0.0
 `
 rem if bullet ray passed waterlevel, create a splash at intersection
 if (brayy1#>waterlevel# and brayy2#<waterlevel#) or (brayy1#<waterlevel# and brayy2#>waterlevel#)
  `
  rem calculate intersect vector
  tbix#=brayx2#-brayx1#
  tby#=brayy1# : tbiy#=brayy2#-brayy1#
  tbz#=brayz1# : tbiz#=brayz2#-brayz1#
  trange=sqrt(abs(tbix#*tbix#)+abs(tbiz#*tbiz#))
  trange#=trange
  tbix#=tbix#/trange#
  tbiy#=tbiy#/trange#
  tbiz#=tbiz#/trange#
  tperc#=(brayy1#-waterlevel#)/abs(tbiy#)
  tbx#=brayx1#+(tbix#*tperc#)
  tby#=brayy1#+(tbiy#*tperc#)
  tbz#=brayz1#+(tbiz#*tperc#)
  `
  rem create a small splash at this point
  rem and only if water does ripple
  if waterdecalripple<>0
   `
   decalid=splashdecalid
   decalorient=0
   decalx=tbx#
   decalscalemodx=10
   decalscalemody=decalscalemodx+rnd(10)
   decaly=waterlevel#-((100-decalscalemody)/2)
   decalz=tbz#
   decalalpha=50
   originatore=0 : gosub _decalelement_create
   `
   rem play splash sound
   tmatindex=9 : tsoundtrigger=material(tmatindex).impactid
   tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
   tsx#=decalx : tsy#=decaly : tsz#=decalz
   tvol#=100.0 : gosub _physics_triggermaterialsound  
   tsoundtrigger=0
   `
   rem create a ripple at intersect point
   decalid=waterdecalripple
   decalorient=0
   decalx=tbx#
   decaly=waterlevel#+1.0
   decalz=tbz#
   decalorient=2
   decalscalemodx=25 : decalscalemody=decalscalemodx
   decalalpha=15
   originatore=0 : gosub _decalelement_create  
   `
  endif
  `
 endif
 `  
 rem go through entities
 tclosestdist#=99999.0
 tcloseste=0 : tlimbifany=-1
 for e=1 to entityelementlist
  gosub _entity_controlrecalcdist
  if dist#<gunrange# and entityelement(e).obj>0
   rem within range of gun
   `
   rem X10 - 061207 - can only shoot friends if mature rating active
   tcanshootfriends=1
   if bloodmode$="off"
    if entityelement(e).eleprof.ex.alignment<>1
     rem any none enemy character cannot be shot
     tcanshootfriends=0
    endif
   endif
   `
   rem X10 - 101007 - spawn leaders take no hits whatsoever
   if entityelement(e).active<>0 and entityelement(e).spawn.leader=0 and tcanshootfriends=1
    `
    rem if character (animated by GPU, work out general hit (faster paced target)
    dst#=0.0 : entid=entityelement(e).bankindex
    if entityprofile(entid).ischaracter=1
     if gmultiplayergame=0
      tbbase#=-25 : tbheight#=30 : if entityelement(e).crouchprofile=1 then tbheight#=10
     else
      tbbase#=0 : tbheight#=55 : if entityelement(e).crouchprofile=1 then tbheight#=35
     endif
     if (entityelement(e).collisionactive=1 and entityelement(e).invincibleactive=0) or gmultiplayergame=0
      dstx#=object position x(entityelement(e).obj)
      dsty#=object position y(entityelement(e).obj)
      dstz#=object position z(entityelement(e).obj)
      tbx#=brayx1# : tbix#=brayx2#-brayx1#
      tby#=brayy1# : tbiy#=brayy2#-brayy1#
      tbz#=brayz1# : tbiz#=brayz2#-brayz1#
      trange=sqrt(abs(tbix#*tbix#)+abs(tbiz#*tbiz#))
      trange#=trange/10.0
      tbix#=tbix#/trange#
      tbiy#=tbiy#/trange#
      tbiz#=tbiz#/trange#
      for st=1 to trange step 10
       if tbx#>=dstx#-15 and tbx#<=dstx#+15
        if tby#>=dsty#+tbbase# and tby#<=dsty#+tbheight#
         if tbz#>=dstz#-15 and tbz#<=dstz#+15
          ttbix#=tbx#-brayx1#
          ttbiy#=tby#-brayy1#
          ttbiz#=tbz#-brayz1#
          dst#=sqrt(abs(ttbix#*ttbix#)+abs(ttbiy#*ttbiy#)+abs(ttbiz#*ttbiz#))
          st=trange
          exit
         endif
        endif
       endif
       tbx#=tbx#+tbix#
       tby#=tby#+tbiy#
       tbz#=tbz#+tbiz#
      next st
     endif
    else
     rem X10 added this condition so bullets go through open doors
     if entityelement(e).collisionactive=1
      dst#=intersect object(entityelement(e).obj,brayx1#,brayy1#,brayz1#,brayx2#,brayy2#,brayz2#)
     endif
    endif
    `
    rem if intersect
    if dst#>0
     if dst#<tclosestdist#
      tclosestdist#=dst# : tcloseste=e
      tlimbifany=checklist value b(1)
     endif
    endif
    `
   endif
  endif
 next e
 `
return

_entity_completerayhit:
 `
 if tcloseste>0
  `
  rem work on closest entity hit
  e=tcloseste
  gosub _entity_controlrecalcdist
  dst#=tclosestdist#
  `
  rem work out bullet force
  distx#=brayx2#-brayx1# : disty#=brayy2#-brayy1# : distz#=brayz2#-brayz1#
  fulldst#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  x#=brayx1#+((distx#/fulldst#)*dst#)
  y#=brayy1#+((disty#/fulldst#)*dst#)
  z#=brayz1#+((distz#/fulldst#)*dst#)
  `
  rem X10 set entity to be damaged with a blast in direction of damage
  entitydamageblastaway=1+(bulletdamage*2)
  entitydamageblastawayx#=(distx#/fulldst#)
  entitydamageblastawayy#=(disty#/fulldst#)
  entitydamageblastawayz#=(distz#/fulldst#)
  `
  rem work out relative direction to throw entity from entity angle
  tdir=0
  distx#=entityelement(e).x-brayx1# : distz#=entityelement(e).z-brayz1#
  tentitya#=wrapvalue(atanfull(distx#,distz#))-wrapvalue(entityelement(e).ry)
  if tentitya#<0.0 then tentitya#=tentitya#+360.0
  if tentitya#>=360.0 then tentitya#=tentitya#-360.0
  if tentitya#>180-45 and tentitya#<180+45
   tdir=1
  else
   if tentitya#>315 or tentitya#<45
    tdir=2
   else
    if tentitya#>45 and tentitya#<180-45
     tdir=4
    else
     tdir=3
    endif
   endif
  endif
  `
  if tdir>0
   `
   rem Pierce
   if bulletraytype<>2
    `
    rem affect limb if hit
    if tlimbifany>0
     if entityelement(e).obj>0
      if object exist(entityelement(e).obj)=1
       tentid=entityelement(e).bankindex
       if entityprofile(tentid).headlimb=tlimbifany
        if limb exist(entityelement(e).obj,tlimbifany)=1
         if rnd(1)=1 then tr=6 else tr=-6
         entityelement(e).ai.headangle=tr
        endif
       endif
      endif
     endif
    endif
    `
   endif
   `
   rem if entity prone to damage deal damage to entity (based on distance)
   tentid=entityelement(e).bankindex
   tperc#=(gunrange#-dst#)/gunrange#
   if dst#<200 then tperc#=1.0
   tdamage=bulletdamage : dec tdamage,rnd(tdamage/5)
   tdamage=tdamage*tperc#
   tdamagesource=0 : timpacttype=bulletraytype
   tdamagex#=x# : tdamagey#=y# : tdamagez#=z#
   tuseentityowndecaldamage=1
   `
   rem arena game there are no knock-downs (multiplayer)
   if gmultiplayergame=1
    timpacttype=1
    tentid=entityelement(e).bankindex
    if entityprofile(tentid).ischaracter=1
     multiplayerdamagecollected=multiplayerdamagecollected+tdamage
     multiplayerdamagechar=e
    else
     gosub _entity_deducthealth
    endif
   else
    gosub _entity_deducthealth
   endif
   `
   rem report bullet hit entity
   bulletrayhitdist#=dst#
   bulletrayhit=e
   `
  endif
  `
 endif
 `
return

_entity_spherecollision:
 `
 rem go through entities
 spheree=-1
 for e=1 to entityelementlist
  if entityelement(e).active=1
   distx#=entityelement(e).x-spherex#
   disty#=entityelement(e).y-spherey#
   distz#=entityelement(e).z-spherez#
   dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
   obj=entityelement(e).obj
   if obj>0
    if dist#<object size(obj)*2
     idist#=intersect object(obj,spherex#,spherey#,spherez#,spherenx#,sphereny#,spherenz#)
     if idist#>0 and idist#<=dist#
      spheree=e : exit
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_addforcesphere:
 `
 rem optimise : only entities with range of the sphere
 `
 rem X10 do a scan to find out how many characters in blast range
 rem so we can find out the lethal radius for the number of available ragdolls
 rem reset flags
 for tte=1 to entityelementlist : entityelement(tte).editorfixed=0 : next tte
 rem how many can we kill as ragdolls this blast
 tcandeallethalcount=5-ragdollcountingame
 if tcandeallethalcount<0 then tcandeallethalcount=0
 if tcandeallethalcount>5 then tcandeallethalcount=5   
 rem go through entities and flag cloest ones
 for tfindxclosest=1 to tcandeallethalcount
  tclosest#=99999 : tclosesttte=0
  for tte=1 to entityelementlist
   if entityelement(tte).editorfixed=0
    ttentid=entityelement(tte).bankindex
    distx#=entityelement(tte).x-spherex#
    disty#=entityelement(tte).y-spherey#
    distz#=entityelement(tte).z-spherez#
    dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
    tblastradius#=400.0*sphereforce#
    if dist#<tblastradius#
     tix#=distx#/dist# : tiy#=disty#/dist# : tiz#=distz#/dist#
     tforce#=(tblastradius#-dist#)/tblastradius#
     if tforce#>0.2
      if entityprofile(ttentid).ischaracter=1
       rem this character with within blast area
       if dist#<tclosest#
        rem find closest of characters still with editorfixed=0 flag 
        tclosest#=dist# : tclosesttte=tte
       endif       
      endif
     endif
    endif
   endif
  next tte
  if tclosesttte>0
   rem this character is closest of all characters to center of sphere
   entityelement(tclosesttte).editorfixed=1
  endif
 next tfindxclosest
 `
 rem go through entities
 for tteforce=1 to entityelementlist
  rem ensure we retain loop value
  tte=tteforce
  rem if entity prone to damage
  ttentid=entityelement(tte).bankindex
  rem work out if in range of force
  distx#=entityelement(tte).x-spherex#
  disty#=entityelement(tte).y-spherey#
  distz#=entityelement(tte).z-spherez#
  dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  distfromcenter#=dist#
  tblastradius#=400.0*sphereforce#
  rem X10 if entity within sphere area, nudge the entity
  if sphereforce#=0.01
   rem special sphereforce# of 0.01 derived from force of 1/100.0
   if dist#<200.0
    if entityelement(tte).obj>0
     phyobjelenudged(entityelement(tte).obj)=2
     tblastradius#=0.0
    endif
   endif
  endif
  if dist#<tblastradius#
   rem calculate force
   tix#=distx#/dist# : tiy#=disty#/dist# : tiz#=distz#/dist#
   tforce#=(tblastradius#-dist#)/tblastradius#
   rem work out if direct or indirect damage (raycast)
   tdirectdamage=0
   if static raycast(spherex#,spherey#+5,spherez#,entityelement(tte).x,entityelement(tte).y+30,entityelement(tte).z)=0
    tdirectdamage=1
   endif
   if tdirectdamage=1
    rem add simple force to entity
    if entityelement(tte).eleprof.isimmobile=0
     rem X10 ALSO if a ragdoll, also apply force
     if entityelement(tte).eleprof.physics=1 or entityelementusingode(tte)>0
      rem apply force using physics
      todee=tte
      if disty#>-15.0
       `x9tdy#=(tiy#*todeforce#)+(0.25*todeforce#)
       todeforce#=tforce#*2000 : tdx#=tix#*todeforce# : tdz#=tiz#*todeforce#
       tdy#=(tiy#*todeforce#)+(2.5*todeforce#)
      else
       todeforce#=tforce#*1000 : tdx#=tix#*todeforce# : tdz#=tiz#*todeforce#
       tdy#=1.0 : rem no downward force (objects can get stuck)
       todeforce#=tforce#
      endif
      todefalloff#=0.0 : twithpointforce=0
      tpx#=spherex# : tpy#=spherey# : tpz#=spherez#
      gosub _physics_applyforce
     else
      rem apply regular force calc
      entityelement(tte).force.ix=entityelement(tte).force.ix+(tix#*tforce#)
      if abs(disty#)<10.0
       entityelement(tte).force.iy=entityelement(tte).force.iy+(tiy#*tforce#)+(1.5*tforce#)
      else
       entityelement(tte).force.iy=entityelement(tte).force.iy+(tiy#*tforce#)
      endif
      entityelement(tte).force.iz=entityelement(tte).force.iz+(tiz#*tforce#)
      `      
      rem for ragdoll account also for impactforce of blast
      rem impact force property is 75 is norma0 for mild blast
      `tforce#=tforce#+(0.01*(gun(gunid).settings.impactforce*gun(gunid).settings.impactforce))
      rem need true force yeild of explosion before when it is triggered (pass in..)
      `tforce#=tforce#*600 : rem force 0.0-1.0 multipled by impact force
      tforce#=tforce#*450 : rem 181007 - reduced by 50 percent to avoid stretched neck bug (rick report)
      `
      rem X10 in case this entity turns to ragdoll, store data
      entityelement(tte).force.active=1+tforce#
      entityelement(tte).force.originx=spherex#
      entityelement(tte).force.originy=spherey#
      entityelement(tte).force.originz=spherez# 
      `
     endif
     rem entity rotates to such large blast
     entityelement(tte).mover.da=atanfull(distx#*-1.0,distz#*-1.0)
    endif
   endif
   rem suggest damage to entity if strong enough force
   if tforce#>0.2
    rem indirect damage is a hugely reduced value
    if tdirectdamage=0 then tforce#=tforce#/50.0
    rem X10 direct damage is also reduced so reduce knock-on effect
    if tdirectdamage<>0 then tforce#=tforce#/10.0
    rem actual entity damage
    tdamagex#=entityelement(tte).x : tdamagey#=entityelement(tte).y : tdamagez#=entityelement(tte).z
    tdamage=tforce#*spheredamage
    tdamagesource=0 : timpacttype=3 : tdir=0
    ste=e : sttentid=tentid
    tentid=entityelement(tte).bankindex
    e=tte
    if entityprofile(tentid).ischaracter=1
     `
     rem X10 - 101207 - player explosions cannot damage allies and neutrals
     if bloodmode$="off"
      if spherecreatedby>0
       theowneroftheexplosion=spherecreatedby-10000
       if theowneroftheexplosion=0
        if entityelement(tte).eleprof.ex.alignment<>1
         tdamage=0
        endif
       endif
      endif
     endif
     `
     rem 200807 - if character a flak thrower, they can handle fringe damage
     if tdamage>0
      tgunid=entityelement(tte).currentweapon
      if gun(tgunid).settings.flakindex<>0 and distfromcenter#>entityelement(tte).eleprof.ex.attackrange/2 then tdamage=0
      if tdamage>0
       rem reapply force damage to lethal levelson bilogical lifeforms
       if gun(tgunid).settings.flakindex<>0
        rem except flak throwers who can withstand explosions better
        tdamage=tdamage*2
       else
        tdamage=tdamage*5
       endif
       rem characters can shrug off some explosion force
       if tdamage<30 then timpacttype=1
       rem only apply damage to characters if that have been flagged as killable
       if entityelement(e).editorfixed=1
        rem 210807 - this flag was set at top when we scanned character damage and number of available ragdolls
        gosub _entity_deducthealth
       endif
      endif
     endif
     `
    else
     rem 200807 - increased overall strength of all explosions
     tdamage=tdamage*2
     rem 200807 - damage can be immediate or slightly delayed (chain reaction randomness)
     if rnd(2)=0
      gosub _entity_delayeddeducthealth
     else
      gosub _entity_deducthealth
     endif
    endif
    e=ste : tentid=sttentid
    rem X10 also nudge these blasted entities
    tte=tteforce
    if tte<=array count(entityelement())
     if entityelement(tte).obj>0
      phyobjelenudged(entityelement(tte).obj)=2
     endif
    endif
   endif
  endif
 next tteforce
 `
 rem initial blast if player close
 distx#=camera position x(playercam)-spherex#
 disty#=camera position y(playercam)-spherey#
 distz#=camera position z(playercam)-spherez#
 dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
 tblastradius#=400.0*sphereforce#
 if dist#<tblastradius#
  rem damage power
  tpower#=(tblastradius#-dist#)/tblastradius#
  rem work out if direct damage or indirect
  tdirectdamage=0
  sphtx#=spherex#+((distx#/dist#)*20.0)
  sphtz#=spherez#+((distz#/dist#)*20.0)
  if static raycast(sphtx#,spherey#+2.5,sphtz#,camera position x(playercam),camera position y(playercam),camera position z(playercam))=0
   tdirectdamage=1
  endif
  if tdirectdamage=1
   rem force applied to player from blast (fly force is cumilative and bleeds into camforce)
   `X10 - 151007 - got stuck in scenery because of these values
   `camflyforcex#=camflyforcex#+((distx#/dist#)*(spheredamage*25)*tpower#)
   `camflyforcey#=camflyforcey#+((spheredamage*25)*tpower#)
   `camflyforcez#=camflyforcez#+((distz#/dist#)*(spheredamage*25)*tpower#)
   camshake#=camshake#+tdamage# : camshakedir=rnd(1)
   if abs(camshake#)>20
    if camshake#>20 then camshake#=20.0
    if camshake#<-20 then camshake#=-20.0
   endif
  endif
  if tpower#>0.2
   rem indirect damage is a hugely reduced value
   if tdirectdamage=0 then tpower#=tpower#/50.0
   rem damage to player (if strong enough force)
   tdamage#=spheredamage*tpower#
   tdamage=tdamage# : if tdamage>0 then gosub _player_takedamage
  endif
 endif
 `
return

_entity_resolveobjective:
 rem e assumed to be active=0, ie tse<>e
 tokay=0 : tleadere=entityelement(e).spawn.leaderid
 if tleadere=0
  rem instant complete - no spawn versions
  tleadere=e
  tokay=1
 else
  if entityelement(tleadere).spawn.upto=0
   tokay=1 : rem complete unless child still alive (active)
   for tse=1+tleadere to tleadere+entityelement(tleadere).spawn.max
    if tse<>e
     tsobj=entityelement(tse).obj
     if tsobj>0
      if object exist(tsobj)=1
       if entityelement(tse).active<>0
        rem entity alive
        tokay=0
       endif
      endif
     endif
    endif
   next tse
  endif
 endif
 if tokay=1
  rem handle objective
  if gamewarmupcount=0
   rem Only if game in ful swing
   mi=entityelement(tleadere).eleprof.isobjective : if mi>0 then playerobjective(mi)=1
  endif
 endif
return

_entity_delayeddeducthealth:
 `
 rem store damage to be dealt when delay runs out
 if entityelement(e).delaydamagecount=0
  entityelement(e).delaydamagecount=10
  entityelement(e).delaydamagesource=tdamagesource
  entityelement(e).delaydamage=tdamage
  entityelement(e).delayimpact=timpacttype
  entityelement(e).delaydamagex#=tdamagex#
  entityelement(e).delaydamagey#=tdamagey#
  entityelement(e).delaydamagez#=tdamagez#
  entityelement(e).delaydir=tdir
 endif
 `
return

_entity_controldelayeddamage:
 `
 rem count down to delayed damage (fuel exploding)
 if entityelement(e).delaydamagecount>0
  entityelement(e).delaydamagecount=entityelement(e).delaydamagecount-1
  if entityelement(e).delaydamagecount=0
   tdamagesource=entityelement(e).delaydamagesource
   tdamage=entityelement(e).delaydamage
   timpacttype=entityelement(e).delayimpact
   tdamagex#=entityelement(e).delaydamagex#
   tdamagey#=entityelement(e).delaydamagey#
   tdamagez#=entityelement(e).delaydamagez#
   tdir=entityelement(e).delaydir
   gosub _entity_deducthealth
  endif
 endif
 `
return

_entity_setbeenkilledflag:
 `
 rem only set this if entity strill alive (once)
 storetobj=tobj
 if entityelement(e).beenkilled=0
  `
  rem set the flag to say the entity is destroyed, frozen or ragdolled
  entityelement(e).beenkilled=1
  `
  rem X10 add score to players toll (single player)
  if gmultiplayergame=0
   `ttttentid=entityelement(e).bankindex
   `if entityprofile(ttttentid).ex.score>0
   ` player(1).score=player(1).score+entityprofile(ttttentid).ex.score
   `endif
   rem X10 - 101007 - use score value from eleprof, not original!
   if entityelement(e).eleprof.ex.score>0
    player(1).score=player(1).score+entityelement(e).eleprof.ex.score
   endif
  endif
  `
  rem X10 record time of kill so weapon can disappear later (and other things)
  entityelement(e).timekilled=timer()
  `
  rem also set the attachment to a physics object so it can fall to ground
  tdropobj=entityelement(e).attachmentobj
  if tdropobj>0
   tobj=tdropobj
   gosub _physics_applyphysicstoattachment
   gosub _physics_ensurephysicsobjvalid
   phyobjele(tobj)=-1 : rem means it will not disappear when out of screen view
  endif
  `
  rem X10 Destroy entity in AI
  gosub _aiss_destroyaientity
  `
  rem remove the shadow blob if have one
  if entityelement(e).attachmentblobobj>0
   if object exist(entityelement(e).attachmentblobobj)=1
    hide object entityelement(e).attachmentblobobj
   endif
   if object exist(entityelement(e).attachmentblobobj+1)=1
    for t=0 to 1
     hide object entityelement(e).attachmentblobobj+1+t
    next t
   endif
  endif  
  `
  rem X10 - 221007 - Stop any sound if looping while got killed
  if entityelement(e).firesoundloop>0
   if sound exist(entityelement(e).firesoundloop)=1
    stop sound entityelement(e).firesoundloop
   endif
   entityelement(e).firesoundloop=0
   entityelement(e).fireweapon=0
  endif
  `
 endif
 tobj=storetobj
 `
return

_entity_deducthealth:
 `
 rem takes TDAMAGE,TDIR and TIMPACTTYPE
 tresult=0 : tentid=entityelement(e).bankindex
 `
 rem spawn leaders take no effect whatsoever
 if entityelement(e).spawn.leader=0
 `
 rem entity damage makes a material sound
 tsoundtrigger=0 : tsoundmaterial=0
 if entityprofile(tentid).ischaracter=0 and tdamage>1
  tmatindex=entityprofile(tentid).materialindex-1
  if tmatindex>=0 and tmatindex<=gmaterialmax
   tsoundtrigger=material(tmatindex).impactid
   tsoundmaterial=1+tmatindex
   tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
   tsx#=tdamagex# : tsy#=tdamagey# : tsz#=tdamagez#
  endif
 endif
 `
 rem work out effect on health and lives
 if entityelement(e).eleprof.strength>0
  if entityelement(e).health>0 or gmultiplayergame=1
   rem multiplayer arena deals damage via server, opposed to directly to entity in single player mode
   if gmultiplayergame=1
    rem actual damage sent to server to control
    gosub _multi_dealentityedamage
   else
    rem deduct the health points (non-multiplayer only)
    entityelement(e).health=entityelement(e).health-tdamage
    entityelement(e).shotdamage=entityelement(e).shotdamage+tdamage
    entityelement(e).shotdamagesource=tdamagesource
    rem if hit, and character, give a priority to deal with AI (and duration to last the action)
    if entityprofile(tentid).ischaracter=1
     gosub _entity_stealpriorityandgivetoe
     if entityelement(e).priorityai=1
      entityelement(e).priorityduration=60
      entityelement(e).logiccount=0
     endif
    endif
   endif
   rem X10 - 270807 - can prevent explodable if explosions maxed out
   if entityelement(e).health<=0
    if entityelement(e).eleprof.explodable<>0
     gosub _part_areexplosionsmaxedout
     if tmaxedoutyes=1 then entityelement(e).health=1
    endif
   endif
   rem work out if dead or alive
   if entityelement(e).health<=0
    rem entity killed
    entityelement(e).health=0
    entityelement(e).shotdamage=0
    entityelement(e).shotdamagesource=0
    entityelement(e).eleprof.lives=entityelement(e).eleprof.lives-1
    rem if entity has more lives
    if entityelement(e).eleprof.lives>0
     rem rejuvinate entity
     entityelement(e).health=entityelement(e).eleprof.strength
     tresult=2
    else
     rem set as killed
     gosub _entity_setbeenkilledflag
     rem mission objective counter
     gosub _entity_resolveobjective
     rem dead perminantly
     tresult=3
     rem get explodable flag (0-none/1-bang/2-scorch leftover)
     texplodable=entityelement(e).eleprof.explodable
     rem remove entity from physics world
     if entityelement(e).eleprof.physics<>0
      if entityprofile(tentid).ischaracter=1 and entityprofile(tentid).noragdoll=1
       rem X10 - V109 - 130309 - but not if NORAGDOLL character, allow DESTROY script..
      else
       tobj=entityelement(e).obj
       if texplodable<>2 then phyobjremove(tobj)=1
      endif
     endif
     rem entity destruction makes a material destroy sound
     if entityprofile(tentid).ischaracter=0
      rem non-character entities made from a material?
      tmatindex=entityprofile(tentid).materialindex-1
      `if tmatindex>=0 and tmatindex<gmaterialmax : rem FPSCV101 - fix
      if tmatindex>=0 and tmatindex<=gmaterialmax
       tsoundtrigger=material(tmatindex).destroyid
       tsoundmaterial=1+tmatindex
       tsx#=tdamagex# : tsy#=tdamagey# : tsz#=tdamagez#
      endif
      rem debris from total destruction (regular physics only objects?)
      debrisshapeindex=entityprofile(tentid).debrisshapeindex
      if entityelement(e).eleprof.physics=1
       rem May shed debris..
       tobj=entityelement(e).obj
       frox#=entityelement(e).x : froy#=entityelement(e).y : froz#=entityelement(e).z
       `froa#=object angle y(tobj)
       frocopyorientfrom=tobj
       if debrisshapeindex>0
        rem place debris to explode in place of real object
        debristextureused=entityelement(e).eleprof.texdid
        if entityprofile(tentid).usetexturearrayforentity>0
         rem 200807 - if texture array, cannot use texDid, must use scorch texture
         debristextureused=0 : rem instructs fragment to use only scorch!
        endif
        debrissizex#=object size x(tobj) : debrissizey#=object size y(tobj) : debrissizez#=object size z(tobj)
        debrisexplodable=texplodable
        rem X10 apply a possible force to physics fragments (if flagged)
        if entitydamageblastaway>0
         rem debrisexplodable (0-none/1-bang/2-scorch only)
         rem new mode 3 - blast away from player using entitydamageblastaway
         debrisexplodable=3 : debrisblastaway=entitydamageblastaway
         debrisblastawayx#=entitydamageblastawayx#
         debrisblastawayy#=entitydamageblastawayy#
         debrisblastawayz#=entitydamageblastawayz#
        endif
        gosub _part_createfragment
        rem Forces object invisible (replaced by fragments)
        tobj=entityelement(e).obj
        hide object tobj
       else
        if texplodable=2 and explosionscorch<>0
         rem not quite explode, just scorch (as though internally fried)
         tobj=entityelement(e).obj
         set blend mapping on tobj, 1, explosionscorch, 3, 6
         set object transparency tobj,0
        endif
       endif
       rem May trigger explosion if entity needs one..
       if texplodable=1
        rem the visual part
        gosub _part_triggerexplosion
        rem the force part
        spheredamage=entityelement(e).eleprof.explodedamage
        spherex#=frox# : spherey#=froy# : spherez#=froz#
        sphereforce#=1.0 : gosub _entity_addforcesphere
       endif
      else
       rem obj not hidden, as phyobjectremove used
      endif
      `
     else
      rem entity character grunts in death
      tplrid=entityelement(e).fakeplayerid : tsnd=15
      tplrid=changeplrforsound(tplrid,tsnd)
      if playersound(tplrid,tsnd)>0
       `x9playinternal3dsoundfactor(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,10.0)
       playinternal3dsoundloudness(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,10.0)
      endif
     endif
    endif
    rem killing blows makes character fall!
    timpacttype=2
   else
    rem entity can sometimes shrug off a fall-over-hit
    if timpacttype=3
     rem flak reactions always thrown
     timpacttype=2
    else
     if timpacttype=2
      if entityelement(e).health>entityelement(e).eleprof.strength/2
       timpacttype=1
      else
       if rnd(3)=1 then timpacttype=1
      endif
     endif
    endif
    rem entity hurt
    tresult=1
    if entityprofile(tentid).ischaracter=1
     rem entity character grunts in hurt
     tplrid=entityelement(e).fakeplayerid : tsnd=12+rnd(2)
     tplrid=changeplrforsound(tplrid,tsnd)
     if playersound(tplrid,tsnd)>0
      playinternal3dsoundloudness(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,5.0)
     endif
     rem 020807 - characters must be alerted when they are hit for first time
     if entityelement(e).eleprof.aiss.beenhurt=0
      entityelement(e).eleprof.aiss.actionmode=1 : rem instant attack
      entityelement(e).eleprof.aiss.beenhurt=1
     endif
    endif
   endif
  endif
 else
  rem FLAK is always throwing
  if timpacttype=3 then timpacttype=2 : tresult=1
 endif
 `
 rem play and sounds that are due (entity hurt, damage, destroy)
 tvol#=100 : gosub _physics_triggermaterialsound
 `
 rem play decal only if requested (set in _entity_completerayhit)
 if tuseentityowndecaldamage=1 then tuseentityowndecaldamage=0 : gosub _decal_triggermaterialdebris
 `
 rem if character, result translates as reaction
 if tresult>0
  rem If exploded, straight to destroy script!
  if tresult=4
   aifile$=entityelement(e).eleprof.aidestroy$
   gosub _entity_setnewai
  else
   tentid=entityelement(e).bankindex
   if entityprofile(tentid).ischaracter=1 and entityprofile(tentid).animmax>0
    rem only if not already reacting
    if entityelement(e).ai.libindex=entityelement(e).ai.libmain or entityelement(e).ai.libindex=entityelement(e).ai.libshoot or tresult=3
     if entityprofile(tentid).noragdoll=1
      rem X9 'throw animation' to restore legacy behaviour    
      rem only if not already reacting
      if entityelement(e).ai.libindex=entityelement(e).ai.libmain or entityelement(e).ai.libindex=entityelement(e).ai.libshoot or tresult=3
       if timpacttype=2
        rem Blast
        aifile$="people\throwback.fpi"
        if tdir=1 then aifile$="people\throwback.fpi"
        if tdir=2 then aifile$="people\throwfore.fpi"
        if tdir=3 then aifile$="people\throwleft.fpi"
        if tdir=4 then aifile$="people\throwright.fpi"
        gosub _entity_setnewai
        rem any waypoint activity must stop right away
        entityelement(e).ai.waypoint.state=999
        entityelement(e).mover.moved=0
       endif
      endif     
     else
      rem X10 must destroy character
      if timpacttype=2
       entityelement(e).ai.waypoint.state=999
       entityelement(e).mover.moved=0
      endif
      if tresult=3
       aifile$=entityelement(e).eleprof.aidestroy$
       gosub _entity_setnewai
      endif
     endif
    endif
   else
    rem non-character reaction
    if tresult=3
     aifile$=entityelement(e).eleprof.aidestroy$
     gosub _entity_setnewai
    endif
   endif
  endif
 endif
 `
 rem spawn leaders take no effect whatsoever ENDIF
 endif
 `
 rem X10 this flag is either used, or reset after call
 entitydamageblastaway=0
 `
return

_entity_findplayerstartposition:

rem Scan present elements for player start markers
playerstartx#=0
playerstartlives=0
playerstartstrength=0
playerstarthasweapon=0
playerstarthasweaponqty=0
playerhurtfall=0
playerspeedratio#=1.25
playerscoregoal=0
playerjumpheight=-1
playerlungcapacity=-1

for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ismarker=1 and entityprofile(entid).lives>0
  rem Player Start Marker
  if playerstartx#=0 or rnd(2)=0
   playerstartx#=entityelement(e).x
   playerstarty#=entityelement(e).y
   playerstartz#=entityelement(e).z
   playerstartrx#=0
   playerstartry#=entityelement(e).ry
   playerstartlives=entityelement(e).eleprof.lives
   playerstartstrength=entityelement(e).eleprof.strength
   playerstarthasweapon=entityelement(e).eleprof.hasweapon
   playerstarthasweaponqty=entityelement(e).eleprof.quantity
   playerhurtfall=entityelement(e).eleprof.hurtfall
   playerspeedratio#=0.25+(entityelement(e).eleprof.speed/100.0)
   playerscoregoal=entityelement(e).eleprof.ex.score
   playerjumpheight=entityelement(e).eleprof.ex.jumpheight
   playerlungcapacity=entityelement(e).eleprof.ex.lungcapacity
  endif
  rem X10 - 231007 - if name changed to cam fly mode, set this flag
  if lower$(entityelement(e).eleprof.name$)="camera fly mode"
   gcameraflymode=1
  endif
 endif
next e

rem FPSCV104 - make playerspeed reasonable - RC2 - min is now zero
if playerspeedratio#<0.0 then playerspeedratio#=0.0
if playerspeedratio#>2.0 then playerspeedratio#=2.0

rem X10 - 270806 - defaults
if playerlungcapacity=-1 then playerlungcapacity=500
if playerjumpheight=-1 then playerjumpheight=50
if gmultiplayergame=1 then playerjumpheight=50

rem Minimum and Maximum jump heights
if playerjumpheight<0 then playerjumpheight=0
if playerjumpheight>100 then playerjumpheight=100

rem if checkpoint, override position
if checkpointentity<>-1
 e=checkpointentity
 rem X10 - 011007 - extra precaution against old checkpoints in new level
 if e<=array count(entityelement())
  playerstartx#=entityelement(e).x
  playerstarty#=entityelement(e).y
  playerstartz#=entityelement(e).z
  playerstartrx#=0
  playerstartry#=entityelement(e).ry
 else
  checkpointentity=-1
 endif
endif

rem Default settings
if playerstartlives=0 then playerstartlives=1
if playerstartstrength=0 then playerstartstrength=100
if playerhurtfall=0 then playerhurtfall=100
if playerspeedratio#=0.0 then playerspeedratio#=1.0

rem If from level 2 onwards, replace player start details with current-save-state
if level>1
 playerstartlives=saveplayerstate.lives
 weaponammoindex=saveplayerstate.weaponindexholding
 playerstarthasweapon=weaponslot(weaponammoindex).pref
endif

return

_entity_switchtostaticformultiplayer:
 `
 rem usually no physics as most dynamic entities are converted to static here for the construction process
 if gmultiplayergame=1
  for e=1 to entityelementlist
   if entityelement(e).staticflag=0
    entid=entityelement(e).bankindex
    if entityprofile(entid).isweapon=0 and entityprofile(entid).isammo=0 and entityprofile(entid).ischaracter=0 and entityprofile(entid).ishealth=0
     if entityelement(e).eleprof.isimmobile=1
      rem door or window
      entityelement(e).eleprof.physics=3
     else
      rem something else
      entityelement(e).staticflag=1
      entityelement(e).eleprof.physics=0
     endif
    else
     rem weapon, ammo or character, or health
     entityelement(e).eleprof.physics=0
    endif
   endif
  next e
 endif
 `
return



rem
rem Artificial Intelegence Core
rem

_ai_setkeywords:

rem Set all condition keywords
dim conword$(AICONDLAST)
conword$(AICONDNEVER)="never"
conword$(AICONDALWAYS)="always"
conword$(AICONDSTATE)="state"
conword$(AICONDRANDOM)="random"
conword$(AICONDHEALTH)="health"
conword$(AICONDHEALTHLESS)="healthless"
conword$(AICONDQUANTITY)="quantity"
conword$(AICONDSPEED)="speed"
conword$(AICONDRATEOFFIRE)="rateoffire"
conword$(AICONDPLRHEALTHLESS)="plrhealthless"
conword$(AICONDPLRHEALTHGREATER)="plrhealthgreater"
conword$(AICONDASSOCIATED)="playerassociated"
conword$(AICONDPLRDISTWITHIN)="plrdistwithin"
conword$(AICONDPLRDISTFURTHER)="plrdistfurther"
conword$(AICONDPLRALIVE)="plralive"
conword$(AICONDPLRHIGHER)="plrhigher"
conword$(AICONDPLRELEVWITHIN)="plrelevwithin"
conword$(AICONDPLRELEVFURTHER)="plrelevfurther"
conword$(AICONDANYWITHIN)="anywithin"
conword$(AICONDANYFURTHER)="anyfurther"
conword$(AICONDPLRCANBESEEN)="plrcanbeseen"
conword$(AICONDPLRCANNOTBESEEN)="plrcannotbeseen"
conword$(AICONDPLRHASKEY)="plrhaskey"
conword$(AICONDPLRUSINGACTION)="plrusingaction"
conword$(AICONDSHOTDAMAGE)="shotdamage"
conword$(AICONDIFWEAPON)="ifweapon"
conword$(AICONDCANTAKE)="cantake"
conword$(AICONDACTIVATED)="activated"
conword$(AICONDPLRWITHINZONE)="plrwithinzone"
conword$(AICONDENTITYWITHINZONE)="entitywithinzone"
conword$(AICONDPLRINGUNSIGHT)="plringunsight"
conword$(AICONDNEARACTIVATABLE)="nearactivatable"
conword$(AICONDNEWWEAPONCANBESEEN)="newweaponcanbeseen"
conword$(AICONDNOISEHEARD)="noiseheard"
conword$(AICONDANYWITHINZONE)="anywithinzone"
conword$(AICONDANYKEYWITHINZONE)="anykeywithinzone"
conword$(AICONDRAYCAST)="raycast"
conword$(AICONDRAYCASTUP)="raycastup"
conword$(AICONDRAYCASTBACK)="raycastback"
conword$(AICONDNORAYCASTUP)="noraycastup"
conword$(AICONDFRAMEATEND)="frameatend"
conword$(AICONDFRAMEATSTART)="frameatstart"
conword$(AICONDFRAMEWITHIN)="framewithin"
conword$(AICONDFRAMEBEYOND)="framebeyond"
conword$(AICONDANIMATIONOVER)="animationover"
conword$(AICONDALPHAFADEEQUAL)="alphafadeequal"
conword$(AICONDREACHTARGET)="reachtarget"
conword$(AICONDLOSETARGET)="losetarget"
conword$(AICONDHEADANGLEGREATER)="headanglegreater"
conword$(AICONDHEADANGLELESS)="headangleless"
conword$(AICONDWAYPOINTSTATE)="waypointstate"
conword$(AICONDIFMARKER)="ifmarker"
conword$(AICONDIFPLRTRAIL)="ifplrtrail"
conword$(AICONDISDARKAISEEING)="isdarkaiseeing"
conword$(AICONDISDARKAIHURT)="isdarkaihurt"
conword$(AICONDISDARKAIFIRING)="isdarkaifiring"
conword$(AICONDHUDSELECTIONMADE)="hudselectionmade"
conword$(AICONDTIMERGREATER)="timergreater"
conword$(AICONDESCAPEKEYPRESSED)="escapekeypressed"
conword$(AICONDSCANCODEKEYPRESSED)="scancodekeypressed"
conword$(AICONDHUDEDITDONE)="hudeditdone"
conword$(AICONDHUDHAVENAME)="hudhavename"
conword$(AICONDEFFECTAMBIENCELESS)="effectambienceless"
conword$(AICONDEFFECTAMBIENCEGREATER)="effectambiencegreater"
conword$(AICONDEFFECTBLOOMSIZELESS)="effectbloomsizeless"
conword$(AICONDEFFECTBLOOMSIZEGREATER)="effectbloomsizegreater"
conword$(AICONDEFFECTBLOOMSTRLESS)="effectbloomstrless"
conword$(AICONDEFFECTBLOOMSTRGREATER)="effectbloomstrgreater"
conword$(AICONDEFFECTWATERSPEEDLESS)="effectwaterspeedless"
conword$(AICONDEFFECTWATERSPEEDGREATER)="effectwaterspeedgreater"
conword$(AICONDEFFECTWATERSMOOTHLESS)="effectwatersmoothless"
conword$(AICONDEFFECTWATERSMOOTHGREATER)="effectwatersmoothgreater"
conword$(AICONDEFFECTWATERREFLECTIONLESS)="effectwaterreflectionless"
conword$(AICONDEFFECTWATERREFLECTIONGREATER)="effectwaterreflectiongreater"
conword$(AICONDEFFECTWATERREFRACTIONLESS)="effectwaterrefractionless"
conword$(AICONDEFFECTWATERREFRACTIONGREATER)="effectwaterrefractiongreater"
conword$(AICONDEFFECTWATERFRESNELLESS)="effectwaterfresnelless"
conword$(AICONDEFFECTWATERFRESNELGREATER)="effectwaterfresnelgreater"
conword$(AICONDEFFECTWATERLEVELLESS)="effectwaterlevelless"
conword$(AICONDEFFECTWATERLEVELGREATER)="effectwaterlevelgreater"
conword$(AICONDEFFECTSHADOWSTRLESS)="effectshadowstrless"
conword$(AICONDEFFECTSHADOWSTRGREATER)="effectshadowstrgreater"
conword$(AICONDEFFECTSHADOWQTYLESS)="effectshadowqtyless"
conword$(AICONDEFFECTSHADOWQTYGREATER)="effectshadowqtygreater"
conword$(AICONDEFFECTWINDOWREFRACTIONLESS)="effectwindowrefractionless"
conword$(AICONDEFFECTWINDOWREFRACTIONGREATER)="effectwindowrefractiongreater"
conword$(AICONDVOLUMEINGAMEMUSICLESS)="volumeingamemusicless"
conword$(AICONDVOLUMEINGAMEMUSICGREATER)="volumeingamemusicgreater"
conword$(AICONDVOLUMEPLAYERSOUNDSLESS)="volumeplayersoundsless"
conword$(AICONDVOLUMEPLAYERSOUNDSGREATER)="volumeplayersoundsgreater"
conword$(AICONDVOLUMEINGAMESOUNDSLESS)="volumeingamesoundsless"
conword$(AICONDVOLUMEINGAMESOUNDSGREATER)="volumeingamesoundsgreater"

rem Set all action keywords
dim actword$(AIACTLAST)
actword$(AIACTNONE)="none"
actword$(AIACTDESTROY)="destroy"
actword$(AIACTSUSPEND)="suspend"
actword$(AIACTRAGDOLL)="ragdoll"
actword$(AIACTFLOORLOGIC)="floorlogic"
actword$(AIACTNOGRAVITY)="nogravity"
actword$(AIACTSNAPSHOTMODE)="snapshotmode"
actword$(AIACTRUNFPIDEFAULT)="runfpidefault"
actword$(AIACTRUNFPI)="runfpi"
actword$(AIACTSTATE)="state"
actword$(AIACTINCSTATE)="incstate"
actword$(AIACTMOVEUP)="moveup"
actword$(AIACTMOVEFORE)="movefore"
actword$(AIACTMOVEBACK)="moveback"
actword$(AIACTRUNFORE)="runfore"
actword$(AIACTFREEZE)="freeze"
actword$(AIACTROTATEY)="rotatey"
actword$(AIACTROTATEIY)="rotateiy"
actword$(AIACTNOROTATE)="norotate"
actword$(AIACTROTATETOPLR)="rotatetoplr"
actword$(AIACTRESETHEAD)="resethead"
actword$(AIACTROTATEHEAD)="rotatehead"
actword$(AIACTROTATEHEADRANDOM)="rotateheadrandom"
actword$(AIACTFORCEBACK)="forceback"
actword$(AIACTFORCEFORE)="forcefore"
actword$(AIACTFORCELEFT)="forceleft"
actword$(AIACTFORCERIGHT)="forceright"
actword$(AIACTFORCEBOUNCE)="forcebounce"
actword$(AIACTSPINRATE)="spinrate"
actword$(AIACTFLOATRATE)="floatrate"
actword$(AIACTSETFRAME)="setframe"
actword$(AIACTINCFRAME)="incframe"
actword$(AIACTDECFRAME)="decframe"
actword$(AIACTANIMATE)="animate"
actword$(AIACTADVFRAME)="advframe"
actword$(AIACTPOSEMODE)="posemode"
actword$(AIACTPLRASS)="associateplayer"
actword$(AIACTPLRNOASS)="unassociateplayer"
actword$(AIACTPLRMOVEUP)="plrmoveup"
actword$(AIACTPLRMOVEDOWN)="plrmovedown"
actword$(AIACTPLRMOVEEAST)="plrmoveeast"
actword$(AIACTPLRMOVEWEST)="plrmovewest"
actword$(AIACTPLRMOVENORTH)="plrmovenorth"
actword$(AIACTPLRMOVESOUTH)="plrmovesouth"
actword$(AIACTPLRMOVETO)="plrmoveto"
actword$(AIACTPLRMOVEIFUSED)="plrmoveifused"
actword$(AIACTACTIVATEIFUSED)="activateifused"
actword$(AIACTACTIVATEIFUSEDNEAR)="activateifusednear"
actword$(AIACTACTIVATETARGET)="activatetarget"
actword$(AIACTACTIVATEALLINZONE)="activateallinzone"
actword$(AIACTACTIVATE)="activate"
actword$(AIACTPLRADDHEALTH)="plraddhealth"
actword$(AIACTPLRADDAIR)="plraddair"
actword$(AIACTSETTARGET)="settarget"
actword$(AIACTROTATETOTARGET)="rotatetotarget"
actword$(AIACTLOOKATTARGET)="lookattarget"
actword$(AIACTMOVETOTARGET)="movetotarget"
actword$(AIACTCOLLECTTARGET)="collecttarget"
actword$(AIACTSETTARGETNAME)="settargetname"
actword$(AIACTCHOOSESTRAFE)="choosestrafe"
actword$(AIACTSTRAFE)="strafe"
actword$(AIACTPIVOTRANDOM)="pivotrandom"
actword$(AIACTLOOKATPLR)="lookatplr"
actword$(AIACTSOUND)="plrsound"
actword$(AIACT3DSOUND)="sound"
actword$(AIACTLOOPSOUND)="loopsound"
actword$(AIACTSTOPSOUND)="stopsound"
actword$(AIACTALTTEXTURE)="alttexture"
actword$(AIACTSETALPHAFADE)="setalphafade"
actword$(AIACTINCALPHAFADE)="incalphafade"
actword$(AIACTDECALPHAFADE)="decalphafade"
actword$(AIACTRUNDECAL)="rundecal"
actword$(AIACTSHAPEDECAL)="shapedecal"
actword$(AIACTTRIGGERFORCE)="triggerforce"
actword$(AIACTWAYPOINTSTART)="waypointstart"
actword$(AIACTWAYPOINTSTOP)="waypointstop"
actword$(AIACTWAYPOINTREVERSE)="waypointreverse"
actword$(AIACTWAYPOINTNEXT)="waypointnext"
actword$(AIACTWAYPOINTPREV)="waypointprev"
actword$(AIACTWAYPOINTRANDOM)="waypointrandom"
actword$(AIACTDROPMARKER)="dropmarker"
actword$(AIACTNEXTMARKER)="nextmarker"
actword$(AIACTRESETMARKERS)="resetmarkers"
actword$(AIACTFOLLOWPLR)="followplr"
actword$(AIACTPLRTAKE)="playertake"
actword$(AIACTPLRDROP)="playerdrop"
actword$(AIACTSHOOTPLR)="shootplr"
actword$(AIACTUSEWEAPON)="useweapon"
actword$(AIACTRELOADWEAPON)="reloadweapon"
actword$(AIACTDODARKAI)="dodarkai"
actword$(AIACTDODARKAIANIM)="dodarkaianim"
actword$(AIACTCOLOFF)="coloff"
actword$(AIACTCOLON)="colon"
actword$(AIACTSPAWNON)="spawnon"
actword$(AIACTSPAWNOFF)="spawnoff"
actword$(AIACTAMBIENCE)="ambience"
actword$(AIACTAMBIENCERED)="ambiencered"
actword$(AIACTAMBIENCEGREEN)="ambiencegreen"
actword$(AIACTAMBIENCEBLUE)="ambienceblue"
actword$(AIACTFOG)="fog"
actword$(AIACTFOGRED)="fogred"
actword$(AIACTFOGGREEN)="foggreen"
actword$(AIACTFOGBLUE)="fogblue"
actword$(AIACTSKY)="sky"
actword$(AIACTSKYSCROLL)="skyscroll"
actword$(AIACTEFFECTAMBIENCE)="effectambience"
actword$(AIACTEFFECTINCAMBIENCE)="effectincambience"
actword$(AIACTEFFECTDECAMBIENCE)="effectdecambience"
actword$(AIACTEFFECTFOGRANGE)="effectfogrange"
actword$(AIACTEFFECTINCFOGRANGE)="effectincfogrange"
actword$(AIACTEFFECTDECFOGRANGE)="effectdecfogrange"
actword$(AIACTEFFECTBLOOMSIZE)="effectbloomsize"
actword$(AIACTEFFECTINCBLOOMSIZE)="effectincbloomsize"
actword$(AIACTEFFECTDECBLOOMSIZE)="effectdecbloomsize"
actword$(AIACTEFFECTBLOOMSTR)="effectbloomstr"
actword$(AIACTEFFECTINCBLOOMSTR)="effectincbloomstr"
actword$(AIACTEFFECTDECBLOOMSTR)="effectdecbloomstr"
actword$(AIACTEFFECTWATERSPEED)="effectwaterspeed"
actword$(AIACTEFFECTINCWATERSPEED)="effectincwaterspeed"
actword$(AIACTEFFECTDECWATERSPEED)="effectdecwaterspeed"
actword$(AIACTEFFECTWATERSMOOTH)="effectwatersmooth"
actword$(AIACTEFFECTINCWATERSMOOTH)="effectincwatersmooth"
actword$(AIACTEFFECTDECWATERSMOOTH)="effectdecwatersmooth"
actword$(AIACTEFFECTWATERCOLORR)="effectwatercolorr"
actword$(AIACTEFFECTWATERCOLORG)="effectwatercolorg"
actword$(AIACTEFFECTWATERCOLORB)="effectwatercolorb"
actword$(AIACTEFFECTUNDERWATERCOLORR)="effectunderwatercolorr"
actword$(AIACTEFFECTUNDERWATERCOLORG)="effectunderwatercolorg"
actword$(AIACTEFFECTUNDERWATERCOLORB)="effectunderwatercolorb"
actword$(AIACTEFFECTWATERREFLECTION)="effectwaterreflection"
actword$(AIACTEFFECTINCWATERREFLECTION)="effectincwaterreflection"
actword$(AIACTEFFECTDECWATERREFLECTION)="effectdecwaterreflection"
actword$(AIACTEFFECTWATERREFRACTION)="effectwaterrefraction"
actword$(AIACTEFFECTINCWATERREFRACTION)="effectincwaterrefraction"
actword$(AIACTEFFECTDECWATERREFRACTION)="effectdecwaterrefraction"
actword$(AIACTEFFECTWATERFRESNEL)="effectwaterfresnel"
actword$(AIACTEFFECTINCWATERFRESNEL)="effectincwaterfresnel"
actword$(AIACTEFFECTDECWATERFRESNEL)="effectdecwaterfresnel"
actword$(AIACTEFFECTWATERLEVEL)="effectwaterlevel"
actword$(AIACTEFFECTINCWATERLEVEL)="effectincwaterlevel"
actword$(AIACTEFFECTDECWATERLEVEL)="effectdecwaterlevel"
actword$(AIACTEFFECTSHADOWSTR)="effectshadowstr"
actword$(AIACTEFFECTINCSHADOWSTR)="effectincshadowstr"
actword$(AIACTEFFECTDECSHADOWSTR)="effectdecshadowstr"
actword$(AIACTEFFECTSHADOWQTY)="effectshadowqty"
actword$(AIACTEFFECTINCSHADOWQTY)="effectincshadowqty"
actword$(AIACTEFFECTDECSHADOWQTY)="effectdecshadowqty"
actword$(AIACTEFFECTWINDOWREFRACTION)="effectwindowrefraction"
actword$(AIACTEFFECTINCWINDOWREFRACTION)="effectincwindowrefraction"
actword$(AIACTEFFECTDECWINDOWREFRACTION)="effectdecwindowrefraction"
actword$(AIACTVOLUMEINGAMEMUSIC)="volumeingamemusic"
actword$(AIACTVOLUMEINCINGAMEMUSIC)="volumeincingamemusic"
actword$(AIACTVOLUMEDECINGAMEMUSIC)="volumedecingamemusic"
actword$(AIACTVOLUMEPLAYERSOUNDS)="volumeplayersounds"
actword$(AIACTVOLUMEINCPLAYERSOUNDS)="volumeincplayersounds"
actword$(AIACTVOLUMEDECPLAYERSOUNDS)="volumedecplayersounds"
actword$(AIACTVOLUMEINGAMESOUNDS)="volumeingamesounds"
actword$(AIACTVOLUMEINCINGAMESOUNDS)="volumeincingamesounds"
actword$(AIACTVOLUMEDECINGAMESOUNDS)="volumedecingamesounds"
actword$(AIACTBACKDROP)="backdrop"
actword$(AIACTMUSIC)="music"
actword$(AIACTMUSICVOLUME)="musicvolume"
actword$(AIACTSOUNDSCALE)="soundscale"
actword$(AIACTVIDEO)="video"
actword$(AIACTLIGHTON)="lighton"
actword$(AIACTLIGHTOFF)="lightoff"
actword$(AIACTLIGHTRED)="lightred"
actword$(AIACTLIGHTGREEN)="lightgreen"
actword$(AIACTLIGHTBLUE)="lightblue"
actword$(AIACTLIGHTRANGE)="lightrange"
actword$(AIACTHUDRESET)="hudreset"
actword$(AIACTHUDX)="hudx"
actword$(AIACTHUDY)="hudy"
actword$(AIACTHUDZ)="hudz"
actword$(AIACTHUDSIZEX)="hudsizex"
actword$(AIACTHUDSIZEY)="hudsizey"
actword$(AIACTHUDSIZEZ)="hudsizez"
actword$(AIACTHUDRED)="hudred"
actword$(AIACTHUDGREEN)="hudgreen"
actword$(AIACTHUDBLUE)="hudblue"
actword$(AIACTHUDIMAGE)="hudimage"
actword$(AIACTHUDIMAGEFINE)="hudimagefine"
actword$(AIACTHUDFONT)="hudfont"
actword$(AIACTHUDSIZE)="hudsize"
actword$(AIACTHUDTEXT)="hudtext"
actword$(AIACTHUDTYPE)="hudtype"
actword$(AIACTHUDHIDE)="hudhide"
actword$(AIACTHUDSHOW)="hudshow"
actword$(AIACTHUDUNSHOW)="hudunshow"
actword$(AIACTHUDNAME)="hudname"
actword$(AIACTHUDANIM)="hudanim"
actword$(AIACTHUDFADEOUT)="hudfadeout"
actword$(AIACTHUDMAKE)="hudmake"
actword$(AIACTNEWGAME)="newgame"
actword$(AIACTLOADGAME)="loadgame"
actword$(AIACTSAVEGAME)="savegame"
actword$(AIACTCONTINUEGAME)="continuegame"
actword$(AIACTQUITGAME)="quitgame"
actword$(AIACTPAUSEGAME)="pausegame"
actword$(AIACTRESUMEGAME)="resumegame"
actword$(AIACTHOSTGAME)="hostgame"
actword$(AIACTJOINGAME)="joingame"
actword$(AIACTREPEATGAME)="repeatgame"
actword$(AIACTTIMERSTART)="timerstart"
actword$(AIACTQUICKLOADGAME)="quickloadgame"
actword$(AIACTQUICKSAVEGAME)="quicksavegame"

return

_ai_reset:

rem Reset counters
actstringmax=0
conindexcount=0
aicondseqcount=0
actindexcount=0
aiactseqcount=0
hudmax=0

return

_ai_stopentsounds:
 `
 rem stop any looping sound
 if entityelement(e).firesoundloop>0 then stop sound entityelement(e).firesoundloop
 entityelement(e).firesoundloop=0
 rem and entity sounds
 if entityelement(e).soundset>0
  if sound exist(entityelement(e).soundset)=1 then stop sound entityelement(e).soundset
 endif
 if entityelement(e).soundset1>0
  if sound exist(entityelement(e).soundset1)=1 then stop sound entityelement(e).soundset1
 endif
 if entityelement(e).soundlooping>0
  if sound exist(entityelement(e).soundlooping)=1 then stop sound entityelement(e).soundlooping
  entityelement(e).soundlooping=0
 endif
 `
return

_ai_control:

rem V109 - 060209 - ensure OBJ is not used if not exist (rare bug)
if obj>0
 if object exist(obj)=0 then obj=0
endif

if aiindex>0
 `
 rem used to update timestamps if resumegame happens
 tensureentitytimestampsupdated=0
 `
 if gshowdebugtextingamestate=1
  if debugviewtog=1
   if entityelement(e).priorityai<>0 then ink rgb(255,255,255),0
   print upper$(entityelement(e).eleprof.name$)
   if entityelement(e).priorityai<>0 then ink rgb(128,255,128),0
  endif
 endif
 `
 rem Go through all triggers
 for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
  `
  rem Result of condition
  dw as DWORD : dw=0
  airesult=1
  `
  rem Process conditions in 'conindex' (all have to be true)
  aiconttimer as DWORD : aiconttimer=0
  for seq=aicond(conindex).first to aicond(conindex).last
   if gshowdebugtextingamestate=1
    if debugviewtog=1
     `if aiconditionseq(seq).type>10 or aiconttimer<>0
     if aiconditionseq(seq).type>10 or aiconttimer<>0
      if aiconttimer=0 then print " : ";
      if aiconttimer<>0 then print ", ";
      if aiconttimer=0 then aiconttimer=timer()
      print conword$(aiconditionseq(seq).type)+"("+str$(aiconditionseq(seq).valuea)+","+str$(aiconditionseq(seq).valueb)+")";
     endif
    endif
   endif
   select aiconditionseq(seq).type
    case AICONDNEVER: airesult=0 : endcase
    case AICONDALWAYS: airesult=airesult : endcase
    case AICONDSTATE:
     conda=entityelement(e).ai.state
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDRANDOM:
     conda=aiconditionseq(seq).valuea
     if rnd(conda)>0 then airesult=0
    endcase
    case AICONDHEALTH:
     conda=entityelement(e).health
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDHEALTHLESS:
     conda=entityelement(e).health
     condb=aiconditionseq(seq).valuea
     if conda>=condb then airesult=0
    endcase
    case AICONDQUANTITY:
     conda=entityelement(e).eleprof.quantity
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDSPEED:
     conda=entityelement(e).eleprof.speed
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDRATEOFFIRE:
     condb=entityelement(e).eleprof.rateoffire
     rem X10 - V109 - 110309 - old system was not timer based and reversed!
     `if condb<=0
     ` rem no fire
     ` airesult=0
     `else
     ` if condb>=100
     `  rem always fire
     ` else
     `  rem X10 - V109 - 110309 - old system was not timer based and reversed!
     `  rem leelee!!
     `  if timer()>ratetimer
     `   ratetimer=timer()+100
     `   if rnd(100-condb)>0 then airesult=0
     `  endif
     ` endif
     `endif
     if condb<=0
      rem constant fire event
     else
      if condb>=100
       rem never fires
       airesult=0
      else
       rem machine idie randomness
       if timer()>entityelement(e).eleprof.uniquetimer
        entityelement(e).eleprof.uniquetimer=timer()+33
        if rnd(100)<condb then airesult=0
       else
        rem do not fire if not got permission from random event
        airesult=0
       endif
      endif
     endif     
    endcase
    case AICONDPLRHEALTHLESS:
     conda=player(1).health
     condb=aiconditionseq(seq).valuea
     if conda>=condb then airesult=0
    endcase
    case AICONDPLRHEALTHGREATER:
     conda=player(1).health
     condb=aiconditionseq(seq).valuea
     if conda<=condb then airesult=0
    endcase
    case AICONDPLRDISTWITHIN:
     conda#=dist#
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDPLRDISTFURTHER:
     conda#=dist#
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDPLRALIVE:
     conda=player(1).health
     if conda<1 then conda=0
     if conda>1 then conda=1
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    case AICONDPLRHIGHER:
     conda#=disty#
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDPLRELEVWITHIN:
     tmpy#=(entityelement(e).y+45.0)-mey#
     conda#=atanfull(dist#,tmpy#)-90
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDPLRELEVFURTHER:
     tmpy#=(entityelement(e).y+45.0)-mey#
     conda#=atanfull(dist#,tmpy#)-90
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDANYWITHIN:
     rem X10 allows any 'mobile' entity to trigger this condition (and player)
     condb=aiconditionseq(seq).valuea
     condx1=entityelement(e).x-condb
     condy1=entityelement(e).y-condb
     condz1=entityelement(e).z+condb
     condx2=entityelement(e).x+condb
     condy2=entityelement(e).y+condb
     condz2=entityelement(e).z-condb
     condfound=0
     rem check if player within
     if gamewarmupstarttime>0 and timer()-gamewarmupstarttime>1000
      rem X10 - 131007 - only start PLR IN ZONE trigger after warm up
      if mex#>condx1 and mex#<condx2
       if mey#>condy1 and mey#<condy2
        if mez#<condz1 and mez#>condz2
         condfound=-1
        endif
       endif
      endif
     endif
     rem check compass points around entity for grid items
     tcont=(entityelement(e).y+5)/100
     if tcont<0 then tcont=0
     if tcont>19 then tcont=19
     if AI Get Undesirable Grid Space( tcont, entityelement(e).x-25, entityelement(e).z )<>0 then condfound=-1
     if AI Get Undesirable Grid Space( tcont, entityelement(e).x+25, entityelement(e).z )<>0 then condfound=-1
     if AI Get Undesirable Grid Space( tcont, entityelement(e).x, entityelement(e).z-25 )<>0 then condfound=-1
     if AI Get Undesirable Grid Space( tcont, entityelement(e).x, entityelement(e).z+25 )<>0 then condfound=-1
     rem check if other entity within
     for te=1 to entityelementlist
      if te<>e and entityelement(te).active=1 and entityelement(te).eleprof.isimmobile=0
       teentid=entityelement(te).bankindex
       if entityprofile(teentid).ismarker=0
        tokay=0
        if entityelement(te).x<condx1 then tokay=1
        if entityelement(te).y<condy1 then tokay=1
        if entityelement(te).z>condz1 then tokay=1
        if entityelement(te).x>condx2 then tokay=1
        if entityelement(te).y>condy2 then tokay=1
        if entityelement(te).z<condz2 then tokay=1
        if tokay=0
         condfound=te : exit
        endif
       endif
      endif
     next te
     if condfound=0 then airesult=0
    endcase
    case AICONDANYFURTHER:
     condb=aiconditionseq(seq).valuea
     condx1=entityelement(e).x-condb
     condy1=entityelement(e).y-condb
     condz1=entityelement(e).z+condb
     condx2=entityelement(e).x+condb
     condy2=entityelement(e).y+condb
     condz2=entityelement(e).z-condb
     condfound=0
     rem check if player within
     if gamewarmupstarttime>0 and timer()-gamewarmupstarttime>1000
      rem X10 - 131007 - only start PLR IN ZONE trigger after warm up
      if mex#>condx1 and mex#<condx2
       if mey#>condy1 and mey#<condy2
        if mez#<condz1 and mez#>condz2
         condfound=-1
        endif
       endif
      endif
     endif
     rem check compass points around entity for grid items
     tcont=(entityelement(e).y+5)/100
     if tcont<0 then tcont=0
     if tcont>19 then tcont=19
     if AI Get Undesirable Grid Space( tcont, entityelement(e).x-25, entityelement(e).z )<>0 then condfound=-1
     if AI Get Undesirable Grid Space( tcont, entityelement(e).x+25, entityelement(e).z )<>0 then condfound=-1
     if AI Get Undesirable Grid Space( tcont, entityelement(e).x, entityelement(e).z-25 )<>0 then condfound=-1
     if AI Get Undesirable Grid Space( tcont, entityelement(e).x, entityelement(e).z+25 )<>0 then condfound=-1
     rem check if other entity within     
     for te=1 to entityelementlist
      if te<>e and entityelement(te).active=1 and entityelement(te).eleprof.isimmobile=0
       teentid=entityelement(te).bankindex
       if entityprofile(teentid).ismarker=0
        tokay=0
        if entityelement(te).x<condx1 then tokay=1
        if entityelement(te).y<condy1 then tokay=1
        if entityelement(te).z>condz1 then tokay=1
        if entityelement(te).x>condx2 then tokay=1
        if entityelement(te).y>condy2 then tokay=1
        if entityelement(te).z<condz2 then tokay=1
        if tokay=0
         condfound=te : exit
        endif
       endif
      endif
     next te
     if condfound<>0 then airesult=0
    endcase
    case AICONDPLRCANBESEEN:
     if player(1).lives=0 or player(1).health=0
      airesult=0
     else
      entityelement(e).mover.viewconeused=10
      tdiffangle#=diffangle#-entityelement(e).ai.headangle
      conda#=abs(tdiffangle#-entityelement(e).mover.da)
      if conda#>180 then conda#=360-conda#
      conda#=abs(conda#)
      condb#=entityelement(e).eleprof.coneangle
      if entityelement(e).eleprof.coneangle=0 then condb#=361
      if conda#>=condb#
       airesult=0
      else
       if obj=0
        airesult=0
       else
        tmpx#=object position x(obj)
        tmpy#=object position y(obj)+20.0
        tmpz#=object position z(obj)
        tvisibility=0 : gosub _player_determinevisibility
        if tvisibility=1
         rem vertical angle of sight
         tconda#=atanfull(dist#,tmpy#-mey#)-90
         tcondb#=aiconditionseq(seq).valuea
         if tcondb#=0 then tcondb#=22
         if tconda#<tcondb# or tcondb#=-1
          inc gameperfentities2
          rem new intermitent raycast
          tokaystate=entityelement(e).raycastlaststate
          if entityelement(e).raycastcount<=0
           entityelement(e).raycastlaststate=static raycast(tmpx#,tmpy#,tmpz#,mex#,mey#,mez#)
           entityelement(e).raycastcount=15
          else
           entityelement(e).raycastcount=entityelement(e).raycastcount-1
          endif
          if tokaystate=0
           if tvisibilityifbreak>0
            if tcondb#=-1
             rem X10 if -1 specified, only true if NOT seen through glass
             airesult=0
            else
             rem must shoot transparent obstacle to player sighting!
             entityelement(e).possibletarget=1+tvisibilityifbreak
            endif
           else
            rem clean shot to player
            entityelement(e).possibletarget=1
           endif
          else
           airesult=0
          endif
         else
          airesult=0
         endif
        else
         airesult=0
        endif
       endif
      endif
     endif
    endcase
    case AICONDPLRCANNOTBESEEN:
     if player(1).lives>0 and player(1).health>0
      entityelement(e).mover.viewconeused=10
      tdiffangle#=diffangle#-entityelement(e).ai.headangle
      conda#=abs(tdiffangle#-entityelement(e).mover.da)
      if conda#>180 then conda#=360-conda#
      conda#=abs(conda#)
      condb#=entityelement(e).eleprof.coneangle
      if conda#<condb#
       if obj=0
        airesult=0
       else
        tmpx#=object position x(obj)
        tmpy#=object position y(obj)+20.0
        tmpz#=object position z(obj)
        tvisibility=0 : gosub _player_determinevisibility
        if tcondb#=-1 and tvisibilityifbreak>0 then tvisibility=0
        if tvisibility=1
         tconda#=atanfull(dist#,tmpy#-mey#)-90
         tcondb#=aiconditionseq(seq).valuea
         if tcondb#=0 then tcondb#=22
         if tconda#<tcondb#
          inc gameperfentities2
          rem new intermitent raycast
          tokaystate=entityelement(e).raycastlaststate
          if entityelement(e).raycastcount<=0
           entityelement(e).raycastlaststate=static raycast(tmpx#,tmpy#,tmpz#,mex#,mey#,mez#)
           entityelement(e).raycastcount=15
          else
           entityelement(e).raycastcount=entityelement(e).raycastcount-1
          endif
          if tokaystate=0
           airesult=0
          endif
         endif
        endif
       endif
      endif
     endif
    endcase
    case AICONDPLRHASKEY:
     gosub _entity_playerhavekey
     conda=aiconditionseq(seq).valuea
     if tokay<>conda then airesult=0
    endcase
    case AICONDPLRUSINGACTION:
     conda=aiconditionseq(seq).valuea
     condb=player(1).usingaction
     if conda<>condb then airesult=0
    endcase
    `
    case AICONDSHOTDAMAGE:
     conda=aiconditionseq(seq).valuea
     condb=entityelement(e).shotdamage
     if condb>0 and condb>conda
      entityelement(e).possibletarget=1+entityelement(e).shotdamagesource
     else
      airesult=0
     endif
     entityelement(e).shotdamage=0
     entityelement(e).shotdamagesource=0
    endcase
    case AICONDIFWEAPON:
     conda=aiconditionseq(seq).valuea
     if entityelement(e).fireweapon=0
      tokay=0 : tgunid=entityelement(e).currentweapon
      if tgunid>0
       if gun(tgunid).settings.flakindex=0
        if entityelement(e).currentammo>0 or gun(tgunid).settings.reloadqty=0
         tokay=1
        endif    
       else
        rem 200807 - if flak, report as flak [3][4]
        if gun(tgunid).weapontype=5
         rem rocket
         tokay=4
        else
         rem grenade
         tokay=3
        endif
       endif       
      else
       rem 120807 - if no weapon, report as no weapon [2]
       tokay=2
      endif
      if conda=0
       if tokay=1 or tokay=2 or tokay=3 or tokay=4
        airesult=0
       else
        rem if about to reload, and instance object, do not reload if reload still being used in slots
        animslottype=6 : gosub _slot_onlyifslotunique
        if tokay=1
         rem X10 - 270907 - but this can cause long delays while AI is waiting for a GFX
         rem slow to perform the reload animation, so give the entity some ammo instead
         rem (directly so we bypass the need to reload altogether)
         if entityprofile(entid).characterinstancingmode=1
          rem X10 - 131007 - only for instanced characters, non-instanced are clones and can reload whenever they like!
          entityelement(e).currentammo=1 : rem magic ammo!
         endif
         airesult=0
        endif
       endif
      endif
      if conda=1
       if tokay=0 or tokay=2 or tokay=3 or tokay=4 then airesult=0
      endif
      if conda=2
       if tokay<>2
        rem if got weapon, fail ifweapon=2 check
        airesult=0
       else
        rem if no weapon, IFWEAPON=2 is true when entity in range
        rem if no weapon, check distance from entity to target
        aiobjid=obj
        if object exist(aiobjid)=1
         ttargetx# = AI Get Entity Target X(aiobjid)
         ttargetz# = AI Get Entity Target Z(aiobjid)
         ttdx#=abs(entityelement(e).x-ttargetx#)
         ttdz#=abs(entityelement(e).z-ttargetz#)
         ttd#=sqrt((ttdx#*ttdx#)+abs(ttdz#*ttdz#))
         if ttd#<=65
          rem within melee attack range
          rem X10 - V110 - 190110 - after some time elapsed, reset for
          rem new melee attack (can get stuck on reload or sudden anim change)
          if entityelement(e).currentweapon=0
           if timer()-entityelement(e).eleprof.aiss.timeoflastmeleeattack>1000
            entityelement(e).currentammo=0
           endif
          endif                
          rem X10 - 071007 - if melee strike is the first HIT in this anim, ok, else false
          if entityelement(e).currentammo<>1
           rem using this variable to flag whether just 'fist' ammo or not (ok its a stretch)
           rem this value is reset back to zero when 
           entityelement(e).currentammo=1
           entityelement(e).eleprof.aiss.timeoflastmeleeattack=timer()
          else
           rem already hit once for this animation strike
           airesult=0
          endif
         else
          rem not in range, return false
          airesult=0
         endif
        else
         rem if obj not exist, false
         airesult=0
        endif
       endif
      endif
      if conda=3 or conda=4
       if (conda=3 and tokay<>3) or (conda=4 and tokay<>4)
        rem if not correct flak weapon, fail this check
        airesult=0
       else
        rem X10 - 200807 - if flak thrower too close to target, DO NOT fire!
        aiobjid=obj
        if object exist(aiobjid)=1
         ttargetx# = AI Get Entity Target X(aiobjid)
         ttargetz# = AI Get Entity Target Z(aiobjid)
         ttdx#=abs(entityelement(e).x-ttargetx#)
         ttdz#=abs(entityelement(e).z-ttargetz#)
         ttd#=sqrt((ttdx#*ttdx#)+abs(ttdz#*ttdz#))
         minattackrange#=entityelement(e).eleprof.ex.attackrange
         if ttd#<minattackrange#*0.75
          rem too close if within 75% of attack range, do not throw/launch
          airesult=0
         endif
        else
         rem if obj not exist, false
         airesult=0
        endif
       endif
      endif
     else
      airesult=0
     endif
    endcase
    case AICONDCANTAKE:
     tokay=1
     if entityprofile(entid).ishealth>0
      rem check if NEED it, single player says do not waste
      if gmultiplayergame=0
       if player(1).health>=playerstartstrength
        tokay=0
       endif
      endif
     endif
     if tokay=0 then airesult=0
    endcase
    `
    case AICONDACTIVATED:
     conda=aiconditionseq(seq).valuea
     condb=entityelement(e).activated
     if conda<>condb then airesult=0
    endcase
    case AICONDPLRWITHINZONE:
     rem X10 - 131007 - only start PLR IN ZONE trigger after warm up
     if gamewarmupstarttime=0 or timer()-gamewarmupstarttime<1000
      airesult=0
     else
      condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
      condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
      condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
      condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
      condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
      condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
      tokay=0
      if mex#<condx1 then tokay=1
      if mey#<condy1 then tokay=1
      if mez#>condz1 then tokay=1
      if mex#>condx2 then tokay=1
      if mey#>condy2 then tokay=1
      if mez#<condz2 then tokay=1
      conda=aiconditionseq(seq).valuea
      if tokay<>conda
       rem player is within zone
       mi=entityelement(e).eleprof.isobjective : if mi>0 then playerobjective(mi)=1
      else
       airesult=0
      endif
     endif
    endcase
    case AICONDENTITYWITHINZONE:
     rem If I push a crate into the trigger zone, then detect for that CRATE
     rem TODO - if find one, set it as the TARGET
    endcase
    case AICONDPLRINGUNSIGHT:
     conda#=abs(diffangle#-entityelement(e).mover.da)
     if conda#>180 then conda#=360-conda#
     conda#=abs(conda#)
     if conda#>=5 then airesult=0
    endcase
    case AICONDNEARACTIVATABLE:
     tokay=0
     for tae=1 to entityelementlist
      if entityelement(tae).active=1
       if entityelement(tae).activated=aiconditionseq(seq).valuea
        cdistx#=entityelement(tae).x-entityelement(e).x
        cdisty#=entityelement(tae).y-entityelement(e).y
        cdistz#=entityelement(tae).z-entityelement(e).z
        cdist#=sqrt(abs(cdistx#*cdistx#)+abs(cdisty#*cdisty#)+abs(cdistz#*cdistz#))
        if cdist#<70.0
         tokay=1 : entityelement(e).possibletarget=1+tae
         tae=entityelementlist+1 : exit
        endif
       endif
      endif
     next tae
     if tokay=0 then airesult=0
    endcase
    `
    case AICONDNEWWEAPONCANBESEEN:
     tentitytype=1 : gosub _entity_conescanforentity
     tplrid=entityelement(e).fakeplayerid
     if tfounde>0 and tplrid>0
      tgunbestdamage=0
      for pi=1 to player(tplrid).inventorymax
       te=playerinventory(tplrid,pi).index
       tentid=entityelement(te).bankindex
       tgunid=entityprofile(tentid).isweapon
       if tgunid>0
        if gun(tgunid).settings.damage>tgunbestdamage then tgunbestdamage=gun(tgunid).settings.damage
       endif
      next pi
      tokay=0
      tent2id=entityelement(tfounde).bankindex
      tgun2id=entityprofile(tent2id).isweapon
      if tgun2id>0
       if gun(tgun2id).settings.damage>tgunbestdamage then tokay=1
      endif
      if tokay=1 then entityelement(e).possibletarget=1+tfounde
      if tokay=0 then airesult=0
     else
      airesult=0
     endif
    endcase
    `
    case AICONDNOISEHEARD:
     if bcsoundstrength#>0
      conda=aiconditionseq(seq).valuea
      cdistx#=bcsoundx#-entityelement(e).x
      cdisty#=bcsoundy#-entityelement(e).y
      cdistz#=bcsoundz#-entityelement(e).z
      cdist#=sqrt(abs(cdistx#*cdistx#)+abs(cdisty#*cdisty#)+abs(cdistz#*cdistz#))
      if cdist#>50.0
       rem not too close (as this would be itself making the noise)
       if bcsoundstrength#*10>cdist#
        rem heard something (-1 is sound coord target)
        entityelement(e).possibletarget=-1
       else
        airesult=0
       endif
      else
       airesult=0
      endif
     else
      airesult=0
     endif
    endcase
    `
    case AICONDANYWITHINZONE:
     condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
     condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
     condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
     condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
     condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
     condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
     conda=aiconditionseq(seq).valuea
     condfound=0
     for te=1 to entityelementlist
      if te<>e and entityelement(te).active=1
       tokay=0
       if entityelement(te).x<condx1 then tokay=1
       if entityelement(te).y<condy1 then tokay=1
       if entityelement(te).z>condz1 then tokay=1
       if entityelement(te).x>condx2 then tokay=1
       if entityelement(te).y>condy2 then tokay=1
       if entityelement(te).z<condz2 then tokay=1
       if tokay=0
        condfound=te : exit
       endif
      endif
     next te
     if conda=1
      if condfound=0
       airesult=0
      endif
     else
      if condfound<>0
       airesult=0
      endif
     endif
    endcase
    case AICONDANYKEYWITHINZONE:
     condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
     condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
     condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
     condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
     condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
     condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
     conda=aiconditionseq(seq).valuea
     condfound=0
     for te=1 to entityelementlist
      if te<>e and entityelement(te).active=1
       tokay=0
       if entityelement(te).x<condx1 then tokay=1
       if entityelement(te).y<condy1 then tokay=1
       if entityelement(te).z>condz1 then tokay=1
       if entityelement(te).x>condx2 then tokay=1
       if entityelement(te).y>condy2 then tokay=1
       if entityelement(te).z<condz2 then tokay=1
       if tokay=0
        if lower$(entityelement(te).eleprof.name$)=lower$(entityelement(e).eleprof.usekey$)
         condfound=te : exit
        endif
       endif
      endif
     next te
     if conda=1
      if condfound=0
       airesult=0
      endif
     else
      if condfound<>0
       airesult=0
      endif
     endif
    endcase
    `
    case AICONDFRAMEATEND:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       condb=aiconditionseq(seq).valuea
       tbaseframe=condb : gosub _entity_getactualframefinish : condb#=tactualframe
       if conda#<condb#
        rem frame not at end yet
        airesult=0
       else
        rem yes, frame is at end
        rem X10 - 071007 - when get to frame end, melee attackers are reset so they can attack again in the future
        if entityelement(e).currentweapon=0
         rem set melee characters 'strike' flag back to zero (after the post-75% hit where this flag was set to one)
         entityelement(e).currentammo=0
        endif      
       endif
      endif
     endif
    endcase
    case AICONDFRAMEATSTART:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       condb=aiconditionseq(seq).valuea
       tbaseframe=condb : gosub _entity_getactualframestart : condb#=tactualframe
       if conda#>condb# then airesult=0
      endif
     endif
    endcase
    case AICONDFRAMEWITHIN:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       conda=aiconditionseq(seq).valuea
       condb#=aiconditionseq(seq).valueb/100.0
       tbaseframe=conda : gosub _entity_getactualframefinish : condc#=tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condc#=condc#-tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condb#=tactualframe+(condc#*condb#)
       if conda#>condb# then airesult=0
      endif
     endif
    endcase
    case AICONDFRAMEBEYOND:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       conda=aiconditionseq(seq).valuea
       condb#=aiconditionseq(seq).valueb/100.0
       tbaseframe=conda : gosub _entity_getactualframefinish : condc#=tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condc#=condc#-tactualframe
       tbaseframe=conda : gosub _entity_getactualframestart : condb#=tactualframe+(condc#*condb#)
       if conda#<condb# then airesult=0
      endif
     endif
    endcase
    case AICONDANIMATIONOVER:
     if obj=0
      airesult=0
     else
      if entityprofile(entid).animmax>0
       conda#=object frame(obj)
       condb=aiconditionseq(seq).valuea
       tbaseframe=condb : gosub _entity_getactualframefinish : condb#=tactualframe-5.0
       if conda#<condb# then airesult=0
      endif
     endif
    endcase
    `
    case AICONDREACHTARGET:
     te=entityelement(e).actualtarget-1
     if te>0
      tdistx#=entityelement(te).x-entityelement(e).x
      tdistz#=entityelement(te).z-entityelement(e).z
     else
      tdistx#=entityelement(e).actualtargetx-entityelement(e).x
      tdistz#=entityelement(e).actualtargetz-entityelement(e).z
     endif
     conda#=sqrt(abs(tdistx#*tdistx#)+abs(tdistz#*tdistz#))
     condb#=aiconditionseq(seq).valuea
     if conda#>=5.0 then airesult=0
    endcase
    case AICONDLOSETARGET:
     conda=entityelement(e).losttargetcount
     condb=aiconditionseq(seq).valuea
     if conda<condb then airesult=0
    endcase
    `
    case AICONDHEADANGLEGREATER:
     conda#=entityelement(e).ai.headangle
     condb#=aiconditionseq(seq).valuea
     if conda#<condb# then airesult=0
    endcase
    case AICONDHEADANGLELESS:
     conda#=entityelement(e).ai.headangle
     condb#=aiconditionseq(seq).valuea
     if conda#>condb# then airesult=0
    endcase
    `
    case AICONDRAYCAST:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj)
      tmpy#=object position y(obj)
      tmpz#=object position z(obj)
      tmpx1#=tmpx#
      tmpz1#=tmpz#
      tmpheight#=40
      tnorm#=abs(entityelement(e).force.ix)+abs(entityelement(e).force.iz)
      tvx#=entityelement(e).force.ix/tnorm#
      tvz#=entityelement(e).force.iz/tnorm#
      tvel#=aiconditionseq(seq).valueb
      tmpx2#=tmpx#+(tvx#*tvel#)
      tmpz2#=tmpz#+(tvz#*tvel#)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if tmpy#>-50
       if static raycast(tmpx1#,tmpy#+tmpheight#,tmpz1#,tmpx2#,tmpy#+tmpheight#,tmpz2#)=0 then airesult=0
      endif
     endif
    endcase
    case AICONDRAYCASTUP:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if tmpy#>-50
       if static raycast(tmpx#,tmpy#+aiconditionseq(seq).valuea,tmpz#,tmpx#,tmpy#+aiconditionseq(seq).valueb,tmpz#)=0 then airesult=0
      endif
     endif
    endcase
    case AICONDRAYCASTBACK:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      tmpa#=object angle y(obj) : tmpheight#=50
      conda#=aiconditionseq(seq).valuea*-1
      condb#=aiconditionseq(seq).valueb*-1
      tmpx1#=tmpx#+(sin(tmpa#)*conda#)
      tmpz1#=tmpz#+(cos(tmpa#)*conda#)
      tmpx2#=tmpx#+(sin(tmpa#)*condb#)
      tmpz2#=tmpz#+(cos(tmpa#)*condb#)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy#+tmpheight#,tmpz1#,tmpx2#,tmpy#+tmpheight#,tmpz2#)=0 then airesult=0
     endif
    endcase
    case AICONDNORAYCASTUP:
     if obj=0
      airesult=0
     else
      tmpx#=object position x(obj) : tmpy#=object position y(obj) : tmpz#=object position z(obj)
      inc gameperfentities2
      entityelement(e).raycastcount=0
      if static raycast(tmpx#,tmpy#+aiconditionseq(seq).valuea,tmpz#,tmpx#,tmpy#+aiconditionseq(seq).valueb,tmpz#)<>0 then airesult=0
      if tmpy#<-50 then airesult=0
     endif
    endcase
    case AICONDALPHAFADEEQUAL:
     conda#=entityelement(e).ai.alphafade
     condb#=aiconditionseq(seq).valuea
     if conda#<>condb# then airesult=0
    endcase
    case AICONDWAYPOINTSTATE:
     conda=entityelement(e).ai.waypoint.state
     condb=aiconditionseq(seq).valuea
     if conda<>condb then airesult=0
    endcase
    `
    case AICONDIFMARKER:
     conda=entitybreadcrumbs(e,0).x
     condb=aiconditionseq(seq).valuea
     if condb=0 and conda>0 then airesult=0
     if condb=1 and conda=0 then airesult=0
    endcase
    case AICONDIFPLRTRAIL:
     rem player trail!
     conda=0
     condb=aiconditionseq(seq).valuea
     if condb=0 and conda>0 then airesult=0
     if condb=1 and conda=0 then airesult=0
    endcase
    `
    case AICONDISDARKAISEEING:
     aiobjidvalue=0 : gosub _aiss_fpi_getconditionvalue
     if aiobjidvalue=0 then airesult=0
     gosub _ai_additionaldarkaientityraycast
    endcase
    case AICONDISDARKAIHURT:
     aiobjidvalue=1 : gosub _aiss_fpi_getconditionvalue
     if aiobjidvalue=0 then airesult=0
    endcase
    case AICONDISDARKAIFIRING:
     aiobjidvalue=2 : gosub _aiss_fpi_getconditionvalue
     gosub _ai_additionaldarkaientityraycast
    endcase
    `
    `
    `
    case AICONDHUDSELECTIONMADE:
     conda=aiconditionseq(seq).valuea
     if conda>0
      if hudselectionmade<>conda then airesult=0 else hudselectionmade=0
     else
      if hudselectionmade=0 then airesult=0 else hudselectionmade=0
     endif
    endcase
    case AICONDTIMERGREATER:
     conda=timer()-hudtimer
     condb=aiconditionseq(seq).valuea
     if conda<condb then airesult=0
    endcase
    case AICONDESCAPEKEYPRESSED:
     conda=aiconditionseq(seq).valuea
     if gtestgamemodefromeditor=1
      rem in test game, do not respond to escape key press
      airesult=0
     else
      if escapekey()=1 and conda=0 then airesult=0
      if escapekey()=0 and conda=1 then airesult=0
     endif
    endcase
    case AICONDSCANCODEKEYPRESSED:
     conda=aiconditionseq(seq).valuea
     condb=scancode()
     if condb<>conda then airesult=0
    endcase
    case AICONDHUDEDITDONE:
     for thudid=1 to hudmax
      if hud(thudid).maintype=8 and hud(thudid).hide=0 and hud(thudid).typemode<20
       airesult=0
      endif
     next thudid
    endcase
    case AICONDHUDHAVENAME:
     conda=aiconditionseq(seq).valuea
     if hudhaveplayername=0 and conda=1 then airesult=0
     if hudhaveplayername=1 and conda=0 then airesult=0
    endcase
    `
    `
    `
    case AICONDEFFECTAMBIENCELESS:
     conda#=guivisualsettings.ambience
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTAMBIENCEGREATER:
     conda#=guivisualsettings.ambience
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTBLOOMSIZELESS:
     conda#=hudbloomwidth(waterisbelowplayer-1)
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTBLOOMSIZEGREATER:
     conda#=hudbloomwidth(waterisbelowplayer-1)
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTBLOOMSTRLESS:
     conda#=hudbloomstrength(waterisbelowplayer-1)
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTBLOOMSTRGREATER:
     conda#=hudbloomstrength(waterisbelowplayer-1)
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERSPEEDLESS:
     conda#=hudwaterspeed
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERSPEEDGREATER:
     conda#=hudwaterspeed
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERSMOOTHLESS:
     conda#=hudwaterdepth
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERSMOOTHGREATER:
     conda#=hudwaterdepth
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERREFLECTIONLESS:
     conda#=hudwaterrefl
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERREFLECTIONGREATER:
     conda#=hudwaterrefl
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERREFRACTIONLESS:
     conda#=hudwaterrefr
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERREFRACTIONGREATER:
     conda#=hudwaterrefr
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERFRESNELLESS:
     conda#=hudwaterfresnel
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERFRESNELGREATER:
     conda#=hudwaterfresnel
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERLEVELLESS:
     conda#=waterlevel#
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTWATERLEVELGREATER:
     conda#=waterlevel#
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTSHADOWSTRLESS:
     conda#=hudshadowstrength
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTSHADOWSTRGREATER:
     conda#=hudshadowstrength
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTSHADOWQTYLESS:
     conda#=hudshadowquantity
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTSHADOWQTYGREATER:
     conda#=hudshadowquantity
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDEFFECTWINDOWREFRACTIONLESS:
     conda#=hudglassrefr
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDEFFECTWINDOWREFRACTIONGREATER:
     conda#=hudglassrefr
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDVOLUMEINGAMEMUSICLESS:
     conda#=volumemeter(2)
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDVOLUMEINGAMEMUSICGREATER:
     conda#=volumemeter(2)
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDVOLUMEPLAYERSOUNDSLESS:
     conda#=volumemeter(3)
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDVOLUMEPLAYERSOUNDSGREATER:
     conda#=volumemeter(3)
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    case AICONDVOLUMEINGAMESOUNDSLESS:
     conda#=volumemeter(4)
     condb#=aiconditionseq(seq).valuea
     if conda#>=condb# then airesult=0
    endcase
    case AICONDVOLUMEINGAMESOUNDSGREATER:
     conda#=volumemeter(4)
     condb#=aiconditionseq(seq).valuea
     if conda#<=condb# then airesult=0
    endcase
    `
    `
    `
   endselect
   `
   rem nw addition, if airesult prematurely zero can leave NOW
   if airesult=0 then seq=aicond(conindex).last
   `
  next seq
  if gshowdebugtextingamestate=1
   if debugviewtog=1
    if aiconttimer<>0 then print " : ";
   endif
  endif
  `
  rem Process action if all true
  if airesult=1
   `
   if gshowdebugtextingamestate=1
    if debugviewtog=1
     if aiconttimer=0 then aiconttimer=timer() : print " : ";
     print strarr$(1);
    endif
   endif
   `
   rem Process all actions in sequence
   actindex=aicond(conindex).action
   for seq=aiaction(actindex).first to aiaction(actindex).last
    if gshowdebugtextingamestate=1
     if debugviewtog=1
      print actword$(aiactionseq(seq).type)+"("+str$(aiactionseq(seq).value)+")"+", ";
     endif
    endif
    select aiactionseq(seq).type
     `
     case AIACTSTATE:
      entityelement(e).ai.state=aiactionseq(seq).value
     endcase
     case AIACTINCSTATE:
      entityelement(e).ai.state=entityelement(e).ai.state+aiactionseq(seq).value
     endcase
     `
     case AIACTDESTROY:
      rem deactivate and hide entity (beenkilled used by spawner)
      `entityelement(e).beenkilled=1
      gosub _entity_setbeenkilledflag
      entityelement(e).active=0
      if obj>0
       if entityelement(e).eleprof.physics<>0
        gosub _physics_switchoffe
       else
        set object collision off obj
       endif
       if entityprofile(entid).ischaracter=1 and entityprofile(entid).noragdoll=0
        rem X10 - 031007 - character object needs to remain visible until ragdoll kicks in
        rem X10 - V109 - 130309 - except noragdoll characters
       else
        hide object obj
       endif
      endif
      rem stop any looping sound
      gosub _ai_stopentsounds
      rem clear entity from col map
      tx=entityelement(e).x/25
      ty=entityelement(e).y/100
      tz=entityelement(e).z/-25
      if tx>=0 and ty>=0 and tz>=0
       if tx<=viscolx and ty<=viscoly and tz<=viscolz
        if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0
       endif
      endif
      rem X10 remove from parent slot resource
      if entityelementwhichslot(e)<>-1
       gosub _slot_end_slot_use
      endif      
     endcase
     case AIACTSUSPEND:
      rem deactivate entity (like a corpse)
      entityelement(e).active=0
      `entityelement(e).beenkilled=1
      gosub _entity_setbeenkilledflag
      entityelement(e).logiccount=0 : entityelement(e).logiccountburst=5
      rem stop any looping sound
      if entityelement(e).firesoundloop>0 then stop sound entityelement(e).firesoundloop
      entityelement(e).firesoundloop=0
      rem clear entity from col map
      tx=entityelement(e).x/25
      ty=entityelement(e).y/100
      tz=entityelement(e).z/-25
      viscolmap(tx,ty,tz)=0
      rem X10 - force object to clone, free up parent slots
      playframeanimset=-1 : gosub _slot_playframe
     endcase
     case AIACTRAGDOLL:
      rem deactivate and convert to rag doll
      `entityelement(e).beenkilled=1
      gosub _entity_setbeenkilledflag
      entityelement(e).active=0
      if obj>0
       if entityelement(e).eleprof.physics<>0
        gosub _physics_switchoffe
       else
        set object collision off obj
       endif
      endif
      rem stop any looping sound
      gosub _ai_stopentsounds
      rem clear entity from col map
      tx=entityelement(e).x/25
      ty=entityelement(e).y/100
      tz=entityelement(e).z/-25
      if tx>=0 and ty>=0 and tz>=0
       if tx<=viscolx and ty<=viscoly and tz<=viscolz
        if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0
       endif
      endif
      rem X10 instead of playing fall anim, switch to rag doll
      if entityelementusingode(e)=0
       rem V109 - 060209 - cannot change OBJ during AI loop perminantly!
       tstoreobj=obj
       obj=entityelement(e).obj
       gosub _slot_ode_collapse
       obj=tstoreobj
      endif
     endcase
     case AIACTFLOORLOGIC:
      entityelement(e).nofloorlogic=1+entityelement(e).y
      entityelement(e).nogravity=1
      if gmultiplayergame=0
       if entityelement(e).eleprof.physics<>0
        rem switch off gravity for this object
        if obj>0 then gosub _physics_gravityoff
       endif
      endif
     endcase
     case AIACTNOGRAVITY:
      entityelement(e).nogravity=1
      if gmultiplayergame=0
       if entityelement(e).eleprof.physics<>0
        rem switch off gravity for this object
        if obj>0 then gosub _physics_gravityoff
       endif
      endif
     endcase
     case AIACTSNAPSHOTMODE:
      if snapshotmodeframebyframe=0
       rem X10 - 241007 - special frame by frame snapshot mode
       snapshotmodeframebyframe=1
      endif
     endcase
     `
     case AIACTRUNFPIDEFAULT:
      rem leave and run new DEFAULT AI script
      trundefaultscriptinternal=1
      if aiactionseq(seq).value=0 then trundefaultscript=1+entityelement(e).ai.libinit
      if aiactionseq(seq).value=1 then trundefaultscript=1+entityelement(e).ai.libmain
      if aiactionseq(seq).value=2 then trundefaultscript=1+entityelement(e).ai.libdestroy
      if aiactionseq(seq).value=3 then trundefaultscript=1+entityelement(e).ai.libshoot
      conindex=ailist(aiindex).conditionlast
      seq=aiaction(actindex).last
      exit
     endcase
     case AIACTRUNFPI:
      rem Switch FPI AI Scripts via SPECIFIED FILE
      trundefaultscriptinternal=0
      trundefaultscript=1+aiactionseq(seq).value
      conindex=ailist(aiindex).conditionlast
      seq=aiaction(actindex).last
      exit
     endcase
     `
     case AIACTMOVEUP:
      if obj>0
       tmpx#=object position x(obj)
       tmpy#=object position y(obj)
       tmpz#=object position z(obj)
       temp#=(entityelement(e).eleprof.speed/100.0)*aiactionseq(seq).value
       entityelement(e).y=tmpy#+temp#
       gosub _entity_controlrecalcdist
       position object obj,tmpx#,entityelement(e).y,tmpz#
      endif
     endcase
     case AIACTMOVEFORE:
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
      tmp#=(entityelement(e).eleprof.speed/100.0)*aiactionseq(seq).value
      rem X10 V109 - 090309 - must have minimum move distance or movement fails (for slow entities)
      if tmp#<2.0 then tmp#=2.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTRUNFORE:
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
      tmp#=(entityelement(e).eleprof.speed/100.0)*aiactionseq(seq).value
      rem X10 V109 - 090309 - must have minimum move distance or movement fails (for slow entities)
      if tmp#<2.0 then tmp#=2.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tmp#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=1
     endcase
     case AIACTFREEZE:
      entityelement(e).mover.dx=entityelement(e).x
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.dz=entityelement(e).z
      entityelement(e).ai.headangle=0.0
      entityelement(e).ai.headdestangle=0.0
      entityelement(e).ai.waypoint.state=999
      entityelement(e).mover.moved=0
      entityelement(e).mover.run=0
      entityelement(e).strafemode=0
      entityelement(e).mover.ix=0
      entityelement(e).mover.iz=0
      entityelement(e).mover.strafe=0
      entityelement(e).mover.stepcount=0
      entityelement(e).plrtrailindex=0
     endcase
     `
     case AIACTROTATEY:
      tmp#=aiactionseq(seq).value
      entityelement(e).mover.da=entityelement(e).mover.da+tmp#
      if entityelement(e).mover.da<0 then entityelement(e).mover.da=entityelement(e).mover.da+360
      if entityelement(e).mover.da>359 then entityelement(e).mover.da=entityelement(e).mover.da-360
     endcase
     case AIACTROTATETOPLR:
      entityelement(e).ai.headangle=0.0
      entityelement(e).ai.headdestangle=0.0
      entityelement(e).mover.da=wrapvalue(diffangle#)
     endcase
     case AIACTROTATEIY:
      tmp#=aiactionseq(seq).value
      entityelement(e).ry=entityelement(e).ry+tmp#
      entityelement(e).mover.da=entityelement(e).ry
      if obj>0
       yrotate object obj,entityelement(e).ry
      endif
     endcase
     case AIACTNOROTATE:
      entityelement(e).norotate=aiactionseq(seq).value
     endcase
     `
     case AIACTRESETHEAD:
      entityelement(e).ai.headdestangle=0.0
     endcase
     case AIACTROTATEHEAD:
      tmp#=aiactionseq(seq).value
      entityelement(e).ai.headdestangle=tmp#
     endcase
     case AIACTROTATEHEADRANDOM:
      tmp#=(rnd(1)*2)-1
      tmp#=rnd(aiactionseq(seq).value)*tmp#
      entityelement(e).ai.headdestangle=tmp#
     endcase
     `
     case AIACTFORCEBOUNCE:
      if tmpframe=aiactionseq(seq).value=0
       entityelement(e).force.ix=0
       entityelement(e).force.iz=0
      else
       entityelement(e).force.ix=entityelement(e).force.ix*-0.5
       entityelement(e).force.iz=entityelement(e).force.iz*-0.5
      endif
     endcase
     `
     case AIACTSPINRATE:
      entityelement(e).spinrate=aiactionseq(seq).value
      rem to have spin, must disable physics
      if entityelement(e).eleprof.physics<>0
       gosub _physics_switchoffe
       entityelement(e).eleprof.physics=0
      endif
     endcase
     case AIACTFLOATRATE:
      entityelement(e).floatrate=aiactionseq(seq).value
      rem to have float, must disable physics
      if entityelement(e).eleprof.physics<>0
       gosub _physics_switchoffe
       entityelement(e).eleprof.physics=0
      endif
     endcase
     `
     case AIACTSETFRAME:
      tmpframe=aiactionseq(seq).value
      tbaseframe=tmpframe : gosub _entity_getactualframestart : tmpframe#=tactualframe
      entityelement(e).animframe=tmpframe#
      entityelement(e).destanimframe=tmpframe#
      entityelement(e).animtime=0
      rem X10 do animate=X, then SETFRAME=X and setframe does not use slot
      rem ensure ANIMATE does not have chance to change SETFRAME operation
      entityelement(e).animdo=tmpframe
      entityelement(e).animset=0
      if obj>0
       rem X10 - play frame through parentslot manager
       playframeanimset=tmpframe : gosub _slot_playframe
       rem X10 actual object may be parent slot managed
       actualobj=entityelementwhichobj(e)
       if actualobj=0 then actualobj=obj
       stop object actualobj
       set object interpolation actualobj,100
       set object frame actualobj,tmpframe#
      endif
      rem X10 - 071007 - at start of frame, a melee entity can reset 'fist' ammo flag
      if entityelement(e).currentweapon=0
       rem set melee characters 'strike' flag to zero
       entityelement(e).currentammo=0
      endif      
     endcase
     case AIACTINCFRAME:
      tmpframe=aiactionseq(seq).value
      tbaseframe=tmpframe : gosub _entity_getactualframefinish : tmpframe#=tactualframe
      entityelement(e).destanimframe=tmpframe#
      entityelement(e).animtime=0
     endcase
     case AIACTDECFRAME:
      tmpframe=aiactionseq(seq).value
      tbaseframe=tmpframe : gosub _entity_getactualframestart : tmpframe#=tactualframe
      entityelement(e).destanimframe=tmpframe#
      entityelement(e).animtime=0
     endcase
     case AIACTANIMATE:
      tmpframe1=entityelement(e).animdo
      tmpframe2=aiactionseq(seq).value
      if tmpframe1<>tmpframe2
       entityelement(e).animset=1+aiactionseq(seq).value
       entityelement(e).destanimframe=0
       entityelement(e).animframe=0
       entityelement(e).animtime=0
      endif
     endcase
     case AIACTADVFRAME:
      tmpframe=aiactionseq(seq).value
      tmpframe#=entityelement(e).destanimframe-entityelement(e).animframe
      tmpframe#=(tmpframe#/100.0)*tmpframe
      entityelement(e).animframe=entityelement(e).animframe+tmpframe#
     endcase
     case AIACTPOSEMODE:
      rem called immediately in main script
      rem cancel any AI and then allow this action to change object frame
      rem cannot be used with instanced characters
      if AI Entity Exist(obj)=1
       rem Kills off AI control of entity
       AI Kill Entity obj
       f#=entityelement(e).eleprof.ex.factor
       set object frame obj,f#
      else
       rem check for controls
       rem only if within range
       if entityelement(e).plrdist<=75.0
        rem and only if directly faced
        tdistx#=entityelement(e).x-mex#
        tdistz#=entityelement(e).z-mez#
        tdiffangle#=wrapvalue(atanfull(tdistx#,tdistz#))-wrapvalue(camera angle y(playercam))
        if tdiffangle#>180 then tdiffangle#=tdiffangle#-360
        if abs(tdiffangle#)<10.0
         lf#=f# : f#=object frame(obj) : r#=entityelement(e).ry
         if shiftkey()=0 then ts#=1.0 else ts#=0.2
         if keystate(12)=1 then f#=f#-ts#
         if keystate(13)=1 then f#=f#+ts#
         if keystate(40)=1 then r#=r#-ts#
         if keystate(43)=1 then r#=r#+ts#
         if f#<0.0 then f#=0.0
         r#=wrapvalue(r#)
         set object frame obj,f#
         entityelement(e).mover.da=r#
         entityelement(e).ry=r#
         yrotate object obj,r#
         if lf#<>f# then set cursor 0,150 : print "FRAME : ";int(f#)
        endif
       endif
      endif
     endcase
     `
     case AIACTSOUND:
      tmpx#=camera position x(playercam)
      tmpy#=camera position y(playercam)
      tmpz#=camera position z(playercam)
      if aiactionseq(seq).value=-1
       playinternal3dsound(entityelement(e).soundset,tmpx#,tmpy#,tmpz#)
       if entityelement(e).soundset>0 then set sound volume entityelement(e).soundset,soundvolumes(0)
      else
       if aiactionseq(seq).value=-2
        playinternal3dsound(entityelement(e).soundset1,tmpx#,tmpy#,tmpz#)
        if entityelement(e).soundset1>0 then set sound volume entityelement(e).soundset1,soundvolumes(0)
       else
        playinternal3dsound(aiactionseq(seq).value,tmpx#,tmpy#,tmpz#)
        if aiactionseq(seq).value>0 then set sound volume aiactionseq(seq).value,soundvolumes(0)
       endif
      endif
      broadcast3dsound(tmpx#,tmpy#,tmpz#,5.0)
     endcase
     case AIACT3DSOUND:
      tmpx#=entityelement(e).x
      tmpy#=entityelement(e).y
      tmpz#=entityelement(e).z
      if aiactionseq(seq).value=-1
       playinternal3dsoundloudness(entityelement(e).soundset,tmpx#,tmpy#,tmpz#,3.0)
       if entityelement(e).soundset>0 then set sound volume entityelement(e).soundset,soundvolumes(0)
      else
       if aiactionseq(seq).value=-2
        playinternal3dsoundloudness(entityelement(e).soundset1,tmpx#,tmpy#,tmpz#,3.0)
        if entityelement(e).soundset1>0 then set sound volume entityelement(e).soundset1,soundvolumes(0)
       else
        playinternal3dsoundloudness(aiactionseq(seq).value,tmpx#,tmpy#,tmpz#,3.0)
        if aiactionseq(seq).value>0 then set sound volume aiactionseq(seq).value,soundvolumes(0)
       endif
      endif
      broadcast3dsound(tmpx#,tmpy#,tmpz#,5.0)
     endcase
     case AIACTLOOPSOUND:
      tmpx#=entityelement(e).x
      tmpy#=entityelement(e).y
      tmpz#=entityelement(e).z
      if aiactionseq(seq).value=-1
       tsnd=entityelement(e).soundset
      else
       if aiactionseq(seq).value=-2
        tsnd=entityelement(e).soundset1
       else
        tsnd=aiactionseq(seq).value
       endif
      endif
      loopinternal3dsound(tsnd,tmpx#,tmpy#,tmpz#)
      if tsnd>0 then set sound volume tsnd,soundvolumes(0)
      entityelement(e).soundlooping=tsnd
     endcase
     case AIACTSTOPSOUND:
      if aiactionseq(seq).value=0
       if entityelement(e).soundset>0 then stop sound entityelement(e).soundset
      else
       if aiactionseq(seq).value=1
        if entityelement(e).soundset1>0 then stop sound entityelement(e).soundset1
       endif
      endif
      if entityelement(e).soundlooping>0
       if sound exist(entityelement(e).soundlooping)=1
        stop sound entityelement(e).soundlooping
       endif
       entityelement(e).soundlooping=0
      endif
     endcase
     `
     case AIACTALTTEXTURE:
      if obj>0
       if entityelement(e).eleprof.texaltdid>0
        rem Texture toggler
        if aiactionseq(seq).value=0
         entityelementtexarrayindex(e)=0
         if obj>0
          delete object obj
          instance object obj,entityelement(e).profileobj,entityelementtexarrayindex(e)
         endif
        else
         entityelementtexarrayindex(e)=1
         if obj>0
          delete object obj
          instance object obj,entityelement(e).profileobj,entityelementtexarrayindex(e)
         endif
        endif
       else
        `280706 - no regular object has alternative texture ( all instances, i.e. switches )
        `rem regular texture (with possible DNS)
        `if aiactionseq(seq).value=0
        ` texture object obj,0,entityelement(e).eleprof.texdid
        `else
        ` texture object obj,0,entityelement(e).eleprof.texaltdid
        `endif
        `if entityelement(e).eleprof.usingeffect>0
        ` if entityelement(e).eleprof.tex1id<>0 then texture object obj,1,entityelement(e).eleprof.tex1id
        ` if entityelement(e).eleprof.tex2id<>0 then texture object obj,2,entityelement(e).eleprof.tex2id
        ` if entityelement(e).eleprof.tex3id<>0 then texture object obj,3,entityelement(e).eleprof.tex3id
        ` set object effect obj,entityelement(e).eleprof.usingeffect
        `endif
       endif
      endif
     endcase
     `
     case AIACTSETALPHAFADE:
      entityelement(e).ai.alphafade=aiactionseq(seq).value
      entityelement(e).ai.destalphafade=aiactionseq(seq).value
      if obj>0
       set alpha mapping on obj,entityelement(e).ai.alphafade
      endif
     endcase
     case AIACTINCALPHAFADE:
      entityelement(e).ai.destalphafade=aiactionseq(seq).value
     endcase
     case AIACTDECALPHAFADE:
      entityelement(e).ai.destalphafade=aiactionseq(seq).value
     endcase
     `
     case AIACTRUNDECAL:
      tdecalmode=aiactionseq(seq).value
      if tdecalmode=-1
       entityelement(e).decalindex=0
      else
       entityelement(e).decalindex=1
       entityelement(e).decalmode=tdecalmode
       if entityelement(e).decalmode=6
        if entityelement(e).currentweapon=0
         entityelement(e).decalindex=0
        endif
       endif
      endif
     endcase
     case AIACTSHAPEDECAL:
      if obj>0
       entityelement(e).decalsizex=object size x(obj)
       entityelement(e).decalsizey=object size y(obj)
      endif
     endcase
     `
     case AIACTTRIGGERFORCE:
      taddforcesphere=aiactionseq(seq).value
     endcase
     `
     case AIACTPLRASS:
      gosub _player_resettrail
      meridinglift=1+e
     endcase
     case AIACTPLRNOASS:
      meridinglift=0
     endcase
     `
     case AIACTPLRMOVEUP:
      memovingy#=(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVEDOWN:
      memovingy#=(aiactionseq(seq).value/100.0)*-1
     endcase
     case AIACTPLRMOVEEAST:
      memovingx#=(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVEWEST:
      memovingx#=(aiactionseq(seq).value/100.0)*-1
     endcase
     case AIACTPLRMOVENORTH:
      memovingz#=(aiactionseq(seq).value/100.0)
     endcase
     case AIACTPLRMOVESOUTH:
      memovingz#=(aiactionseq(seq).value/100.0)*-1
     endcase
     case AIACTPLRMOVETO:
      foundte=aiactionseq(seq).value
      if foundte>0
       tranmex#=entityelement(foundte).x
       tranmey#=entityelement(foundte).y+55.0
       tranmez#=entityelement(foundte).z
       tranmeangley#=entityelement(foundte).ry+180
       gosub _player_resettrail
       meridingtransporter=1
      endif
     endcase
     case AIACTPLRMOVEIFUSED:
      tname$=entityelement(e).eleprof.ifused$
      gosub _entity_findname
      if foundte>0
       tranmex#=entityelement(foundte).x
       tranmey#=entityelement(foundte).y+55.0
       tranmez#=entityelement(foundte).z
       tranmeangley#=entityelement(foundte).ry+180
       gosub _player_resettrail
       meridingtransporter=1
      endif
     endcase
     `
     case AIACTACTIVATEIFUSED:
      tname$=entityelement(e).eleprof.ifused$
      tstate=aiactionseq(seq).value
      gosub _entity_activatename
     endcase
     case AIACTACTIVATEIFUSEDNEAR:
      tname$=entityelement(e).eleprof.ifusednear$
      tstate=aiactionseq(seq).value
      gosub _entity_activatename
     endcase
     case AIACTACTIVATETARGET:
      te=entityelement(e).actualtarget-1
      if te>0
       entityelement(te).activated=aiactionseq(seq).value
       entityelement(te).logiccount=0 : entityelement(te).logiccountburst=5
       entityelement(te).dormant=0
      endif
     endcase
     case AIACTACTIVATE:
      entityelement(e).activated=aiactionseq(seq).value
      entityelement(e).logiccount=0 : entityelement(e).logiccountburst=5
      entityelement(e).dormant=0
     endcase
     case AIACTACTIVATEALLINZONE:
      tactivated=aiactionseq(seq).value
      condx1=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax1*100))-50.0
      condy1=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay1*100))
      condz1=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz1*100))+50.0
      condx2=(entityelement(e).x+(entityelement(e).eleprof.trigger.areax2*100))+50.0
      condy2=(entityelement(e).y+(entityelement(e).eleprof.trigger.areay2*100))+100.0
      condz2=(entityelement(e).z-(entityelement(e).eleprof.trigger.areaz2*100))-50.0
      condy1=condy1/100 : condy1=condy1*100
      condy2=condy2/100 : condy2=condy2*100
      gosub _entity_activateallinzone
     endcase
     `
     case AIACTPLRADDHEALTH:
      tvalue=aiactionseq(seq).value
      if entityelement(e).eleprof.ex.factor>1
       tvalue=tvalue*entityelement(e).eleprof.ex.factor
      endif
      if aiactionseq(seq).value<0
       tdamage=abs(tvalue)
       gosub _player_takedamage
      else
       player(1).health=player(1).health+tvalue
       if player(1).health>playerstartstrength then player(1).health=playerstartstrength
      endif
     endcase
     `
     case AIACTPLRADDAIR:
      if aiactionseq(seq).value>0
       player(1).air=player(1).air+aiactionseq(seq).value
       if player(1).air>player(1).airmax then player(1).air=player(1).airmax
      endif
     endcase
     `
     case AIACTSETTARGET:
      if entityelement(e).possibletarget<>0
       entityelement(e).actualtarget=entityelement(e).possibletarget
       if entityelement(e).actualtarget>1
        tte=entityelement(e).actualtarget-1
        entityelement(e).actualtargetx=entityelement(tte).x
        entityelement(e).actualtargety=entityelement(tte).y
        entityelement(e).actualtargetz=entityelement(tte).z
        entityelement(e).losttargetcount=0
       else
        if entityelement(e).actualtarget=-1
         entityelement(e).actualtargetx=bcsoundx#
         entityelement(e).actualtargety=bcsoundy#
         entityelement(e).actualtargetz=bcsoundz#
         entityelement(e).losttargetcount=0
        else
         `
         rem target is player
         tdx#=(mex#-entityelement(e).x)
         tdy#=(mey#-entityelement(e).y)
         tdz#=(mez#-entityelement(e).z)
         tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)+abs(tdy#*tdy#))+0.001
         tdxh#=(tdx#/tdd#)*10.0
         tdzh#=(tdz#/tdd#)*10.0
         ttactualtargetx=mex#-tdxh#
         ttactualtargety=mey#-phyeyeheight# : rem too much -meheight#
         ttactualtargetz=mez#-tdzh#
         `
         rem only if actual target position has CHANGED!
         taquirelinetoplr=0
         if int(entityelement(e).actualtargetx/100)<>int(ttactualtargetx/100) or int(entityelement(e).actualtargety/100)<>int(ttactualtargety/100) or int(entityelement(e).actualtargetz/100)<>int(ttactualtargetz/100)
          rem new position of target, so check ground before use it
          entityelement(e).actualtargetx=ttactualtargetx
          entityelement(e).actualtargety=ttactualtargety
          entityelement(e).actualtargetz=ttactualtargetz
          rem can go straight to players position to start trail if plr level(ish)
          traily#=entityelement(e).actualtargety
          if entityelement(e).plrtrailindex<>0
           rem entity already has trail, but might be 'follow the leader' nonesense
           rem if there is good ground between player and entity, give opportunity to skip
           tokay=1
           tstbx#=entityelement(e).x
           tstby#=entityelement(e).y
           tstbz#=entityelement(e).z
           tdxi#=tdx#/tdd# : tdyi#=tdy#/tdd# : tdzi#=tdz#/tdd#
           for tst#=0.0 to tdd# step 90.0
            tstx#=tstbx#+(tdxi#*tst#)
            tsty#=tstby#+(tdyi#*tst#)
            tstz#=tstbz#+(tdzi#*tst#)
            inc gameperfentities3
            entityelement(e).raycastcount=0
            if static raycast(tstx#,tsty#,tstz#,tstx#,tsty#-50,tstz#)=0
             tokay=0
            endif
           next tst#
           if tokay=1 then taquirelinetoplr=2
          endif
          `
         else
          entityelement(e).losttargetcount=0
         endif
         if taquirelinetoplr=2
          if abs(traily#-entityelement(e).y)<10.0
           rem if on same level
           taquirelinetoplr=1
          endif
          if traily#<entityelement(e).y
           rem if player lower than entity
           taquirelinetoplr=1
          endif
         endif
         if taquirelinetoplr=1
          trailx#=mex# : trailz#=mez#
          trailaction=1 : gosub _player_leavetrail
          entityelement(e).plrtrailindex=playertrailmax-1
          if entityelement(e).plrtrailindex<1 then entityelement(e).plrtrailindex=100
         endif
         `
        endif
       endif
       entityelement(e).possibletarget=0
`       interferes with target lock, but character is stuck (like a barrier)
`       entityelement(e).losttargetcount=0
      endif
     endcase
     case AIACTROTATETOTARGET:
      tdistx#=entityelement(e).actualtargetx-entityelement(e).x
      tdistz#=entityelement(e).actualtargetz-entityelement(e).z
      tdiffangle#=atanfull(tdistx#,tdistz#)
      if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
      entityelement(e).mover.da=wrapvalue(tdiffangle#)
     endcase
     case AIACTLOOKATTARGET:
      tdistx#=entityelement(e).actualtargetx-entityelement(e).x
      tdistz#=entityelement(e).actualtargetz-entityelement(e).z
      tdiffangle#=wrapvalue(atanfull(tdistx#,tdistz#))-wrapvalue(entityelement(e).mover.da)
      if tdiffangle#>180 then tdiffangle#=tdiffangle#-360
      if abs(tdiffangle#)>aiactionseq(seq).value then tdiffangle#=0
      entityelement(e).ai.headdestangle=tdiffangle#
     endcase
     case AIACTMOVETOTARGET:
      tokay=0
      if entityelement(e).actualtarget<>1 then tokay=1
      if entityelement(e).actualtarget=1 and player(1).health>0 then tokay=1
      if tokay=1
       tdistx#=entityelement(e).actualtargetx-entityelement(e).x
       tdistz#=entityelement(e).actualtargetz-entityelement(e).z
       tdiffangle#=atanfull(tdistx#,tdistz#)
       tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdistz#*tdistz#))
       if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
       entityelement(e).mover.da=wrapvalue(tdiffangle#)
       tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
       entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
       entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
       entityelement(e).mover.dy=entityelement(e).actualtargety
       entityelement(e).mover.moved=1
       entityelement(e).mover.run=aiactionseq(seq).value
       entityelement(e).mover.strafe=0
       rem X10 reset trail (followplr) if we are moving direct to target
       entityelement(e).plrtrailindex=0
      endif
     endcase
     case AIACTCOLLECTTARGET:
      te=entityelement(e).actualtarget-1
      if te>0
       tobj=entityelement(te).obj
       if tobj>0
        if entityelement(te).x<>-99999
         rem Not already collected
         `detach object from static tobj : hide object tobj
         hide object tobj
         entityelement(te).x=-99999
         entityelement(te).y=-99999
         entityelement(te).z=-99999
         tplrid=entityelement(e).fakeplayerid
         if tplrid>0
          pi=player(tplrid).inventorymax : inc pi
          playerinventory(tplrid,pi).new=1
          playerinventory(tplrid,pi).index=te
          player(tplrid).inventorymax=pi
          rem make NPC player responsible for weapon selection (change to entity control)
          tentid=entityelement(te).bankindex : tgunid=entityprofile(tentid).isweapon
          if tgunid>0
           entityelement(e).currentweapon=tgunid
          endif
         endif
         entityelement(e).actualtarget=0
        endif
       endif
      endif
     endcase
     case AIACTCHOOSESTRAFE:
      entityelement(e).strafemode=rnd(2)
     endcase
     case AIACTSTRAFE:
`      if entityelement(e).strafemode=0 then entityelement(e).mover.strafe=0
`      if entityelement(e).strafemode=1 then entityelement(e).mover.strafe=aiactionseq(seq).value
`      if entityelement(e).strafemode=2 then entityelement(e).mover.strafe=aiactionseq(seq).value*-1
      rem replaced with immediate strafe
      tdiffangle#=aiactionseq(seq).value
      entityelement(e).mover.da=entityelement(e).mover.da+tdiffangle#
      if entityelement(e).mover.da<0 then entityelement(e).mover.da=entityelement(e).mover.da+360
      if entityelement(e).mover.da>359 then entityelement(e).mover.da=entityelement(e).mover.da-360
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z : tdist#=15.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.strafe=0
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTPIVOTRANDOM:
      tmp#=aiactionseq(seq).value
      tdiffangle#=rnd(tmp#*2)-tmp#
      entityelement(e).mover.da=entityelement(e).mover.da+tdiffangle#
      if entityelement(e).mover.da<0 then entityelement(e).mover.da=entityelement(e).mover.da+360
      if entityelement(e).mover.da>359 then entityelement(e).mover.da=entityelement(e).mover.da-360
      tmpx#=entityelement(e).x : tmpz#=entityelement(e).z : tdist#=5.0
      entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.strafe=0
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTLOOKATPLR:
      tdistx#=mex#-entityelement(e).x
      tdistz#=mez#-entityelement(e).z
      tdiffangle#=wrapvalue(atanfull(tdistx#,tdistz#))-wrapvalue(entityelement(e).mover.da)
      if tdiffangle#>180 then tdiffangle#=tdiffangle#-360
      if abs(tdiffangle#)>aiactionseq(seq).value
       if tdiffangle#>=0
        tdiffangle#=aiactionseq(seq).value
       else
        tdiffangle#=aiactionseq(seq).value*-1
       endif
      endif
      entityelement(e).ai.headdestangle=tdiffangle#
     endcase
     case AIACTSETTARGETNAME:
      tstrindex=aiactionseq(seq).value
      tname$=actstring$(tstrindex)
      gosub _entity_findname
      if foundte>0
       entityelement(e).actualtarget=1+foundte
       entityelement(e).possibletarget=0
       if entityelement(e).actualtarget>1
        tte=entityelement(e).actualtarget-1
        entityelement(e).actualtargetx=entityelement(tte).x
        entityelement(e).actualtargety=entityelement(tte).y
        entityelement(e).actualtargetz=entityelement(tte).z
        entityelement(e).losttargetcount=0
       endif
      endif
     endcase
     `
     case AIACTWAYPOINTSTART:
      rem find nearest waypoint
      twdistbest#=99999.9 : twbest=0
      for w=1 to waypointcoordmax
       twdx#=abs(waypointcoord(w).x-entityelement(e).x)
       twdy#=abs(waypointcoord(w).y-entityelement(e).y)
       twdz#=abs(waypointcoord(w).z-entityelement(e).z)
       twdist#=sqrt((twdx#*twdx#)+(twdy#*twdy#)+(twdz#*twdz#))
       if twdist#<1000.0
        inc gameperfentities3
        entityelement(e).raycastcount=0
        if static raycast(entityelement(e).x,entityelement(e).y+35,entityelement(e).z,waypointcoord(w).x,waypointcoord(w).y+35,waypointcoord(w).z)=0
         if twdist#<twdistbest#
          twdistbest#=twdist# : twbest=w
         endif
        endif
       endif
      next w
      if twbest>0
       entityelement(e).ai.waypoint.current=twbest
       entityelement(e).ai.waypoint.tracker=waypointcoord(twbest).index
       entityelement(e).ai.waypoint.direction=1
       entityelement(e).ai.waypoint.state=1
      else
       rem if no start, place state in limbo away from WP activity
       entityelement(e).ai.waypoint.state=99
       rem special animation directive to enter idle mode
       entityelement(e).animset=1+1
       entityelement(e).destanimframe=0
       entityelement(e).animframe=0
       entityelement(e).animtime=0
      endif
      entityelement(e).losttargetcount=0
     endcase
     case AIACTWAYPOINTSTOP:
      entityelement(e).mover.dx=entityelement(e).x
      entityelement(e).mover.dy=entityelement(e).y
      entityelement(e).mover.dz=entityelement(e).z
      entityelement(e).ai.waypoint.state=99 : rem still waypoint activity
      entityelement(e).mover.moved=1
      entityelement(e).mover.run=0
     endcase
     case AIACTWAYPOINTREVERSE:
      if entityelement(e).ai.waypoint.current>0
       if entityelement(e).ai.waypoint.direction=1
        entityelement(e).ai.waypoint.direction=2
        w=entityelement(e).ai.waypoint.current
        if w>waypoint(entityelement(e).ai.waypoint.tracker).start
         entityelement(e).ai.waypoint.current=w-1
        endif
       else
        entityelement(e).ai.waypoint.direction=1
        w=entityelement(e).ai.waypoint.current
        if w<waypoint(entityelement(e).ai.waypoint.tracker).finish
         entityelement(e).ai.waypoint.current=w+1
        endif
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     case AIACTWAYPOINTNEXT:
      if entityelement(e).ai.waypoint.current>0
       if entityelement(e).ai.waypoint.direction=1
        w=entityelement(e).ai.waypoint.current
        if w<waypoint(entityelement(e).ai.waypoint.tracker).finish
         entityelement(e).ai.waypoint.current=w+1
        endif
       else
        w=entityelement(e).ai.waypoint.current
        if w>waypoint(entityelement(e).ai.waypoint.tracker).start
         entityelement(e).ai.waypoint.current=w-1
        endif
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     case AIACTWAYPOINTPREV:
      if entityelement(e).ai.waypoint.current>0
       if entityelement(e).ai.waypoint.direction=1
        entityelement(e).ai.waypoint.current=entityelement(e).ai.waypoint.current-1
       else
        entityelement(e).ai.waypoint.current=entityelement(e).ai.waypoint.current+1
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     case AIACTWAYPOINTRANDOM:
      if entityelement(e).ai.waypoint.current>0
       r=rnd(1)
       if r=0
        entityelement(e).ai.waypoint.current=linkto
        entityelement(e).ai.waypoint.tracker=waypointcoord(linkto).index
       else
        if entityelement(e).ai.waypoint.direction=1
         w=entityelement(e).ai.waypoint.current
         if w<waypoint(entityelement(e).ai.waypoint.tracker).finish
          entityelement(e).ai.waypoint.current=w+1
         endif
        else
         w=entityelement(e).ai.waypoint.current
         if w>waypoint(entityelement(e).ai.waypoint.tracker).start
          entityelement(e).ai.waypoint.current=w-1
         endif
        endif
       endif
       entityelement(e).ai.waypoint.state=1
      endif
     endcase
     `
     case AIACTDROPMARKER:
      tindex=entitybreadcrumbs(e,0).x
      if tindex<50
       rem find center of tile
       tcx=(int(entityelement(e).x/100)*100)+50
       tcy=(int(entityelement(e).y/100)*100)+10
       tcz=(int(entityelement(e).z/100)*100)-50
       tgeoblock=0
       tmpx1#=tcx
       tmpy1#=tcy+50
       tmpz1#=tcz
       tmpx2#=entitybreadcrumbs(e,tindex).x
       tmpy2#=entitybreadcrumbs(e,tindex).y+50
       tmpz2#=entitybreadcrumbs(e,tindex).z
       inc gameperfentities3
       entityelement(e).raycastcount=0
       if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)<>0
        tcx=entityelement(e).x
        tcy=entityelement(e).y
        tcz=entityelement(e).z
       endif
       if entitybreadcrumbs(e,tindex).x=tcx and entitybreadcrumbs(e,tindex).y=tcy and entitybreadcrumbs(e,tindex).z=tcz
        rem same as current crumb
       else
        rem new one
        if tindex<50
         inc tindex
         entitybreadcrumbs(e,0).x=tindex
         entitybreadcrumbs(e,tindex).x=tcx
         entitybreadcrumbs(e,tindex).y=tcy
         entitybreadcrumbs(e,tindex).z=tcz
        endif
       endif
      endif
     endcase
     case AIACTNEXTMARKER:
      tindex=entitybreadcrumbs(e,0).x
      tmpx1#=entityelement(e).x
      tmpy1#=entityelement(e).y+40
      tmpz1#=entityelement(e).z
      tmpx2#=entitybreadcrumbs(e,tindex).x
      tmpy2#=entitybreadcrumbs(e,tindex).y+40
      tmpz2#=entitybreadcrumbs(e,tindex).z
      inc gameperfentities3
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)<>0
       rem entity lost or trapped, or clipping geometry
       tmpx2#=(entitybreadcrumbs(e,tindex).x+rnd(150))-75
       tmpz2#=(entitybreadcrumbs(e,tindex).z+rnd(150))-75
       inc gameperfentities3
       entityelement(e).raycastcount=0
       if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)=0
        entitybreadcrumbs(e,tindex).x=tmpx2#
        entitybreadcrumbs(e,tindex).z=tmpz2#
       endif
      endif
      rem keep looking until clear path found
      inc gameperfentities3
      entityelement(e).raycastcount=0
      if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)=0
       if tindex>0
        tdistx#=entitybreadcrumbs(e,tindex).x-entityelement(e).x
        tdistz#=entitybreadcrumbs(e,tindex).z-entityelement(e).z
        if entityelement(e).mover.moved=0
         tdiffangle#=atanfull(tdistx#,tdistz#)
         tdist#=sqrt((tdistx#*tdistx#)+(tdistz#*tdistz#))
         if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
         entityelement(e).mover.da=wrapvalue(tdiffangle#)
         tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
         entityelement(e).mover.dx=newxvalue(tmpx#,entityelement(e).mover.da,tdist#)
         entityelement(e).mover.dz=newzvalue(tmpz#,entityelement(e).mover.da,tdist#)
         entityelement(e).mover.dy=entitybreadcrumbs(e,tindex).y
         entityelement(e).mover.moved=1
         entityelement(e).mover.run=0
        endif
        if abs(tdistx#+tdistz#)<2.0
         dec tindex : entitybreadcrumbs(e,0).x=tindex
        endif
       endif
      else
       rem no, that path was blocked
       entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
      endif
     endcase
     case AIACTRESETMARKERS:
      entitybreadcrumbs(e,0).x=0
      entityelement(e).mover.moved=0
      entityelement(e).mover.run=0
     endcase
     case AIACTFOLLOWPLR:
      `
      rem EXISTING MARKER TO FOLLOW?
      if entityelement(e).plrtrailindex>0
       `
       rem FOLLOW PLAYER MARKERS
       if entityelement(e).plrtrailindex<>playertrailmax
        ttrailindex=entityelement(e).plrtrailindex+1
        if ttrailindex>100 then ttrailindex=1
        if playertrial(ttrailindex).time>0
         tdistx#=playertrial(ttrailindex).x-entityelement(e).x
         tdistz#=playertrial(ttrailindex).z-entityelement(e).z
         if sqrt(abs(tdistx#*tdistx#)+abs(tdistz#*tdistz#))<20.0
          entityelement(e).plrtrailindex=entityelement(e).plrtrailindex+1
          if entityelement(e).plrtrailindex>100
           entityelement(e).plrtrailindex=1
          endif
         endif
         if entityelement(e).mover.moved=0
          tdiffangle#=atanfull(tdistx#,tdistz#)
          if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
          entityelement(e).mover.da=wrapvalue(tdiffangle#)
          tmpx#=entityelement(e).x : tmpz#=entityelement(e).z
          entityelement(e).mover.dx=playertrial(ttrailindex).x
          entityelement(e).mover.dy=playertrial(ttrailindex).y
          entityelement(e).mover.dz=playertrial(ttrailindex).z
          entityelement(e).mover.run=aiactionseq(seq).value
          entityelement(e).mover.moved=1
         endif
        else
         entityelement(e).plrtrailindex=0
        endif
       else
        rem reached player, no more following just look at plr
        tdistx#=mex#-entityelement(e).x
        tdistz#=mez#-entityelement(e).z
        tdiffangle#=atanfull(tdistx#,tdistz#)
        if tdiffangle#<0 then tdiffangle#=tdiffangle#+360
        entityelement(e).mover.da=wrapvalue(tdiffangle#)
       endif
       `
      else
       `
       rem FIND BEST MARKER TO GO TO FIRST (to follow player)
       rem if no place in trail, find newest nod  that was at entities level
       tcount=0 : ttrailindex=playertrailmax-1
       while tcount<100
        `
        rem IF MARKER VALID
        if playertrial(ttrailindex).time>0
         `
         rem IF MARKER ON SAME LEVEL AS ENEMY
         if abs(playertrial(ttrailindex).y-entityelement(e).y)<40.0
          `
          rem IS MARKER BLOCKED BY WALL OR ENTITY?
          rem IS MARKER UNOBSTRUCTED BY ANY HOLES IN THE GROUND?
          tmpx#=entityelement(e).x
          tmpy#=entityelement(e).y+20
          tmpz#=entityelement(e).z
          ttox#=playertrial(ttrailindex).x
          ttoy#=playertrial(ttrailindex).y+20
          ttoz#=playertrial(ttrailindex).z
          tvisibility=0 : gosub _entity_determinevisibility
          if tvisibility=1
           ` 
           rem A GOOD MARKER!
           exit
           `
          endif
          `
         endif
         `
        endif
        `
        rem NEXT MARKER?
        dec ttrailindex : if ttrailindex<1 then ttrailindex=100
        inc tcount
        `
       endwhile
       if tcount<100
        rem if point is good to go, go to it
        if playertrial(ttrailindex).time>0
         `
         rem GOOD MARKER FOUND
         rem However when FOLLOWPLR called next, it will follow index+1, so..
         dec ttrailindex : if ttrailindex<1 then ttrailindex=100
         entityelement(e).plrtrailindex=ttrailindex
         `
        else
         rem NO GOOD MARKER FOUND
         entityelement(e).plrtrailindex=0
        endif
       else
        rem could not find any markers in trail
        entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
       endif
      endif
      `
      rem if debug, show which trail marker by flashing it
      if gshowdebugtextingamestate=1
       if entityelement(e).plrtrailindex>0
        ttrailindex=entityelement(e).plrtrailindex+1
        if ttrailindex>100 then ttrailindex=1
        tdobj=gamdebugobjoffset+ttrailindex
        if object exist(tdobj)=1
         position object tdobj,object position x(tdobj),entityelement(e).y+rnd(20),object position z(tdobj)
        endif
       endif
      endif
      `
     endcase
     `
     case AIACTPLRTAKE:
       `
       rem send trigger signal to sync players (multiplayer)
       if gmultiplayergame=1
        mptrigger=1 : mptriggervalue1=e
        gosub _multi_mptrigger
       endif
       `
       rem if child of spawn leader, reset spawn count
       spawne=entityelement(e).spawn.leaderid
       if spawne=0 then spawne=e
       entityelement(spawne).spawn.leadercount=entityelement(spawne).spawn.delay
       `
       rem switch off obj
       if obj>0
        gosub _physics_switchoffe
        hide object obj
        set object collision off obj
       endif
       rem stop any looping sound
       gosub _ai_stopentsounds
       rem reset values
       `entityelement(e).beenkilled=1
       gosub _entity_setbeenkilledflag
       entityelement(e).active=0
       rem clear entity from col map
       tx=entityelement(e).x/25
       ty=entityelement(e).y/100
       tz=entityelement(e).z/-25
       if tx>=0 and ty>=0 and tz>=0
        if tx<=viscolx and ty<=viscoly and tz<=viscolz
         if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0
        endif
       endif
       `
       rem mission objective counter
       gosub _entity_resolveobjective
       `
       rem only allow weapons
       pi=player(1).inventorymax : inc pi
       if pi<100
        playerinventory(1,pi).new=1
        playerinventory(1,pi).index=e
        player(1).inventorymax=pi
       endif
       `
     endcase
     case AIACTPLRDROP:
      entityelement(e).x=mex# : rem whoever had it
      entityelement(e).y=mey#-40
      entityelement(e).z=mez#
      entityelement(e).active=1
      gosub _entity_controlrecalcdist
      if obj>0
       position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
       set object collision on obj
       show object obj
      endif
      rem in case drop originated outside (not .drop=x)
      for pi=1 to player(1).inventorymax
       if playerinventory(1,pi).index=e then player(1).command.drop=pi : exit
      next pi
     endcase
     `
     case AIACTSHOOTPLR:
      rem replace with shoot sequence
      trundefaultscriptinternal=1
      trundefaultscript=1+entityelement(e).ai.libshoot
      conindex=ailist(aiindex).conditionlast
      seq=aiaction(actindex).last
      exit
     endcase
     `
     case AIACTUSEWEAPON:
      rem fire weapon (entity may have)
      tgunid=entityelement(e).currentweapon
      if tgunid>0
       if entityelement(e).currentammo>0 or gun(tgunid).settings.reloadqty=0
        if entityelement(e).currentammo>0
         entityelement(e).currentammo=entityelement(e).currentammo-1
        endif
        entityelement(e).fireweapon=1
       endif
      else
       rem enemy has no weapon to use, so use melee strike (11)
       entityelement(e).fireweapon=101
      endif
     endcase
     case AIACTRELOADWEAPON:
      tgunid=entityelement(e).currentweapon
      if tgunid>0
       tneedfromclip=gun(tgunid).settings.reloadqty-entityelement(e).currentammo
       if tneedfromclip>0
        entityelement(e).currentammo=gun(tgunid).settings.reloadqty
        entityelement(e).currentclipammo=entityelement(e).currentclipammo-tneedfromclip
       endif
      endif
     endcase
     `
     case AIACTDODARKAI:
      aiobjidaction=0 : aiobjidvalue=aiactionseq(seq).value
      gosub _aiss_fpi_doaction
     endcase
     case AIACTDODARKAIANIM:
      aiobjidaction=1
      gosub _aiss_fpi_doaction
     endcase
     `
     case AIACTCOLOFF:
      if obj>0
       `
       rem send trigger signal to sync players (multiplayer)
       if gmultiplayergame=1 then mptrigger=2 : mptriggervalue1=e : gosub _multi_mptrigger
       `
       entityelement(e).collisionactive=0
       if entityelement(e).eleprof.physics<>0
        gosub _physics_switchoffe
       else
        set object collision off obj
       endif
      endif
     endcase
     case AIACTCOLON:
      if obj>0
       `
       rem send trigger signal to sync players (multiplayer)
       if gmultiplayergame=1 then mptrigger=2 : mptriggervalue1=e : gosub _multi_mptrigger
       `
       rem entity collision solid
       entityelement(e).collisionactive=1
       rem activate object collision
       if entityelement(e).eleprof.physics<>0
        gosub _physics_setupewithphysics
        gosub _physics_ensureeisnotpenetrated
       else
        set object collision on obj
       endif
       rem ensure plr is pushed out of entity influence
       tdx#=mex#-entityelement(e).x
       tdz#=mez#-entityelement(e).z
       tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
       if tdd#<30.0
        tda#=atanfull(tdx#,tdz#)
        camforcex#=newxvalue(entityelement(e).x,tda#,30.0)-camerapositionx
        camforcez#=newzvalue(entityelement(e).z,tda#,30.0)-camerapositionz
       endif
       rem ensure ALL entities are pushed out of entity influence (this is why second door zoomed away)
       for te=1 to entityelementlist
        if entityelement(te).active=1 and entityelement(te).eleprof.physics<=2
         if entityelement(te).eleprof.isimmobile=0
          tdx#=entityelement(te).x-entityelement(e).x
          tdz#=entityelement(te).z-entityelement(e).z
          tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
          if tdd#<30.0
           rem TE-entity within solid entity
           tda#=atanfull(tdx#,tdz#)
           entityelement(te).mover.dx=newxvalue(entityelement(e).x,tda#,30.0)
           entityelement(te).mover.dz=newzvalue(entityelement(e).z,tda#,30.0)
           entityelement(te).mover.dy=entityelement(e).y
           entityelement(te).mover.moved=1
           entityelement(te).mover.run=0
          endif
         endif
        endif
       next te
      endif
     endcase
     case AIACTSPAWNON:
      entityelement(e).spawn.atstart=1
     endcase
     case AIACTSPAWNOFF:
      entityelement(e).spawn.atstart=0
     endcase
     `
     case AIACTAMBIENCE:
      guivisualsettings.ambience=aiactionseq(seq).value
      forceambientlightsetting=10
      gosub _lighting_postdefaults
     endcase
     case AIACTAMBIENCERED:
      hudambiencered=aiactionseq(seq).value
      color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue)
     endcase
     case AIACTAMBIENCEGREEN:
      hudambiencegreen=aiactionseq(seq).value
      color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue)
     endcase
     case AIACTAMBIENCEBLUE:
      hudambienceblue=aiactionseq(seq).value
      color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue)
     endcase
     case AIACTFOG:
      if aiactionseq(seq).value>0
       fog on
       hudfogon=1
       hudfognear(waterisbelowplayer-1)=aiactionseq(seq).value
       hudfogfar=hudfognear(waterisbelowplayer-1)+(hudfognear(waterisbelowplayer-1)*2)
       fog distance hudfognear(waterisbelowplayer-1),hudfogfar
       fog color hudfogred(waterisbelowplayer-1),hudfoggreen(waterisbelowplayer-1),hudfogblue(waterisbelowplayer-1)
      else
       fog off
       hudfogon=0
      endif
     endcase
     case AIACTFOGRED:
      hudfogred(waterisbelowplayer-1)=aiactionseq(seq).value
      fog color hudfogred(waterisbelowplayer-1),hudfoggreen(waterisbelowplayer-1),hudfogblue(waterisbelowplayer-1)
     endcase
     case AIACTFOGGREEN:
      hudfoggreen(waterisbelowplayer-1)=aiactionseq(seq).value
      fog color hudfogred(waterisbelowplayer-1),hudfoggreen(waterisbelowplayer-1),hudfogblue(waterisbelowplayer-1)
     endcase
     case AIACTFOGBLUE:
      hudfogblue(waterisbelowplayer-1)=aiactionseq(seq).value
      fog color hudfogred(waterisbelowplayer-1),hudfoggreen(waterisbelowplayer-1),hudfogblue(waterisbelowplayer-1)
     endcase
     case AIACTSKY:
      rem Already done during loading of AI-Asset
     endcase
     case AIACTSKYSCROLL:
      rem Already done during loading of AI-Asset
     endcase
     `
     `
     `
     case AIACTEFFECTAMBIENCE:
      guivisualsettings.ambience=aiactionseq(seq).value
      if guivisualsettings.ambience<0 then guivisualsettings.ambience=0
      if guivisualsettings.ambience>100 then guivisualsettings.ambience=100
      guivisualsettings.updateflag=1
     endcase
     case AIACTEFFECTINCAMBIENCE:
      guivisualsettings.ambience=guivisualsettings.ambience+aiactionseq(seq).value
      if guivisualsettings.ambience>entityelement(e).eleprof.ex.factor then guivisualsettings.ambience=entityelement(e).eleprof.ex.factor
      guivisualsettings.updateflag=1
     endcase
     case AIACTEFFECTDECAMBIENCE:
      guivisualsettings.ambience=guivisualsettings.ambience-aiactionseq(seq).value
      if guivisualsettings.ambience<entityelement(e).eleprof.ex.factor then guivisualsettings.ambience=entityelement(e).eleprof.ex.factor
      guivisualsettings.updateflag=1
     endcase
     case AIACTEFFECTFOGRANGE:
      hudfognear(waterisbelowplayer-1)=4000-(aiactionseq(seq).value*40)
     endcase
     case AIACTEFFECTINCFOGRANGE:
      hudfognear(waterisbelowplayer-1)=hudfognear(waterisbelowplayer-1)+(aiactionseq(seq).value*40)
      if hudfognear(waterisbelowplayer-1)>entityelement(e).eleprof.ex.factor then hudfognear(waterisbelowplayer-1)=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECFOGRANGE:
      hudfognear(waterisbelowplayer-1)=hudfognear(waterisbelowplayer-1)-(aiactionseq(seq).value*40)
      if hudfognear(waterisbelowplayer-1)<entityelement(e).eleprof.ex.factor then hudfognear(waterisbelowplayer-1)=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTBLOOMSIZE:
      hudbloomwidth(waterisbelowplayer-1)=aiactionseq(seq).value
     endcase
     case AIACTEFFECTINCBLOOMSIZE:
      hudbloomwidth(waterisbelowplayer-1)=hudbloomwidth(waterisbelowplayer-1)+aiactionseq(seq).value
      if hudbloomwidth(waterisbelowplayer-1)>entityelement(e).eleprof.ex.factor then hudbloomwidth(waterisbelowplayer-1)=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECBLOOMSIZE:
      hudbloomwidth(waterisbelowplayer-1)=hudbloomwidth(waterisbelowplayer-1)-aiactionseq(seq).value
      if hudbloomwidth(waterisbelowplayer-1)<entityelement(e).eleprof.ex.factor then hudbloomwidth(waterisbelowplayer-1)=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTBLOOMSTR:
      hudbloomstrength(waterisbelowplayer-1)=aiactionseq(seq).value
      if hudbloomstrength(waterisbelowplayer-1)<1 then hudbloomstrength(waterisbelowplayer-1)=1
     endcase
     case AIACTEFFECTINCBLOOMSTR:
      hudbloomstrength(waterisbelowplayer-1)=hudbloomstrength(waterisbelowplayer-1)+aiactionseq(seq).value
      if hudbloomstrength(waterisbelowplayer-1)>entityelement(e).eleprof.ex.factor then hudbloomstrength(waterisbelowplayer-1)=entityelement(e).eleprof.ex.factor
      if hudbloomstrength(waterisbelowplayer-1)<1 then hudbloomstrength(waterisbelowplayer-1)=1
     endcase
     case AIACTEFFECTDECBLOOMSTR:
      hudbloomstrength(waterisbelowplayer-1)=hudbloomstrength(waterisbelowplayer-1)-aiactionseq(seq).value
      if hudbloomstrength(waterisbelowplayer-1)<entityelement(e).eleprof.ex.factor then hudbloomstrength(waterisbelowplayer-1)=entityelement(e).eleprof.ex.factor
      if hudbloomstrength(waterisbelowplayer-1)<1 then hudbloomstrength(waterisbelowplayer-1)=1
     endcase
     case AIACTEFFECTWATERSPEED:
      hudwaterspeed=aiactionseq(seq).value
     endcase
     case AIACTEFFECTINCWATERSPEED:
      hudwaterspeed=hudwaterspeed+aiactionseq(seq).value
      if hudwaterspeed>entityelement(e).eleprof.ex.factor then hudwaterspeed=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECWATERSPEED:
      hudwaterspeed=hudwaterspeed-aiactionseq(seq).value
      if hudwaterspeed<entityelement(e).eleprof.ex.factor then hudwaterspeed=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTWATERSMOOTH:
      hudwaterdepth=aiactionseq(seq).value
     endcase
     case AIACTEFFECTINCWATERSMOOTH:
      hudwaterdepth=hudwaterdepth+aiactionseq(seq).value
      if hudwaterdepth>entityelement(e).eleprof.ex.factor then hudwaterdepth=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECWATERSMOOTH:
      hudwaterdepth=hudwaterdepth-aiactionseq(seq).value
      if hudwaterdepth<entityelement(e).eleprof.ex.factor then hudwaterdepth=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTWATERCOLORR:
      rem reserved
     endcase
     case AIACTEFFECTWATERCOLORG:
      rem reserved
     endcase
     case AIACTEFFECTWATERCOLORB:
      rem reserved
     endcase
     case AIACTEFFECTUNDERWATERCOLORR:
      rem reserved
     endcase
     case AIACTEFFECTUNDERWATERCOLORG:
      rem reserved
     endcase
     case AIACTEFFECTUNDERWATERCOLORB:
      rem reserved
     endcase
     case AIACTEFFECTWATERREFLECTION:
      hudwaterrefl=aiactionseq(seq).value
     endcase
     case AIACTEFFECTINCWATERREFLECTION:
      hudwaterrefl=hudwaterrefl+aiactionseq(seq).value
      if hudwaterrefl>entityelement(e).eleprof.ex.factor then hudwaterrefl=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECWATERREFLECTION:
      hudwaterrefl=hudwaterrefl-aiactionseq(seq).value
      if hudwaterrefl<entityelement(e).eleprof.ex.factor then hudwaterrefl=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTWATERREFRACTION:
      hudwaterrefr=aiactionseq(seq).value
     endcase
     case AIACTEFFECTINCWATERREFRACTION:
      hudwaterrefr=hudwaterrefr+aiactionseq(seq).value
      if hudwaterrefr>entityelement(e).eleprof.ex.factor then hudwaterrefr=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECWATERREFRACTION:
      hudwaterrefr=hudwaterrefr-aiactionseq(seq).value
      if hudwaterrefr<entityelement(e).eleprof.ex.factor then hudwaterrefr=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTWATERFRESNEL:
      hudwaterfresnel=aiactionseq(seq).value
     endcase
     case AIACTEFFECTINCWATERFRESNEL:
      hudwaterfresnel=hudwaterfresnel+aiactionseq(seq).value
      if hudwaterfresnel>entityelement(e).eleprof.ex.factor then hudwaterfresnel=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECWATERFRESNEL:
      hudwaterfresnel=hudwaterfresnel-aiactionseq(seq).value
      if hudwaterfresnel<entityelement(e).eleprof.ex.factor then hudwaterfresnel=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTWATERLEVEL:
      waterlevel#=aiactionseq(seq).value
      tchangethewaterclipping=2
     endcase
     case AIACTEFFECTINCWATERLEVEL:
      waterlevel#=waterlevel#+aiactionseq(seq).value
      if waterlevel#>entityelement(e).eleprof.ex.factor then waterlevel#=entityelement(e).eleprof.ex.factor
      tchangethewaterclipping=2
     endcase
     case AIACTEFFECTDECWATERLEVEL:
      waterlevel#=waterlevel#-aiactionseq(seq).value
      if waterlevel#<entityelement(e).eleprof.ex.factor then waterlevel#=entityelement(e).eleprof.ex.factor
      tchangethewaterclipping=2
     endcase
     case AIACTEFFECTSHADOWSTR:
      hudshadowstrength=aiactionseq(seq).value
     endcase
     case AIACTEFFECTINCSHADOWSTR:
      hudshadowstrength=hudshadowstrength+aiactionseq(seq).value
      if hudshadowstrength>entityelement(e).eleprof.ex.factor then hudshadowstrength=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECSHADOWSTR:
      hudshadowstrength=hudshadowstrength-aiactionseq(seq).value
      if hudshadowstrength<entityelement(e).eleprof.ex.factor then hudshadowstrength=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTSHADOWQTY:
      hudshadowquantity=aiactionseq(seq).value
     endcase
     case AIACTEFFECTINCSHADOWQTY:
      hudshadowquantity=hudshadowquantity+aiactionseq(seq).value
      if hudshadowquantity>entityelement(e).eleprof.ex.factor then hudshadowquantity=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECSHADOWQTY:
      hudshadowquantity=hudshadowquantity-aiactionseq(seq).value
      if hudshadowquantity<entityelement(e).eleprof.ex.factor then hudshadowquantity=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTWINDOWREFRACTION:
      hudglassrefr=aiactionseq(seq).value
     endcase
     case AIACTEFFECTINCWINDOWREFRACTION:
      hudglassrefr=hudglassrefr+aiactionseq(seq).value
      if hudglassrefr>entityelement(e).eleprof.ex.factor then hudglassrefr=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTEFFECTDECWINDOWREFRACTION:
      hudglassrefr=hudglassrefr-aiactionseq(seq).value
      if hudglassrefr<entityelement(e).eleprof.ex.factor then hudglassrefr=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTVOLUMEINGAMEMUSIC:
      hudmusicvolume=aiactionseq(seq).value
      volumemeter(2)=hudmusicvolume
     endcase
     case AIACTVOLUMEINCINGAMEMUSIC:
      hudmusicvolume=hudmusicvolume+aiactionseq(seq).value
      if hudmusicvolume>entityelement(e).eleprof.ex.factor then hudmusicvolume=entityelement(e).eleprof.ex.factor
      volumemeter(2)=hudmusicvolume
     endcase
     case AIACTVOLUMEDECINGAMEMUSIC:
      hudmusicvolume=hudmusicvolume-aiactionseq(seq).value
      if hudmusicvolume<entityelement(e).eleprof.ex.factor then hudmusicvolume=entityelement(e).eleprof.ex.factor
      volumemeter(2)=hudmusicvolume
     endcase
     case AIACTVOLUMEPLAYERSOUNDS:
      volumemeter(3)=aiactionseq(seq).value
     endcase
     case AIACTVOLUMEINCPLAYERSOUNDS:
      volumemeter(3)=volumemeter(3)+aiactionseq(seq).value
      if volumemeter(3)>entityelement(e).eleprof.ex.factor then volumemeter(3)=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTVOLUMEDECPLAYERSOUNDS:
      volumemeter(3)=volumemeter(3)-aiactionseq(seq).value
      if volumemeter(3)<entityelement(e).eleprof.ex.factor then volumemeter(3)=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTVOLUMEINGAMESOUNDS:
      volumemeter(4)=aiactionseq(seq).value
     endcase
     case AIACTVOLUMEINCINGAMESOUNDS:
      volumemeter(4)=volumemeter(4)+aiactionseq(seq).value
      if volumemeter(4)>entityelement(e).eleprof.ex.factor then volumemeter(4)=entityelement(e).eleprof.ex.factor
     endcase
     case AIACTVOLUMEDECINGAMESOUNDS:
      volumemeter(4)=volumemeter(4)-aiactionseq(seq).value
      if volumemeter(4)<entityelement(e).eleprof.ex.factor then volumemeter(4)=entityelement(e).eleprof.ex.factor
     endcase
     `
     `
     `
     case AIACTBACKDROP:
      if aiactionseq(seq).value>0
       set sprite 65534,0,0
       sprite 65534,-10000,-10000,aiactionseq(seq).value
       size sprite 65534,screen width(),screen height()
       if gmultiplayergame=1
        rem multiplayer title screen requires immediate backdrop writing
        paste sprite 65534,0,0,1 : rem flag to draw immediately
       else
        rem standalone single player title screen cannot have immediate backdrop drawn
        paste sprite 65534,0,0 : rem 130907 - above caused backdrop to overrite buttons
       endif
      endif
     endcase
     case AIACTMUSIC:
      if lastmusicplayed>0
       if sound exist(lastmusicplayed)=1 then stop sound lastmusicplayed
       lastmusicplayed=0
      endif
      newmusictoplay=0
      if aiactionseq(seq).value=-1
       newmusictoplay=entityelement(e).soundset
      else
       if aiactionseq(seq).value=-2
        newmusictoplay=entityelement(e).soundset1
       else
        newmusictoplay=aiactionseq(seq).value
       endif
      endif      
      if newmusictoplay=0
       rem play first music if no music to play
       if firstmusicplayed>0
        rem X10 V106 - added to avoid trying to play deleted music
        if sound exist(firstmusicplayed)=1
         newmusictoplay=firstmusicplayed
        endif
       endif
      endif
      if newmusictoplay>0
       if sound exist(newmusictoplay)=1
        loop sound newmusictoplay
        set sound volume newmusictoplay,67+(hudmusicvolume/3)       
        lastmusicplayed=newmusictoplay
        if firstmusicplayed=0 then firstmusicplayed=newmusictoplay
       endif
      endif
     endcase
     case AIACTMUSICVOLUME:
      hudmusicvolume=aiactionseq(seq).value
      if lastmusicplayed>0
       if sound exist(lastmusicplayed)=1
        set sound volume lastmusicplayed,67+(hudmusicvolume/3)       
       endif
      endif
     endcase
     case AIACTSOUNDSCALE:
      tmp#=aiactionseq(seq).value
      tmp#=tmp#/200.0 : scale listener tmp#
     endcase
     `
     case AIACTVIDEO:
      videofilename$=""
      if aiactionseq(seq).value=-1
       videofilename$=entityelement(e).eleprof.soundset$
      else
       if aiactionseq(seq).value=-2
        videofilename$=entityelement(e).eleprof.soundset1$
       else
        tstringindex=aiactionseq(seq).value
        if tstringindex>0
         videofilename$=actstring$(tstringindex)
        endif
       endif
      endif
      if videofilename$<>""
       if file exist(myownrootdir$+videofilename$)=1
        lastvideoplayed=1
        rem X10 uses playback feature for storyzone
        start playback myownrootdir$+videofilename$,1.0
        sync mask %0
        while playback playing()=1
         if escapekey()=1 then exit
         if spacekey()=1 then exit
         if mouseclick()<>0 then exit
         update playback
         sync
        endwhile
        while escapekey()=1 or spacekey()=1 or mouseclick()<>0 : sync : endwhile
        stop playback
        sync mask %1
        remstart X9
        load animation videofilename$,lastvideoplayed
        play animation lastvideoplayed,0,0,screen width(),screen height()
        while animation playing(lastvideoplayed)=1
         if escapekey()=1 then exit
         if spacekey()=1 then exit
         if mouseclick()<>0 then exit
         sync
        endwhile
        while escapekey()=1 or spacekey()=1 or mouseclick()<>0 : sync : endwhile
        delete animation lastvideoplayed
        remend
        lastvideoplayed=0
        tensureentitytimestampsupdated=1
       endif
      endif
     endcase
     `
     case AIACTLIGHTON:
      entityelement(e).eleprof.light.islit=1
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).islit=1
      endif
     endcase
     case AIACTLIGHTOFF:
      entityelement(e).eleprof.light.islit=0
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).islit=0
      endif
     endcase
     case AIACTLIGHTRED:
      dw=entityelement(e).eleprof.light.color
      entityelement(e).eleprof.light.color=rgb(aiactionseq(seq).value,rgbg(dw),rgbb(dw))
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).colrgb.r=aiactionseq(seq).value
      endif
     endcase
     case AIACTLIGHTGREEN:
      dw=entityelement(e).eleprof.light.color
      entityelement(e).eleprof.light.color=rgb(rgbr(dw),aiactionseq(seq).value,rgbb(dw))
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).colrgb.g=aiactionseq(seq).value
      endif
     endcase
     case AIACTLIGHTBLUE:
      dw=entityelement(e).eleprof.light.color
      entityelement(e).eleprof.light.color=rgb(rgbr(dw),rgbg(dw),aiactionseq(seq).value)
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).colrgb.b=aiactionseq(seq).value
      endif
     endcase
     case AIACTLIGHTRANGE:
      entityelement(e).eleprof.light.range=aiactionseq(seq).value
      if gdynamiclightingstate=1
       infinilight(entityelement(e).eleprof.light.index).range=aiactionseq(seq).value
      endif
     endcase
     `
     case AIACTHUDRESET:
      workhudx=0 : workhudy=0 : workhudz=0
      workhudsizex=0 : workhudsizey=0 : workhudsizez=0
      workhudred=255 : workhudgreen=255 : workhudblue=255 : workhudimage=0
      workhudfont$="" : workhudsize=0 : workhudtext$=""
      workhudtype=0 : workhudmake$=""
      workhudname$=""
      workhudhide=0
     endcase
     case AIACTHUDX:
      workhudx=(gdisplaywidth/100.0)*aiactionseq(seq).value
     endcase
     case AIACTHUDY:
      workhudy=(gdisplayheight/100.0)*aiactionseq(seq).value
     endcase
     case AIACTHUDZ:
      workhudz=aiactionseq(seq).value
     endcase
     case AIACTHUDSIZEX:
      workhudsizex=aiactionseq(seq).value
     endcase
     case AIACTHUDSIZEY:
      workhudsizey=aiactionseq(seq).value
     endcase
     case AIACTHUDSIZEZ:
      workhudsizez=aiactionseq(seq).value
     endcase
     case AIACTHUDRED:
      workhudred=aiactionseq(seq).value
     endcase
     case AIACTHUDGREEN:
      workhudgreen=aiactionseq(seq).value
     endcase
     case AIACTHUDBLUE:
      workhudblue=aiactionseq(seq).value
     endcase
     case AIACTHUDIMAGE:
      workhudimage=aiactionseq(seq).value
     endcase
     case AIACTHUDIMAGEFINE:
      workhudimage=aiactionseq(seq).value
     endcase
     case AIACTHUDFONT:
      tindex=aiactionseq(seq).value
      workhudfont$=actstring$(tindex)
     endcase
     case AIACTHUDSIZE:
      workhudsize=aiactionseq(seq).value
     endcase
     case AIACTHUDTEXT:
      tindex=aiactionseq(seq).value
      workhudtext$=actstring$(tindex)
     endcase
     case AIACTHUDTYPE:
      workhudtype=aiactionseq(seq).value
     endcase
     case AIACTHUDHIDE:
      workhudhide=aiactionseq(seq).value
     endcase
     case AIACTHUDSHOW:
      tindex=aiactionseq(seq).value
      tworkhudshow$=actstring$(tindex)
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(tworkhudshow$)
        hud(thudid).hide=0
        if hud(thudid).maintype=8
         if hud(thudid).typemode>=20
          hud(thudid).typemode=hud(thudid).typemode-20
         endif
         clear entry buffer
         `x9set text size 30
         set text size 24
        endif
       endif
      next thudid
     endcase
     case AIACTHUDUNSHOW:
      tindex=aiactionseq(seq).value
      tworkhudshow$=actstring$(tindex)
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(tworkhudshow$)
        hud(thudid).hide=1
       endif
      next thudid
     endcase
     case AIACTHUDNAME:
      tindex=aiactionseq(seq).value
      workhudname$=actstring$(tindex)
     endcase
     case AIACTHUDANIM:
      workhudimage=aiactionseq(seq).value
     endcase
     case AIACTHUDFADEOUT:
      tindex=aiactionseq(seq).value
      tworkhudshow$=actstring$(tindex)
      for thudid=1 to hudmax
       if lower$(hud(thudid).name$)=lower$(tworkhudshow$)
        hud(thudid).fadeout=150
       endif
      next thudid
     endcase
     case AIACTHUDMAKE:
      tindex=aiactionseq(seq).value
      workhudmake$=actstring$(tindex)
      gosub _ai_hud_add
     endcase
     `
     case AIACTNEWGAME:
      rem Continue Only
      continueokay=1
     endcase
     case AIACTLOADGAME:
      rem Continue And Load
      saveload.loadswitch=1
      saveloadfile$=""
      position mouse screen width()/2,(screen height()/4)*3.5
      cleardelta=mousemovex() : cleardelta=mousemovey()
      gosub _saveload_maindialogloop
      if saveloadfile$<>""
       rem Load level from scratch (using loadsavedlevel$)
       loadsavedlevel$=saveloadfile$ : saveloadfile$=""
       continueokay=1 : levelwon=3
      endif
      position mouse screen width()/2,(screen height()/4)*3.5
      cleardelta=mousemovex() : cleardelta=mousemovey()
      hudselectionmade=0
      rem X10 - 131007 - this ensures physics calculations only start from here
      gosub _physics_ensurephysicsisreset
     endcase
     case AIACTSAVEGAME:
      rem Continue And Save
      saveload.loadswitch=0
      saveloadfile$=""
      position mouse screen width()/2,(screen height()/4)*3.5
      cleardelta=mousemovex() : cleardelta=mousemovey()
      gosub _saveload_maindialogloop
      if saveloadfile$<>""
       rem Save the current game position using 'saveloadfile$'
       gosub _saveload_savegame
       saveloadfile$=""
      endif
      while mouseclick()<>0 : endwhile
      position mouse screen width()/2,(screen height()/4)*3.5
      cleardelta=mousemovex() : cleardelta=mousemovey()
      hudselectionmade=0
      rem X10 - 131007 - this ensures physics calculations only start from here
      gosub _physics_ensurephysicsisreset
     endcase
     case AIACTQUICKLOADGAME:
      rem Quick Load no prompt
      if gtestgamemodefromeditor=0
       saveloadfile$="gamesaves\slot"+str$(1)+".dat"
       if file exist(saveloadfile$)=1
        saveload.loadswitch=1
        loadsavedlevel$=saveloadfile$
        continueokay=1 : levelwon=3
        hudselectionmade=0
       endif
       saveloadfile$=""
      endif
     endcase
     case AIACTQUICKSAVEGAME:
      rem Quick Save no prompt
      if gtestgamemodefromeditor=0
       gosub _saveload_savebox_earlygrab
       gosub _saveload_savebox_initlist
       saveload.loadswitch=0
       saveload.slotselected=1
       gosub _saveload_savebox_dosave
       gosub _saveload_savegame
       hudselectionmade=0
       saveloadfile$=""
      endif
     endcase
     case AIACTCONTINUEGAME:
      rem Continue And Leave Level
      continueokay=1 : levelwon=2
     endcase
     case AIACTQUITGAME:
      rem Continue And Quit Out
      continueokay=1 : loopapp=0 : levelwon=2
     endcase
     case AIACTPAUSEGAME:
      rem User pressed ESCAPE, and is now in pause mode
      gosub _saveload_savebox_earlygrab
      position mouse screen width()/2,(screen height()/4)*3
      hudselectionmade=0 : ttemp=mouseclick()
      showgamemenu=1
     endcase
     case AIACTRESUMEGAME:
      showgamemenu=0
      while mouseclick()<>0 : endwhile
      cleardelta=mousemovex() : cleardelta=mousemovey()
      tensureentitytimestampsupdated=1
      rem X10 - 131007 - this ensures physics calculations only start from here
      gosub _physics_ensurephysicsisreset
     endcase
     case AIACTHOSTGAME:
      createorjoin=1
      gmultiplayergame=1
     endcase
     case AIACTJOINGAME:
      createorjoin=2
      gmultiplayergame=1
     endcase
     case AIACTREPEATGAME:
      rem flag a repeat of the game (without reloading then remove comments)
      repeatsamelevel=1
     endcase
     case AIACTTIMERSTART:
      hudtimer=timer()
     endcase
     `
     `
     `
    endselect
    `
   next seq
   `
  else
   if gshowdebugtextingamestate=1
    if debugviewtog=1
     if aiconttimer<>0
      print strarr$(2);
     endif
    endif
   endif
  endif
  `
  if gshowdebugtextingamestate=1
   if debugviewtog=1
    if aiconttimer<>0
     print "."
    endif
   endif
  endif
  `
 rem next trigger
 next conindex
 `
 if tensureentitytimestampsupdated=1
  tensureentitytimestampsupdated=0
  for ttse=1 to entityelementlist
   if entityelement(ttse).active=1
    entityelement(ttse).logictimestamp=timer()
   endif
  next ttse
  timestamp=timer()
 endif
 `
endif

return

_ai_additionaldarkaientityraycast:
 `
 rem called within DODARKAISEEING and FIRING (so cannot see and fire through doors)
 if aiobjidvalue=0
  airesult=0
 else
  rem darkai has a target, fill in details
  gosub _aiss_gettargetforshooting
  rem X10 - 231007 - ghost or fly precludes a target being player
  if gghostrunmode=1 or gcameraflymode=1
   if targetID=physicsplayerborble then targetID=0
  endif
  if targetID>0
   if object exist(targetID)=1
    tmpx#=entityelement(e).x
    tmpy#=entityelement(e).y+30
    tmpz#=entityelement(e).z
    ttox#=object position x(targetID)
    ttoy#=object position y(targetID)
    ttoz#=object position z(targetID)
    toisobj=entityelement(e).obj
    t=1
    if toisobj>0 
     if object visible(toisobj)=0
      t=0
     endif
    endif
    if t=1
     tvisibility=0 : gosub _entity_determinevisibility
    else
     if rnd(50)=1
      rem X10 - 111007 - if not in screen, reduce vis cast to one in 50
      tvisibility=0 : gosub _entity_determinevisibility
     else
      tvisibility=0
     endif
    endif
    if tvisibility=1
     if tvisibilityifbreak>0
      rem replace target value for this cod  destroy breabable interfering entity
      if object exist(entityobjectoffset+tvisibilityifbreak)=1
       targetID=entityobjectoffset+tvisibilityifbreak
      endif
     endif
    endif
    if tvisibility=1
     if targetID=physicsplayerborble
      entityelement(e).actualtarget=1
      entityelement(e).actualtargetx=object position x(targetID)
      entityelement(e).actualtargety=object position y(targetID)
      entityelement(e).actualtargetz=object position z(targetID)
     else
      entityelement(e).actualtarget=1+(targetID-entityobjectoffset)
      entityelement(e).actualtargetx=object position x(targetID)
      entityelement(e).actualtargety=object position y(targetID)
      entityelement(e).actualtargetz=object position z(targetID)
     endif
    else
     rem X10 - 130807 - if not visible line of sight, no shoot
     airesult=0
    endif
   endif
  else
   entityelement(e).actualtarget=-1
  endif       
 endif
 `
return

_ai_load:

rem FPSCV10X : Ensure AILIST is large enough
if aiindex>=array count(ailist(0))
 dim ailist(aiindex+32) as ailiblisttype
endif

rem If not loaded, load it
if ailist(aiindex).loaded=0

rem Load AI Script
gosub _ai_loaddata

rem Only if AI data exists
desc$=ailist(aiindex).desc$
if desc$<>""
 `
 rem Go through actions to look for required resources
 for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
  actindex=aicond(conindex).action
  for seq=aiaction(actindex).first to aiaction(actindex).last
   select aiactionseq(seq).type
    case AIACTRUNFPI:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      aifile$=tfile$ : gosub _ai_findlibindex
      aiactionseq(seq).value=libindex
     endif
    endcase
    case AIACTSOUND:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if file exist(rootdir$+tfile$)=1 or file exist(myownrootdir$+tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(rootdir$+tfile$,0)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(rootdir$+tfile$,0)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACT3DSOUND:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if file exist(rootdir$+tfile$)=1 or file exist(myownrootdir$+tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(rootdir$+tfile$,1)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(rootdir$+tfile$,1)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTLOOPSOUND:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="$0"
       aiactionseq(seq).value=-1
      else
       if tfile$="$1"
        aiactionseq(seq).value=-2
       else
        if file exist(rootdir$+tfile$)=1 or file exist(myownrootdir$+tfile$)=1
         addfiletocollection(tfile$)
         aiactionseq(seq).value=loadinternalsoundcore(rootdir$+tfile$,1)
         if aiactionseq(seq).value=0
          tfile$="languagebank\"+language$+"\"+tfile$
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(rootdir$+tfile$,1)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTMUSIC:
     aiactionseq(seq).value=0
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      if tfile$="0"
       aiactionseq(seq).value=0
      else
       if tfile$="$0"
        aiactionseq(seq).value=-1
       else
        if tfile$="$1"
         aiactionseq(seq).value=-2
        else
         if file exist(rootdir$+tfile$)=1 or file exist(myownrootdir$+tfile$)=1
          addfiletocollection(tfile$)
          aiactionseq(seq).value=loadinternalsoundcore(rootdir$+tfile$,0)
         endif
        endif
       endif
      endif
     endif
    endcase
    case AIACTVIDEO:
     aiactionseq(seq).value=0
     tfile$=aiactionseq(seq).filename
     if tfile$="$0"
      aiactionseq(seq).value=-1
     else
      if tfile$="$1"
       aiactionseq(seq).value=-2
      else
       if file exist(myownrootdir$+tfile$)=1
        inc actstringmax : dim actstring$(actstringmax)
        actstring$(actstringmax)=tfile$
        addfiletocollection(tfile$)
        aiactionseq(seq).value=actstringmax
       endif
      endif
     endif
    endcase
    `
    case AIACTSKY:
     sky$=aiactionseq(seq).filename
     if sky$<>""
      rem Load in sky
      gosub _sky_load
     endif
    endcase
    case AIACTSKYSCROLL:
     skyscroll$=aiactionseq(seq).filename
     if skyscroll$<>""
      rem Load in sky scroll texture
      if guseskystate=1
       if file exist(skyscroll$)=1
        addfiletocollection(skyscroll$)
        if object exist(65124)=0
         debugviewtext(-1,strarr$(4))
         make object plain 65124,9000,9000
         tskyscrollimg=loadinternalimagecompressquality(skyscroll$,5,1)
         texture object 65124,0,tskyscrollimg
         set object texture 65124,2,0
         rem hack - change to new command when DGSDK done!
`         set blend mapping on 65124,loadinternalimage("skybank\generic\skyportal.tga"),4,0
`         set blend mapping on 65124,loadinternalimage("skybank\generic\skyportal.tga"),10
         position object 65124,0,1000,0
         `set object transparency 65124,1
         set object transparency 65124,20
         set object collision off 65124
         xrotate object 65124,270
         set object light 65124,0
         set object cull 65124,0
         set object fog 65124,0
         rem X10 - object only for main scene, refract scene and reflect scene (and shadow in shadow scene)
         set object mask 65124,%110010,%0100,%10
         `
         rem now create a second UV data layer for static second texture (alphaportal)
         q#=1.0
         lock vertexdata for limb 65124,0
         set vertexdata uv 0,1,0,0
         set vertexdata uv 0,1,q#,0
         set vertexdata uv 1,1,0,0
         set vertexdata uv 2,1,q#,q#
         set vertexdata uv 3,1,0,0
         set vertexdata uv 4,1,0,q#
         set vertexdata uv 5,1,q#,q#
         unlock vertexdata
         `
        endif
       endif
      endif
     endif
    endcase
    case AIACTBACKDROP:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      addfiletocollection(tfile$)
      aiactionseq(seq).value=loadinternalimagequality(tfile$)
      if aiactionseq(seq).value=0
       tfile$="languagebank\"+language$+"\"+tfile$
       addfiletocollection(tfile$)
       aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
      endif
     endif
    endcase
    case AIACTHUDIMAGE:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      addfiletocollection(tfile$)
      aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
      if aiactionseq(seq).value=0
       tfile$="languagebank\"+language$+"\"+tfile$
       addfiletocollection(tfile$)
       aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
      endif
     endif
    endcase
    case AIACTHUDIMAGEFINE:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      addfiletocollection(tfile$)
      aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,0,1)
      if aiactionseq(seq).value=0
       tfile$="languagebank\"+language$+"\"+tfile$
       addfiletocollection(tfile$)
       aiactionseq(seq).value=loadinternalimagecompressquality(tfile$,5,1)
      endif
     endif
    endcase
    case AIACTHUDTEXT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDFONT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDSHOW:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDUNSHOW:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDNAME:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDANIM:
     tfile$=aiactionseq(seq).filename
     if tfile$<>""
      for tnum=0 to 10
       ttfile$=tfile$+str$(tnum)+".tga"
       addfiletocollection(ttfile$)
       tnumimg=loadinternalimagecompressquality(ttfile$,5,1)
       if tnum=0 then aiactionseq(seq).value=tnumimg
      next tnum
     endif
    endcase
    case AIACTHUDFADEOUT:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    case AIACTHUDMAKE:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
    case AIACTSETTARGETNAME:
     inc actstringmax : dim actstring$(actstringmax)
     actstring$(actstringmax)=aiactionseq(seq).filename
     aiactionseq(seq).value=actstringmax
    endcase
    `
   endselect
  next seq
  `
 next conindex
 `
rem no AI script exists endif
endif

rem AI has been delt with and loaded
ailist(aiindex).loaded=1

rem If not loaded, load above
endif

return

_ai_createentityreferences:

rem go through all AI, and link entitynames to entityelementsubscripts
for aiindex=1 to aiindexmaster
 desc$=ailist(aiindex).desc$
 if desc$<>""
  for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
   actindex=aicond(conindex).action
   for seq=aiaction(actindex).first to aiaction(actindex).last
    select aiactionseq(seq).type
     case AIACTPLRMOVETO:
      tname$=aiactionseq(seq).filename : gosub _entity_findname
      aiactionseq(seq).value=foundte
     endcase
    endselect
   next seq
  next conindex
 endif
next aiindex

return


_ai_free:

rem Only if AI data exists
desc$=ailist(aiindex).desc$
if desc$<>""
 for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
  actindex=aicond(conindex).action
  for seq=aiaction(actindex).first to aiaction(actindex).last
   select aiactionseq(seq).type
    case AIACTSOUND:
     if aiactionseq(seq).value>0
      stop sound aiactionseq(seq).value
     endif
    endcase
    case AIACTMUSIC:
     if aiactionseq(seq).value>0
      stop sound aiactionseq(seq).value
     endif
    endcase
   endselect
  next seq
 next conindex
endif

rem Free AI resource flag
ailist(aiindex).loaded=0

return

_ai_dividetriggerblock:

rem go through and get item from stringblock$
word$="" : value$=""
for c=1 to len(stringblock$)
 if mid$(stringblock$,c)="," or c=len(stringblock$)
  rem get one item in block
  if c=len(stringblock$)
   chunk$=stringblock$
  else
   chunk$=left$(stringblock$,c-1)
  endif
  stringblock$=right$(stringblock$,len(stringblock$)-(len(chunk$)+1))
  if len(chunk$)>0
   rem find equate seperator (or all otherwise)
   sep=0
   for c2=1 to len(chunk$)
    if mid$(chunk$,c2)="=" then sep=c2 : exit
    if c2=len(chunk$) then sep=c2+1 : exit
   next c2
   if sep>0
    `
    rem find word and value
    word$=lower$(removeedgespaces(left$(chunk$,sep-1)))
    value$=removeedgespaces(right$(chunk$,len(chunk$)-(len(word$)+1)))
    `
    rem reset value vars
    mid1=0 : mid2=0
    value1$=""
    value2$=""
    value3$=""
    `
    rem take value 1 2 3 from value
    for c=0 to len(value$)
     if mid$(value$,c)=" " and mid1=0 then mid1=c : exit
     if mid$(value$,c)=" " and mid1<>0 and mid2=0 then mid2=c : exit
    next c
    if mid1=0
     value1$=value$
    else
     if mid2=0
      value1$=left$(value$,mid1-1)
      value2$=right$(value$,len(value$)-(len(value1$)+1))
     else
      value1$=left$(value$,mid1-1)
      value2$=left$(right$(value$,mid1),(mid2-mid1)-1)
      value3$=right$(value$,len(value$)-mid2)
     endif
    endif
    `
    rem calculate values from value strings
    value1=val(value1$)
    value2=val(value2$)
    value3=val(value3$)
    `
   endif
  endif
  exit
 endif
next c

return

_ai_loaddata:

rem Ensure AI Script still exists
if file exist(myownrootdir$+aidir$+ai$)=1
`
rem About to add conditions
conindexfirst=conindexcount
`
rem Load AI Script Data from file
dim data$(150)
load array myownrootdir$+aidir$+ai$,data$()
addfiletocollection(aidir$+ai$)
for l=0 to 149
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem Field or Triggerline
   if left$(line$,1)<>":"
    `
    rem Standard Field Line
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem AI header
    if field$="desc" then ailist(aiindex).desc$=value$
    `
   else
    `
    rem AI Triggerline (slice line marked by leading colon:)
    cutline$=right$(line$,len(line$)-1)
    `
    rem find : seperator
    sep=0
    for c=1 to len(cutline$)
     if mid$(cutline$,c)=":" then sep=c : exit
    next c
    if sep>0
     `
     rem conditions collected
     conditions$=left$(cutline$,sep-1)
     cutline$=right$(cutline$,len(cutline$)-(len(conditions$)+1))
     rem now rest is actions
     if len(cutline$)>0
      rem actions collected
      actions$=cutline$
     endif
     `
     rem Parse through conditions
     aicondfirst=aicondseqcount
     stringblock$=conditions$
     while len(stringblock$)>0
      gosub _ai_dividetriggerblock
      for tindex=0 to AICONDLAST
       if word$=conword$(tindex)
        if aicondseqcount+10>array count(aiconditionseq()) then dim aiconditionseq(aicondseqcount+1000) as aiconditiontype
        aiconditionseq(aicondseqcount).type=tindex
        aiconditionseq(aicondseqcount).valuea=value1
        aiconditionseq(aicondseqcount).valueb=value2
        aiconditionseq(aicondseqcount).valuec=value3
        inc aicondseqcount
        exit
       endif
      next tindex
     endwhile
     if conindexcount+10>array count(aicond()) then dim aicond(conindexcount+100) as aiconditionitemtype
     aicond(conindexcount).first=aicondfirst
     aicond(conindexcount).last=aicondseqcount-1
     aicond(conindexcount).action=actindexcount
     inc conindexcount
     `
     rem Parse through actions
     aiactfirst=aiactseqcount
     stringblock$=actions$
     while len(stringblock$)>0
      gosub _ai_dividetriggerblock
      for tindex=0 to AIACTLAST
       if word$=actword$(tindex)
        if aiactseqcount+10>array count(aiactionseq()) then dim aiactionseq(aiactseqcount+1000) as aiactiontype
        aiactionseq(aiactseqcount).type=tindex
        aiactionseq(aiactseqcount).value=value1
        aiactionseq(aiactseqcount).filename=value$
        inc aiactseqcount
        exit
       endif
      next tindex
     endwhile
     if actindexcount+10>array count(aiaction()) then dim aiaction(actindexcount+100) as aiactionitemtype
     aiaction(actindexcount).first=aiactfirst
     aiaction(actindexcount).last=aiactseqcount-1
     inc actindexcount
     `
    endif
    `
   endif
  endif
 endif
next l
undim data$()
`
rem Finalise condition data values
conindexlast=conindexcount-1
ailist(aiindex).conditionfirst=conindexfirst
ailist(aiindex).conditionlast=conindexlast
`
rem File not exist endif
endif

return

_ai_scanfornewscriptsonly:

rem Reset count
aiindexmaster=0

rem Scan for scripts
oldir$=get dir$()
aidir$="scriptbank\"
empty array filelist$()
buildfilelist(myownrootdir$+aidir$,"")

rem Ensure scriptbank is big enough
dim scriptbank$(1+array count(filelist$()))

rem If AI Script exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem AI Script filename from folder
  ai$=filelist$(chkfile)
  `
  rem Check if filename valid
  if right$(ai$,4)=".fpi"
  `
  rem Check AI Script exists in bank
  tokay=1
  if aiindexmaster>0
   for aiindex=1 to aiindexmaster
    if scriptbank$(aiindex)=ai$ then tokay=0
   next aiindex
  endif
  if tokay=1
    `
    rem Find free space in 'scriptbank'
    freeaiindex=-1
    if aiindexmaster>0
     for aiindex=1 to aiindexmaster
      if scriptbank$(aiindex)="" then freeaiindex=aiindex : exit
     next aiindex
    endif
    `
    rem New AI Script or Free One
    if freeaiindex=-1
     inc aiindexmaster
     aiindex=aiindexmaster
    else
     aiindex=freeaiindex
    endif
    `
    rem Store AI Script for later loading (below)
    scriptbank$(aiindex)=ai$
    `
   endif
   `
  endif
  `
 next chkfile
endif

rem Restore directory
set dir oldir$

rem X10 - 130807 - Count number of skies (for skymax value)
hudskymax=countskybank("skybank\","",0)

return

_ai_loadallscripts:
 if aiindexmaster>0
  aidir$="scriptbank\"
  for aiindex=1 to aiindexmaster
   ai$=scriptbank$(aiindex)
   if lower$(left$(ai$,len(aidir$)))<>lower$(aidir$)
    gosub _ai_load
   endif
  next aiindex
 endif
return

_ai_scanfornewscripts:

rem Scan all to get names
gosub _ai_scanfornewscriptsonly

rem Now load all AI scripts fully
gosub _ai_loadallscripts

return

_ai_findlibindex:
 libindex=-1
 if aiindexmaster>0
  for taiindex=1 to aiindexmaster
   if lower$(scriptbank$(taiindex))=lower$(aifile$) then libindex=taiindex : exit
  next taiindex
 endif
return

_ai_getmusicactionfromscript:
 `
 rem used by title and loading screens in test game mode
 rem to get the MUSIC file from them, for previewing in test game
 tfile$=""
 for conindex=ailist(aiindex).conditionfirst to ailist(aiindex).conditionlast
  actindex=aicond(conindex).action
  for seq=aiaction(actindex).first to aiaction(actindex).last
   select aiactionseq(seq).type
    case AIACTMUSIC:
     tfile$=aiactionseq(seq).filename
    endcase
   endselect
  next seq
 next conindex
 `
return

`
` Seperate SKY loader for usage by X10 effects menu
`

_sky_load:
 `
 rem Load sky overwriting existing if exist
 if guseskystate=1
  tskyname$=right$(sky$,3)
  tsky$=sky$+"\"+tskyname$+".x"
  if file exist(tsky$)=1
   if object exist(65123)=1 then delete object 65123
   if object exist(65123)=0
    debugviewtext(-1,strarr$(3))
    load object tsky$,65123
    addfiletocollection(tsky$)
    for tfor=0 to 1
     if tfor=0 then text$="dds"
     if tfor=1 then text$="tga"
     tsky$=sky$+"\"+tskyname$+"_U."+text$
     if file exist(tsky$)=1
      addfiletocollection(tsky$)
      tsky$=sky$+"\"+tskyname$+"_D."+text$ : addfiletocollection(tsky$)
      tsky$=sky$+"\"+tskyname$+"_L."+text$ : addfiletocollection(tsky$)
      tsky$=sky$+"\"+tskyname$+"_R."+text$ : addfiletocollection(tsky$)
      tsky$=sky$+"\"+tskyname$+"_B."+text$ : addfiletocollection(tsky$)
      tsky$=sky$+"\"+tskyname$+"_F."+text$ : addfiletocollection(tsky$)
      tfor=2
     endif
    next tfor
    set object collision off 65123
    sk#=(100*(realrange#-4000))/5.0
    scale object 65123,sk#,sk#,sk#
    set object texture 65123,2,0
    set object light 65123,0
    set object cull 65123,0
    set object fog 65123,0
    rem X10 - object only for main scene, refract scene and reflect scene (and shadow in shadow scene)
    set object mask 65123,%110010,%0100,%10
    set object transparency 65123,20
   endif
  endif
 endif
 `
 rem Find sky value for this sky (if called by name from FPI)
 gosub _sky_findvalue
 `
 rem Position sky in case loading sky mid-game
 gosub _sky_positionsky
 `
return

_sky_positionsky:
 `
 rem position sky and cloud cover
 if object exist(65123)=1
  position object 65123,camera position x(playercam,),camera position y(playercam,),camera position z(playercam,)
 endif
 if object exist(65124)=1
  position object 65124,camera position x(playercam,),camera position y(playercam,)+1000,camera position z(playercam,)
  scroll object texture 65124,0.0004,0.0005
 endif
 `
return

_sky_findvalue:
 `
 rem Scan all skybank, find this sky, and assign it the value
 tskyname$=right$(sky$,3)
 tsky$=sky$+"\"+tskyname$+".x"
 rem this func sets hudskyvalue
 recurseskybank("skybank\",rel$,0,tsky$)
 `
return

_sky_loadbyvalue:
 `
 rem Scan all skybank, and use the passedin sky value to locate a sky to load
 rem this func sets sky name
 recurseskybank("skybank\",rel$,0,">"+str$(hudskyvalue)) 
 gosub _sky_load
 `
return

function recurseskybank(folder$,rel$,value,mode$)
 if path exist(folder$)=1
  set dir folder$
  find first : fin=0
  while get file type()>-1
   file$=get file name$()
   if file$="." or file$=".."
    rem ignore . and ..
   else
    if get file type()=1
     rem folder
     value=recurseskybank(file$,rel$+file$+"\",value,mode$)
     find first
     if fin>0
      for t=1 to fin : find next : next t
     endif
    else
     rem file
     if lower$(right$(file$,2))=".x"
      if len(mode$)>0
       inc value
       if left$(mode$,1)=">"
        rem searching for a sky value, and setting the new sky when found
        tfind=val(right$(mode$,len(mode$)-1))
        if tfind=value
         sky$="skybank\"+rel$
         if right$(sky$,1)="\" then sky$=left$(sky$,len(sky$)-1)
         mode$=""
        endif
       else
        rem searching for a skyname, and setting the sky value
        if lower$("skybank\"+rel$+file$)=lower$(mode$)
         hudskyvalue=value
         mode$=""
        endif
       endif
      endif
     endif
    endif
   endif
   find next
   fin=fin+1
  endwhile
  set dir ".."
 endif
endfunction value

function countskybank(folder$,rel$,value)
 if path exist(folder$)=1
  set dir folder$
  find first : fin=0
  while get file type()>-1
   file$=get file name$()
   if file$="." or file$=".."
    rem ignore . and ..
   else
    if get file type()=1
     rem folder
     value=countskybank(file$,rel$+file$+"\",value)
     find first
     if fin>0
      for t=1 to fin : find next : next t
     endif
    else
     rem file
     if lower$(right$(file$,2))=".x"
      rem count this sky
      inc value
     endif
    endif
   endif
   find next
   fin=fin+1
  endwhile
  set dir ".."
 endif
endfunction value

rem
rem FUNCTIONS FOR COMMON USE
rem

`
` SUBROUTINES RELATING TO COMMON ACTIVITIES AND RESOURCES
`

_common_wipeeffectifnotexist:
 `rem if file not exist, do not try to use effect
 `x9if file exist(tfile$)=0 then tfile$=""
 rem X10 effects are all through universe.fx, or wiped out
 tuseuniverseshader=0
 if right$(lower$(tfile$),18)="illuminationmap.fx" then tuseuniverseshader=1
 if right$(lower$(tfile$),7)="bump.fx" then tuseuniverseshader=2
 if tuseuniverseshader>0
  tfile$="effectbank\universe\universe.fx"
 else
  tfile$=""
 endif
 rem segment will not apply shader effect during assembly, just record shader and load textures
return

_common_makeeffecttextureset:
 `
 rem used by entitycore and segmentmaker (takes tfile$ and texdir$)
 gosub _common_wipeeffectifnotexist
 `
 rem reset output
 ensureclearlayermax=0
 texdir1$=""
 texdir2$=""
 texdir3$=""
 texdir4$=""
 texdir5$=""
 `
 rem determine effect textures to use
 if tfile$<>"" and segnoeffects=0
  `
  rem D2=D+I+N+S
  tstr0$=left$(texdir$,len(texdir$)-4) : rem _01_D2.TGA -> _01_D2
  tstr1$="" : tstr2$=""
  if upper$(right$(tstr0$,2))="D2"
   tstr1$=left$(texdir$,len(texdir$)-6) : rem _01_D2.TGA -> _01_
   tstr2$=right$(texdir$,4) : rem _01_D2.TGA -> .TGA
  endif
  if upper$(right$(tstr0$,1))="D"
   tstr1$=left$(texdir$,len(texdir$)-5) : rem _01_D.TGA -> _01_
   tstr2$=right$(texdir$,4) : rem _01_D.TGA -> .TGA
  endif
  `
  rem D2 or D only
  if tstr1$<>""
   `
   rem The system used by FPSC is D.I.N.S for 0,1,2,3
   if guseeffectsonessentials=1
    rem no EA essential mode in V1
   else
    rem we will deal with shaders more thoroughly in V1
    hardcodedtexturestages=tuseuniverseshader
    `
    rem related to entities (lightmap stage NOT present)
    ttt$="illuminationent.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=11
    `x9ttt$="bumpent.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=12
    `x9ttt$="bumpbone.fx" : if lower$(right$(tfile$,len(ttt$)))=ttt$ then hardcodedtexturestages=13
    `
    rem set texture files for this effect
    if hardcodedtexturestages>0
     if hardcodedtexturestages=1
      rem [LM]+[DIFF+ILLU]
      ensureclearlayermax=2
      texdir1$=tstr1$+"D2"+tstr2$
      texdir2$=tstr1$+"D2"+tstr2$
      texdir3$=tstr1$+"I"+tstr2$ : rem soon to be replaced with _S!
     endif
     if hardcodedtexturestages=2
      rem [LM]+[DIFF+SPEC+NORM]
      ensureclearlayermax=3
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"D"+tstr2$
      texdir3$=tstr1$+"S"+tstr2$
      texdir4$=tstr1$+"N"+tstr2$
     endif
     if hardcodedtexturestages=11
      rem [DIFF+ILLU]
      ensureclearlayermax=1
      texdir1$=tstr1$+"D2"+tstr2$
      texdir2$=tstr1$+"I"+tstr2$
     endif
     if hardcodedtexturestages=12
      rem [DIFF+NORM]
      ensureclearlayermax=1
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"N"+tstr2$
     endif
     if hardcodedtexturestages=13
      rem [DIFF+NORM+SPEC]
      ensureclearlayermax=2
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"N"+tstr2$
      texdir3$=tstr1$+"S"+tstr2$
     endif
    else
     rem Standard DINS system
     if teffectuseslightmapstage=1
      rem [LM]+[DIFF+ILLU+NORM+SPEC+BRIH]
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"D"+tstr2$
      texdir3$=tstr1$+"I"+tstr2$
      `x9texdir4$=tstr1$+"N"+tstr2$
      `x9texdir5$=tstr1$+"S"+tstr2$
     else
      rem [DIFF+ILLU+NORM+SPEC+BRIH]
      texdir1$=tstr1$+"D"+tstr2$
      texdir2$=tstr1$+"I"+tstr2$
      `x9texdir3$=tstr1$+"N"+tstr2$
      `x9texdir4$=tstr1$+"S"+tstr2$
      `x9texdir5$=tstr1$+"B"+tstr2$
     endif
    endif
   endif
   `
  else
   `
   rem not D2.XXX, so just use texdir$ as base texture
   texdir1$=texdir$
   `
  endif
  `
 else
  rem use no effect this time
  tfile$=""
 endif
 `
return

rem
rem MESH AND TEXTURE HANDLING
rem
`
function loadinternalmesh(tfile$)

rem Default return
meshid=0

rem Scan for existing mesh
if meshbankmax>0
 for m=1 to meshbankmax
  if tfile$=meshbank$(m) then meshid=meshbankoffset+m : exit
 next m
else
 m=meshbankmax+1
endif

rem Did not find, load it
if m>meshbankmax
 inc meshbankmax
 dim meshbank$(meshbankmax)
 if file exist(tfile$)=1
  meshid=meshbankoffset+meshbankmax
  load mesh tfile$,meshid
  meshbank$(meshbankmax)=tfile$
 endif
endif

endfunction meshid

function deleteallinternalimages()
 if imagebankmax>0
  for t=1 to imagebankmax
   imgid=imagebankoffset+t
   if image exist(imgid)=1
    delete image imgid
   endif
  next t
  imagebankmax=0
  undim imagebank$()
  dim imagebank$(imagebankmax)
 endif
 if texturebankmax>0
  for t=1 to texturebankmax
   texid=texturebankoffset+t
   if image exist(texid)=1
    delete image texid
   endif
  next t
  texturebankmax=0
  undim texturebank$()
  dim texturebank$(texturebankmax)
 endif
endfunction

function refreshallinternalimages()
 if imagebankmax>0
  for t=1 to imagebankmax
   tfile$=imagebank$(t)
   imgid=imagebankoffset+t
   loadinternalimageexcompressquality(tfile$,imgid,1,0)
  next t
 endif
endfunction

function refreshinternalimage(t)
 tfile$=imagebank$(t)
 imgid=imagebankoffset+t
 loadinternalimageexcompressquality(tfile$,imgid,1,0)
endfunction

function loadinternalimageexcompressquality(tfile$,imgid,compressmode,quality)
 `
 rem X10 GPU Texture (quality=1)
 if segobjusedformapeditor=0
  rem only for X10 game engine
  if quality=-1
   rem set when we want to temp-load image for texture array creation (must have read-bit set)
   quality=0
  else
   rem new mode quality 2 will use colour to produce alpha channel (colorkey from coldata)
   if quality<>9 then quality=1
  endif
 endif
 `
 rem X10 cannot load TGA any more
 if lower$(right$(tfile$,4))=".tga"
  rem place with DDS so TGA file loadings are never attempted
  tfile$=left$(tfile$,len(tfile$)-4)+".dds"
 endif
 `
 rem X10 if JPG or PNG, skip DDS
 if lower$(right$(tfile$,4))=".jpg"
  tstarttry=2
 else
  if lower$(right$(tfile$,4))=".png"
   tstarttry=2
  else
   tstarttry=1
  endif
 endif
 `
 rem X10 - 221007 - also try looking in mydocs folder too (assets; custom media)
 `for try=tstarttry to 3
 for try=tstarttry to 4
  if try=1 then tryfile$=left$(tfile$,len(tfile$)-4)+".dds"
  if try=2 then tryfile$=tfile$
  if try=3 then tryfile$=left$(tfile$,len(tfile$)-3)+imgext$
  if try=4 then tryfile$=myownrootdir$+"\"+tfile$
  if file exist(tryfile$)=1
   if gincludeonlyvideo=1 and left$(lower$(tryfile$),len(gincludeonlyname$))<>lower$(gincludeonlyname$)
    rem fill video with basic random color
    create bitmap 7,4,4
    cls rgb(rnd(255),rnd(255),rnd(255))
    get image imgid,0,0,4,4
    delete bitmap 7
    set current bitmap 0
   else
    `
    rem low texture use in editor ( Special divide reduction value of 16384=norealload )
    tempdividetexturesize=gdividetexturesize
    if segobjusedformapeditor=1 then tempdividetexturesize=8
    `
    rem FPSCV104RC10 - can skip 'real load' unless full lightmapping which requires alpha from texture
    `if gcompilestandaloneexe=1 then tempdividetexturesize=16384 : quality=0
    if gcompilestandaloneexe=1 and glightshadowsstate=0 then tempdividetexturesize=16384 : quality=0
    `
    rem load image (skip if building = quicker build)
    if quality=0
     load image tryfile$,imgid,quality,tempdividetexturesize
    else
     if quality=1 or quality=9
      load image tryfile$,imgid,quality
     else
      rem Quality Mode 2 means only reduce have as much (smaller items blur too much in QM=1)
      load image tryfile$,imgid,1,tempdividetexturesize/2
     endif
    endif
    `
    rem and perhaps save it
    if try=4
     rem X10 - 221007 - if custom media, keep custom file path
     addfiletocollection(tfile$)
    else
     if grealgameviewstate=0
      tdds$=left$(tfile$,len(tfile$)-4)+".dds"
      if file exist(tdds$)=0 and tempdividetexturesize=0
       save image tdds$,imgid,compressmode
       addfiletocollection(tdds$)
      else
       addfiletocollection(tryfile$)
      endif
     else
      addfiletocollection(tryfile$)
     endif
    endif
    `
   endif
   exit
  endif
 next try
endfunction

function loadinternalimageexcompress(tfile$,imgid,compressmode)
 loadinternalimageexcompressquality(tfile$,imgid,compressmode,0)
endfunction

function loadinternalimageex(tfile$,imgid)
 loadinternalimageexcompress(tfile$,imgid,1)
endfunction

function loadinternalimagecompressquality(tfile$,compressmode,quality)

rem Default return
imgid=0

rem Scan for existing (X10 -1 means we need a UNIQUE texture each time (for reading by texture array creation))
if imagebankmax>0 and quality<>-1
 for t=1 to imagebankmax
  if tfile$=imagebank$(t) then imgid=imagebankoffset+t : exit
 next t
else
 t=imagebankmax+1
endif

rem Did not find, load it
if t>imagebankmax
 inc imagebankmax
 dim imagebank$(imagebankmax)
 imgid=imagebankoffset+imagebankmax
 loadinternalimageexcompressquality(tfile$,imgid,compressmode,quality)
 if image exist(imgid)=1
  imagebank$(imagebankmax)=tfile$
 else
  dec imagebankmax
  imgid=0
 endif
endif

endfunction imgid

function loadinternalimagecompress(tfile$,compressmode)
 imgid=loadinternalimagecompressquality(tfile$,compressmode,0)
endfunction imgid

function loadinternalimage(tfile$)
 imgid=loadinternalimagecompress(tfile$,1)
endfunction imgid

function loadinternalimagequality(tfile$)
 imgid=loadinternalimagecompressquality(tfile$,1,1)
endfunction imgid

function loadinternaltexture(tfile$)

rem Default return
texid=0

rem Scan for existing
if texturebankmax>0
 for t=1 to texturebankmax
  if tfile$=texturebank$(t) then texid=texturebankoffset+t : exit
 next t
else
 t=texturebankmax+1
endif

rem Did not find, load it
if t>texturebankmax
 rem Attempt to load
 inc texturebankmax
 dim texturebank$(texturebankmax)
 texturebank$(texturebankmax)=tfile$
 texid=texturebankoffset+texturebankmax
 loadinternalimageex(tfile$,texid)
 if image exist(texid)=0
  rem failed to load, so reverse creation
  texturebank$(texturebankmax)=""
  dec texturebankmax : texid=0
 endif
endif

endfunction texid

function loadinternaltextureex(tfile$,compressmode,quality)

rem Default return
texid=0

rem Scan for existing
if texturebankmax>0
 for t=1 to texturebankmax
  if tfile$=texturebank$(t) then texid=texturebankoffset+t : exit
 next t
else
 t=texturebankmax+1
endif

rem Did not find, load it
if t>texturebankmax
 rem Attempt to load
 inc texturebankmax
 dim texturebank$(texturebankmax)
 texturebank$(texturebankmax)=tfile$
 texid=texturebankoffset+texturebankmax
 loadinternalimageexcompressquality(tfile$,texid,compressmode,quality)
 if image exist(texid)=0
  rem failed to load, so reverse creation
  texturebank$(texturebankmax)=""
  dec texturebankmax : texid=0
 endif
endif

endfunction texid

function loadinternaleffectunique(tfile$,makeunique)

rem Default return
effectid=0

rem Scan for existing
if effectbankmax>0 and makeunique=0
 for t=1 to effectbankmax
  if tfile$=effectbank$(t) then effectid=effectbankoffset+t : exit
 next t
else
 t=effectbankmax+1
endif

rem Did not find, load it
if t>effectbankmax
 rem X10 - 221007 - if not found, try mydoc folder
 if file exist(tfile$)=0
  tfile$=myownrootdir$+"\"+tfile$
 endif
 if file exist(tfile$)=1
  inc effectbankmax
  dim effectbank$(effectbankmax)
  effectid=effectbankoffset+effectbankmax
  if lower$(left$(tfile$,14))="effectbank\csg"
   load effect tfile$,effectid,1
  else
   load effect tfile$,effectid,0
  endif
  if effect exist(effectid)=1
   effectbank$(effectbankmax)=tfile$
  else
   rem could not use effect
   dec effectbankmax
   effectid=0
  endif
  addfiletocollection(tfile$)
 endif
endif

endfunction effectid

function loadinternaleffect(tfile$)
 effectid=loadinternaleffectunique(tfile$,0)
endfunction effectid

function loadinternalsoundcore(tfile$,mode)

rem Default return
soundid=0

rem X10 - 161007 - can modify location of audio file 
if lower$(left$(tfile$,len(rootdir$)))=lower$(rootdir$)
 if lower$(left$(tfile$,len(rootdir$+"assets")))=lower$(rootdir$+"assets")
  rem if detect 'assets' folder, switch it to mydoc area
  `ltfile$=tfile$
  tfile$=myownrootdir$+right$(tfile$,len(tfile$)-len(rootdir$))
  `exit prompt tfile$,ltfile$ : end 
 endif
endif

rem No scan for existing - all sounds unique for overlay play
t=soundbankmax+1
if t>soundbankmax
 tspecialogg=0 : if right$(lower$(tfile$),4)=".ogg" then tspecialogg=1
 if right$(lower$(tfile$),4)=".wav" or tspecialogg=1
  if file exist(tfile$)=1
   inc soundbankmax
   dim soundbank$(soundbankmax)
   soundid=soundbankoffset+soundbankmax
   if mode=1 and tspecialogg=0
    load 3dsound tfile$,soundid,1
    if sound exist(soundid)=0 then load sound tfile$,soundid,0,1
   else
    load sound tfile$,soundid,0,1
   endif
   if sound exist(soundid)=0
    rem sound could not loaded
    soundbank$(soundbankmax)=""
    dec soundbankmax
    soundid=0
   else
    rem success
    soundbank$(soundbankmax)=tfile$
    if lower$(left$(tfile$,len(rootdir$)))=lower$(rootdir$)
     rem 161007 - add only audiobank\ path, not full root path!
     addfiletocollection(right$(tfile$,len(tfile$)-len(rootdir$)))
    else
     if lower$(left$(tfile$,len(myownrootdir$)))=lower$(myownrootdir$)
      rem 130907 - add only audiobank\ path, not full mydoc root path!
      addfiletocollection(right$(tfile$,len(tfile$)-len(myownrootdir$)))
     else
      addfiletocollection(tfile$)
     endif
    endif
   endif
  endif
 endif
endif

endfunction soundid

function loadinternalsound(tfile$)
 soundid=loadinternalsoundcore(tfile$,0)
endfunction soundid

function changeplrforsound(tplrid,tsnd)
 if tplrid>1 and gmultiplayergame=0
  if playersound(tplrid,tsnd)=0
  
   rem look for available sound that matches sound set index
   tsoundsetindex=playersoundsetindex(tplrid)
   for tscanplrid=1 to playermax
    tscansoundid=playersound(tscanplrid,tsnd)
    if tscansoundid>0
     if playersoundsetindex(tscanplrid)=tsoundsetindex
      if sound exist(tscansoundid)=1
       if sound playing(tscansoundid)=0
        tplrid=tscanplrid : scanplrid=playermax
       endif
      endif
     endif
    endif
   next tscanplrid
   `rem use first three sounds
   `if tplrid>4
   ` tplridset=(tplrid-5)/3
   ` tplrid=tplrid-((1+tplridset)*3)
   `endif
  endif
 endif
endfunction tplrid

function managebroadcastsound()
 if bcsoundstrength#>0.0
  dec bcsoundstrength#,1.0
  if bcsoundstrength#<0 then bcsoundstrength#=0.0
 endif
endfunction

function loopsound(id)
 if id>0
  if sound exist(id)=1
   loop sound id
   set sound volume id,soundvolumes(1)
  endif
 endif
endfunction

function stopsound(soundid)
 if soundid>0
  if sound exist(soundid)=1
   stop sound soundid
  endif
 endif
endfunction

function broadcast3dsoundcore(x#,y#,z#,strength#,soundpriority)
 rem FPI based sound detection
 if strength#>bcsoundstrength#
  bcsoundstrength#=strength#
  bcsoundx#=x# : bcsoundy#=y# : bcsoundz#=z#
 endif
 rem X10 AI sound trigger
 tradius#=strength#*50 : rem based on a footfall = 1.0 * 50 = radius + entity maxrange
 tcontainer=(y#+15)/100 
 if tcontainer>=0 and tcontainer<=19
  `AI Create Sound x#,y#+15.0,z#,soundpriority,tradius#,tcontainer
 endif
endfunction

function broadcast3dsound(x#,y#,z#,strength#)
 if strength#<100
  tpriority=1 : rem lowest priority noise (entities, other sounds)
 else
  tpriority=9 : rem BEST ENTITY priority noise (gun shot)
 endif
 broadcast3dsoundcore(x#,y#,z#,strength#,tpriority)
endfunction

function broadcast3dplrsound(x#,y#,z#,strength#)
 if strength#<100
  tpriority=2 : rem higher priority noise (player other noises)
 else
  tpriority=11 : rem HIGEST priority noise (player gun)
 endif
 broadcast3dsoundcore(x#,y#,z#,strength#,tpriority)
endfunction

function playinternalBC3dsound(id,x#,y#,z#,strength#)
 if id>0
  if sound exist(id)=1
   broadcast3dsound(x#,y#,z#,strength#)
   position sound id,x#/10.0,y#/10.0,z#/10.0
   set sound volume id,soundvolumes(1)
   play sound id
  endif
 endif
endfunction

function playinternal3dsound(id,x#,y#,z#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/10.0,z#/10.0
   set sound volume id,soundvolumes(1)
   play sound id
  endif
 endif
endfunction

function playinternal3dsoundloudness(id,x#,y#,z#,loudness#)
 if id>0
  if sound exist(id)=1
   loudx#=x#/10.0
   loudy#=y#/10.0
   loudz#=z#/10.0
   roughx=camera position x(playercam)/10.0
   roughy=camera position y(playercam)/10.0
   roughz=camera position z(playercam)/10.0
   loudx#=loudx#-((loudx#-roughx)/loudness#)
   loudy#=loudy#-((loudy#-roughy)/loudness#)
   loudz#=loudz#-((loudz#-roughz)/loudness#)
   position sound id,loudx#,loudy#,loudz#
   set sound volume id,soundvolumes(1)
   play sound id
  endif
 endif
endfunction

function loopinternal3dsound(id,x#,y#,z#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/10.0,z#/10.0
   set sound volume id,soundvolumes(1)
   if sound playing(id)=0 then loop sound id
  endif
 endif
endfunction

function posinternal3dsound(id,x#,y#,z#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/10.0,z#/10.0
  endif
 endif
endfunction

function playinternal3dsoundfactor(id,x#,y#,z#,factor#)
 if id>0
  if sound exist(id)=1
   position sound id,x#/10.0,y#/10.0,z#/10.0
   factor#=(factor#/100.0)*soundvolumes(1)
   factor#=(factor#*2.0)+80.0
   if factor#<0 then factor#=0
   if factor#>100 then factor#=100
   set sound volume id,factor#
   play sound id
  endif
 endif
endfunction

`
` FUNCTION TO BUILD A SUB-DIRECTORY = filelist$()
`
function buildfilelist(folder$,rel$)
 if path exist(folder$)=1
  set dir folder$
  find first : fin=0
  while get file type()>-1
   file$=get file name$()
   if file$="." or file$=".."
    rem ignore . and ..
   else
    if get file type()=1
     rem folder
     buildfilelist(file$,rel$+file$+"\")
     find first
     if fin>0
      for t=1 to fin : find next : next t
     endif
    else
     rem file
     array insert at bottom filelist$()
     filelist$()=rel$+file$
    endif
   endif
   find next
   fin=fin+1
  endwhile
  set dir ".."
 endif
endfunction

`
` FUNCTIONS TO CUT-UP STRINGS
`
function getfirstdir(file$)
 firstdir$=""
 for c=1 to len(file$)
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   firstdir$=left$(file$,c) : exit
  endif
 next c
endfunction firstdir$

function getseconddir(file$)
 firstdir$="" : count=2
 for c=1 to len(file$)
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   dec count
   if count=0
    firstdir$=left$(file$,c) : exit
   endif
  endif
 next c
endfunction firstdir$

function getpath(file$)
 path$=""
 for c=len(file$) to 1 step -1
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   path$=left$(file$,c) : exit
  endif
 next c
endfunction path$

function getfile(file$)
 for c=len(file$) to 1 step -1
  if mid$(file$,c)="\" or mid$(file$,c)="/"
   file$=right$(file$,len(file$)-c) : exit
  endif
 next c
endfunction file$

`
` SUPPORT FUNCTIONS (DUPLICATED IN GUNSYSTEM)
`
function removeedgespaces(text$)
 returntext$=""
 if len(text$)>0
  st=0
  for c=1 to len(text$)
   if asc(mid$(text$,c))>32 then st=c : exit
  next c
  if st=0
   rem all sub-spaces
  else
   for c=len(text$) to 1 step -1
    if asc(mid$(text$,c))>32 then en=c : exit
   next c
   for c=st to en
    returntext$=returntext$+mid$(text$,c)
   next c
  endif
 endif
endfunction returntext$

function minstring(text$,minsize)
 sizegap=minsize-len(text$)
 text$=text$+space$(sizegap)
endfunction text$

`
` FILECOLLECTOR FUNCTIONS
`

function resetfilecollection()
 empty array filecollection$()
endfunction

function addfiletocollection(filename$)
 if segobjusedformapeditor=0 and segobjusedforsegeditor=0
  if len(filename$)>0
   if mid$(filename$,2)=":"
    rem absolute paths not allowed for filenames!
    debugstring(filename$,strarr$(41))
   else
    rem verify file not duplicated
    tokay=1
    for chk=1 to array count(filecollection$())
     if lower$(filecollection$(chk))=lower$(filename$)
      tokay=0
     endif
     if lower$(left$(filecollection$(chk),len(filecollection$(chk))-4))=lower$(left$(filename$,len(filename$)-4))
      rem if have a DDS, and a TGA of the same name, replace it
      if lower$(right$(filecollection$(chk),4))=".tga"
       if lower$(right$(filename$,4))=".dds"
        filecollection$(chk)=filename$
        tokay=0 : exit
       endif
      endif
     endif
    next chk
    rem add file to collection
    if tokay=1
     array insert at bottom filecollection$()
     filecollection$()=filename$
    endif
   endif
  endif
 endif
endfunction

`
` ASSESS FILE FOR HOW OLD IT IS
`
function getdatevaluefromdatestring(dayofyear$)
   rem get year
   year$=right$(dayofyear$,4)
   dayofyear$=left$(dayofyear$,len(dayofyear$)-5)
   rem eat day
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)=" "
     dayofyear$=right$(dayofyear$,len(dayofyear$)-c)
     exit
    endif
   next c
   rem find month
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)=" "
     month$=lower$(left$(dayofyear$,c-1))
     dayofyear$=right$(dayofyear$,len(dayofyear$)-c)
     exit
    endif
   next c
   rem find date
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)=" "
     date$=lower$(left$(dayofyear$,c-1))
     dayofyear$=right$(dayofyear$,len(dayofyear$)-c)
     exit
    endif
   next c
   rem get time
   time$=""
   for c=1 to len(dayofyear$)
    if mid$(dayofyear$,c)<>":"
     time$=time$+mid$(dayofyear$,c)
    endif
   next c
   time$=left$(time$,len(time$)-2)
   if month$="jan" then month=1
   if month$="feb" then month=2
   if month$="mar" then month=3
   if month$="apr" then month=4
   if month$="may" then month=5
   if month$="jun" then month=6
   if month$="jul" then month=7
   if month$="aug" then month=8
   if month$="sep" then month=9
   if month$="oct" then month=10
   if month$="nov" then month=11
   if month$="dec" then month=12
   filedatevalue=((val(year$)-2004)*12*32*2500)+(month*32*2500)+(val(date$)*2500)+val(time$)
endfunction filedatevalue

function isbinaryfileolderthantxtfile(binaryfilefull$,textfilefull$)
 result=0
 if file exist(binaryfilefull$)=1
  stdir$=get dir$()
  binaryfile$=getfile(binaryfilefull$)
  textfile$=getfile(textfilefull$)
  set dir getpath(binaryfilefull$)
  filedatevalueB=0
  filedatevalueT=0
  find first
  while get file type()<>-1
   if get file type()=0
    if lower$(get file name$())=lower$(binaryfile$)
     this$=get file date$()
     dayofyearB$=this$
     filedatevalueB=getdatevaluefromdatestring(dayofyearB$)
    else
     if lower$(get file name$())=lower$(textfile$)
      this$=get file date$()
      dayofyearT$=this$
      filedatevalueT=getdatevaluefromdatestring(dayofyearT$)
     endif
    endif
    if filedatevalueB<>0 and filedatevalueT<>0 then exit
   endif
   find next
  endwhile
  if filedatevalueB<>0 and filedatevalueT<>0
   if filedatevalueB<filedatevalueT
    result=1
   endif
  endif
  set dir stdir$
 endif
endfunction result


function reporttologfile$(logfile$,report$)
 arraysize=array count(logfilereport$())
 if logfilereportindex>arraysize-10
  dim logfilereport$(arraysize*2)
 endif
 logfilereport$(logfilereportindex)=report$
 if file exist(logfile$)=1 then delete file logfile$
 open to write 9,logfile$
  for i=0 to logfilereportindex
   write string 9,logfilereport$(i)
  next i
 close file 9
 inc logfilereportindex
endfunction

function scancopy(folder$,rel$,destination$,fpscx10extractionlogfile$)
 `
 set dir folder$
 find first : fin=0
 while get file type()>-1
  file$=get file name$()
  if file$="." or file$=".."
   rem ignore . and ..
  else
   if get file type()=1
    rem create folder if not present in destination
    if path exist(destination$+rel$+file$)=0
     reporttologfile$(fpscx10extractionlogfile$,"Creating folder:"+destination$+rel$+file$)
     make directory destination$+rel$+file$
    endif
    rem folder
    scancopy(file$,rel$+file$+"\",destination$,fpscx10extractionlogfile$)
    find first
    if fin>0
     t=1
     while t<=fin and get file type()>-1
      find next
      inc t
     endwhile
    endif
   else
    rem copy file
    if file exist(destination$+rel$+file$)=1 then delete file destination$+rel$+file$
    reporttologfile$(fpscx10extractionlogfile$,"Copying "+file$+" to "+destination$+rel$+file$)
    copy file file$,destination$+rel$+file$
   endif
  endif
  if get file type()>-1 then find next
  fin=fin+1
 endwhile
 set dir ".."
 `
endfunction

function turnfilenameuserlocal(t$)
 `
 rem converts entitybank\scifi\stuff\lee.bin -> mydoc\entitybank_scifi_stuff_lee.bin
 newt$=myownrootdir$+"binfiles\"
 for n=1 to len(t$)
  if mid$(t$,n)=":" or mid$(t$,n)="\" or mid$(t$,n)="/"
   newt$=newt$+"_"
  else
   newt$=newt$+mid$(t$,n)
  endif
 next n
 `
endfunction newt$

function copyoveruniquescripts(a$,b$)
 rem only used in map editor
endfunction

function findvweaptexture(tfile$)
 rem D2 file comes in, VWEAP texture name goes out if available
 vweapfile$=""
 rem find path
 path$=getpath(tfile$)
 rem search for VWEAP in any file
 oldoldir$=get dir$()
 set dir path$
 perform checklist for files
 for c=1 to checklist quantity()
  ttfile$=lower$(checklist string$(c))
  if ttfile$<>"." and ttfile$<>".." and right$(ttfile$,4)=".dds"
   for t=1 to len(ttfile$)-5
    if left$(right$(ttfile$,len(ttfile$)-t),5)="vweap"
     vweapfile$=path$+"\"+ttfile$
    endif
   next t
  endif
 next c
 set dir oldoldir$
endfunction vweapfile$

rem
rem GAME PLAYER
rem

`
` Player Core Subroutines (for human and NPC players)
`

_player_init:

rem X10 why enemies have 3D sounds hardly used
if gmultiplayergame=1
 tusefullsounds=1
else
 tusefullsounds=0
endif

rem LEE, ONLY LOADING PLR 2 3 and 4 for material and grunt sounds
rem modify code to re-use these slots (means 50 characters use 50k ticks in processing without this)

rem For all players
for plrid=1 to playermax
 `
 rem Player or NPCs
 if plrid=1 then t3d=0 else t3d=1
 `
 rem Sounds 0-9 reserved
 `
 rem can soundsets be stored in a list, and referenced by index
 tsoundset$=playersoundset$(plrid) : gosub _player_submitsoundsettolist
 tsoundsetindex=0 : gosub _player_getsoundsetlistindex : rem returns tsoundsetindex
 playersoundsetindex(plrid)=tsoundsetindex
 soundsetlist(tsoundsetindex)=soundsetlist(tsoundsetindex)+1
 `
 rem Load player grunt sounds
 if tsoundset$<>"" and right$(tsoundset$,1)<>"\" then tsoundset$=tsoundset$+"\"
 if tusefullsounds=1 or plrid=1
  snd$="audiobank\voices\"+tsoundset$+"leap.wav"
  playersound(plrid,10)=loadinternalsoundcore(rootdir$+snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"land.wav"
  playersound(plrid,11)=loadinternalsoundcore(rootdir$+snd$,t3d)
 endif
 if tusefullsounds=1 or soundsetlist(tsoundsetindex)<3
  snd$="audiobank\voices\"+tsoundset$+"hurt1.wav"
  playersound(plrid,12)=loadinternalsoundcore(rootdir$+snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"hurt2.wav"
  playersound(plrid,13)=loadinternalsoundcore(rootdir$+snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"hurt3.wav"
  playersound(plrid,14)=loadinternalsoundcore(rootdir$+snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"finalmoan.wav"
  playersound(plrid,15)=loadinternalsoundcore(rootdir$+snd$,t3d)
  snd$="audiobank\voices\"+tsoundset$+"spawn.wav"
  playersound(plrid,16)=loadinternalsoundcore(rootdir$+snd$,t3d)
 endif
 `
 rem X10 Additional WATER sound for main player
 if plrid=1
  tsndid=17 : snd$="audiobank\water\WaterIn.wav" : playersound(plrid,tsndid)=loadinternalsoundcore(rootdir$+snd$,t3d)
  tsndid=18 : snd$="audiobank\water\WaterOut.wav" : playersound(plrid,tsndid)=loadinternalsoundcore(rootdir$+snd$,t3d)
  tsndid=19 : snd$="audiobank\water\GaspForAir.wav" : playersound(plrid,tsndid)=loadinternalsoundcore(rootdir$+snd$,t3d)
  tsndid=20 : snd$="audiobank\water\Drown.wav" : playersound(plrid,tsndid)=loadinternalsoundcore(rootdir$+snd$,t3d)
 endif
 `
 rem Load tred sounds from material list plrid of 2,3,4 used by entities)
 if tusefullsounds=1 or plrid<=4
  for mi=0 to gmaterialmax
   for titer=0 to 3
    if material(mi).name$<>""
     if titer=0 then snd$=material(mi).tred0$
     if titer=1 then snd$=material(mi).tred1$
     if titer=2 then snd$=material(mi).tred2$
     if titer=3 then snd$=material(mi).tred3$
     playersound(plrid,21+(mi*4)+titer)=loadinternalsoundcore(rootdir$+snd$,t3d)
    endif
   next titer
  next mi
 endif
 `
 rem Setup player default start values (before startpos fills with real ones)
 if plrid=1
  checkpointentity=-1
  gosub _entity_findplayerstartposition : rem gets 'playerstartlives'
  player(plrid).lives=playerstartlives
  player(plrid).livesmax=playerstartlives
  player(plrid).healthmax=playerstartstrength
 else
  player(plrid).lives=1
  player(plrid).livesmax=1
  player(plrid).healthmax=100
  playerscoregoal=0
 endif
 player(plrid).recovershield=0
 player(plrid).health=100
 `
 rem X10 default lung capacity
 player(plrid).air=0 
 player(plrid).airmax=playerlungcapacity
 `
 rem X10 score reset
 player(plrid).score=0
 player(plrid).scoremax=playerscoregoal
 `
 rem X10 jump height
 player(plrid).jumpheight=playerjumpheight
 `
 rem test game gives player 99 lives (but regular health to test logic)
 if gtestgamemodefromeditor=1 then player(plrid).lives=99
 `
next plrid

rem X10 Load underwater sound for players built-in atmos
if 1
 snd$="audiobank\atmos\underwater.wav"
 waterunderwatersoundid=loadinternalsound(rootdir$+snd$)
endif

rem place listener far away at start
position listener -999999,-999999,-999999
rotate listener 90,0,0

return

_player_submitsoundsettolist:
 rem in: tsoundset$
 tsoundsetindex=0
 if soundsetlistmax>0
  for t=1 to soundsetlistmax
   if lower$(soundsetlist$(t))=lower$(tsoundset$)
    tsoundsetindex=t : t=soundsetlistmax
   endif
  next t
 endif
 if tsoundsetindex=0
  rem new soundset entry
  inc soundsetlistmax
  dim soundsetlist$(soundsetlistmax)
  dim soundsetlist(soundsetlistmax)
  soundsetlist$(soundsetlistmax)=tsoundset$
  soundsetlist(tsoundsetindex)=0
 endif
return

_player_getsoundsetlistindex:
 tsoundsetindex=0
 if soundsetlistmax>0
  for t=1 to soundsetlistmax
   if lower$(soundsetlist$(t))=lower$(tsoundset$)
    tsoundsetindex=t : t=soundsetlistmax
   endif
  next t
 endif
return

_player_free:

rem As sounds are unique, free them before re-creating players
for plrid=1 to playermax
 for tt=0 to 520
  tsnd=playersound(plrid,tt)
  if tsnd>0
   if sound exist(tsnd)=1 then delete sound tsnd
  endif
 next tt
next plrid

rem reset checkpoint storage at end of player session
checkpointentity=-1

return

_player_startgun:

rem Get player start data
gosub _entity_findplayerstartposition
if playerstarthasweapon>0
 rem only if not got gun in slot already
 for tww=1 to 10
  if weaponslot(tww).pref>0
   if weaponslot(tww).pref=playerstarthasweapon then exit
  endif
 next tww
 if tww>10
  for tww=1 to 10
   if weaponslot(tww).pref=0
    weaponslot(tww).pref=playerstarthasweapon
    weaponslot(tww).got=playerstarthasweapon
    weaponhud(tww)=gun(playerstarthasweapon).hudimage
    tww=11 : exit
   endif
  next tww
 endif
 gun(playerstarthasweapon).activeingame=1
endif

return

_player_setstartposonly:
 `
 rem Find player start location
 gosub _entity_findplayerstartposition
 if playerstartx#=0
  rem look for first filled map piece
  for lay=0 to 19
   for x=0 to maxx-1
    for y=0 to maxy-1
     if map(lay,x,y)<>0
      playerstartx#=(x*100)+50
      playerstarty#=(lay*100)
      playerstartz#=(y*-100)-50
      playerstartrx#=0
      playerstartry#=135
      x=maxx : y=maxy : lay=20
      exit
     endif
    next y
   next x
  next lay
 endif
 `
return

_player_startpos:
 `
 rem clear weaponammoindex (startpostion routine can fill this var)
 weaponammoindex=0
 `
 rem Find player start location
 gosub _player_setstartposonly
 `
 rem Setup player default start values
 player(1).health=playerstartstrength
 if level>1
  rem FPSCV10X - carried from previous level (no longer writes over MAX)
  player(1).health=saveplayerstate.health
 endif
 `
 rem restart basic player vars
 gosub _player_restart
 `
return

_player_restart:
 `
 rem uses playerstartxyz#
 rem Ensure player start height avoids stairs and other ground obstacles
 if playerstartingfromreload=0
  rem V110 - 190110 - except where from reload (need exact spot)
  pttry=0
  while pttry<500
   if static volume(playerstartx#,playerstarty#+1.0,playerstartz#,playerstartx#,playerstarty#,playerstartz#,1.0)=0 then exit
   playerstarty#=playerstarty#+1.0
   inc pttry
  endwhile
 endif
 `
 rem sort out camera default rotation at start
 yrotate camera playercam,playerstartry#
 xrotate camera playercam,playerstartrx#
 zrotate camera playercam,0
 lastcamangx#=camera angle x(playercam)
 lastcamangy#=camera angle y(playercam)
 `
 rem start with a jump
 grav#=-1.0 : jumpaction=0 : jumpspeed#=0.0 : jumpangle#=camera angle y(playercam) : gravlasty#=mey#
 camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
 camforcex#=0 : camforcey#=0 : camforcez#=0
 `
 rem crouch state (V110 - 190110 - can load in crouchmode)
 if playerstartingfromreload=0 then crouchmode=0
 tcamerasize#=1.0 
 `
 rem recover shield
 player(1).recovershield=0`
 `
 rem Player Weapon default
 if gunzoommode=10 then gunzoommode=11
 autoloadgun=playerstarthasweapon
 `
 rem Default position in center (borble uses this xyz for its position, then camera adjustment later)
 `tvalueheight=11 : rem height from base of player start value to center of borble
 phystood#=40.0
 if playerstartingfromreload=0 or crouchmode=0
  tvalueheight=1 : rem 150907 - reduced this value so dont start high up and falling
  ellipsevolumesize#=1.0
  phyeyeheight#=phystood#
 else
  rem V110 - 190110 - except where from reload (need exact spot)
  tvalueheight=2
  ellipsevolumesize#=phycrouchedellipsevolumesize#
  phyeyeheight#=phycrouched#
 endif
 lastcamx#=playerstartx# : lastcamy#=playerstarty#+tvalueheight : lastcamz#=playerstartz#
 camerapositionx=lastcamx#
 camerapositiony=lastcamy#+phyeyeheight#
 camerapositionz=lastcamz#
 mex#=camerapositionx : mey#=camerapositiony : mez#=camerapositionz
 cx#=camerapositionx : cy#=camerapositiony : cz#=camerapositionz
 `
 rem Activate player borble (uses plrpos) (also handles crouchmode)
 gosub _physics_playerborble
 `
 rem Can be called within before_and_after move, so ensure vars are set
 ctox#=ctx# : ctoy#=cty# : ctoz#=ctz#
 if object exist(physicsplayerborble)=1
  camerapositionx=object position x(physicsplayerborble)
  camerapositiony=object position y(physicsplayerborble)+phyeyeheight#
  camerapositionz=object position z(physicsplayerborble)
  position camera playercam,camerapositionx,camerapositiony,camerapositionz
 endif
 realcx#=camerapositionx : realcy#=camerapositiony : realcz#=camerapositionz
 `
 rem X10 020807 - restart ensuring player does not choke if died underwater
 watertransitionbyrestart=1 : wateroccupiedtimer=timer()
 `
return

_player_savestate:

rem Record players leaving level state
saveplayerstate.lives=player(1).lives
saveplayerstate.health=player(1).health
saveplayerstate.weaponindexholding=weaponammoindex
saveplayerstate.score=player(1).score

return

_player_setup:
 `
 rem Setup camera
 position camera playercam,0,52,0
 point camera playercam,0,52,0
 set light range 0,10000
 `
 rem start camera for player
 plrzoominchange=0 : plrzoomin#=0.0
 `
 rem Find player start location
 gosub _player_startpos
 `
 rem if weapon, add bullets if any
 if playerstarthasweapon>0 and level=1
  for tww=1 to 10
   if weaponslot(tww).pref=playerstarthasweapon
    tqty=gun(playerstarthasweapon).settings.reloadqty
    if playerstarthasweaponqty>=1
     rem gun or flak
     if gun(playerstarthasweapon).settings.flakindex=0
      rem gun with clips
      weaponammo(tww)=tqty
      if playerstarthasweaponqty>1
       weaponclipammo(tww)=(playerstarthasweaponqty-1)*tqty
      endif
     else
      rem flak, no clips
      weaponammo(tww)=playerstarthasweaponqty
     endif
    endif
    tww=11 : exit
   endif
  next tww
 endif
 `
 rem Reset some plater related states when restart
 gosub _player_resettrail
 trailx#=mex# : traily#=mey#-52 : trailz#=mez#
 inc playertrailmax
 playertrial(playertrailmax).time=timer()
 playertrial(playertrailmax).x=trailx#
 playertrial(playertrailmax).y=traily#
 playertrial(playertrailmax).z=trailz#
 `
 rem restore player camera states
 phyeyeheight#=phystood#
 tcamerasize#=1.0
 grav#=0
 cameraspeed=0
 cameraholding=0
 camerapickupkeyrelease=0
 camerareach#=0
 camerapicked=0
 cameradampen#=1.0
 `
return

_player_playfootfall:

sndid=0
if colmaterialtype>=0
 if colmaterialtype>=100 then colmaterialtype=colmaterialtype-(int(colmaterialtype/100)*100)
 if colmaterialtype>=0 and colmaterialtype<100
  rem X10 Change the material sound if near or under water
  if plrid>1
   footaty#=entityelement(e).y
   playinternal3dsoundfactor(sndid,entityelement(e).x,entityelement(e).y,entityelement(e).z,1.0)
  else
   footaty#=camera position y(playercam)-(phyeyeheight#+18)
  endif
  if footaty#<waterlevel#
   if footaty#<waterlevel#-50
    rem underwater
    if plrid=1
     rem V109 - 100209 - extra code to handle swimming sound along surface of water
     tnearsurfaceofwater=abs(camera position y(playercam)-waterlevel#)
     if waterisbelowplayer=1 and tnearsurfaceofwater<15
      colmaterialtype=9
     else
      `colmaterialtype=11 `V109 - 110209 - moved material table to make room for MP3 slots
      colmaterialtype=17
     endif
    else
     `colmaterialtype=11
     colmaterialtype=17
    endif
   else
    rem in shallow water
    if waterdecalripple<>0
     rem and only if water does ripple
     colmaterialtype=9
    endif
   endif
  endif
  rem Play the footfall sound
  tt=21+(colmaterialtype*4)
  tplrid=plrid
  for titer=0 to 3
   ttrr=rnd(3)
   tplrid=changeplrforsound(tplrid,tt+ttrr)
   sndid=playersound(tplrid,tt+ttrr)
   if sndid>0
    if sound playing(sndid)=1 then sndid=0
   endif
   if sndid<>0 then playersoundtimeused(tplrid,tt+ttrr)=perftimer() : exit
  next titer
  if sndid=0
   titerdw as DWORD
   tdwsmalltest as DWORD
   bestsndid=0
   for titer=0 to 3
    titerdw=playersoundtimeused(tplrid,tt+titer)
    if titer=0 then tdwsmalltest=titerdw
    sndid=playersound(tplrid,tt+titer)
    if sndid>0
     if titerdw<=tdwsmalltest
      tdwsmalltest=titerdw : bestsndid=sndid
     endif
    endif
   next titer
   sndid=bestsndid
  endif
 endif
 if sndid>0
  if (movement<>0 and jumpaction=0) or leapedlanded=1 or plrid>1
   rem X10 if in water, footfall sound must be immediate from static pose
   if plrid=1
    if colmaterialtype=9 or colmaterialtype=17 : rem V109 - 110209 - replaces colmaterialtype=11
     if playermovingfromastandingposture=0
      playermovementstep(plrid)=9999.9
      playermovingfromastandingposture=1
     endif
    endif
   endif
   playermovementstep(plrid)=playermovementstep(plrid)+timeelapsed#
   if movement=2 then tfootspeed#=2.0 else tfootspeed#=1.0
   if plrid=1
    if basespeed#<=40.0 then tsteppingsound#=6.0*tfootspeed#
    if basespeed#>40.0 then tsteppingsound#=5.0*tfootspeed#
   else
    if basespeed#<=40.0 then tsteppingsound#=11.0*tfootspeed#
    if basespeed#>40.0 then tsteppingsound#=7.0*tfootspeed#
   endif
   if plrid=1 then tsteppingsound#=tsteppingsound#/playerspeedratio#
   rem X10 water footfalls take longer and are spaced out (wading)
   if colmaterialtype=9 then tsteppingsound#=tsteppingsound#*1.25
   if playermovementstep(plrid)>tsteppingsound# or leapedlanded=1
    leapedlanded=0 : playermovementstep(plrid)=0.0
    if plrid>1
     playinternal3dsoundfactor(sndid,entityelement(e).x,entityelement(e).y,entityelement(e).z,1.0)
    else
     broadcast3dplrsound(camera position x(playercam),camera position y(playercam),camera position z(playercam),1.0)
     tvol=soundvolumes(0)-10 : if tvol<0 then tvol=0
     if tvol>100 then tvol=100
     set sound volume sndid,tvol : rem quiten footfalls (they annoy!!)
     play sound sndid
    endif
    if colmaterialtype=9
     rem X10 water noise related to intensity
     if basespeed#>50.0 or leapedlanded=1
      tsndvolume#=95+rnd(5)
     else
      tsndvolume#=85+rnd(5)
     endif
     tsndvolume#=(tsndvolume#/100.0)*soundvolumes(0)
     tvol=tsndvolume#-10 : if tvol<0 then tvol=0
     if tvol>100 then tvol=100
     set sound volume sndid,tvol : rem quiten footsplashes (they annoy!!)
    endif
   endif
  else
   rem reset this flag only not moving/jumping/causing-footfalls
   if plrid=1 then playermovingfromastandingposture=0
  endif
 endif
endif

return

_player_resetobjectives:

rem Set mission after 100 cycle void, for now reset objectives
for mi=1 to 99 : playerobjective(mi)=0 : next mi
newlevelobjectivevoid=10
triggergameexitfade=0
missiongoaltotal=0

return

_player_mission:

rem For player one only
plrid=1

rem Only if game in ful swing
if newlevelobjectivevoid>0
 `
 rem Ensure objective cannot be met for 100 cycles at start of level
 dec newlevelobjectivevoid
 if newlevelobjectivevoid<=0
  rem Set mission through entity objective flags
  for mi=1 to 99 : playerobjective(mi)=0 : next mi
  gosub _entity_calculateobjectivestotal
  newlevelobjectivevoid=0
  triggergameexitfade=0
  rem FPSCV104RC4 - if just loaded a game, refresh objectives from savedata
  if gsaveloadobjectivesloaded=1
   for mi=0 to 99
    playerobjective(mi)=saveloadgamepositionplayerobjective(mi)
   next mi
   gsaveloadobjectivesloaded=0
  endif
 endif
 `
else
 `
 rem Decide when player wins/loses
 if player(plrid).lives=0 and player(plrid).health=0
  `
  rem Never lose if in arena mode (other players you see)
  if gmultiplayergame=1
   rem simply skip
  else
   rem LOST
   if triggergameexitfade=0
    triggergameexitfade=1 : levelwon=0
   endif
  endif
  `
 else
  `
  rem only if objectives in this level
  if missiongoaltotal>0 or (player(1).scoremax>0 and gmultiplayergame=0)
   `
   rem default is mission COMPLETE
   objectivesmet=1
   `
   rem All active objectives must be met, else mission not complete
   for mi=1 to missiongoaltotal
    if playerobjective(mi)=0 then objectivesmet=0
   next mi
   `
   rem Objective never met if arena game not objective based
   if gmultiplayergame=1
    if ggameobjectivetype<>1 then objectivesmet=0
   endif
   `
   rem X10 220707 - score goal is new overriding objective
   `if player(1).score<player(1).scoremax then objectivesmet=0
   rem X10 101207 - if score hits, ignore other objectives and WIN!
   `if player(1).scoremax>0
   ` if player(1).score>=player(1).scoremax then objectivesmet=1
   `endif
   rem V109 - 100209 - above meant any score would end level
   rem new code means if score used, then score must be met otherwise objective not met
   if player(1).scoremax>0 and gmultiplayergame=0
    if player(1).score<player(1).scoremax then objectivesmet=0
   endif
   `  
   rem If all objectives met, player wins level
   if objectivesmet=1
    `
    rem WON
    if triggergameexitfade=0
     triggergameexitfade=1 : levelwon=1
    endif
    `
   endif
   `
  endif
  `
 endif
 `
endif

rem Fading system prior to WIN/LOSE logic escape
if triggergameexitfade>0
 `
 rem Fade out screen
 inc triggergameexitfade,4
 if triggergameexitfade>255
  triggergameexitfade=255
 endif
 `
 rem apply fade to hud
 if internalfaderhud>0
  hudid=internalfaderhud : hud(hudid).hide=0
  set sprite alpha hudid,triggergameexitfade
 endif
 `
 rem When fade complete, can continue win/lose triggers
 if triggergameexitfade=255
  rem can switch from WIN to LOSE if no health by time fade done
  if player(1).health<=0 then levelwon=0
  rem complete game session
  if gmultiplayergame=1
   rem allow multi code to determine conclusion actions (multiplayer)
   gosub _multi_missioncomplete
  else
   rem exit level (single player)
   continueokay=1
  endif
  rem reset fader
  triggergameexitfade=0
 endif
 `
endif

return

_player_manager:

rem For all players
for plrid=1 to playermax
 `
 rem Player commands received
 dropitem=player(plrid).command.drop
 if dropitem>0
  playerinventory(plrid,dropitem).drop=1
  player(plrid).command.drop=0
 endif
 `
 rem X10 run out of air when underwater
` if player(plrid).y<waterlevel#
 rem 190907 - and in single player (arena players have infinite lungs)
 if plrid=1 and gmultiplayergame=0
  if waterisbelowplayer=2
   if timer()-playerairtimer>1
    ttimepassed=timer()-playerairtimer : playerairtimer=timer()
    playerairloss=playerairloss+ttimepassed
    if playerairloss>10
     ttimepassed=playerairloss/10
     playerairloss=playerairloss-(ttimepassed*10)
     player(plrid).air=player(plrid).air-ttimepassed
     if player(plrid).air<0
      rem choke under water
      player(plrid).air=player(plrid).airmax/5
      rem damage player
      tdamage=25 : if tdamage>0 then gosub _player_takedamage
      rem drown sound
      sndid=playersound(plrid,20)
      if sndid>0
       if sound playing(sndid)=1 then sndid=0
      endif
      if sndid<>0
       set sound volume sndid,soundvolumes(0)    
       play sound sndid
      endif
     endif
    endif
   endif
  else
   rem breath
   player(plrid).air=player(plrid).airmax
   playerairtimer=timer()
  endif
 endif
 `
next plrid

return

_player_obtainaweapon:
 `
 rem uses weaponindex,tqty
 if weaponindex>0
  rem adds the weapon
  weaponinvposition=pi : tgunid=weaponindex
  if gun(tgunid).settings.weaponisammo=0 and tqty=0 then tqty=1
  `x9this warped the ammo value, needs to represent cartridges only
  `x9tqty=tqty*gun(tgunid).settings.reloadqty
  gosub _player_addweapon
 endif
 `
return

_player_itemmanager:

rem For all players
for plrid=1 to playermax
 `
 rem Check inventory for any new items added
 for pi=1 to player(plrid).inventorymax
  if playerinventory(plrid,pi).new=1
   `
   rem Item checked in
   playerinventory(plrid,pi).new=0
   `
   rem Entity ID
   e=playerinventory(plrid,pi).index
   entid=entityelement(e).bankindex
   `
   rem If main player, handle internal resources
   if plrid=1
    `
    rem Entities record when they have been collected
    entityelement(e).collected=1
    `
    rem Respond to presence of WEAPON
    weaponindex=entityprofile(entid).isweapon
    tqty=entityelement(e).eleprof.quantity
    gosub _player_obtainaweapon
    `
    rem Respond to presence of AMMO
    ammoindex=entityprofile(entid).isammo
    if ammoindex>0
     tnogunforammo=1
     for ws=1 to 10
      tgunid=weaponslot(ws).pref
      if tgunid=entityprofile(entid).hasweapon
       tnogunforammo=0
       tqty=entityelement(e).eleprof.quantity*gun(tgunid).settings.reloadqty
       if gun(tgunid).settings.weaponisammo=1
        weaponammo(ws)=weaponammo(ws)+tqty
       else
        weaponclipammo(ws)=weaponclipammo(ws)+tqty
       endif
       exit
      endif
     next ws
     if tnogunforammo=1
      rem create a gun slot for it, and fill with ready ammo
      for ws=1 to 10
       if weaponslot(ws).pref=0
        tgunid=entityprofile(entid).hasweapon
        weaponslot(ws).pref=tgunid
        weaponhud(ws)=gun(tgunid).hudimage
        tqty=entityelement(e).eleprof.quantity*gun(tgunid).settings.reloadqty
        weaponclipammo(ws)=tqty
        exit
       endif
      next ws
     endif
    endif
    `
   else
    `
    rem any maintenance the NPC needs to do when it gets an item
    `
   endif
   `
  endif
 next pi
 `
 rem Check inventory for any items we need to drop
 for pi=1 to player(plrid).inventorymax
  if playerinventory(plrid,pi).drop=1
   `
   rem Entity ID
   e=playerinventory(plrid,pi).index
   entid=entityelement(e).bankindex
   `
   rem Item Entities expect a state incrememt if player drops after pickup
   entityelement(e).ai.state=entityelement(e).ai.state+1
   `
   rem Handle main player internal resources
   if plrid=1
    `
    rem Entities record when they have been dropped
    entityelement(e).collected=0
    `
    rem Respond to removal of item from inventory
    weaponindex=entityprofile(entid).isweapon
    if weaponindex>0 then gosub _player_removeweapon
    `
   else
    `
    rem any maintenance the NPC needs to do when it drops an item
    `
   endif
   `
   rem Item checked out
   playerinventory(plrid,pi).drop=0
   playerinventory(plrid,pi).index=0
   `
  endif
 next pi
 `
next plrid

return

`
` Main Player Subroutines Only
`

_player_input:

rem Input relates to PLAYER ONE ONLY (main controller of this app)
plrid=1

rem Gather input data
k$=lower$(inkey$())

rem Invincibe Mode - God Mode
if ggodmodestate=1 or gtestgamemodefromeditor=1
 if k$="i" then player(1).health=9999
endif

rem Mouseclick
tmouseclick=mouseclick()
if showgamemenu=1 or debugviewmode<>0 then tmouseclick=0

rem Mouse
player(plrid).state.firingmode=0
if player(plrid).health>0
 if tmouseclick=1 then player(plrid).state.firingmode=1
 if tmouseclick=2
  if gunzoommode=0 and gun(gunid).settings.zoommode<>0
   gunzoommode=1 : gunzoommag#=1.0
   rem play sound of gun select-zoom
   if gunsound(gunid,4).soundid>0
    if sound exist(gunsound(gunid,4).soundid)=1
     if sound playing(gunsound(gunid,4).soundid)=0
      playinternalBC3dsound(gunsound(gunid,4).soundid,camera position x(playercam),camera position y(playercam),camera position z(playercam),1)
      set sound volume gunsound(gunid,4).soundid,soundvolumes(0)    
     endif
    endif
   endif
  endif
  if gunzoommode=10 then gunzoommode=11
 else
  if gunzoommode=9 then gunzoommode=10
  if gunzoommode=20 then gunzoommode=0
 endif
 if (plrkeyR)=1 then player(plrid).state.firingmode=2
endif

rem Keyboard
if k$<>"" and gunzoommode=0
 if keyboardpress=0
  `
  rem Change weapon
  if player(plrid).health>0
   if (k$>="1" and k$<="9")
    sel=(asc(k$)-asc("1"))
    weaponkeyselection=1+sel
    weaponindex=weaponslot(weaponkeyselection).got
    if weaponindex>0 then player(plrid).command.newweapon=weaponindex
   endif
   if k$="0"
    if gunid<>0
     gunmode=31 : gunselectionafterhide=0
    endif
   endif
  endif
  `
  rem Restart if in recovermode, early start
  if player(plrid).recovershield>0 and player(plrid).recovershield<50 and k$=" "
   player(plrid).recovershield=1
  endif
  `
  rem Cannot keypress until release
  keyboardpress=1
  `
 endif
else
 keyboardpress=0
endif

rem Mouse Wheel scrolls weapons
tmz=mousemovez()
if gunselectionlockdown=0 and gunzoommode=0
 if tmz<>0
  tokay=0 : ttries=10
  while tokay=0 and ttries>0
   if tmz<0 then weaponkeyselection=weaponkeyselection-1
   if tmz>0 then weaponkeyselection=weaponkeyselection+1
   if weaponkeyselection>10 then weaponkeyselection=1
   if weaponkeyselection<1 then weaponkeyselection=10
   tweaponindex=weaponslot(weaponkeyselection).got
   if tweaponindex>0 then tokay=1
   dec ttries
  endwhile
  if tokay=1
   rem change up or down
   weaponindex=weaponslot(weaponkeyselection).got
   if weaponindex>0 then player(plrid).command.newweapon=weaponindex
  endif
 endif
else
 rem zoom magnification wheel
 if tmz<>0
  tmz#=tmz : gunzoommag#=gunzoommag#+(tmz#/100.0)
  if gunzoommag#<1.0 then gunzoommag#=1.0
  if gunzoommag#>10.0 then gunzoommag#=10.0
  plrzoominchange=1
 endif
endif

rem Use Action
if (plrkeyRETURN)=1
 player(plrid).usingaction=1
else
 player(plrid).usingaction=0
endif

rem Recover mode progress (RESTART PLAYER NEW LIFE)
tsetplayereyehud=0
if player(plrid).recovershield>0
 if player(plrid).lives>0
  player(plrid).recovershield=player(plrid).recovershield-1
  if player(plrid).recovershield>0
   tsetplayereyehud=1
  else
   rem recover player
   player(plrid).recovershield=0
   player(plrid).health=playerstartstrength
   rem restart player at spawn point
   gosub _player_unmark
   gosub _player_startpos
   rem reset entities to make distant ones dormant again
   gosub _entity_resetentitiesifplrleaps
  endif
 endif
endif
if player(plrid).lives=0 and player(plrid).health<=0
 tsetplayereyehud=1
endif
if tsetplayereyehud=1
 rem update sprite used for screen fade
 if internaleyehud>0
  hudid=internaleyehud : hud(hudid).hide=0
  hud(hudid).hidedelay=10
 endif
endif

return

_player_addweapon:

rem check all weapon slots
gotweapon=0
for ws=1 to 10
 if weaponslot(ws).got=weaponindex then gotweapon=ws
next ws
if gotweapon=0
 rem check if we have a slot preference
 gotweaponpref=0
 for ws=1 to 10
  if weaponslot(ws).pref=weaponindex then gotweaponpref=ws
 next ws
 rem add weapon
 if gotweaponpref=0
  rem find free slot
  for ws=1 to 10
   if weaponslot(ws).pref=0 then exit
  next ws
  if ws<=10
   rem add weapon into free slow and create pref for it
   weaponslot(ws).pref=weaponindex
   weaponhud(ws)=gun(weaponindex).hudimage
  else
   rem no room for weapon in available slots
   ws=0
  endif
 else
  ws=gotweaponpref
 endif
 remstart
 rem switch to collected weapon
 if ws>0
  rem insert as slot weapon
  weaponslot(ws).got=weaponindex
  weaponslot(ws).invpos=weaponinvposition
  autoloadgun=weaponindex
  weaponkeyselection=ws
  gotweapon=ws
 endif
 remend
 rem place details of weapon in slot
 if ws>0
  rem insert as slot weapon
  weaponslot(ws).got=weaponindex
  weaponslot(ws).invpos=weaponinvposition
  gotweapon=ws
  if gunid=0
   rem if no gun held, auto select collected
   autoloadgun=weaponindex
   weaponkeyselection=ws
  endif
 endif
endif
`
rem weapons start with some ammo
if gotweapon>0
 tgunid=weaponslot(gotweapon).pref
 if gun(tgunid).settings.weaponisammo=0
  if tqty=0 then tqty=1
  if weaponammo(gotweapon)=0
   weaponammo(gotweapon)=gun(tgunid).settings.reloadqty
   dec tqty
  endif
  weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
 endif
endif

return

_player_removeweapon:

rem check all weapon slots
for ws=1 to 10
 if weaponslot(ws).got=weaponindex then exit
next ws
if ws<=10
 `
 rem Ensure gun is removed (if applicable)
 if gunid>0 and weaponslot(ws).got=gunid
  autoloadgun=0
 endif
 `
 rem drop weapon from slot
 weaponslot(ws).got=0
 weaponslot(ws).invpos=0
 `
endif

return

`
` Player Movement Related
`

_player_unmark:
 gosub _physics_unmark
return

_player_mark:
 gosub _physics_mark
return

_player_camera:
 plrid=1 : gosub _physics_playercamera
 basespeed#=plrbasespeed# : gosub _player_playfootfall
 if cty#<=-100 then tdamage=65000 : gosub _player_takedamage
return

_player_listener:
 gosub _physics_listener
return

`
` Player Gun Functions (should they be here)
`

function loadgun(tfile$)
 index=0
 if gunbankmax>0
  for t=1 to gunbankmax
   if tfile$=gunbank$(t) then index=gunbankoffset+t : exit
  next t
 else
  t=gunbankmax+1
 endif
 if t>gunbankmax
  inc gunbankmax
  if file exist(tfile$)=1
   index=gunbankoffset+gunbankmax
   gunbank$(gunbankmax)=tfile$
   load object tfile$,index
   addfiletocollection(tfile$)
   set object collision off index
   set object interpolation index,100
   set object frame index,gun(gunbankmax).action.show.s
   hide object index
  endif
 endif
endfunction index

function createsecondgun()
 inc gunbankmax
 gunbank$(gunbankmax)="second"
 index=gunbankoffset+gunbankmax
endfunction index

function loadbrass(tfile$)
 index=0
 if brassbankmax>0
  for t=1 to brassbankmax
   if tfile$=brassbank$(t) then index=brassbankoffset+t : exit
  next t
 else
  t=brassbankmax+1
 endif
 if t>brassbankmax
  inc brassbankmax
  if file exist(tfile$)=1
   index=brassbankoffset+brassbankmax
   brassbank$(brassbankmax)=tfile$
   load object tfile$,index
   addfiletocollection(tfile$)
   set object collision off index
   disable object zdepth index
   set object transparency index,1
   set object specular index,15
   set object fov index,45
  endif
 endif
endfunction index

function loadmuzzle(tfile$)
 index=0
 if muzzlebankmax>0
  for t=1 to muzzlebankmax
   if tfile$=muzzlebank$(t) then index=muzzlebankoffset+t : exit
  next t
 else
  t=muzzlebankmax+1
 endif
 if t>muzzlebankmax
  inc muzzlebankmax
  muzzlebank$(muzzlebankmax)=tfile$
  index=muzzlebankoffset+muzzlebankmax
  loadinternalimageexcompress(tfile$,index,5)
 endif
endfunction index

function loadsmoke(tfile$)
 index=0
 if smokebankmax>0
  for t=1 to smokebankmax
   if tfile$=smokebank$(t) then index=smokebankoffset+t : exit
  next t
 else
  t=smokebankmax+1
 endif
 if t>smokebankmax
  inc smokebankmax
  smokebank$(smokebankmax)=tfile$
  index=smokebankoffset+smokebankmax
  loadinternalimageexcompress(tfile$,index,5)
 endif
endfunction index



rem
rem GUN CORE
rem


_gun_init:

rem Load all guns into memory
gosub _gun_scaninall_ref

rem Force all weapons into weapon slots (initial default start)
if level=1 then gosub _gun_gatherslotorder

rem No gun to start with
weaponammoindex=0
autoloadgun=-1
gunid=0

return

_gun_loadonlypresent:
 `
 rem Load only active guns from slots (and from playerstartentry)
 for tww=1 to 10
  gunid=weaponslot(tww).pref
  if gunid>0 then gun(gunid).activeingame=1
 next tww
 `
 rem load in any guns that entities specify
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  gunid=entityprofile(entid).hasweapon
  if gunid>0 then gun(gunid).activeingame=1
  gunid=entityprofile(entid).isweapon
  if gunid>0 then gun(gunid).activeingame=1
 next e
 `
 rem Load all guns that have been activated
 for gunid=1 to gunmax
  if gun(gunid).activeingame=1
   gun$=gun(gunid).name$ : gosub _gun_load
  endif
 next gunid
 `
 rem And now fill in player weapon details
 for tww=1 to 10
  gunid=weaponslot(tww).pref
  if gunid>0
   if gun(gunid).activeingame=1
    weaponhud(tww)=gun(gunid).hudimage
   endif
  endif
 next tww
 `
 rem Ensure gun vars are reset
 gunid=0
 `
return

_gun_resetgunsettings:
 `
 rem Reset weapons (1=restart)
 if tcopyorrestart=0
  rem copy
  dim copyweaponslot(10) as weaponslottype
  dim copyweaponammo(10) as integer
  dim copyweaponclipammo(10) as integer
  dim copyweaponhud(10) as integer
  for ws=1 to 10
   copyweaponslot(ws)=weaponslot(ws)
   copyweaponammo(ws)=weaponammo(ws)
   copyweaponclipammo(ws)=weaponclipammo(ws)
   copyweaponhud(ws)=weaponhud(ws)
  next ws
 else
  rem restore
  for ws=1 to 10
   weaponslot(ws)=copyweaponslot(ws)
   weaponammo(ws)=copyweaponammo(ws)
   weaponclipammo(ws)=copyweaponclipammo(ws)
   weaponhud(ws)=copyweaponhud(ws)
  next ws
 endif
 `
return

_gun_manager:

rem Gun controls
gunclick=player(1).state.firingmode
if gunmode<100
 rem Gun Firing
 if gunclick<>1 then gunmustreleasefirst=0
 if gunclick<>0
  if gunclick=1 and gunmustreleasefirst=0 then gunmode=101
  if gunclick=2 then gunmode=121
 else
  rem Gun Movement
  if gunmode<21 or gunmode>39
   if player(1).state.moving=1 then gunmode=21
  endif
 endif
endif

rem Gun Selection
if gunselectionlockdown=0
 if player(1).command.newweapon>0
  sel=player(1).command.newweapon
  player(1).command.newweapon=0
  if weaponammoindex>0
   rem only if 'different weapon'
   if weaponslot(weaponammoindex).pref<>sel
    gunmode=31 : gunselectionafterhide=sel
   endif
  else
   gunmode=131 : autoloadgun=sel
  endif
 endif
endif

rem Change weapon
gosub _gun_change

rem Need to update hud object for gun here (and again after SYNC)
gosub _gun_update_hud

rem Gun control
if gunid>0
 if object exist(currentgunobj)=1
  gosub _gun_control
  gosub _gun_shoot
  if gun(gunid).settings.flashlimb>=0 then gosub _gun_flash
  if gun(gunid).settings.brasslimb>=0 then gosub _gun_brass
  `x9if gun(gunid).settings.brasslimb>=0 then gosub _gun_smoke
  if gun(gunid).settings.smokelimb>=0 then gosub _gun_smoke
  gosub _gun_soundcontrol
 endif
endif

rem Independent handling (no matter which guns is selected)
gosub _gun_brass_indi

return

_gun_change:

if autoloadgun<>-1
 `
 rem Free the old gun
 gosub _gun_free
 `
 rem Gun selection
 gunid=autoloadgun
 gun$=gun(gunid).name$
 autoloadgun=-1
 hudcrosshair=0
 `
 rem If gun selection valid, load it
 if gun$<>"" then gosub _gun_selectandorload

 rem cause gun lighting to reset
 currentguncolr=-1 : gosub _lighting_applyplayerlighting

 rem Show gun as active
 currentgunobj=gun(gunid).obj
 if currentgunobj>0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.show.s
  show object currentgunobj
 else
  gunid=0
 endif

 rem Default gun action is to SHOW and reveal gun (then goes to gunmode=5 idle)
 gunmode=131 : keyboardpress=0

 rem locate slot for ammo usage
 weaponammoindex=0
 if gunid>0
  for ws=1 to 10
   if weaponslot(ws).pref=gunid
    weaponammoindex=ws : exit
   endif
  next ws
 endif

endif

return

_gun_update_hud:

rem HUD marker update
if object exist(hudbankoffset+2)=1
 gunax#=camera angle x(playercam) : gunay#=camera angle y(playercam)
 position object hudbankoffset+2,camera position x(playercam),camera position y(playercam),camera position z(playercam)
 if gunsafetymode=1
  rem X10 - 061207 - drop gun downwards to avoid shooting allies ad neutrals
  rotate object hudbankoffset+2,curveangle(gunax#+9,object angle x(hudbankoffset+2),5.0),gunay#,0
 else
  rem V109 - 140109 - for MP5 guns (with arms) can see end of arms and gun flicks on Y (so restore X9 functionality)
  `rotate object hudbankoffset+2,curveangle(gunax#,object angle x(hudbankoffset+2),2.0),gunay#,0
  rotate object hudbankoffset+2,gunax#,gunay#,0
 endif
 if currentgunobj>0
  if object exist(currentgunobj)=1
   if player(1).health>0
    show object currentgunobj
   else
    hide object currentgunobj
   endif
  endif
 endif
endif

return

_gun_update_overlay:
return

_gun_control:

rem X10 gun animation speed (before timer based mod)
gunanimationspeed#=75.0

rem gun position offset and rotation
if plrzoomin#<>0.0
 plrzoomaccuracy#=gun(gunid).settings.zoomaccuracy/100.0
 position object currentgunobj,gun(gunid).horiz#,gun(gunid).vert#,gun(gunid).forward#-(plrzoomin#*10.0)
else
 position object currentgunobj,gun(gunid).horiz#,gun(gunid).vert#,gun(gunid).forward#
endif
rotate object currentgunobj,0,180,0

rem hide the object if weapon-ammo and no qty left
if gun(gunid).settings.weaponisammo=1
 if weaponammo(weaponammoindex)=0
  hide object currentgunobj
 else
  show object currentgunobj
 endif
endif

rem gun idle control ((4*0.75)=3.0)
if gunmode=5
 gunmode=6
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.idle.s+3.0
endif
if gunmode=6
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.idle.s+3.0
  gunmode=7
 endif
endif
if gunmode=7
 gunmode=8
 play object currentgunobj,gun(gunid).action.idle.s+3.0,gun(gunid).action.idle.e
endif
if gunmode=8
 if object frame(currentgunobj)>=gun(gunid).action.idle.e then gunmode=9
endif
if gunmode=9
 gunmode=10
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.idle.s+3.0
endif
if gunmode=10
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.idle.s+3.0
  gunmode=7
 endif
endif

rem gun movment control ((4*0.75)=3.0
if gunmode=21
 gunmode=22
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.move.s+3.0
endif
if gunmode=22
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.move.s+3.0
  gunmode=23
 endif
endif
if gunmode>=23 and gunmode<=26
 if movement=0 then gunmode=5
endif
if gunmode=23
 gunmode=24
 play object currentgunobj,gun(gunid).action.move.s+3.0,gun(gunid).action.move.e
endif
if gunmode=24
 if object frame(currentgunobj)>=gun(gunid).action.move.e then gunmode=25
endif
if gunmode=25
 gunmode=26
 guninterp=4
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.move.s+3.0
endif
if gunmode=26
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.move.s+3.0
  gunmode=23
 endif
endif

rem gun put away and hide control
if gunmode=31
 gunmode=32
 guninterp=4
 gunselectionlockdown=1
 stop object currentgunobj
 set object interpolation currentgunobj,25
 set object frame currentgunobj,gun(gunid).action.hide.s
 rem play sound of gun select-change
 if gunsound(gunid,4).soundid>0
  if sound exist(gunsound(gunid,4).soundid)=1
   if sound playing(gunsound(gunid,4).soundid)=0
    playinternalBC3dsound(gunsound(gunid,4).soundid,camera position x(playercam),camera position y(playercam),camera position z(playercam),1)
   endif
  endif
 endif
endif
if gunmode=32
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.hide.s
  gunanimationspeed#=125.0
  gunmode=33
 endif
endif
if gunmode=33
 gunmode=34
 set object interpolation currentgunobj,100
 play object currentgunobj,gun(gunid).action.hide.s,gun(gunid).action.hide.e
endif
if gunmode=34
 if object frame(currentgunobj)>=gun(gunid).action.hide.e then gunmode=35
endif
if gunmode=35
 gunanimationspeed#=75.0
 autoloadgun=gunselectionafterhide
 gunselectionlockdown=0
 gunmode=5
endif

rem X10 - 061207 - scan direction of gun, ensure cannot point at neutral or allies
gunsafetymode=0
gunsafetymodeoverride=0
closestfriendly#=99999.9
closestenemy#=99999.9
if bloodmode$="off"
 for friendscane=1 to entityelementlist
  if entityelement(friendscane).active=1
   friendscanentid=entityelement(friendscane).bankindex
   if entityprofile(friendscanentid).ischaracter=1
    friendscanobj=entityelement(friendscane).obj
    if friendscanobj>0
     if object exist(friendscanobj)=1
      if object in screen(friendscanobj)=1
       friendscanx=object screen x(friendscanobj)
       friendscany=object screen y(friendscanobj)
       friendscanwidth=screen width()/5
       friendscanheight=screen height()/4
       if friendscanx>(screen width()/2)-friendscanwidth
        if friendscanx<(screen width()/2)+friendscanwidth
         if friendscany>(screen height()/2)-friendscanheight
          if friendscany<(screen height()/2)+friendscanheight
           if entityelement(friendscane).eleprof.ex.alignment=1
            rem at least one enemy in view, so keep gun raised (HL2 style)
            if gunmode=104
             rem but only if was already firing!
             closestenemy#=0
            else
             rem or closer than any friendly (see below)
             ttdx#=entityelement(friendscane).x-mex#
             ttdz#=entityelement(friendscane).z-mez#
             closestenemy#=sqrt(abs(ttdx#*ttdx#)+abs(ttdz#*ttdz#))
            endif
            gunsafetymodeoverride=1
           else
            rem any none enemy character cannot be shot          
            ttdx#=entityelement(friendscane).x-mex#
            ttdz#=entityelement(friendscane).z-mez#
            closestfriendly#=sqrt(abs(ttdx#*ttdx#)+abs(ttdz#*ttdz#))
            gunsafetymode=1
           endif
          endif
         endif
        endif
       endif 
      endif
     endif
    endif
   endif
  endif
 next friendscane
endif
if gunsafetymodeoverride=1
 if closestenemy#<closestfriendly#
  gunsafetymode=0
 endif
endif

rem gun firing control
if gunmode=101
 if gunsafetymode=1
  gunmode=107
 else
  if gun(gunid).settings.reloadqty=0 then weaponammo(weaponammoindex)=99999
  if weaponammo(weaponammoindex)>0
   gunmode=102
   set object interpolation currentgunobj,100
   play object currentgunobj,gun(gunid).action.start.s,gun(gunid).action.start.e
  else
   if gunclick<>1
    if gunsound(gunid,3).soundid>0
     if sound exist(gunsound(gunid,3).soundid)=1
      if sound playing(gunsound(gunid,3).soundid)=0
       playinternalBC3dsound(gunsound(gunid,3).soundid,camera position x(playercam),camera position y(playercam),camera position z(playercam),100)
      endif
     endif
    endif
    gunmode=107
   endif
  endif
 endif
endif
if gunmode=102
 if gunsafetymode=1
  gunmode=107
 else
  if object frame(currentgunobj)>=gun(gunid).action.start.e then gunmode=103
 endif
endif
if gunmode=103
 if gunsafetymode=1
  gunmode=107
 else
  gunmode=104 : gunflash=1
  gunshoot=1 : guntimercount=6
  weaponammo(weaponammoindex)=weaponammo(weaponammoindex)-1
  if gun(gunid).settings.brasslimb<>-1 then gunbrass=1 : gunbrasscount=6
  if gun(gunid).settings.smokelimb<>-1 then gunsmoke=1 : gunsmokecount=6
  sndid=gunsound(gunid,1).soundid
  if sndid>0
   if sound exist(sndid)=1
    if gun(gunid).action.automatic.s>0
     loop object currentgunobj,gun(gunid).action.automatic.s,gun(gunid).action.automatic.e
     set sound volume sndid,soundvolumes(0)
     play sound sndid,gun(gunid).sound.fireloopend : rem some sound bug
     loop sound sndid,0,gun(gunid).sound.fireloopend
     gunstartedaloopsoundsndid=sndid
     gunstartedaloopsoundattimer=timer()
    endif
   endif
  endif
 endif
endif
if gunmode=104
 if gunsafetymode=1
  gunmode=107
 else
  if weaponammo(weaponammoindex)>0
   if gunflash=0 then gunflash=1
   gunbrasscount=gunbrasscount-timebasepercycle#
   gunsmokecount=gunsmokecount-timebasepercycle#
   guntimercount=guntimercount-timebasepercycle#
   if gunbrasscount<=0 and gun(gunid).settings.brasslimb<>-1 then gunbrass=1 : gunbrasscount=6
   if gunsmokecount<=0 and gun(gunid).settings.smokelimb<>-1 then gunsmoke=1 : gunsmokecount=6
   if guntimercount<=0 then gunshoot=1 : guntimercount=6 : weaponammo(weaponammoindex)=weaponammo(weaponammoindex)-1
   if gun(gunid).action.automatic.s=0 then gunmode=105
   if gunclick<>1 then gunmode=105
   sndid=gunsound(gunid,1).soundid
   if sndid>0
    if sound exist(sndid)=1
     position sound sndid,camera position x(playercam),camera position y(playercam),camera position z(playercam)
     broadcast3dplrsound(camera position x(playercam),camera position y(playercam),camera position z(playercam),100)
     set sound volume sndid,soundvolumes(0)
    endif
   endif
  else
   gunmode=105
  endif
 endif
endif
if gunmode=105
 if gunsafetymode=1
  gunmode=107
 else
  if gun(gunid).action.automatic.s>0
   rem automatic weapons cannot resume firing right away
  else
   gunmustreleasefirst=1
  endif
  if gun(gunid).action.finish.s>0
   gunmode=106
   play object currentgunobj,gun(gunid).action.finish.s,gun(gunid).action.finish.e
   sndid=gunsound(gunid,1).soundid
   if sndid>0
    if sound exist(sndid)=1
     position sound sndid,camera position x(playercam),camera position y(playercam),camera position z(playercam)
     set sound volume sndid,soundvolumes(0)
     play sound sndid,gun(gunid).sound.fireloopend
    endif
   endif
   broadcast3dplrsound(camera position x(playercam),camera position y(playercam),camera position z(playercam),100)
  else
   gunmode=107
  endif
 endif
endif
if gunmode=106
 if gunsafetymode=1
  gunmode=107
 else
  if object frame(currentgunobj)>=gun(gunid).action.finish.e then gunmode=107
 endif
endif
if gunmode=107
 rem X10 stop stray fire sound (loop can be left on)
 rem also added more code doing the same thing below
 sndid=gunsound(gunid,1).soundid
 if sndid>0
  if sound exist(sndid)=1
   if gun(gunid).action.automatic.s>0
    if sound playing(sndid)=1
     stop sound sndid
    endif
   endif
  endif
 endif
 rem reset to normal
 gunmode=5
 rem auto-reload if no bullets
 if weaponammo(weaponammoindex)=0
  if weaponclipammo(weaponammoindex)>0
   rem direct into reload
   gunmode=121
  endif
 endif
endif

rem X10 - 071007 - sound loop can be left on
if gunmode<101 or gunmode>106
 if timer()-gunstartedaloopsoundattimer>1000
  sndid=gunstartedaloopsoundsndid
  gunstartedaloopsoundsndid=0
  if sndid>0
   if sound exist(sndid)=1
    stop sound sndid
   endif
  endif
 endif
endif

rem gun reload and cock control
if gunmode=121
 if weaponclipammo(weaponammoindex)=0 or gun(gunid).settings.weaponisammo=1
  if gun(gunid).settings.weaponisammo=0
   if gunsound(gunid,3).soundid>0
    if sound exist(gunsound(gunid,3).soundid)=1
     if sound playing(gunsound(gunid,3).soundid)=0
      playinternalBC3dsound(gunsound(gunid,3).soundid,camera position x(playercam),camera position y(playercam),camera position z(playercam),50)
      set sound volume gunsound(gunid,3).soundid,soundvolumes(0)
     endif
    endif
   endif
  endif
  gunmode=5
 else
  gunmode=122
  guninterp=4
  stop object currentgunobj
  set object interpolation currentgunobj,25
  set object frame currentgunobj,gun(gunid).action.startreload.s
 endif
endif
if gunmode=122
 dec guninterp,1
 if guninterp<=0
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.startreload.s
  gunmode=123
 endif
endif
if gunmode=123
 gunmode=124
 set object interpolation currentgunobj,100
 play object currentgunobj,gun(gunid).action.startreload.s,gun(gunid).action.cock.e
 if gunsound(gunid,2).soundid>0
  if sound exist(gunsound(gunid,2).soundid)=1
   position sound gunsound(gunid,2).soundid,camera position x(playercam),camera position y(playercam),camera position z(playercam)
  endif
 endif
endif
if gunmode=124
 if object frame(currentgunobj)>=gun(gunid).action.cock.e then gunmode=125
endif
if gunmode=125
 rem actual reload
 tneedfromclip=gun(gunid).settings.reloadqty-weaponammo(weaponammoindex)
 if tneedfromclip>weaponclipammo(weaponammoindex) then tneedfromclip=weaponclipammo(weaponammoindex)
 if tneedfromclip>0
  weaponammo(weaponammoindex)=weaponammo(weaponammoindex)+tneedfromclip
  weaponclipammo(weaponammoindex)=weaponclipammo(weaponammoindex)-tneedfromclip
 endif
 gunmode=5
endif

rem gun reveal
if gunmode=131
 set object interpolation currentgunobj,100
 set object frame currentgunobj,gun(gunid).action.show.s
 play object currentgunobj,gun(gunid).action.show.s,gun(gunid).action.show.e
 if gunsound(gunid,2).soundid>0
  if sound exist(gunsound(gunid,2).soundid)=1
   position sound gunsound(gunid,2).soundid,camera position x(playercam),camera position y(playercam),camera position z(playercam)
  endif
 endif
 gunmode=132
endif
if gunmode=132
 if object frame(currentgunobj)>=gun(gunid).action.show.e then gunmode=5
endif

rem X10 timer based speed - if we ran at 60fps, animspeed# would be exactly 1.0
rem if we ran at 30fps, animspeed# would be 2.0, and 120fps would be 0.5
animspeed#=(1.0/40.0)*(timer()-lastanimspeedtime) : lastanimspeedtime=timer()
set object speed currentgunobj,gunanimationspeed#*animspeed#

return

_gun_flash:

if plrzoomin#<>0.0
 rem X10 - 101007 - ensure muzzle flash is hidden when in zoom mode
 gunflash=3 `gunflash=0
endif
if gunflash=1
 `
 rem fire flash init
 gunflash=2
 gunflashcount=6
 rotate object hudbankoffset+5,0,0,rnd(360)
 show object hudbankoffset+5
 if gun(gunid).settings.flashlimb2<>-1
  rotate object hudbankoffset+32,0,0,rnd(360)
  show object hudbankoffset+32
 endif
 `
 rem light flash init
 if spotmultiplier#<>5.0
  spotflash=100 : spotmultiplier#=1.0
  tx#=camera position x(playercam)
  ty#=camera position y(playercam)
  tz#=camera position z(playercam)
  tcolr=gun(gunid).settings.muzzlecolorr/3
  tcolg=gun(gunid).settings.muzzlecolorg/3
  tcolb=gun(gunid).settings.muzzlecolorb/3
  gosub _lighting_spotflash
 endif
 `
endif
if gunflash=2
 gunflashcount=gunflashcount-timebasepercycle#
 if gunflashcount<=4
  rem hide early
  hide object hudbankoffset+5
  hide object hudbankoffset+32
 endif
 if gunflashcount<=0
  gunflash=3
 endif
endif
if gunflash=3
 gunflash=0
 rem final hide
 hide object hudbankoffset+5
 hide object hudbankoffset+32
endif

return

_gun_brass:

rem FPSCV104RC5-twingun
gunbrass2=0 : if gunbrass=1 and gun(gunid).settings.flashlimb2<>-1 then gunbrass2=1

rem find free shell and expell
for o=6 to 20
 obj=hudbankoffset+o
 if object visible(obj)=0 and gunbrass=1
  lx#=limb position x(currentgunobj,gun(gunid).settings.brasslimb)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,gun(gunid).settings.brasslimb)
  lz#=limb position z(currentgunobj,gun(gunid).settings.brasslimb)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  set object to object orientation obj,hudbankoffset+2
  roll object left obj,25+rnd(10)
  brassfallcount(o)=15
  show object obj
  gunbrass=0
 endif
 if object visible(obj)=0 and gunbrass=0 and gunbrass2=1
  lx#=limb position x(currentgunobj,gun(gunid).settings.brasslimb2)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,gun(gunid).settings.brasslimb2)
  lz#=limb position z(currentgunobj,gun(gunid).settings.brasslimb2)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  set object to object orientation obj,hudbankoffset+2
  roll object left obj,25+rnd(10)
  brassfallcount(o)=15
  show object obj
  gunbrass2=0
 endif
next o

return

_gun_brass_indi:
 for o=6 to 20
  obj=hudbankoffset+o
  if object visible(obj)=1
   if brassfallcount(o)>5
    eject#=1.0
   else
    eject#=brassfallcount(o)/5.0
   endif
   move object right obj,1.0
   if object position y(obj)>object position y(hudbankoffset+2)-20
    if brassfallcount(o)>0
     brassfallcount(o)=brassfallcount(o)-1
     roll object right obj,4.0
    endif
   endif
   position object obj,object position x(obj),object position y(obj)-((1.0-eject#)*1.0),object position z(obj)
   if object position y(obj)<object position y(hudbankoffset+2)-50 or object in screen(obj)=0
    hide object obj
   endif
  endif
 next o
return

_gun_smoke:

rem FPSCV104RC5-twingun
gunsmoke2=0 : if gunsmoke=1 and gun(gunid).settings.flashlimb2<>-1 then gunsmoke2=1

rem find free smoke and puff
for o=21 to 30
 obj=hudbankoffset+o
 if object visible(obj)=0 and gunsmoke=1
  ttsmokelimb=gun(gunid).settings.smokelimb
  if ttsmokelimb<=0 then ttsmokelimb=gun(gunid).settings.brasslimb
  lx#=limb position x(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  lz#=limb position z(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  show object obj
  gunsmoke=0 : smokeframe=0
 endif
 if object visible(obj)=0 and gunsmoke=0 and gunsmoke2=1
  ttsmokelimb=gun(gunid).settings.smokelimb2
  if ttsmokelimb<=0 then ttsmokelimb=gun(gunid).settings.brasslimb
  lx#=limb position x(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  ly#=limb position y(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  lz#=limb position z(currentgunobj,ttsmokelimb)+1.0-(rnd(20)/10.0)
  position object obj,lx#,ly#,lz#
  show object obj
  gunsmoke2=0 : smokeframe=0
 endif
 if object visible(obj)=1
  point object obj,camera position x(playercam),camera position y(playercam),camera position z(playercam)
  smokerisespeed#=gun(gunid).settings.smokespeed/100.0
  position object obj,object position x(obj),object position y(obj)+smokerisespeed#,object position z(obj)
  smokeframe=(object position y(obj)-ly#)/0.75
  if object in screen(obj)=1 and smokeframe<=15
   ty=smokeframe/4
   tx=smokeframe-(ty*4)
   q#=1.0/4.0 : tx#=tx*q# : ty#=ty*q#
   rem vertex data lock mode of 1=update (faster method if mesh size unchanged)
   lock vertexdata for limb obj,0,1
   rem X10 plane
   if 1
    set vertexdata uv 0,tx#,ty#
    set vertexdata uv 1,tx#+q#,ty#
    set vertexdata uv 2,tx#,ty#+q#
    set vertexdata uv 3,tx#+q#,ty#
    set vertexdata uv 4,tx#+q#,ty#+q#
    set vertexdata uv 5,tx#,ty#+q#
   else
    set vertexdata uv 0,tx#+q#,ty#
    set vertexdata uv 1,tx#,ty#
    set vertexdata uv 2,tx#+q#,ty#+q#
    set vertexdata uv 3,tx#,ty#
    set vertexdata uv 4,tx#,ty#+q#
    set vertexdata uv 5,tx#+q#,ty#+q#
   endif
   unlock vertexdata
  else
   hide object obj
  endif
 endif
next o

return

_gun_shoot:

rem when fire line active
if gunshoot=1
 if gun(gunid).settings.flakindex=0
  `
  rem BULLET
  rem gun data controls iterations and accuracy
  trayiter=1+gun(gunid).settings.iterate
  trayaccuracy=gun(gunid).settings.accuracy
  bulletdamage=gun(gunid).settings.damage
  `
  rem Special ZOOMODE kill in multiplayer
  if gmultiplayergame=1
   if gunzoommode<>0
    bulletdamage=65500
   endif
  endif
  `
  rem for some weapons, blunderbus style five-ray shot
  multiplayerdamagecollected=0
  for traycount=1 to trayiter
   `
   rem project gun-line-for-shot
   x1#=camera position x(playercam)+(trayaccuracy/2)-rnd(trayaccuracy)
   y1#=camera position y(playercam)+(trayaccuracy/2)-rnd(trayaccuracy)
   z1#=camera position z(playercam)+(trayaccuracy/2)-rnd(trayaccuracy)
   position object hudbankoffset+3,x1#,y1#,z1#
   set object to camera orientation hudbankoffset+3
   move object hudbankoffset+3,gun(gunid).settings.range
   disable object zdepth hudbankoffset+3
   x2#=object position x(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
   y2#=object position y(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
   z2#=object position z(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
   `
   rem reset bullethit vars
   bullethit=0 : bullethitstatic=0
   tbullethitmaterial=0 : tbullethitflesh=0
   bulletraytype=gun(gunid).settings.damagetype
   gunrange#=gun(gunid).settings.range
   `
   rem raycast to surface (bullets path)
   rem 120807 - moved to before _entity_hasbulletrayhit so I can shorten destination
   rem if the wall is going to stop the bullet and cut short the current ray
   dstwallhit#=static raycast(x1#,y1#,z1#,x2#,y2#,z2#)
   if dstwallhit#>0
    wallhitx#=checklist fvalue a(6)
    wallhity#=checklist fvalue b(6)
    wallhitz#=checklist fvalue c(6)
    wallhitmaterial=get static collision value()-1
    rem 120807 - cut short this ray if bullet hits wall
    x2#=wallhitx#
    y2#=wallhity#
    z2#=wallhitz#
   endif
   `
   rem raycastto entity
   gosub _entity_hasbulletrayhit
   `
   rem has bullet hit any entity
   if tcloseste>0 and (dstwallhit#=0 or dstwallhit#>tclosestdist#)
    `
    rem complete rayhit if wall not in way (must come right after _entity_hasbulletrayhit)
    gosub _entity_completerayhit
    `
    rem move entity by that direction with some force (non-multiplayer)
    useknockbackasplayershotcharacter=1
    e=bulletrayhit : gosub _entity_shotbygun
    remstart
    rem this was moved to a subroutine we can call as the player or as ally/enemy
    tentid=entityelement(e).bankindex
    if gmultiplayergame=0
     if bulletraytype=2
      tforce#=gun(gunid).settings.damage/5.0
     else
      tforce#=gun(gunid).settings.damage/30.0
     endif
     rem entity prone to force
     if entityelement(e).eleprof.isimmobile=0
      rem apply force
      rem X10 also, if a ragdoll when shot, also apply force
      rem X10 or it is a character (soon to be ragdoll)
      if entityelement(e).eleprof.physics=1
       rem using advanced physics (force is soft if entity destroyed in hit)
       todee=e : tdx#=tix# : tdy#=tiy# : tdz#=tiz# : todefalloff#=0.0
       rem X10 apply general force for any entity forced by shot
       todeforce#=tforce#*25.0
       tpx#=x# : tpy#=y# : tpz#=z# : gosub _physics_applypointforce
      else
       if entityprofile(tentid).ischaracter=1
        rem used later when convert to ragdoll
        if entityelement(e).health<=0
         rem if health low
         entityelement(e).force.active=1+tforce#
         entityelement(e).force.ix=tix#
         entityelement(e).force.iy=tiy#
         entityelement(e).force.iz=tiz#
         rem 040707 - provide origin of force (for later use in ragdoll velocity)
         entityelement(e).force.originx=x1#
         entityelement(e).force.originy=y1#
         entityelement(e).force.originz=z1#
        endif
       else
        rem using regular force calc
        entityelement(e).force.active=1
        entityelement(e).force.ix=tix#*tforce#
        entityelement(e).force.iy=tiy#*tforce#
        entityelement(e).force.iz=tiz#*tforce#
        rem 040707 - provide origin of force
        entityelement(e).force.originx=x1#
        entityelement(e).force.originy=y1#
        entityelement(e).force.originz=z1#
       endif
      endif
     endif
    endif
    remend
    if entityprofile(tentid).ischaracter=1
     rem only if character full of red blood (and had health)!
     tbullethitflesh=entityprofile(tentid).bloodscorch
    endif
    bullethit=1
    `
   else
    `
    rem has bullet hit some debris between gun and wall
    if dstwallhit#>0
     tforce#=gun(gunid).settings.damage/5.0
     gosub _part_movedebrisifinray
    endif
    `
   endif
   `
   rem had bulletray hit anything solid
   if bulletrayhit>0
    if tbullethitflesh=0
     if bulletrayhitdist#<dstwallhit# then dstwallhit#=0.0
    else
     rem work out size of blood splat based on distance from flesh to surface (0-100)
     t#=abs(dstwallhit#-bulletrayhitdist#)
     if t#<200
      tbullethitflesh=t#/2.0
     else
      dstwallhit#=0.0
     endif
    endif
   endif
   `
   rem wallhit?
   tsoundtrigger=0 : tsoundmaterial=0
   if dstwallhit#>0
    rem flag the creation of a scorch for the solid surface
    x#=wallhitx# : y#=wallhity# : z#=wallhitz#
    if wallhitmaterial>=1 then tbullethitmaterial=wallhitmaterial
    bullethitstatic=1 : bullethit=1
    rem trigger a sound for this material type (1-stone/4-glass)
    if wallhitmaterial>=0
     tmatindex=wallhitmaterial
     if tmatindex>=0 and tmatindex<=gmaterialmax
      tsoundmaterial=1+tmatindex
      tsoundtrigger=material(tmatindex).impactid
      tsx#=wallhitx# : tsy#=wallhity# : tsz#=wallhitz#
      tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
     endif
    endif
   endif
   `
   rem if material sound triggered
   tvol#=100 : gosub _physics_triggermaterialsound
   gosub _decal_triggermaterialdebris
   `
   rem bullet result
   if bullethit=1
    `
    rem trigger decal for blood splat/whatever effect
    if bulletrayhit>0
     e=bulletrayhit
     tentid=entityelement(e).bankindex
     decalid=entitydecal(tentid,1)
     if decalid>0
      rem direction from player to entity
      tix#=x2#-x1# : tiy#=y2#-y1# : tiz#=z2#-z1#
      tdd#=sqrt(abs(tix#*tix#)+abs(tiy#*tiy#)+abs(tiz#*tiz#))
      tix#=tix#/tdd# : tiy#=tiy#/tdd# : tiz#=tiz#/tdd#
      rem find point of impact
      tix#=tix#*(bulletrayhitdist#-10.0)
      tiy#=tiy#*(bulletrayhitdist#-10.0)
      tiz#=tiz#*(bulletrayhitdist#-10.0)
      rem create a splat decal
      decalscalemodx=0 : rem FPSCV101 - fix
      decalorient=0 : decalx=x1#+tix# : decaly=y1#+tiy# : decalz=z1#+tiz#
      originatore=-1 : gosub _decalelement_create
     endif
    endif
    `
    rem add scorch if hit universe static polygons
    if bullethitstatic=1
     `
     rem add scorch to universe
     tscorchtype=gun(gunid).settings.scorchtype
     gosub _entity_doscorch
     `
     rem X10 impact smoke (short-lived smoke emit)
     rem only if above waterline
     if wallhity#>waterlevel#
      if particlegunsmoke<>0
       inc particlegunsmoke
       if particlegunsmoke>5 then particlegunsmoke=1
       rem work out a step back direction
       tix#=x2#-x1# : tiy#=y2#-y1# : tiz#=z2#-z1#
       tdd#=sqrt(abs(tix#*tix#)+abs(tiy#*tiy#)+abs(tiz#*tiz#))
       tix#=tix#/tdd# : tiy#=tiy#/tdd# : tiz#=tiz#/tdd#
       tix#=tix#*15 : tiy#=tiy#*15 : tiz#=tiz#*15
       emit particle particlegunsmoke,wallhitx#-tix#,wallhity#-tiy#,wallhitz#-tiz#
      endif
     endif
     `
    endif
    `
   endif
   `
  rem repeat ray over
  next traycount
  `
  rem after all rays of shot, deal damage OR missed-shot (multiplayer)
  if gmultiplayergame<>0
   rem inform session when make a shot
   gosub _multi_playershoots
   rem deal damage if collected for character hit
   if multiplayerdamagecollected>0
    rem deal damage to entitycharacter (to multiplayerdamagechar)
    tdamage=multiplayerdamagecollected
    e=multiplayerdamagechar : gosub _entity_deducthealth
   endif
  endif
  `
  rem shot over
  gunshoot=0
  `
 else
  `
  rem FLAK
  rem create-projectile-for-shot
  flakid=gun(gunid).settings.flakindex
  if flakid>0
   flakangle=camera angle y(playercam) : flakpitch=camera angle x(playercam) : flakowner=0
   if gun(gunid).settings.flashlimb<>-1
    rem x10 need to update muzzle-obj to latest glued position
    position object hudbankoffset+5,object position x(hudbankoffset+5),object position y(hudbankoffset+5),object position z(hudbankoffset+5)
    flakx=limb position x(hudbankoffset+5,0)
    flaky=limb position y(hudbankoffset+5,0)
    flakz=limb position z(hudbankoffset+5,0)
   else
    flakx=camera position x(playercam)+newxvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
    flaky=camera position y(playercam)+flak(flakid).throwheight
    flakz=camera position z(playercam)+newzvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
    flaky=flaky-(sin(flakpitch)*flak(flakid).throwforward)
   endif
   flakspeed#=1.0
   gosub _flakelement_create
   rem if something blocking launch, explode flak
   texplodeflakinstantly=0
   flakx=flakelement(tf).xpos
   flaky=flakelement(tf).ypos
   flakz=flakelement(tf).zpos
   if static raycast(camerapositionx,camerapositiony,camerapositionz,flakx,flaky,flakz)<>0
    texplodeflakinstantly=1
   endif
   rem intensive scan for solid entity obstacles
   for te=1 to entityelementlist
    if entityelement(te).active=1
     if entityelement(te).obj>0 and entityelement(te).collisionactive=1
      tentid=entityelement(te).bankindex
      if intersect object(entityelement(te).obj,camerapositionx,camerapositiony,camerapositionz,flakx,flaky,flakz)<>0
       texplodeflakinstantly=1 : exit
      endif
     endif
    endif
   next te
   if texplodeflakinstantly=1
    flakelement(tf).profile.weight=0
    flakelement(tf).profile.xinc=0
    flakelement(tf).profile.yinc=0
    flakelement(tf).profile.zinc=0
    flakelement(tf).xpos=camerapositionx
    flakelement(tf).ypos=camerapositiony
    flakelement(tf).zpos=camerapositionz
    gosub _flakelement_explodeinstantly
   endif
  endif
  `
  rem shot over
  gunshoot=0
  `
 endif
endif

return

_gun_soundcontrol:

rem Play sound frames when object frame matches
if gun(gunid).sound.soundframes>0
 for p=0 to gun(gunid).sound.soundframes-1
  sndid=gunsound(gunid,gunsounditem(gunid,p).playsound).soundid
  if gun(gunid).action.automatic.s>0 and p=0 then sndid=0
  if sndid>0
   rem X10 - 241007 - to prevent END of object frame anim leaking to End+1 (causing a sound effect being triggered for neighboring sound, use FRM+1)
   `if int(gunsounditem(gunid,p).keyframe)=int(object frame(currentgunobj))
   if int(gunsounditem(gunid,p).keyframe)+1=int(object frame(currentgunobj))
    if gunsounditem(gunid,p).lastplay=0
     gunsounditem(gunid,p).lastplay=1
     broadcast3dplrsound(camera position x(playercam),camera position y(playercam),camera position z(playercam),50)
     if sound exist(sndid)=1
      set sound volume sndid,soundvolumes(0)      
      play sound sndid
     endif
    endif
   else
    gunsounditem(gunid,p).lastplay=0
   endif
  endif
 next p
endif

return

`
` Gun Resources
`

_gun_create_hud:

rem Setup HUD Center Marker
make object box hudbankoffset+2,30,100,30
set object collision off hudbankoffset+2
hide object hudbankoffset+2

rem Setup HUD Gun-line Marker (shows impact coord)
make object cube hudbankoffset+3,5
set object collision off hudbankoffset+3
hide object hudbankoffset+3

rem Muzzle Flash(es)
for t=0 to 1
 if t=0 then tobj=hudbankoffset+5
 if t=1 then tobj=hudbankoffset+32
 make object plain tobj,25,25
 set object collision off tobj
 set object transparency tobj,1
 disable object zdepth tobj
 set object ambient tobj,0
 set object light tobj,0
 set object cull tobj,0
 set object fov tobj,45
 hide object tobj
 rem X10 - HUD object is for main scene ONLY
 set object mask tobj,%100000,%0,%0
next t

rem Brass
for o=6 to 20
 obj=hudbankoffset+o
 make object sphere obj,5
 set object collision off obj
 disable object zdepth obj
 set object fov obj,45
 hide object obj
 rem X10 - HUD object is for main scene ONLY
 set object mask tobj,%100000,%0,%0
next o

rem Smoke
for o=21 to 30
 obj=hudbankoffset+o
 make object plain obj,20,20
 set object collision off obj
 disable object zdepth obj
 disable object zwrite obj
 set object transparency obj,1
 set object ambient obj,0
 set object light obj,0
 set object cull obj,0
 set object fov obj,45
 hide object obj
 rem X10 - HUD object is for main scene ONLY
 set object mask obj,%100000,%0,%0
next obj

`x9rem crosshair hud object - cross hair should be HUD item
`obj=hudbankoffset+31
`make object cube obj,25
`set object collision off obj
`disable object zdepth obj
`disable object zwrite obj
`lock object on obj
`position object obj,0,0,400
`ghost object on obj
`set object ambient obj,0
`set object light obj,0
`set object cull obj,0
`hide object obj
`rem X10 - HUD object is for main scene ONLY
`set object mask obj,%100000,%0,%0

return

_gun_setup:

rem Create common resources for gun
gosub _gun_create_hud

return

_gun_gatherslotorder:

tslotmax=0
gunslotmax=0
dim data$(100)
filename$=setupfilename$
if file exist(filename$)=0 then debugstring(strarr$(375),filename$)
load array filename$,data$()
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem gather gun type from slot
   for tww=1 to 9
    tryfield$="slot"+str$(tww)
    if field$=tryfield$
     rem find gun id from name
     findgun$=value$
     gosub _gun_findweaponindexbyname
     weaponslot(tww).pref=foundgunid
     if foundgunid>0 then gunslotmax=tww
    endif
   next tww
   `
  endif
 endif
next l
undim data$()

return

_gun_loaddata:

rem X10 - 240907 - default values if not set in gunspec.txt
gun(gunid).settings.impactforce=25

dim data$(100)
filename$="gamecore\guns\"+gun$+"\gunspec.txt"
if file exist(filename$)=1
load array filename$,data$()
addfiletocollection(filename$)
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem take value 1 and 2 from value
   for c=0 to len(value$)
    if mid$(value$,c)="," then mid=c : exit
   next c
   value1=val(removeedgespaces(left$(value$,mid-1)))
   value2=val(removeedgespaces(right$(value$,len(value$)-mid)))
   `
   rem GUN SETTINGS
   if field$="muzzleflash" then gun(gunid).settings.muzzleflash=value1
   if field$="muzzlelasertype" then gun(gunid).settings.muzzlelasertype=value1
   if field$="muzzlesize" then gun(gunid).settings.muzzlesize#=value1
   if field$="muzzlecolorr" then gun(gunid).settings.muzzlecolorr=value1
   if field$="muzzlecolorg" then gun(gunid).settings.muzzlecolorg=value1
   if field$="muzzlecolorb" then gun(gunid).settings.muzzlecolorb=value1
   if field$="brass" then gun(gunid).settings.brass=value1
   if field$="smoke" then gun(gunid).settings.smoke=value1
   if field$="flak" then gun(gunid).settings.flakname$=value$
   if field$="second" then gun(gunid).settings.seconduse=value1
   if field$="damage" then gun(gunid).settings.damage=value1
   if field$="damagetype" then gun(gunid).settings.damagetype=value1
   if field$="scorchtype" then gun(gunid).settings.scorchtype=value1
   if field$="reloadqty" then gun(gunid).settings.reloadqty=value1
   if field$="weaponisammo" then gun(gunid).settings.weaponisammo=value1
   if field$="iterate" then gun(gunid).settings.iterate=value1
   if field$="accuracy" then gun(gunid).settings.accuracy=value1
   if field$="zoommode" then gun(gunid).settings.zoommode=value1
   if field$="zoomaccuracy" then gun(gunid).settings.zoomaccuracy=value1
   if field$="range" then gun(gunid).settings.range=value1
   if field$="decal" then gun(gunid).decal$=value$
   if field$="smokespeed" then gun(gunid).settings.smokespeed=value1
   if field$="smokedecal" then gun(gunid).settings.smokedecal$=value$
   `
   rem GUN VISUALS
   tryfield$="textured"
   if field$=tryfield$ then gun(gunid).texd$=value$
   tryfield$="effect"
   if field$=tryfield$ then gun(gunid).effect$=value$
   tryfield$="transparency"
   if field$=tryfield$ then gun(gunid).transparency=value1
   tryfield$="zoomscope"
   if field$=tryfield$ then gun(gunid).zoomscope$=value$
   tryfield$="weapontype"
   if field$=tryfield$ then gun(gunid).weapontype=value1
   `
   rem GUN SOUNDS
   if field$="fireloop" then gun(gunid).sound.fireloopend=value1
   for p=1 to 5 : rem V109 - 020209 - from 4 to 5
    tryfield$="sound"+str$(p)
    if field$=tryfield$ then gunsound(gunid,p).name$=value$
   next p
   `
   rem GUN AND MUZZLE ALIGNMENT
   if field$="horiz" then gun(gunid).horiz#=value1
   if field$="vert" then gun(gunid).vert#=value1
   if field$="forward" then gun(gunid).forward#=value1
   if field$="alignx" then gun(gunid).settings.muzzlex#=value1
   if field$="aligny" then gun(gunid).settings.muzzley#=value1
   if field$="alignz" then gun(gunid).settings.muzzlez#=value1
   `
   rem HUD ANIMATION DATA
   if field$="select" then gun(gunid).action.show.s=value1 : gun(gunid).action.show.e=value2
   if field$="idle" then gun(gunid).action.idle.s=value1 : gun(gunid).action.idle.e=value2
   if field$="move" then gun(gunid).action.move.s=value1 : gun(gunid).action.move.e=value2
   if field$="fire" then gun(gunid).action.start.s=value1 : gun(gunid).action.start.e=value1 : gun(gunid).action.finish.s=value1 : gun(gunid).action.finish.e=value2
   if field$="start fire" then gun(gunid).action.start.s=value1 : gun(gunid).action.start.e=value2
   if field$="automatic fire" then gun(gunid).action.automatic.s=value1 : gun(gunid).action.automatic.e=value2
   if field$="end fire" then gun(gunid).action.finish.s=value1 : gun(gunid).action.finish.e=value2
   if field$="reload"
    gun(gunid).action.startreload.s=value1 : gun(gunid).action.startreload.e=value2
    gun(gunid).action.reloadloop.s=value2 : gun(gunid).action.reloadloop.e=value2
    gun(gunid).action.endreload.s=value2 : gun(gunid).action.endreload.e=value2
   endif
   if field$="start reload" then gun(gunid).action.startreload.s=value1 : gun(gunid).action.startreload.e=value2
   if field$="reload loop" then gun(gunid).action.reloadloop.s=value1 : gun(gunid).action.reloadloop.e=value2
   if field$="end reload" then gun(gunid).action.endreload.s=value1 : gun(gunid).action.endreload.e=value2
   if field$="cock" then gun(gunid).action.cock.s=value1 : gun(gunid).action.cock.e=value2
   if field$="putaway" then gun(gunid).action.hide.s=value1 : gun(gunid).action.hide.e=value2
   if field$="keyframe ratio" then keyframeratio=value1
   `
   rem GUN SOUND FRAMES DATA
   tryfield$="soundframes"
   if field$=tryfield$ then gun(gunid).sound.soundframes=value1
   if gun(gunid).sound.soundframes>0
    for p=0 to gun(gunid).sound.soundframes
     tryfield$="sframe"+str$(p)
     if field$=tryfield$
      gunsounditem(gunid,p).keyframe=(value1*keyframeratio)
      `
      rem V109 - 020209 - array only goes to five (MP9 uses 6?)
      if value2>5 then value2=0
      gunsounditem(gunid,p).playsound=value2
      `
     endif
    next p
   endif
   `
  endif
 endif
next l
undim data$()
endif

rem If no COCK animation, fill with end of reload data
if gun(gunid).action.cock.e=0
 gun(gunid).action.cock.s=gun(gunid).action.endreload.e
 gun(gunid).action.cock.e=gun(gunid).action.endreload.e
endif

rem FPSCV104RC5 if no muzzle colour, go with default
if gun(gunid).settings.muzzlecolorr=0 and gun(gunid).settings.muzzlecolorg=0 and gun(gunid).settings.muzzlecolorb=0
 gun(gunid).settings.muzzlecolorr=255
 gun(gunid).settings.muzzlecolorg=255
 gun(gunid).settings.muzzlecolorb=0
endif

rem FPSCV104RC8 - can set the smoke speed
if gun(gunid).settings.smokespeed=0
 gun(gunid).settings.smokespeed=25
endif

rem FPSCV104RC9
if gun(gunid).settings.smokedecal$=""
 gun(gunid).settings.smokedecal$="smoke1"
endif

rem Find the decal specified
gun(gunid).decalid=0
if gun(gunid).decal$<>""
 decal$=gun(gunid).decal$ : gosub _decal_find
 if decalid<0
  decalid=0
 else
  decal(decalid).active=1
  gun(gunid).decalid=decalid
 endif
endif

rem Default gun range
if gun(gunid).settings.range=0 then gun(gunid).settings.range=1000

return

_gun_selectandorload:

rem Load gun if not selected
if gun(gunid).obj=0
 gosub _gun_load
endif

rem Associate gun with player
currentgunobj=gun(gunid).obj

rem Setup gun with muzzle flash image
if gun(gunid).settings.flashlimb<>-1
 texture object hudbankoffset+5,gun(gunid).settings.flashimg
 glue object to limb hudbankoffset+5,hudbankoffset+2,0
 position object hudbankoffset+5,gun(gunid).settings.muzzlex#,gun(gunid).settings.muzzley#,gun(gunid).settings.muzzlez#
 size#=gun(gunid).settings.muzzlesize# : if size#=0.0 then size#=100.0
 scale object hudbankoffset+5,size#,size#,size#
endif
if gun(gunid).settings.flashlimb2<>-1
 texture object hudbankoffset+32,gun(gunid).settings.flashimg
 glue object to limb hudbankoffset+32,hudbankoffset+2,0
 position object hudbankoffset+32,gun(gunid).settings.muzzlex#*-1,gun(gunid).settings.muzzley#,gun(gunid).settings.muzzlez#
 size#=gun(gunid).settings.muzzlesize# : if size#=0.0 then size#=100.0
 scale object hudbankoffset+32,size#,size#,size#
else
 scale object hudbankoffset+32,0,0,0
endif

rem Setup gun with brass models
if gun(gunid).settings.brasslimb<>-1
 for o=6 to 20
  obj=hudbankoffset+o
  if object exist(obj)=1 then delete object obj
  `x9 instance object obj,gun(gunid).settings.brassobjmaster
  clone object obj,gun(gunid).settings.brassobjmaster
  set object collision off obj
  disable object zdepth obj
  set object fov obj,45
  hide object obj
 next o
endif

rem Setup gun with smoke images
`x9if gun(gunid).settings.brasslimb<>-1
if gun(gunid).settings.smokelimb<>-1
 for o=21 to 30
  obj=hudbankoffset+o
  texture object obj,gun(gunid).settings.smokeimg
  hide object obj
 next o
endif

rem X10 provide crosshair image value to HUD global
hudcrosshair=gun(gunid).settings.crosshairimg

`x9rem Setup gun with crosshair
`obj=hudbankoffset+31
`timg=gun(gunid).settings.crosshairimg
`texture object obj,timg
`crosshairx=(screen width()-image width(timg))/2
`crosshairy=(screen height()-image height(timg))/2
`ts#=(100.0/64.0)*image width(timg)
`scale object obj,ts#,ts#,ts#
`show object obj

`rem Second-Handed Weapon Mode
`if gun(gunid).settings.seconduse=1
` currentgunsecondobj=gun(gunid).secondobj
` glue object to limb currentgunsecondobj,hudbankoffset+2,0
` if gun(gunid).settings.flashlimb<>-1
`  texture object hudbankoffset+32,gun(gunid).settings.flashimg
`  glue object to limb hudbankoffset+32,hudbankoffset+2,0
`  position object hudbankoffset+32,gun(gunid).settings.muzzlex#*-1.0,gun(gunid).settings.muzzley#,gun(gunid).settings.muzzlez#
`  size#=gun(gunid).settings.muzzlesize# : if size#=0.0 then size#=100.0
`  scale object hudbankoffset+32,size#,size#,size#
` endif
`else
` hide object hudbankoffset+32
`endif

return

_gun_load:

rem Load gun data
gosub _gun_loaddata

rem Load gun models
currentgunobj=loadgun("gamecore\guns\"+gun$+"\HUD.x")
gun(gunid).obj=currentgunobj

rem X10 - HUD object is for main scene ONLY
set object mask currentgunobj,%100000,%0,%0

rem FPSCV10X - ensure multi-textures in HUD are recorded for final build
nout$=findmaterialtexturesinmodelfile("gamecore\guns\"+gun$+"\HUD.x","gamecore\guns\"+gun$+"\")

rem Set the unique FOV aspect of the gun
set object fov currentgunobj,45

rem Perform scan to determine hotspot markers
flashlimb=-1 : brasslimb=-1 : smokelimb=-1 : handlimb=-1
flashlimb2=-1 : brasslimb2=-1 : smokelimb2=-1
perform checklist for object limbs currentgunobj
for c=1 to checklist quantity()
 name$=upper$(checklist string$(c))
 if name$="FIRESPOT" then flashlimb=c-1
 if name$="X3DS_FIRESPOT" then flashlimb=c-1
 if name$="FIRESPOT02" then flashlimb2=c-1
 if name$="BRASS" then brasslimb=c-1
 if name$="X3DS_BRASS" then brasslimb=c-1
 if name$="BRASS02" then brasslimb2=c-1
 if name$="SMOKE" then smokelimb=c-1
 if name$="X3DS_SMOKE" then smokelimb=c-1
 if name$="SMOKE02" then smokelimb2=c-1
 if name$="HAND" then handlimb=c-1
 if name$="X3DS_HAND" then handlimb=c-1
next c

rem Store limbs in limb-data
gun(gunid).settings.flashlimb=flashlimb
gun(gunid).settings.brasslimb=brasslimb
gun(gunid).settings.handlimb=handlimb
rem FPSCV104RC5 - new fields
gun(gunid).settings.smokelimb=smokelimb
gun(gunid).settings.flashlimb2=flashlimb2
gun(gunid).settings.brasslimb2=brasslimb2
gun(gunid).settings.smokelimb2=smokelimb2

rem Determine number of frames per keyframe
if keyframeratio>0
 ratio#=keyframeratio
else
 ratio#=1
endif

rem Adjust animation data based on actual number of keyframes
gun(gunid).action.show.s = gun(gunid).action.show.s * ratio#
gun(gunid).action.show.e = gun(gunid).action.show.e * ratio#
gun(gunid).action.idle.s = gun(gunid).action.idle.s * ratio#
gun(gunid).action.idle.e = gun(gunid).action.idle.e * ratio#
gun(gunid).action.move.s = gun(gunid).action.move.s * ratio#
gun(gunid).action.move.e = gun(gunid).action.move.e * ratio#
gun(gunid).action.start.s = gun(gunid).action.start.s * ratio#
gun(gunid).action.start.e = gun(gunid).action.start.e * ratio#
gun(gunid).action.automatic.s = gun(gunid).action.automatic.s * ratio#
gun(gunid).action.automatic.e = gun(gunid).action.automatic.e * ratio#
gun(gunid).action.finish.s = gun(gunid).action.finish.s * ratio#
gun(gunid).action.finish.e = gun(gunid).action.finish.e * ratio#
gun(gunid).action.startreload.s = gun(gunid).action.startreload.s * ratio#
gun(gunid).action.startreload.e = gun(gunid).action.startreload.e * ratio#
gun(gunid).action.reloadloop.s = gun(gunid).action.reloadloop.s * ratio#
gun(gunid).action.reloadloop.e = gun(gunid).action.reloadloop.e * ratio#
gun(gunid).action.endreload.s = gun(gunid).action.endreload.s * ratio#
gun(gunid).action.endreload.e = gun(gunid).action.endreload.e * ratio#
gun(gunid).action.cock.s = gun(gunid).action.cock.s * ratio#
gun(gunid).action.cock.e = gun(gunid).action.cock.e * ratio#
gun(gunid).action.hide.s = gun(gunid).action.hide.s * ratio#
gun(gunid).action.hide.e = gun(gunid).action.hide.e * ratio#

rem Load Effect
rem X10 new gun system shader
dirbefore$=get dir$() : set dir commoneffects$
tfile$="weapon.fx" : addfiletocollection(commoneffects$+tfile$)
tweaponeffectid=loadinternaleffectunique(tfile$,0)
tfile$="weaponhand.fx" : addfiletocollection(commoneffects$+tfile$)
tskineffectid=loadinternaleffectunique(tfile$,0)
set dir dirbefore$

if tweaponeffectid>0
 rem V109 - 140109 - switch technique at end of file scan if _N not found
 foundNtexture=0
 set object effect currentgunobj,tweaponeffectid
 perform checklist for object limbs currentgunobj
 for c=1 to checklist quantity()
  rem change texture of limb if DNRS available
  tlimbid=c-1 : texname$=lower$(limb texture name(currentgunobj,tlimbid))
  rem 190907 - if gun specifies a texture (ignore limb and apply texture to each limb - for guns like minigun with a lost texture name in the model)
  if gun(gunid).texd$<>"" then texname$=lower$(gun(gunid).texd$)
  if len(texname$)>0
   if right$(texname$,7)="_d2.dds" or right$(texname$,7)="_d2.tga"
    rem Replace D2 with shader set D+N+S/R
    texnamebase$=left$(texname$,len(texname$)-7)
    rem V109 - 140109 - check if N exists, and flag for later
    texname$=texnamebase$+"_N.dds" : img$="gamecore\guns\"+gun$+"\"+texname$
    if file exist(img$)=1 then foundNtexture=1
    texname$=texnamebase$+"_D.dds" : img$="gamecore\guns\"+gun$+"\"+texname$
    if file exist(img$)=1
     rem Apply bump mapping DNS
     realtexstage=0
     for texstage=0 to 2
      if texstage=0 then texname$=texnamebase$+"_D.dds"
      if texstage=1 then texname$=texnamebase$+"_N.dds"
      if texstage=2 then texname$=texnamebase$+"_S.dds"
      img$="gamecore\guns\"+gun$+"\"+texname$
      if file exist(img$)=0 and texstage=2
       rem X10 - 280807 - Try for R is S not available
       texname$=texnamebase$+"_R.dds"
       img$="gamecore\guns\"+gun$+"\"+texname$
      endif
      if file exist(img$)=1
       imgid=loadinternalimagecompressquality(img$,0,1)
       texture limb currentgunobj,tlimbid,realtexstage,imgid
       inc realtexstage
      endif
     next texstage
    endif
   endif
   rem V109 - 060209 - moved code below out of ELSE _D2 check as texture can be anything
   if foundNtexture=0
    rem D2 only, use blank textures
    `
    rem V109 - 060209 - also need to load and apply a 'specified' gun D2 texture
    tfile$=gun(gunid).texd$
    if len(tfile$)=0 then tfile$="gun_D2.tga"
    img$="gamecore\guns\"+gun$+"\"+tfile$
    imgD2id=loadinternalimagecompressquality(img$,0,1)
    if len(gun(gunid).texd$)>0 and left$(gun(gunid).texd$,1)<>" "
     texture object currentgunobj,0,imgD2id
    endif
    `
    rem V109 - 140109 - for guns that use Relief Mapping, we need special normal with
    rem 128,128,128 in the apha channel for the height information (seals the polygons)
    `img$="texturebank\common\defaultnormals.tga"
    img$="texturebank\common\defaultrelief.dds"
    imgid=loadinternalimagecompressquality(img$,0,1)
    texture limb currentgunobj,tlimbid,1,imgid
    img$="texturebank\common\defaultspecular.tga"
    imgid=loadinternalimagecompressquality(img$,0,1)
    texture limb currentgunobj,tlimbid,2,imgid
   endif
  endif
  rem change shader of limb if hand detected (requires bone animation on GPU)
  if left$(lower$(checklist string$(c)),4)="hand"
   set limb effect currentgunobj,tlimbid,tskineffectid
  endif
 next c
 rem V109 - 140109 - if NORMAL not found, use simpler weapon shader via technique
 if foundNtexture=0
  set effect technique tweaponeffectid,"DrawSimple"
  set effect technique tskineffectid,"DrawSimple"
 endif
endif

rem X10 V109 - 170309 - include extra gun files that may be present (and are needed for EXE)
dirbefore$=get dir$() : set dir "gamecore\guns\"+gun$+"\"
perform checklist for files
for tc=1 to checklist quantity()
 tttfile$=lower$(checklist string$(tc))
 if tttfile$<>"." and tttfile$<>".."
  if right$(tttfile$,4)=".dds" or right$(tttfile$,4)=".jpg"
   addfiletocollection("gamecore\guns\"+gun$+"\"+tttfile$)
  endif
 endif
next tc
set dir dirbefore$

remstart
img$="gamecore\guns\"+gun$+"\gun_D.dds" : imgDid=loadinternalimagecompressquality(img$,0,1)
img$="gamecore\guns\"+gun$+"\gun_N.dds" : imgNid=loadinternalimagecompressquality(img$,0,1)
img$="gamecore\guns\"+gun$+"\gun_R.dds" : imgRid=loadinternalimagecompressquality(img$,0,1)
texture object currentgunobj,0,imgDid
texture object currentgunobj,1,imgNid
texture object currentgunobj,2,imgRid
set object effect currentgunobj,tweaponeffectid
tlimbid=-1
perform checklist for object limbs currentgunobj
for c=1 to checklist quantity()
 if left$(lower$(checklist string$(c)),4)="hand" then tlimbid=c-1
next c
if tlimbid>=0
 img$="gamecore\guns\"+gun$+"\hand_D.dds" : imgDid=loadinternalimagecompressquality(img$,0,1)
 img$="gamecore\guns\"+gun$+"\hand_N.dds" : imgNid=loadinternalimagecompressquality(img$,0,1)
 img$="gamecore\guns\"+gun$+"\hand_S.dds" : imgSid=loadinternalimagecompressquality(img$,0,1)
 texture limb currentgunobj,tlimbid,0,imgDid
 texture limb currentgunobj,tlimbid,1,imgNid
 texture limb currentgunobj,tlimbid,2,imgSid
 set limb effect currentgunobj,tlimbid,tskineffectid
endif
remend

remstart 
X9 approach
`if guseeffectongunsstate=1 and gun(gunid).effect$<>""
` tfile$=gun(gunid).effect$
` debugfilename(tfile$,"effect for gun")
` teffectid=loadinternaleffect(tfile$)
`else
` teffectid=0
`endif

rem Setup gun model materiual properties
set object diffuse currentgunobj,rgb(255,255,255)
set object ambience currentgunobj,rgb(255,255,255)
set object specular currentgunobj,0
set object emissive currentgunobj,0

rem First Textures are PLATES
if teffectid>0
 `
 rem Load effect textures
 if gun(gunid).transparency>2
  img$="gamecore\guns\"+gun$+"\gun_D.tga" : imgDid=loadinternalimagecompressquality(img$,0,1)
  img$="gamecore\guns\"+gun$+"\gun_N.tga" : imgNid=loadinternalimagecompressquality(img$,0,1)
  img$="gamecore\guns\"+gun$+"\gun_R.tga" : imgRid=loadinternalimagecompressquality(img$,0,1)
 else
  img$="gamecore\guns\"+gun$+"\gun_D.tga" : imgDid=loadinternalimagecompress(img$,5)
  img$="gamecore\guns\"+gun$+"\gun_N.tga" : imgNid=loadinternalimage(img$)
  img$="gamecore\guns\"+gun$+"\gun_R.tga" : imgRid=loadinternalimage(img$)
 endif
 `
 rem Last Texture Image is CUBE
 img$="gamecore\guns\"+gun$+"\gun_cube.dds" : imgCUBEid=loadinternalimage(img$)
 if file exist(img$)=1 then load image img$,imgCUBEid,2
 `
 rem Bump Quality
 texture object currentgunobj,0,imgDid
 texture object currentgunobj,1,imgNid
 texture object currentgunobj,2,imgRid
 texture object currentgunobj,3,imgCUBEid
 `
 rem Apply effect to object
 gun(gunid).effectidused=teffectid
 set object effect currentgunobj,teffectid
 `
else
 `
 rem Basic Diffuse2 for Gun (and AmmoClip) - if specified in gunspec.txt
 tfile$=gun(gunid).texd$
 if len(tfile$)=0 then tfile$="gun_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 if len(gun(gunid).texd$)>0 and left$(gun(gunid).texd$,1)<>" "
  texture object currentgunobj,imgD2id
 endif
 tfile$="ammo_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 tfile$="scope_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 rem FPSCV104RC10
 tfile$="hand_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 tfile$="supressor_D2.tga"
 img$="gamecore\guns\"+gun$+"\"+tfile$
 if gun(gunid).transparency>2
  imgD2id=loadinternalimagecompressquality(img$,0,1)
 else
  imgD2id=loadinternalimagecompress(img$,5)
 endif
 `
endif
remend

rem load in scope if any
if gun(gunid).zoomscope$<>""
 img$="gamecore\guns\"+gun$+"\"+gun(gunid).zoomscope$
 gun(gunid).zoomscope=loadinternalimagecompress(img$,5)
 addfiletocollection(img$)
else
 gun(gunid).zoomscope=0
endif

rem Glue gun to HUD-Gun-Marker
glue object to limb currentgunobj,hudbankoffset+2,0

rem Setup gun for correct visuals (special transparency for after-shadow setting)
if gun(gunid).transparency=5
 rem X10 - 071007 - new transparency mode for PLASMA type weapons (CHUGSHOT)
 rem 100 wil cause all the weapons transparency to be used (but creates problems in MINIGUN where texture used to cap the end of a polygon tube)
 set alpha mapping on currentgunobj,100
else
 rem 0 will cause all the weapons transparency NOT to be used (but such things as plasma will be solid)
 rem 10 will allow 10 percent of the objects alpha data to come through
 set alpha mapping on currentgunobj,10
 if gun(gunid).transparency>2
  set object transparency currentgunobj,gun(gunid).transparency
 else
  set object transparency currentgunobj,2
 endif
endif
disable object zdepth currentgunobj

rem Setup gun for animation
loop object currentgunobj

rem Setup gun with muzzle flash image
num=gun(gunid).settings.muzzleflash : if num=0 then num=1
size#=gun(gunid).settings.muzzlesize# : if size#=0.0 then size#=100.0
muzzleflash$="gamecore\muzzleflash\flash"+str$(num)+".tga"
imgid=loadmuzzle(muzzleflash$)
gun(gunid).settings.flashimg=imgid

rem X10 new muzzle flash used primary by characters
muzzleflash$="gamecore\muzzleflash\mflash"+str$(num)+".tga"
imgid=loadinternalimagecompress(muzzleflash$,5)
if imgid=0
 rem X10 No MFLASH texture (must be an old model pack)
 muzzleflash$="gamecore\muzzleflash\mflash"+str$(1)+".tga"
 imgid=loadinternalimagecompress(muzzleflash$,5)
 gun(gunid).settings.newflashimg=imgid
else
 gun(gunid).settings.newflashimg=imgid
endif
`
rem Setup gun with brass models
num=gun(gunid).settings.brass : if num=0 then num=1
brass$="gamecore\brass\brass"+str$(num)+"\brass"+str$(num)+".x"
brassobj=loadbrass(brass$)
addfiletocollection("gamecore\brass\brass"+str$(num)+"\brass"+str$(num)+"_D2.dds")
gun(gunid).settings.brassobjmaster=brassobj

rem Setup gun with smoke images
num=gun(gunid).settings.smoke
if len(gun(gunid).settings.smokedecal$)>0
 smoke$="gamecore\decals\"+gun(gunid).settings.smokedecal$+"\decal.tga"
 imgid=loadsmoke(smoke$)
else
 if num=0 then num=1
 rem FPSCV04RC9 0- replace smoke1 usage with gunsmoke usage (better visual)
 if num=1
  smoke$="gamecore\decals\gunsmoke\decal.tga"
 else
  smoke$="gamecore\decals\smoke"+str$(num)+"\decal.tga"
 endif
 imgid=loadsmoke(smoke$)
endif
gun(gunid).settings.smokeimg=imgid

rem Setup gun with crosshair
crosshair$="gamecore\guns\"+gun$+"\crosshair.dds"
rem V109 - 090109 - changed to quality of 2, new mode for X10, to use color to make alpha (colorkey)
crosshairimage=loadinternalimagecompressquality(crosshair$,5,9) `090109 - used to be ,1)
gun(gunid).settings.crosshairimg=crosshairimage
gun(gunid).secondobj=0

rem Load gun sounds (and companions)
for p=1 to 5
 if gunsound(gunid,p).name$<>""
  rem main sound for player
  snd$="gamecore\guns\"+gun$+"\"+gunsound(gunid,p).name$
  timestampactivity(0,"Loading Sound:"+snd$)
  gunsound(gunid,p).soundid=loadinternalsound(snd$)
  rem FPSCV104RC4 - extra sound value checks in many places
  if gunsound(gunid,p).soundid>0
   if sound exist(gunsound(gunid,p).soundid)=0
    gunsound(gunid,p).soundid=0
   endif
  endif
  rem companion sounds for other weapon sound uses
  if p<=3
   gunsoundcompanion(gunid,p,0).soundid=loadinternalsoundcore(snd$,1)
   gunsoundcompanion(gunid,p,1).soundid=loadinternalsoundcore(snd$,1)
   gunsoundcompanion(gunid,p,2).soundid=loadinternalsoundcore(snd$,1)
  endif
 endif
next p

rem Load HUD image (ammo and weapon selected image)
img$="gamecore\guns\"+gun$+"\hud_icon.tga" : addfiletocollection(img$)
gun(gunid).hudimage=loadinternalimagecompressquality(img$,5,1)

rem Find and store flak index for later use
if gun(gunid).settings.flakname$<>""
 flak$=gun(gunid).settings.flakname$ : gosub _flak_findindex
 gun(gunid).settings.flakindex=tindex
endif

return

_gun_freeafterlevel:
 `
 rem Free the old gun
 autoloadgun=0 : gosub _gun_change
 `
return

_gun_scaninall:

rem Scan entire guns folder
gosub _gun_scaninall_ref

rem Load all guns
for gunid=1 to gunmax
 gun$=gun(gunid).name$ : gosub _gun_load
next gunid

return

_gun_scaninall_dataonly:
 for gunid=1 to gunmax
  gun$=gun(gunid).name$ : gosub _gun_loaddata
 next gunid
return

`
` NEW MUZZLE FLASH SUBROUTINES
`

_muzzle_createall:
 `
 rem create all muzzle flash resources
 for m=1 to newmuzzlemax
  mobj=newmuzzleobjstart+m
  if m=1
   load object "gamecore\muzzleflash\mflash.X",mobj
   addfiletocollection("gamecore\muzzleflash\mflash.X")
  else
   clone object mobj,newmuzzleobjstart+1
  endif
  rem textured when shoot the resource
  set object transparency mobj,2
  disable object zwrite mobj
  hide object mobj
  set object cull mobj,0
  set object light mobj,0
  set object rotation zyx mobj
  ghost object on mobj
 next m
 `
return

_muzzle_placeflash:
 `
 rem trigger a muzzle flash
 inc muzzlecycle
 if muzzlecycle>newmuzzlemax then muzzlecycle=1
 newmuzzle(muzzlecycle)=1
 mobj=newmuzzleobjstart+muzzlecycle
 texture object mobj,gun(muzzlegunid).settings.newflashimg
 position object mobj,muzzlex#,muzzley#,muzzlez#
 rotate object mobj,muzzlerx#,muzzlery#,muzzlerz#
 if gun(muzzlegunid).settings.muzzlelasertype=1
  rem laser type
  muzzlelaserdistance#=muzzlelaserdistance#/19.0
  scale object mobj,25,25,100*muzzlelaserdistance#
  move object mobj,-10 : rem move it out of gun
  `
  rem E passed in from entity shooting this laser
  rem point gun if they have acquired a target and shot is a laser
  x3#=muzzlex#-entityelement(e).actualtargetx
  y3#=muzzley#-entityelement(e).actualtargety
  z3#=muzzlez#-entityelement(e).actualtargetz
  point object mobj,muzzlex#+x3#,muzzley#+y3#,muzzlez#+z3#
  `  
 else
  rem blast type
  scale object mobj,(80+rnd(20))*muzzlescale#,(80+rnd(20))*muzzlescale#,(80+rnd(20))*muzzlescale#
  move object mobj,-2 : rem move it out of gun
 endif
 show object mobj
 `
return

_muzzle_control:
 `
 rem control all muzzle flashes
 for m=1 to newmuzzlemax
  if newmuzzle(m)>0
   fu#=(newmuzzle(m)-1)*0.25
   mobj=newmuzzleobjstart+m
   lock vertexdata for limb mobj,1
   rem head
   set vertexdata uv 0,fu#+0,0
   set vertexdata uv 1,fu#+0.25,0
   set vertexdata uv 2,fu#,0.25
   set vertexdata uv 3,fu#+0.25,0.25
   set vertexdata uv 4,fu#,0.25
   set vertexdata uv 5,fu#+0.25,0
   rem horiz plane diag
   set vertexdata uv 6,fu#,1
   set vertexdata uv 7,fu#,0.25
   set vertexdata uv 8,fu#+0.25,1
   set vertexdata uv 9,fu#+0.25,0.25
   set vertexdata uv 10,fu#+0.25,1
   set vertexdata uv 11,fu#,0.25
   rem vert plane diag
   set vertexdata uv 12,fu#,1
   set vertexdata uv 13,fu#,0.25
   set vertexdata uv 14,fu#+0.25,1
   set vertexdata uv 15,fu#+0.25,0.25
   set vertexdata uv 16,fu#+0.25,1
   set vertexdata uv 17,fu#,0.25
   unlock vertexdata
   newmuzzle(m)=newmuzzle(m)+1
   if newmuzzle(m)>4
    newmuzzle(m)=0
    hide object mobj
   endif
  endif
 next m
 `
return

rem
rem Waypoint Core Functions
rem

`
` Subroutines for waypoint system
`

_waypoint_savedata:

rem Save list
if file exist(myownrootdir$+"mapbank\testmap\map.way")=1 then delete file myownrootdir$+"mapbank\testmap\map.way"
open to write 1,myownrootdir$+"mapbank\testmap\map.way"
 rem strands
 write file 1,waypointmax
 if waypointmax>0
  for w=1 to waypointmax
   a=waypoint(w).count : write file 1,a
   a=waypoint(w).start : write file 1,a
   a=waypoint(w).finish : write file 1,a
  next w
 endif
 rem coords
 write file 1,waypointcoordmax
 if waypointcoordmax>0
  for w=1 to waypointcoordmax
   a#=waypointcoord(w).x : write float 1,a#
   a#=waypointcoord(w).y : write float 1,a#
   a#=waypointcoord(w).z : write float 1,a#
   a=waypointcoord(w).link : write file 1,a
   a=waypointcoord(w).index : write file 1,a
  next w
 endif
close file 1

return

_waypoint_loaddata:

rem Free any old
gosub _waypoint_deleteall

rem load list
if file exist(levelmapptah$+"\map.way")=1
 filename$=levelmapptah$+"map.way"
 open to read 1,filename$
  rem strands
  read file 1,waypointmax
  if waypointmax>0
   undim waypoint()
   dim waypoint(waypointmax+1) as waypointtype
   for w=1 to waypointmax
    read file 1,a : waypoint(w).count=a
    read file 1,a : waypoint(w).start=a
    read file 1,a : waypoint(w).finish=a
   next w
  endif
  rem coords
  read file 1,waypointcoordmax
  if waypointcoordmax>0
   undim waypointcoord()
   dim waypointcoord(waypointcoordmax+1) as waypointcoordtype
   for w=1 to waypointcoordmax
    read float 1,a# : waypointcoord(w).x=a#
    read float 1,a# : waypointcoord(w).y=a#
    read float 1,a# : waypointcoord(w).z=a#
    read file 1,a : waypointcoord(w).link=a
    read file 1,a : waypointcoord(w).index=a
   next w
  endif
 close file 1
endif

rem also ensure data is not pointing to larger arrays than we have (old legacy editing rogue data)
if waypointmax>0
 for waypointindex=1 to waypointmax
  if waypoint(waypointindex).count>0
   if waypoint(waypointindex).start>waypointcoordmax or waypoint(waypointindex).finish>waypointcoordmax
    rem waypoint indexes exceed current arrays - diable waypoint
    waypoint(waypointindex).count=0
    waypoint(waypointindex).start=0
    waypoint(waypointindex).finish=0
   endif
  endif
 next waypointindex
 for w=1 to waypointcoordmax
  if waypointcoord(w).link>waypointcoordmax
   waypointcoord(w).link=0
  endif
  if waypointcoord(w).index>waypointmax
   waypointcoord(w).index=0
  endif
 next w
endif

return

_waypoint_recreateobjs:
 for waypointindex=1 to waypointmax
  if waypoint(waypointindex).count>0
   createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
  endif
 next waypointindex
return

_waypoint_createnew:

rem Create a new waypoint strand (or find empty one)
for tw=1 to waypointmax
 if waypoint(tw).count=0
  waypointindex=tw : exit
 endif
next tw
if tw>waypointmax
 inc waypointmax
 dim waypoint(waypointmax)
 waypointindex=waypointmax
endif
`
rem Do the creatin
waypoint(waypointindex).count=1
inc waypointcoordmax
w=waypointcoordmax
dim waypointcoord(waypointcoordmax)
waypoint(waypointindex).start=w
waypoint(waypointindex).finish=w
waypointcoord(w).x=mx#
waypointcoord(w).y=(gridlayer*100.0)+5
waypointcoord(w).z=mz#
waypointcoord(w).index=waypointindex
`if waypointindex<=10 `odd - 210105
 if gdontcreatewaypointobjects=0
  if waypoint(waypointindex).count>0
   createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
  endif
 endif
`endif

rem Create highlight sphere for easier selection
if gdontcreatewaypointobjects=0
 if object exist(editorwaypointoffset+0)=0
  make object sphere editorwaypointoffset+0,25
  set object collision off editorwaypointoffset+0
  ghost object on editorwaypointoffset+0
  set object transparency editorwaypointoffset+0,2
  disable object zread editorwaypointoffset+0
  hide object editorwaypointoffset+0
 endif
endif

return

_waypoint_createallobjs:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if gdontcreatewaypointobjects=0
   if waypoint(waypointindex).count>0
    createwaypointobj(obj,waypointindex)
   else
    if object exist(obj)=1 then delete object obj
   endif
  endif
 next waypointindex
return

_waypoint_deleteall:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if object exist(obj)=1 then delete object obj
 next waypointindex
 waypointmax=0
 waypointcoordmax=0
return

_waypoint_hideall:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if object exist(obj)=1 then hide object obj
 next waypointindex
return

_waypoint_showall:
 for waypointindex=1 to waypointmax
  obj=editorwaypointoffset+waypointindex
  if object exist(obj)=1 then show object obj
 next waypointindex
return

_waypoint_mousemanage:

rem Grid the waypoint coordinate input
mx#=int(mx#/5)*5 : mz#=int(mz#/5)*5

rem Simply find waypoint over cursor
waypointiovercursor=0
waypointindexovercursor=0
for twaypointindex=1 to waypointmax
 if waypoint(twaypointindex).count>0
  tbest#=9999 : tbestwaypointindex=0 : tbestwaypointiovercursor=0
  for w=waypoint(twaypointindex).start to waypoint(twaypointindex).finish
   dx#=abs(mx#-waypointcoord(w).x)
   dz#=abs(mz#-waypointcoord(w).z)
   tdd#=sqrt((dx#*dx#)+(dz#*dz#))
   if tdd#<20 and abs(waypointeditheight#-waypointcoord(w).y)<20
    if tdd#<tbest#
     tbest#=tdd# : tbestwaypointindex=twaypointindex : tbestwaypointiovercursor=w
    endif
   endif
  next w
  if tbest#<9999
   if tbestwaypointiovercursor<>0
    waypointindexovercursor=tbestwaypointindex
    waypointiovercursor=tbestwaypointiovercursor
    exit
   endif
  endif
 endif
next twaypointindex

rem mclickdone is for singlr mouse clicks
mclickdone=0
if mclick=0 then mclickpressed=0
if mclick>0 and mclickpressed=0 then mclickdone=mclick : mclickpressed=1

rem Move existing new waypoint
if mclick>0
 `
 if onedrag=0
  rem Find waypoint
  if waypointiovercursor>0 and waypointindexovercursor>0
   onedrag=waypointiovercursor : onedragmode=mclick : onedragx#=mx# : onedragz#=mz#
   waypointindex=waypointindexovercursor
  endif
 else
  rem Drag waypoint around
  if onedragmode=1 and (mx#<>onedragx# or mz#<>onedragz#)
   w=onedrag
   waypointcoord(w).x=mx#
   waypointcoord(w).y=waypointeditheight#
   waypointcoord(w).z=mz#
   createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
   rem Drag linked waypoint too
   linkto=waypointcoord(w).link
   if linkto>0
    waypointcoord(linkto).x=mx#
    waypointcoord(linkto).y=waypointeditheight#
    waypointcoord(linkto).z=mz#
    for twayp=1 to waypointmax
     for w=waypoint(twayp).start to waypoint(twayp).finish
      if w=linkto then createwaypointobj(editorwaypointoffset+twayp,twayp)
     next w
    next twayp
   endif
  endif
 endif
else
 rem Release waypoint
 if onedrag>0
  if onedragmode=1
   rem Glue if waypoint is linked to other waypoint
   for twayp=1 to waypointmax
    if twayp<>waypointindex
     for w=waypoint(twayp).start to waypoint(twayp).finish
      clipx1=int(mx#/20)
      clipz1=int(mz#/20)
      clipx2=int(waypointcoord(w).x/20)
      clipz2=int(waypointcoord(w).z/20)
      if clipx1=clipx2 and abs(waypointcoord(w).y-waypointeditheight#)<20 and clipz1=clipz2
       if waypointcoord(w).link=0
        waypointcoord(onedrag).link=w : waypointcoord(w).link=onedrag
        createwaypointobj(editorwaypointoffset+twayp,twayp)
        exit
       endif
      endif
     next w
    endif
   next twayp
  else
   rem Detatch if waypoint is linked
   if waypointcoord(onedrag).link>0
    linkto=waypointcoord(onedrag).link
    waypointcoord(linkto).x=waypointcoord(linkto).x+10
    waypointcoord(linkto).z=waypointcoord(linkto).z+10
    waypointcoord(onedrag).x=waypointcoord(onedrag).x
    waypointcoord(onedrag).z=waypointcoord(onedrag).z
    waypointcoord(onedrag).link=0
    waypointcoord(linkto).link=0
   endif
   for twayp=1 to waypointmax
    for w=waypoint(twayp).start to waypoint(twayp).finish
     if w=onedrag then createwaypointobj(editorwaypointoffset+twayp,twayp) : exit
     if w=linkto then createwaypointobj(editorwaypointoffset+twayp,twayp) : exit
    next w
   next twayp
  endif
 endif
 onedrag=0
endif

rem Delete last waypoint selected
if inputsys.keyshift=1 and mclickdone=2 and waypointiovercursor>0
 rem Delete waypoint
 w=waypointiovercursor
 if w=waypoint(waypointindex).start
  rem delete whole waypoint
  tsize0=0+waypoint(waypointindex).finish-waypoint(waypointindex).start
  tsize1=1+waypoint(waypointindex).finish-waypoint(waypointindex).start
  while w<waypointcoordmax-tsize0
   waypointcoord(w).x=waypointcoord(w+tsize1).x
   waypointcoord(w).y=waypointcoord(w+tsize1).y
   waypointcoord(w).z=waypointcoord(w+tsize1).z
   waypointcoord(w).link=waypointcoord(w+tsize1).link
   waypointcoord(w).index=waypointcoord(w+tsize1).index
   inc w
  endwhile
  for tw=w to w+tsize0
   waypointcoord(tw).x=0
   waypointcoord(tw).y=0
   waypointcoord(tw).z=0
   waypointcoord(tw).link=0
   waypointcoord(tw).index=0
  next tw
  dec waypointcoordmax,tsize1
  w=waypointiovercursor+tsize0
  for twayp=1 to waypointmax
   if twayp<>waypointindex
    if w<waypoint(twayp).start then waypoint(twayp).start=waypoint(twayp).start-tsize1
    if w<waypoint(twayp).finish then waypoint(twayp).finish=waypoint(twayp).finish-tsize1
   endif
  next twayp
  rem delete wayppint-sequence itself
  waypoint(waypointindex).count=0
  waypoint(waypointindex).start=0
  waypoint(waypointindex).finish=0
 else
  rem delete node from waypoint
  w=waypointiovercursor
  while w<waypointcoordmax
   waypointcoord(w).x=waypointcoord(w+1).x
   waypointcoord(w).y=waypointcoord(w+1).y
   waypointcoord(w).z=waypointcoord(w+1).z
   waypointcoord(w).link=waypointcoord(w+1).link
   waypointcoord(w).index=waypointcoord(w+1).index
   inc w
  endwhile
  waypointcoord(w).x=0
  waypointcoord(w).y=0
  waypointcoord(w).z=0
  waypointcoord(w).link=0
  waypointcoord(w).index=0
  dec waypointcoordmax
  waypoint(waypointindex).count=waypoint(waypointindex).count-1
  waypoint(waypointindex).finish=waypoint(waypointindex).finish-1
  w=waypointiovercursor
  for twayp=1 to waypointmax
   for tw=waypoint(twayp).start to waypoint(twayp).finish
    if w<waypointcoord(tw).link then waypointcoord(tw).link=waypointcoord(tw).link-1
   next tw
   if twayp<>waypointindex
    if w<waypoint(twayp).start then waypoint(twayp).start=waypoint(twayp).start-1
    if w<waypoint(twayp).finish then waypoint(twayp).finish=waypoint(twayp).finish-1
   endif
  next twayp
 endif
 if waypoint(waypointindex).count>0
  createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
 else
  if object exist(editorwaypointoffset+waypointindex)=1
   delete object editorwaypointoffset+waypointindex
  endif
 endif
 waypointiovercursor=0
 mdoubleclick=0
 onedragmode=0
 onedrag=0
endif

rem Insert waypoint at selected
if inputsys.keyshift=1 and mclickdone=1 and waypointiovercursor>0
 w=waypointiovercursor+1
 if w>=waypointcoordmax
  rem at end
  inc waypointcoordmax
  dim waypointcoord(waypointcoordmax)
  w=waypointcoordmax
 else
  rem shuffle
  inc waypointcoordmax
  dim waypointcoord(waypointcoordmax)
  w=waypointcoordmax
  while w>waypointiovercursor+1
   waypointcoord(w).x=waypointcoord(w-1).x
   waypointcoord(w).y=waypointcoord(w-1).y
   waypointcoord(w).z=waypointcoord(w-1).z
   waypointcoord(w).link=waypointcoord(w-1).link
   waypointcoord(w).index=waypointcoord(w-1).index
   dec w
  endwhile
  w=waypointiovercursor+1
 endif
 waypointcoord(w).x=waypointcoord(w-1).x+10
 waypointcoord(w).y=waypointcoord(w-1).y
 waypointcoord(w).z=waypointcoord(w-1).z+10
 waypointcoord(w).link=0
 waypointcoord(w).index=waypointindex
 waypoint(waypointindex).count=waypoint(waypointindex).count+1
 waypoint(waypointindex).finish=waypoint(waypointindex).finish+1
 for twayp=1 to waypointmax
  if twayp<>waypointindex
   if w<=waypoint(twayp).start then waypoint(twayp).start=waypoint(twayp).start+1
   if w<=waypoint(twayp).finish then waypoint(twayp).finish=waypoint(twayp).finish+1
  endif
  for tw=waypoint(twayp).start to waypoint(twayp).finish
   if waypointcoord(tw).link>0
    if w<=waypointcoord(tw).link then waypointcoord(tw).link=waypointcoord(tw).link+1
   endif
  next tw
 next twayp
 if waypoint(waypointindex).count>0
  createwaypointobj(editorwaypointoffset+waypointindex,waypointindex)
 else
  if object exist(editorwaypointoffset+waypointindex)=1
   delete object editorwaypointoffset+waypointindex
  endif
 endif
 waypointiovercursor=0
 onedragmode=0
 onedrag=0
endif

rem Show selected waypoint
if object exist(editorwaypointoffset+0)=1
 if waypointiovercursor>0
  w=waypointiovercursor
  position object editorwaypointoffset+0,waypointcoord(w).x,waypointcoord(w).y,waypointcoord(w).z
  show object editorwaypointoffset+0
 else
  hide object editorwaypointoffset+0
 endif
endif

return


`
` Function to build waypoint object
`


function createwaypointobj(obj,waypointindex)
if obj<=editorwaypointoffsetmax
 if waypoint(waypointindex).count>0
  polycount=((waypoint(waypointindex).count-1)*2)+(waypoint(waypointindex).count*2)
  makepolymesh(obj,polycount)
  w=waypoint(waypointindex).start
  fwx#=waypointcoord(w).x
  fwy#=waypointcoord(w).y+6
  fwz#=waypointcoord(w).z
  polyindex=0
  diffuse as DWORD
  rem lines
  for w=waypoint(waypointindex).start+1 to waypoint(waypointindex).finish
   wx#=waypointcoord(w).x
   wy#=waypointcoord(w).y+6
   wz#=waypointcoord(w).z
   wa#=atanfull(wx#-fwx#,wz#-fwz#)-90
   pwa#=wa# : fwa#=wa#
   fade#=1.0-(abs(waypointcoord(w).y-waypointeditheight#)/500.0)
   tcolorcycle=waypointcoord(w).index-((waypointcoord(w).index/6)*6)
   if tcolorcycle=0 then diffuse=rgb(0*fade#,0*fade#,155*fade#)
   if tcolorcycle=1 then diffuse=rgb(155*fade#,0,0)
   if tcolorcycle=2 then diffuse=rgb(0,155*fade#,0)
   if tcolorcycle=3 then diffuse=rgb(155*fade#,155*fade#,0)
   if tcolorcycle=4 then diffuse=rgb(155*fade#,0,155*fade#)
   if tcolorcycle=5 then diffuse=rgb(0,155*fade#,155*fade#)
   if w=waypoint(waypointindex).start+1 then lastdiffuse=diffuse
   c1x#=newxvalue(fwx#,fwa#,5) : c1z#=newzvalue(fwz#,fwa#,5) : c1y#=fwy#
   c2x#=newxvalue(fwx#,fwa#,-5) : c2z#=newzvalue(fwz#,fwa#,-5) : c2y#=fwy#
   c3x#=newxvalue(wx#,pwa#,5) : c3z#=newzvalue(wz#,pwa#,5) : c3y#=wy#
   c4x#=newxvalue(wx#,pwa#,-5) : c4z#=newzvalue(wz#,pwa#,-5) : c4y#=wy#
   addpolytomesh(obj,polyindex+0,lastdiffuse,diffuse,diffuse,c1x#,c1y#,c1z#,c3x#,c3y#,c3z#,c4x#,c4y#,c4z#)
   addpolytomesh(obj,polyindex+1,lastdiffuse,lastdiffuse,diffuse,c2x#,c2y#,c2z#,c1x#,c1y#,c1z#,c4x#,c4y#,c4z#)
   fwx#=wx# : fwy#=wy# : fwz#=wz# : fwa#=wa# : lastdiffuse=diffuse : inc polyindex,2
  next w
  rem stars
  for w=waypoint(waypointindex).start to waypoint(waypointindex).finish
   wx#=waypointcoord(w).x
   wy#=waypointcoord(w).y+6
   wz#=waypointcoord(w).z
   if waypointcoord(w).link>0
    if abs(waypointcoord(w).y-waypointeditheight#)<50
     diffuse=rgb(0,255,255)
    else
     diffuse=rgb(0,128,128)
    endif
   else
    if abs(waypointcoord(w).y-waypointeditheight#)<50
     diffuse=rgb(255,255,0)
    else
     diffuse=rgb(255,0,0)
    endif
   endif
   if w=waypoint(waypointindex).start then tsize#=1.5 else tsize#=1.0
   c1x#=newxvalue(wx#,55,8*tsize#) : c1z#=newzvalue(wz#,55,8*tsize#) : c1y#=wy#
   c2x#=newxvalue(wx#,-55,8*tsize#) : c2z#=newzvalue(wz#,-55,8*tsize#) : c2y#=wy#
   c3x#=newxvalue(wx#,180,10*tsize#) : c3z#=newzvalue(wz#,180,10*tsize#) : c3y#=wy#
   c4x#=newxvalue(wx#,235,8*tsize#) : c4z#=newzvalue(wz#,235,8*tsize#) : c4y#=wy#
   c5x#=newxvalue(wx#,125,8*tsize#) : c5z#=newzvalue(wz#,125,8*tsize#) : c5y#=wy#
   c6x#=newxvalue(wx#,0,10*tsize#) : c6z#=newzvalue(wz#,0,10*tsize#) : c6y#=wy#
   addpolytomesh(obj,polyindex+0,diffuse,diffuse,diffuse,c1x#,c1y#,c1z#,c2x#,c2y#,c2z#,c3x#,c3y#,c3z#)
   addpolytomesh(obj,polyindex+1,diffuse,diffuse,diffuse,c4x#,c4y#,c4z#,c5x#,c5y#,c5z#,c6x#,c6y#,c6z#)
   inc polyindex,2
  next w
  finalisepolymesh(obj)
 else
  if object exist(obj)=1 then delete object obj
 endif
endif
endfunction

function makepolymesh(obj,polycount)
 `
 rem Free old memblock
 memblock=1 : if memblock exist(1)=1 then delete memblock 1
 `
 rem Make a Simple Cube Mesh Memblock
 headersize=12 : fvf=338 : vertsize=36 : verts=polycount*3
 memsize=headersize+(vertsize*verts)
 make memblock 1,memsize
 `
 rem Set header info
 write memblock dword 1,0,fvf
 write memblock dword 1,4,vertsize
 write memblock dword 1,8,verts
 `
endfunction

function addpolytomesh(obj,polyindex,diffuse1 as DWORD,diffuse2 as DWORD,diffuse3 as DWORD,x1#,y1#,z1#,x2#,y2#,z2#,x3#,y3#,z3#)
 `
 rem Create vertex data (3 make a triangle polygon)
 diff as DWORD
 memblock=1 : vertsize=36
 for t=0 to 2
  `
  rem Corners of poly
  if t=0 then x#=x1#:y#=y1#:z#=z1# : diff=diffuse1
  if t=1 then x#=x2#:y#=y2#:z#=z2# : diff=diffuse2
  if t=2 then x#=x3#:y#=y3#:z#=z3# : diff=diffuse3
  v=(polyindex*3)+t
  `
  rem Position of vertex in memblock
  pos=12+(v*vertsize)
  `
  rem Create some random vertex data
  nx#=0 : ny#=1.0 : nz#=0
  `
  rem Set vertex position
  write memblock float 1,pos+0,x#
  write memblock float 1,pos+4,y#
  write memblock float 1,pos+8,z#
  `
  rem Set vertex normals
  write memblock float 1,pos+12,nx#
  write memblock float 1,pos+16,ny#
  write memblock float 1,pos+20,nz#
  `
  rem Set vertex diffuse
  write memblock dword 1,pos+24,diff
  `
  rem Set vertex texture UV coords
  write memblock float 1,pos+28,0
  write memblock float 1,pos+32,0
  `
 next t
 `
endfunction

function finalisepolymesh(obj)
 `
 rem Make a new object from the memblock
 if object exist(obj)=1 then delete object obj
 if mesh exist(2)=1 then delete mesh 2
 memblock=1 : make mesh from memblock 2,memblock
 make object obj,2,0 : set object obj,1,0,0,0,0,0,0
 texture object obj,editorimagesoffset+13
 set object transparency obj,2
 set object collision off obj
 disable object zdepth obj
 set object light obj,0
 ghost object on obj
 set object transparency obj,2
 disable object zread obj
 rem X10 - HUD object is for main scene ONLY
 set object mask obj,%000010,%0,%0 
 `
endfunction



rem
rem FUNCTIONS FOR LINKING EXES
rem

`
` FUNCTION TO LAUNCH BROWSER
`
function browseropen$(browsemode)

rem this way still used by segment editor
localdesc$=""
if segobjusedforsegeditor=1

 `
 ` FOR SEGMENT EDITOR
 `

 rem Clear result
 resultstring$=""

 rem Store directory
 curdir$=get dir$()

 rem Launch browser in freeze mode
 set dir rootdir$ : set dir ".."

 rem Run if not currently active
 if window exist(browsername$)=0
  execute file browserexe$,"",""
  while window exist(browsername$)=0
   sync
  endwhile
 else
  window to front browsername$
 endif

 rem Trigger it to provide correct cateogory for browse
 filemapname$=browsername$+"(ACTIVE)"
 write filemap value filemapname$,1
 filemapname$=browsername$+"(MODE)"
 write filemap value filemapname$,browsemode
 write filemap string filemapname$,strarr$(42)

 rem Switch this app to processor friendly
 sync off : always active off

 rem Must wait for response..
 filemapname$=browsername$+"(ACTIVE)"
 while read filemap value(filemapname$)<>2
 endwhile

 rem This app must wait for..
 tresult=0
 tresult$=""
 filemapname$=browsername$+"(RESULT)"
 while tresult=0
  if window exist(browsername$)=1
   window to front browsername$
   tresult=read filemap value(filemapname$)
  else
   exit
  endif
 endwhile

 rem Take action based on result
 if tresult=0 then resultstring$=""
 if tresult=1 then resultstring$=read filemap string(filemapname$)
 if tresult=2 then resultstring$=""

 rem Restore primary activity
 window to back browsername$
 window to front
 sync on : always active on : sync

 rem set directory to return string (or restore)
 if len(resultstring$)>0
  tfile$=getfile(resultstring$)
  tpath$=left$(resultstring$,len(resultstring$)-len(tfile$))
  set dir rootdir$ : set dir tpath$
  resultstring$=get dir$()+"\"+tfile$
 else
  set dir curdir$
 endif

else

`
` FOR MAP EDITOR
`

rem Prepare browse type settings
browsetype=browsemode
baseimagepath$=".\editors\gfx\browser\"
if browsetype=1
 browsetitle$=strarr$(43)
 baselib$=""
 baseimage$="all.bmp"
endif
if browsetype=2
 browsetitle$=strarr$(44)
 baselib$="texturebank\"
 baseimage$="texture.bmp"
endif
if browsetype=3
 browsetitle$=strarr$(45)
 baselib$="meshbank\"
 baseimage$="mesh.bmp"
endif
if browsetype=4
 browsetitle$=strarr$(46)
 baselib$="audiobank\"
 baseimage$="audio.bmp"
endif
if browsetype=5
 browsetitle$=strarr$(47)
 baselib$="effectbank\"
 baseimage$="effect.bmp"
endif
if browsetype=6
 browsetitle$=strarr$(48)
 baselib$="segments\"
 baseimage$="segment.bmp"
endif
if browsetype=7
 browsetitle$=strarr$(49)
 baselib$="prefabs\"
 baseimage$="prefab.bmp"
endif
if browsetype=8
 browsetitle$=strarr$(50)
 baselib$="mapbank\"
 baseimage$="map.bmp"
endif
if browsetype=9
 browsetitle$=strarr$(51)
 baselib$="entitybank\"
 baseimage$="entity.bmp"
endif

rem Assign filters to browse types
browseextcount=0
dim browseext$(64)
if browsetype=1
 browseext$(browseextcount+1)=".*"
 inc browseextcount,1
endif
if browsetype=2
 browseext$(browseextcount+1)="tga"
 inc browseextcount,1
endif
if browsetype=3
 browseext$(browseextcount+1)="x"
 inc browseextcount,1
endif
if browsetype=4
 browseext$(browseextcount+1)="wav"
 browseext$(browseextcount+2)="mp3"
 inc browseextcount,2
endif
if browsetype=5
 browseext$(browseextcount+1)="fx"
 inc browseextcount
endif
if browsetype=6
 browseext$(browseextcount+1)="fps"
 inc browseextcount
endif
if browsetype=7
 browseext$(browseextcount+1)="fpp"
 inc browseextcount
endif
if browsetype=8
 browseext$(browseextcount+1)="fpm"
 inc browseextcount
endif
if browsetype=9
 browseext$(browseextcount+1)="fpe"
 inc browseextcount
endif

rem Build extension string (ie .wav,.mp3)
extstring$=""
for t=1 to browseextcount
 if t>1 then extstring$=extstring$+","
 extstring$=extstring$+browseext$(t)
next t

rem Call up browser dialog
set file map string$ 1, 1000, rootdir$+"\"+baselib$
set file map string$ 1, 1256, browsetitle$

rem File Filter
set file map string$ 1, 1768,extstring$

rem Default image if no thumbnail found
set file map string$ 1, 2024, rootdir$+"\"+baseimagepath$+baseimage$

rem Window Title
set file map string$ 1, 2280, browsetitle$

rem Set last location for navigation
if browserfolderhistory$(browsetype)<>""
 set file map string$ 1, 2536, browserfolderhistory$(browsetype)
endif

rem Wait for dialog session to end
set file map dword 1, 800, 1
wait for file map event 1
while get file map dword(1,800)=1
 wait for file map event 1
endwhile

rem localized description of selection
localdesc$=get file map string$( 1, 1768 )

rem return string from browser dialog
set dir rootdir$
resultstring$=get file map string$( 1, 1512 )
if resultstring$<>""
 rem Final return string
 rem Store location as we leave browser
 resultstring$=right$(resultstring$,len(resultstring$)-len(rootdir$+"\"))
 browserfolderhistory$(browsetype)=right$(resultstring$,len(resultstring$)-len(baselib$))
 resultstring$=get dir$()+"\"+resultstring$
else
 rem No return string
endif

rem Seg Or Map Browser version
endif

endfunction resultstring$

`
` FUNCTION TO LAUNCH SEGEDIT (INDEPENDENT TOOL)
`
function segedit$(segeditmode)

rem Clear result
resultstring$=""

rem Store directory
curdir$=get dir$()

rem Launch in freeze mode
set dir rootdir$ : set dir ".."

rem Run if not currently active
if window exist(segeditname$)=0
 execute file segeditexe$,"",""
 while window exist(segeditname$)=0
  sync
 endwhile
else
 window to front segeditname$
endif

endfunction


rem
rem FLAK
rem

_flak_init:

rem Load in all flak
gosub _flak_scaninall_dataonly

rem Start with no flak
flakid=0

return

_flak_loaddata:

dim data$(100)
filename$="gamecore\flak\"+flak$+"\flakspec.txt"
load array filename$,data$()
addfiletocollection(filename$)
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem take value 1 and 2 from value
   for c=0 to len(value$)
    if mid$(value$,c)="," then mid=c : exit
   next c
   value1=val(removeedgespaces(left$(value$,mid-1)))
   value2=val(removeedgespaces(right$(value$,len(value$)-mid)))
   `
   rem flak START
   if field$="throwangle" then flak(flakid).throwangle=value1
   if field$="throwforward" then flak(flakid).throwforward=value1
   if field$="throwheight" then flak(flakid).throwheight=value1
   `
   rem flak MOVEMENT
   if field$="lifespan" then flak(flakid).profile.lifespan=value1
   if field$="yinc" then flak(flakid).profile.yinc=value1
   if field$="zinc" then flak(flakid).profile.zinc=value1
   if field$="xspeed" then flak(flakid).profile.xspeed=1.0+(value1/1000.0)
   if field$="yspeed" then flak(flakid).profile.yspeed=1.0+(value1/1000.0)
   if field$="zspeed" then flak(flakid).profile.zspeed=1.0+(value1/1000.0)
   if field$="weight" then flak(flakid).profile.weight=value1/1000.0
   if field$="spinx" then flak(flakid).profile.spinx=value1/10.0
   if field$="bounceonhit" then flak(flakid).profile.bounceonhit=value1
   if field$="explodeonhit" then flak(flakid).profile.explodeonhit=value1
   if field$="damage" then flak(flakid).profile.damage=value1
   `
   rem flak EXPLOSION
   if field$="exponfloor" then flak(flakid).exponfloor$=value$
   if field$="expinair" then flak(flakid).expinair$=value$
   `
   rem flak SOUND
   if field$="sndbounce" then flak(flakid).sound.sndbounce$=value$
   if field$="sndexplode" then flak(flakid).sound.sndexplode$=value$
   `
  endif
 endif
next l
undim data$()

return

_flak_load:

rem Load flak data
gosub _flak_loaddata

rem Load flak models
currentflakobj=loadflak("gamecore\flak\"+flak$+"\PROJECTILE.x")
flak(flakid).obj=currentflakobj

rem X10 - object only for main scene, refract scene and reflect scene (and shadow in shadow scene)
set object mask currentflakobj,%110010,%0100,%10

rem Effect on projectiles
`if guseeffectongunsstate=0 `lee, currently no NORMAL MAPS for projectiles!
if 1
 `
 rem Base texture for fast moving projectiles
 img$="gamecore\flak\"+flak$+"\projectile_D2.tga" : imgD2id=loadinternalimage(img$)
 texture object currentflakobj,imgD2id
 `
else
 `
 rem Load Effect
 tfile$="effectbank\BumpCubeReflectAlpha\BumpCubeReflectAlpha.fx"
 debugfilename(tfile$,"effect for flak")
 teffectid=loadinternaleffect(tfile$)
 `
 rem First Textures are PLATES
 img$="gamecore\flak\"+flak$+"\flak_D.tga" : imgDid=loadinternalimage(img$)
 img$="gamecore\flak\"+flak$+"\flak_N.tga" : imgNid=loadinternalimage(img$)
 img$="gamecore\flak\"+flak$+"\flak_R.tga" : imgRid=loadinternalimage(img$)
 `
 rem Last Texture Image is CUBE
 img$="gamecore\flak\"+flak$+"\flak_cube.dds" : imgCUBEid=loadinternalimage(img$)
 if file exist(img$)=1 then load image img$,imgCUBEid,2
 addfiletocollection(img$)
 `
 rem Bump Quality
 texture object currentflakobj,0,imgDid
 texture object currentflakobj,1,imgNid
 texture object currentflakobj,2,imgRid
 texture object currentflakobj,3,imgCUBEid
 `
 rem Apply effect to object
 set object effect currentflakobj,teffectid
 `
endif

rem Setup flak for correct visuals
`300707 - green glaive - disable object zdepth currentflakobj
`set object transparency currentflakobj,2
`transparency now set when clone the flak

rem Setup flak for animation
set object speed currentflakobj,45
loop object currentflakobj

rem Find Explosion for this flak
decal$=flak(flakid).exponfloor$ : gosub _decal_find : flak(flakid).exponfloorid=decalid : if decalid>0 then decal(decalid).active=1
decal$=flak(flakid).expinair$ : gosub _decal_find : flak(flakid).expinairid=decalid : if decalid>0 then decal(decalid).active=1

rem Load sounds into bank
flak(flakid).sound.sndbounceid=loadinternalsoundcore("gamecore\flak\"+flak$+"\"+flak(flakid).sound.sndbounce$,1)
flak(flakid).sound.sndexplodeid=loadinternalsoundcore("gamecore\flak\"+flak$+"\"+flak(flakid).sound.sndexplode$,1)

return

_flak_scaninall_ref:

rem Scan entire flaks folder
set dir "gamecore" : flakid=1
empty array filelist$()
buildfilelist("flak","")
set dir ".."
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   if lower$(right$(file$,12))="projectile.x"
    if flakid>flakmax
     flakmax=flakid
     dim flak(flakmax) as flaktype
    endif
    flak(flakid).name$=left$(file$,len(file$)-13)
    inc flakid
   endif
  endif
 next chkfile
endif

return

_flak_scaninall_dataonly:

rem Scan entire flaks folder
gosub _flak_scaninall_ref
for flakid=1 to flakmax
 flak$=flak(flakid).name$
 gosub _flak_loaddata
next flakid

rem At start, no flak is loaded
for flakid=1 to flakmax
 flak(flakid).usedsoload=0
next flakid

return

_flak_scaninall:
`170807 - loading all FLAK at start wasteful!
`rem Scan entire flaks folder
`gosub _flak_scaninall_ref
`rem Load all flaks
`for flakid=1 to flakmax
` flak$=flak(flakid).name$
` gosub _flak_load
`next flakid
return

_flak_loadonlypresent:
 `
 rem when entities loaded, flak is flagged
 rem when player start is scanned, flak is flagged
 for flakid=1 to flakmax
  flak$=flak(flakid).name$
  if flak(flakid).usedsoload=1
   gosub _flak_load
  endif
 next flakid
 `
return

_flak_findindex:
 tindex=0 : rem 291007 - from -1 which created a negative index into arrays
 for flakid=1 to flakmax
  if flak$=flak(flakid).name$
   tindex=flakid
   rem 170806 - when ask for FLAKID, we know it is being used, so flag it for later load
   flak(flakid).usedsoload=1
   exit
  endif
 next flakid
return

`
` FLAK ELEMENTS HANDLING
`

_flakelement_create:

for tf=1 to flakelementmax
 if flakelement(tf).active=0 then exit
next tf
if tf<flakelementmax
 rem found free flak element
 flakelement(tf).flakid=flakid
 flakelement(tf).profile=flak(flakid).profile
 rem activate new flak element
 flakelement(tf).active=1
 flakelement(tf).range=0
 flakelement(tf).xpos=flakx
 flakelement(tf).ypos=flaky
 flakelement(tf).zpos=flakz
 flakelement(tf).owner=flakowner
 rem X10 - 030807 - water hanlding of flak
 if flakelement(tf).ypos>waterlevel#
  flakelement(tf).abovewater=1
 else
  flakelement(tf).abovewater=0
 endif
 rem create projectile
 flakelement(tf).obj=flakelementoffset+tf
 tfobj=flakelement(tf).obj
 if object exist(tfobj)=1 then delete object tfobj
 `x9instance object tfobj,flak(flakid).obj
 `clone is easier to delete and recreate, instances for hide/show
 clone object tfobj,flak(flakid).obj
 set object transparency tfobj,2
 rem use ORIENT to get correct rotation and intertias
 if flakowner=0
  set object to camera orientation tfobj
 else
  rotate object tfobj,flakpitch,flakangle,0
 endif
 move object tfobj,flakelement(tf).profile.zinc
 flakelement(tf).profile.xinc=object position x(tfobj)*2
 flakelement(tf).profile.yinc=flakelement(tf).profile.yinc+(object position y(tfobj)*2)
 flakelement(tf).profile.zinc=object position z(tfobj)*2
 flakelement(tf).xpos=flakelement(tf).xpos+(flakelement(tf).profile.xinc*flakspeed#)
 flakelement(tf).ypos=flakelement(tf).ypos+(flakelement(tf).profile.yinc*flakspeed#)
 flakelement(tf).zpos=flakelement(tf).zpos+(flakelement(tf).profile.zinc*flakspeed#)
 flakelement(tf).noimpactdelay=0
 rem X10 set the flak object as an actual physics objects
 if flakelement(tf).profile.bounceonhit=0
  rem no ODE, straight flak
  position object tfobj,99999,99999,99999
 else
  rem bounce object is physics (grenade, glaive) `  if flakowner=0
  rem angle flak as glaive needs to pint in player direction
  rotate object tfobj,0,camera angle y(playercam),0
  position object tfobj,flakelement(tf).xpos,flakelement(tf).ypos,flakelement(tf).zpos
  tttobj=tobj : tobj=tfobj : tte=e : e=0
  gosub _physics_ensurephysicsobjvalid
  tobj=tttobj : e=tte
  gosub _physics_createfragment
 endif
 rem show flak object
 show object tfobj
else
 rem no more free flak
endif

return

_flakelement_explodeinstantly:
 rem last tick before BANG! (tf from _flakelement_create)
 flakelement(tf).profile.lifespan=1
return

_flakelement_control:

rem flak timing
timeelapsedflak#=(1.0/30.0)*(timer()-timestampflak) : timestampflak=timer()

rem update me vars
mex#=camera position x(playercam)
mey#=camera position y(playercam)
mez#=camera position z(playercam)

rem Control all flak activity
for f=1 to flakelementmax
 if flakelement(f).active=1
  `
  rem update flak object (initial so we see starting position of flak)
  tobj=flakelement(f).obj
  tflakid=flakelement(f).flakid
  `
  rem spin test
  if flakelement(f).profile.spinx<>0
   rotate limb tobj,0,limb angle x(tobj,0)+flakelement(f).profile.spinx,0,0
  endif
  `
  rem bounce uses ODE, else regular
  if flakelement(f).profile.bounceonhit=0
   rem affect flak by inertia and gravity
   position object tobj,flakelement(f).xpos,flakelement(f).ypos,flakelement(f).zpos
   xrotate object tobj,object angle x(tobj)+flakelement(f).profile.spinx
   tmpx1#=flakelement(f).xpos : tmpy1#=flakelement(f).ypos : tmpz1#=flakelement(f).zpos
   flakelement(f).xpos=flakelement(f).xpos+(flakelement(f).profile.xinc*timeelapsedflak#)
   flakelement(f).ypos=flakelement(f).ypos+(flakelement(f).profile.yinc*timeelapsedflak#)
   flakelement(f).zpos=flakelement(f).zpos+(flakelement(f).profile.zinc*timeelapsedflak#)
   flakelement(f).profile.xinc=flakelement(f).profile.xinc/flakelement(f).profile.xspeed
   flakelement(f).profile.yinc=flakelement(f).profile.yinc/flakelement(f).profile.yspeed
   flakelement(f).profile.zinc=flakelement(f).profile.zinc/flakelement(f).profile.zspeed
   flakelement(f).profile.yinc=flakelement(f).profile.yinc-flakelement(f).profile.weight
  else
   rem X10 get coordinate from object pos
   flakelement(f).xpos=object position x(tobj)
   flakelement(f).ypos=object position y(tobj)
   flakelement(f).zpos=object position z(tobj)
  endif
  `
  rem X10 handle water aspects of flak
  if flakelement(f).ypos<waterlevel# and flakelement(f).abovewater=1
   rem create splash
   flakelement(f).abovewater=0   
   rem show splash
   decalid=splashdecalid
   decalorient=0
   decalx=flakelement(f).xpos
   decaly=waterlevel#
   decalz=flakelement(f).zpos
   decalscalemodx=100
   decalscalemody=decalscalemodx
   decalalpha=50
   originatore=0 : gosub _decalelement_create
   rem play splash sound
   tmatindex=9 : tsoundtrigger=material(tmatindex).impactid
   tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
   tsx#=decalx : tsy#=decaly : tsz#=decalz
   tvol#=50
   gosub _physics_triggermaterialsound
  endif 
  `
  rem handle flak collision
  tdetonate=0 : tcollide=0
  `text object screen x(tobj),object screen y(tobj),str$(flakelement(f).profile.lifespan)
  if flakelement(f).profile.lifespan>0
   tttick=timeelapsedflak# : if tttick<1 then tttick=1
   dec flakelement(f).profile.lifespan,tttick
   if flakelement(f).profile.lifespan<2
    flakelement(f).profile.lifespan=0
    tdetonate=1
   endif
  endif
  if tdetonate=0
   `
   rem bounce uses ODE, else regular
   if flakelement(f).profile.bounceonhit=0
    `
    rem if not zero-life
    if flakelement(f).ypos<0
     rem bounce at base of universe
     flakelement(f).profile.yinc=flakelement(f).profile.yinc*-0.9
     flakelement(f).ypos=0
     tcollide=1
    endif
    `
    rem check for collision
    tmpx2#=tmpx1#+(flakelement(f).profile.xinc*3.0)
    tmpy2#=tmpy1#+(flakelement(f).profile.yinc*3.0)
    tmpz2#=tmpz1#+(flakelement(f).profile.zinc*3.0)
    if static raycast(tmpx1#,tmpy1#,tmpz1#,tmpx2#,tmpy2#,tmpz2#)<>0
     `
     rem yes, checklist now filled with collision feedback data
     flakelement(f).profile.xinc=checklist fvalue a(8)
     flakelement(f).profile.yinc=checklist fvalue b(8)
     flakelement(f).profile.zinc=checklist fvalue c(8)
     flakelement(f).profile.xinc=flakelement(f).profile.xinc*0.4
     flakelement(f).profile.yinc=flakelement(f).profile.yinc*0.6
     flakelement(f).profile.zinc=flakelement(f).profile.zinc*0.4
     flakelement(f).xpos=checklist fvalue a(6)+flakelement(f).profile.xinc
     flakelement(f).ypos=checklist fvalue b(6)+flakelement(f).profile.yinc
     flakelement(f).zpos=checklist fvalue c(6)+flakelement(f).profile.zinc
     tcollide=2
     `
     rem collision bounce requires orientation
     if flakelement(f).profile.bounceonhit>0
      point object tobj,flakelement(f).xpos+(flakelement(f).profile.xinc*10.0),flakelement(f).ypos+(flakelement(f).profile.yinc*10.0),flakelement(f).zpos+(flakelement(f).profile.zinc*10.0)
     endif
     `
     rem kill Y ineria if get too low
     if abs(flakelement(f).profile.yinc)<0.02
      flakelement(f).profile.spinx=0
      flakelement(f).profile.yinc=0
     endif
     `
    endif
    `
    rem collides with entity in area - bounce off entities
    spherex#=flakelement(f).xpos
    spherey#=flakelement(f).ypos
    spherez#=flakelement(f).zpos
    spherenx#=spherex#+flakelement(f).profile.xinc
    sphereny#=spherey#+flakelement(f).profile.yinc
    spherenz#=spherez#+flakelement(f).profile.zinc
    gosub _entity_spherecollision
    if spheree<>-1
     if flakelement(f).owner=spheree
      rem owners of flak are except
     else
      rem backtrack to leave collision
      flakelement(f).profile.xinc=flakelement(f).profile.xinc*-1
      flakelement(f).profile.zinc=flakelement(f).profile.zinc*-1
      flakelement(f).xpos=flakelement(f).xpos+flakelement(f).profile.xinc
      flakelement(f).ypos=flakelement(f).ypos+flakelement(f).profile.yinc
      flakelement(f).zpos=flakelement(f).zpos+flakelement(f).profile.zinc
      tcollide=1
     endif
    endif
    `
    rem if shot BY entity, can collide with player
    if flakelement(f).owner<>0
     tx#=flakelement(f).xpos-mex#
     tz#=flakelement(f).zpos-mez#
     td#=sqrt(abs(tx#*tx#)+abs(tz#*tz#))
     ty#=abs(flakelement(f).ypos-mey#)
     if td#<30.0 and ty#<100.0 then tcollide=1
    endif
    `
    rem complete collision code - detonate or deduct from bounce count
    if tcollide>0
     if flakelement(f).profile.explodeonhit>0 or flakelement(f).profile.bounceonhit>0
      if flakelement(f).profile.bounceonhit>0 and flakelement(f).profile.explodeonhit=0
       flakelement(f).profile.bounceonhit=flakelement(f).profile.bounceonhit-1
       playinternal3dsound(flak(tflakid).sound.sndbounceid,tmpx1#,tmpy1#,tmpz1#)
      else
       rem detonate at last collision, add scorch
       tdetonate=1
      endif
     endif
    endif
    `
   else
    `
    rem complete collision code - physics bouncer
    if flakelement(f).profile.explodeonhit=2
     rem detonate at last collision, add scorch
     tdetonate=1
    endif
    `
   endif
   `
  endif
  rem detonate trigger
  if tdetonate=1
   rem trigger explosion
   flakelement(f).active=2
  endif
 endif
 if flakelement(f).active=2
  rem hide flak object
  hide object flakelement(f).obj
  rem X10 remove object from physics
  tobj=flakelement(f).obj : gosub _physics_deleteentity
  rem trigger exploder
  frox#=flakelement(f).xpos
  froy#=flakelement(f).ypos
  froz#=flakelement(f).zpos
  if flakelement(f).profile.bounceonhit=0
   rem affect flak by inertia and gravity
   frox#=frox#-(flakelement(f).profile.xinc*timeelapsedflak#*2)
   froy#=froy#-(flakelement(f).profile.yinc*timeelapsedflak#*2)
   froz#=froz#-(flakelement(f).profile.zinc*timeelapsedflak#*2)
  endif
  gosub _part_triggerexplosion
  rem make sound seem louder by moving it closer to player
  playinternal3dsound(flak(tflakid).sound.sndexplodeid,frox#,froy#,froz#)
  rem ONLY affect decal with ZBIAS if explosion that needs to be seen by player in full
  `x9if object exist(tobj)=1 then enable object zbias tobj,-500.0,0.0
  rem initial blast creates scorch (in six directions)
  for tscdir=1 to 6
   if tscdir=1 then t=static raycast(frox#+0,froy#,froz#,frox#-200,froy#,froz#)
   if tscdir=2 then t=static raycast(frox#+0,froy#,froz#,frox#+200,froy#,froz#)
   if tscdir=3 then t=static raycast(frox#,froy#+0,froz#,frox#,froy#-200,froz#)
   if tscdir=4 then t=static raycast(frox#,froy#+0,froz#,frox#,froy#+200,froz#)
   if tscdir=5 then t=static raycast(frox#,froy#,froz#+0,frox#,froy#,froz#-200)
   if tscdir=6 then t=static raycast(frox#,froy#,froz#+0,frox#,froy#,froz#+200)
   tsize#=45-rnd(30) : if t=1 then add static scorch tsize#,4+rnd(3)
  next tscdir
  rem start range of expanding explosion at zero
  flakelement(f).range=0
  rem create force of damage
  flakelement(f).active=3
  rem all entities that can take damage (characters, windows)
  tx#=flakelement(f).xpos : ty#=flakelement(f).ypos : tz#=flakelement(f).zpos
  spheredamage=flakelement(f).profile.damage
  spherex#=tx# : spherey#=ty# : spherez#=tz# : sphereforce#=1.0
  spherecreatedby=10000+flakelement(f).owner
  gosub _entity_addforcesphere
  spherecreatedby=0
 endif
 if flakelement(f).active=3
  rem increase range as force expands
  flakelement(f).range=flakelement(f).range+10
  if flakelement(f).range>100
   flakelement(f).active=0
  endif
  rem detonate any other flak (other grenades)
  tx#=flakelement(f).xpos
  ty#=flakelement(f).ypos
  tz#=flakelement(f).zpos
  for sf=1 to flakelementmax
   if f<>sf and flakelement(sf).active=1
    tsx#=flakelement(sf).xpos-tx#
    tsy#=flakelement(sf).ypos-ty#
    tsz#=flakelement(sf).zpos-tz#
    d#=sqrt(abs(tsx#*tsx#)+abs(tsy#*tsy#)+abs(tsz#*tsz#))
    if d#<flakelement(f).range
     rem explode the flak
     flakelement(sf).active=2
     flakelement(sf).range=0
    endif
   endif
  next sf
 endif
 `
next f

return

_flak_deleteall:
 `
 rem X10 - 041007 - go through all flak and delete objects (including physics objects)
 for f=1 to flakelementmax
  tobj=flakelement(f).obj
  if tobj>0
   if object exist(tobj)=1
    gosub _physics_deleteentity
    delete object tobj
   endif
  endif
 next f
 `
return


`
` FUNCTIONS FOR FLAK
`

function loadflak(tfile$)
 index=0
 if flakbankmax>0
  for t=1 to flakbankmax
   if tfile$=flakbank$(t) then index=flakbankoffset+t : exit
  next t
 else
  t=flakbankmax+1
 endif
 if t>flakbankmax
  inc flakbankmax
  if file exist(tfile$)=1
   index=flakbankoffset+flakbankmax
   flakbank$(flakbankmax)=tfile$
   addfiletocollection(tfile$)
   load object tfile$,index
   yrotate object index,180
   fix object pivot index
   set object collision off index
   hide object index
  endif
 endif
endfunction index


rem
rem DECAL
rem

_decal_init:

rem Load in all decal
gosub _decal_scaninallref

rem X10 apply a soft decal shader for all decals (depth-buffer-read)
dirbefore$=get dir$() : set dir commoneffects$
tfile$="softdecal.fx" : gsoftdecalshader=loadinternaleffectunique(tfile$,0)
addfiletocollection(commoneffects$+tfile$)
set dir dirbefore$

rem Precreate elements as each is unique (UV writing)
for f=1 to decalelementmax
 tobj=decalelementoffset+f : decalelement(f).obj=tobj
 if object exist(tobj)=1 then delete object tobj
 make object plain tobj,100,100
 set object transparency tobj,2
 set object collision off tobj
 disable object zwrite tobj
 set object texture tobj,0,0
 set object light tobj,0
 set object cull tobj,0
 hide object tobj
 rem X10 apply the soft decal effect to all decals
 set object effect tobj,gsoftdecalshader
 rem X10 - object only for main scene, refract scene and reflect scene (and shadow in shadow scene)
 set object mask tobj,%110010,%0100,%10
next f

rem X10 ensure water ripple decal available
decal$="ripple"
gosub _decal_find
if decalid>0
 waterdecalripple=decalid
 decal(waterdecalripple).active=1
else
 waterdecalripple=0
endif
waterdecalripplemaster=waterdecalripple

rem X10 splash decal
decal$="splash"
gosub _decal_find
if decalid>0
 splashdecalid=decalid
 decal(splashdecalid).active=1
else
 splashdecalid=0
endif

return

_decal_loaddata:

dim data$(100)
filename$="gamecore\decals\"+decal$+"\decalspec.txt"
addfiletocollection(filename$)
load array filename$,data$()
for l=0 to 99
 line$=data$(l)
 if len(line$)>0
  if left$(line$,1)<>";"
   `
   rem take fieldname and value
   for c=0 to len(line$)
    if mid$(line$,c)="=" then mid=c : exit
   next c
   field$=lower$(removeedgespaces(left$(line$,mid-1)))
   value$=removeedgespaces(right$(line$,len(line$)-mid))
   `
   rem take value 1 and 2 from value
   for c=0 to len(value$)
    if mid$(value$,c)="," then mid=c : exit
   next c
   value1=val(removeedgespaces(left$(value$,mid-1)))
   value2=val(removeedgespaces(right$(value$,len(value$)-mid)))
   `
   rem decal
   if field$="across" then decal(decalid).across=value1
   if field$="down" then decal(decalid).down=value1
   if field$="offsety" then decal(decalid).offsety=value1
   if field$="scale" then decal(decalid).scale=value1
   `
  endif
 endif
next l
undim data$()

rem default scale is 100
if decal(decalid).scale=0 then decal(decalid).scale=100

rem Some pre-game calculations
decal(decalid).framemax=decal(decalid).across*decal(decalid).down

return

_decal_load:

rem Load decal data
gosub _decal_loaddata

rem Load decal image and store name in bank
loaddecal("gamecore\decals\"+decal$+"\decal.tga",decalid)

return

_decal_scaninallref:

rem Scan entire decals folder
set dir "gamecore" : decalid=1
empty array filelist$()
buildfilelist("decals","")
set dir ".."
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   tryfile$=lower$(right$(file$,9))
   if left$(tryfile$,len(tryfile$)-4)="decal"
    newdecal$=left$(file$,len(file$)-10)
    for tdecalid=1 to decalmax
     if decal(tdecalid).name$=newdecal$ then exit
    next tdecalid
    if tdecalid>decalmax
     if decalid>decalmax
      decalmax=decalid
      dim decal(decalmax) as decaltype
     endif
     decal(decalid).name$=newdecal$
     inc decalid
    endif
   endif
  endif
 next chkfile
endif
decalmax=decalid-1

return

_decal_scaninall:

rem Load all decal data list in
gosub _decal_scaninallref

rem Load all decals
for decalid=1 to decalmax
 decal$=decal(decalid).name$
 decal(decalid).active=1
 gosub _decal_load
next decalid

return

_decal_loadonlyactivedecals:

rem Load all decals that have been activated
for decalid=1 to decalmax
 if decal(decalid).active=1
  decal$=decal(decalid).name$
  gosub _decal_load
 endif
next decalid

return

`
` decal ELEMENTS HANDLING
`

_decalelement_create:

for d=1 to decalelementmax
 if decalelement(d).active=0 then exit
next d
if d<decalelementmax
 rem activate new decal element
 currentdecald=d
 decalelement(d).decalid=decalid
 decalelement(d).active=1
 decalelement(d).xpos=decalx
 decalelement(d).ypos=decaly
 decalelement(d).zpos=decalz
 decalelement(d).frame=0
 decalelement(d).framedelay=timer()
 decalelement(d).orient=decalorient
 decalelement(d).originator=originatore
 decalelement(d).looping=0
 decalelement(d).alphafactor=decalalpha
 rem prepare decal object
 tobj=decalelement(d).obj
 ty=decal(decalid).offsety
 position object tobj,decalelement(d).xpos,decalelement(d).ypos+ty,decalelement(d).zpos
 rem face camera or leave as is
 if decalelement(d).orient=0
  point object tobj,camera position x(playercam),camera position y(playercam),camera position z(playercam)
  xrotate object tobj,0 : zrotate object tobj,0
 endif
 if decalelement(d).orient=1
  rotate object tobj,decalorientx#,decalorienty#,decalorientz#
 endif
 if decalelement(d).orient=2
  rotate object tobj,90,0,0
 endif
 if decalelement(d).orient=3
  point object tobj,camera position x(playercam),camera position y(playercam),camera position z(playercam)
 endif
 if decalelement(d).orient=4
  point object tobj,camera position x(playercam),camera position y(playercam),camera position z(playercam)
  move object tobj,5.0
 endif
 enable object zbias tobj,0.0,0.0
 rem texture for this decal type
 texture object tobj,decal(decalid).imageid
 rem X10 re-apply the soft decal effect after retexturing
 set object effect tobj,gsoftdecalshader
 rem set alpha factor as texturing erases it
 set alpha mapping on tobj,decalelement(d).alphafactor
 rem scale the decal
 if decalscalemodx=0
  decalelement(d).scalemodx=decal(decalid).scale
  decalelement(d).scalemody=decal(decalid).scale
 else
  decalelement(d).scalemodx=decalscalemodx
  decalelement(d).scalemody=decalscalemody
 endif
 scale object tobj,decalelement(d).scalemodx,decalelement(d).scalemody,100
 rem show decal object
 show object tobj
else
 tobj=0
endif

return

_decalelement_continue:
 `
 rem decal is looping, merely need to continue the current decal
 d=currentdecald
 decalelement(d).looping=1
 decalelement(d).keepalivefornextloop=1
 if d>0 and decalelement(d).originator=originatore
  `x9rem simply reset decal
  `removed, decalelement(d).looping added and loop control now in control routine
  `decalelement(d).frame=0
  `decalelement(d).framedelay=timer()
 else
  rem different, so recreate
  gosub _decalelement_create
 endif
 `
return

_decalelement_control:

rem Control all decal activity
for f=1 to decalelementmax
 if decalelement(f).active=1
  rem update decal object
  tobj=decalelement(f).obj : tdetonate=0
`  rem if decal not in visible screen, destroy for performance - off no code
  if tdetonate=0
   rem animation
   decalid=decalelement(f).decalid
   if (decalelement(f).frame<decal(decalid).framemax and decalelement(f).looping=1) or (decalelement(f).frame<decal(decalid).framemax-1 and decalelement(f).looping=0)
    rem next frame
    `x9decalelement(f).framedelay=decalelement(f).framedelay+1
    `if decalelement(f).framedelay>0
    ` decalelement(f).framedelay=0
    ` decalelement(f).frame=decalelement(f).frame+1
    `endif
    rem X10 uses timing math rather than incremental math
    `if timer()-decalelement(f).framedelay>35
    if timer()-decalelement(f).framedelay>20
     decalelement(f).framedelay=timer()
     decalelement(f).frame=decalelement(f).frame+1
     if decalelement(f).looping=1 and decalelement(f).keepalivefornextloop=1
      if decalelement(f).frame>=decal(decalid).framemax
       decalelement(f).keepalivefornextloop=0
       decalelement(f).frame=0
      endif
     endif
    endif   
   else
    rem no more animation
    tdetonate=1
   endif
   rem write UV for correct anim frame
   trenderdecalanimation=0
   if tdetonate=0
    rem 130907 - if decal visible, or ripple (which can be very close to player)
    if object visible(tobj)=1 and object in screen(tobj)=1 then trenderdecalanimation=1
    if decalelement(f).decalid=waterdecalripple then trenderdecalanimation=1
   endif
   if trenderdecalanimation=1
    rem rotate to face camera if flagged
    if decalelement(f).orient=0
     point object tobj,camera position x(playercam),camera position y(playercam),camera position z(playercam)
     xrotate object tobj,0 : zrotate object tobj,0
    endif
    if decalelement(f).orient=2
     set object cull tobj,1
    else
     set object cull tobj,0
    endif
    if decalelement(f).orient=3
     point object tobj,camera position x(playercam),camera position y(playercam),camera position z(playercam)
    endif
    rem animation UVs
    tframe=decalelement(f).frame
    ty=tframe/decal(decalid).across : tx=tframe-(ty*decal(decalid).across)
    q#=1.0/(decal(decalid).across+0.0) : tx#=tx*q# : ty#=ty*q#
    rem X10 use fU and fV [ and fSize ] to handle UV control from constant, rather than vertexdata write!
    ` set effect constant float 12,"fU",frameu
    ` set effect constant float 12,"fV",framev
    lock vertexdata for limb tobj,0,1
    rem x10 new plane
    if 1
     set vertexdata uv 0,tx#,ty#
     set vertexdata uv 1,tx#+q#,ty#
     set vertexdata uv 2,tx#,ty#+q#
     set vertexdata uv 3,tx#+q#,ty#
     set vertexdata uv 4,tx#+q#,ty#+q#
     set vertexdata uv 5,tx#,ty#+q#
    else
     set vertexdata uv 0,tx#+q#,ty#
     set vertexdata uv 1,tx#,ty#
     set vertexdata uv 2,tx#+q#,ty#+q#
     set vertexdata uv 3,tx#,ty#
     set vertexdata uv 4,tx#,ty#+q#
     set vertexdata uv 5,tx#+q#,ty#+q#
    endif
    unlock vertexdata
   endif
  endif
  rem detonate trigger
  if tdetonate=1
   hide object decalelement(f).obj
   decalelement(f).originator=0
   decalelement(f).active=0
  endif
 endif
next f

return

_decal_triggermaterialdebris:
 `
 rem takes tsoundmaterial,tsx#,tsy#,tsz#
 if tsoundmaterial>0
  decalid=material(tsoundmaterial-1).decalid
  rem X10 - 120807 - only trigger material debris if above water (+10 wetzone)
  if tsy#<waterlevel#+10 then decalid=0
  if decalid>0
   rem create the decal for this event
   decalscalemodx=0 : rem FPSCV101 - fix
   decalorient=4 : decalx=tsx# : decaly=tsy# : decalz=tsz#
   decalalpha=100 : rem strong decal alpha from impacts and debris effects
   originatore=-1 : gosub _decalelement_create
  endif
  rem FPSCV101 - add
  tsoundmaterial=0
 endif
 `
return

`
` FUNCTIONS FOR decal
`

function loaddecal(tfile$,decalid)
 timg=loadinternalimagecompress(tfile$,5)
 decal(decalid).imageid=timg
endfunction timg


`
`
`

_gun_findweaponindexbyname:

foundgunid=0
if findgun$<>""
 for tid=1 to gunmax
  if findgun$=lower$(gun(tid).name$)
   foundgunid=tid
   exit
  endif
 next tid
endif

return

_player_resettrail:
 playertrailmax=1
 for tp=0 to 100
  playertrial(tp).time=0
 next tp
return

_player_spawnsound:
 rem uses plrindex and te, make the spawn sound for the player appearing
 if gmultiplayergame=1
  tsnd=16
  if playersound(plrindex,tsnd)>0
   playinternal3dsoundfactor(playersound(plrindex,tsnd),entityelement(te).x,entityelement(te).y,entityelement(te).z,25.0)
  endif
 endif
return

_player_takedamage:

rem Either player One (main) or tplrid to use 'fake player entity soundset (multiplayer)
plrid=1 : tplrid=plrid : if gmultiplayergame=1 then tplrid=plrindex

rem special client case
if gmultiplayergame=1 and createorjoin=2
`
rem if multiplayer client, cannot take damage directly
`
else
`
rem Determine what to do from damage
if player(plrid).health>0 and tdamage>0
 player(plrid).health=player(plrid).health-tdamage
 if player(plrid).health<=0
  rem player looses a life
  player(plrid).recovershield=100
  player(plrid).health=0
  player(plrid).lives=player(plrid).lives-1
  if player(plrid).lives<=0
   player(plrid).lives=0
  endif
  rem player AI position out of range of enemies
  gosub _aiss_playerisheaven
  rem player grunts in deadness
  tsnd=15
  if playersound(tplrid,tsnd)>0
   broadcast3dplrsound(camera position x(playercam),camera position y(playercam),camera position z(playercam),10.0)
   set sound volume playersound(tplrid,tsnd),soundvolumes(0)    
   play sound playersound(tplrid,tsnd)
  endif
  rem player puts weapon away if fallen
  autoloadgun=0 : gosub _gun_change
  rem restore player zoom
  plrzoominchange=1 : plrzoomin#=0.0
  rem restore player modes
  onladder=0 : jumpaction=0 : crouchmode=0
  gunzoommode=0 : gunzoommag#=0
  rem stop any sliding force
  camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
  camforcex#=0 : camforcey#=0 : camforcez#=0
 else
  rem player grunts in hurt
  tsnd=12+rnd(2)
  if playersound(tplrid,tsnd)>0
   broadcast3dplrsound(camera position x(playercam),camera position y(playercam),camera position z(playercam),10.0)
   set sound volume playersound(tplrid,tsnd),soundvolumes(0)    
   play sound playersound(tplrid,tsnd)
  endif
 endif
 rem cause eyehud(red) to flare quickly
 hudid=internaleyehud
 hud(hudid).hidedelay=5
 hud(hudid).hide=0
 `not used hudbloomfromhurtcounter=50
endif
`
endif

return

_decal_find:

rem Load all decals
for decalid=1 to decalmax
 if decal(decalid).name$=decal$ then exit
next decalid
if decalid>decalmax then decalid=-1

return

_gun_free:

rem Hide gun from HUD
if currentgunobj>0
 if object exist(currentgunobj)=1
  set object interpolation currentgunobj,100
  set object frame currentgunobj,gun(gunid).action.show.s
  hide object currentgunobj
 endif
` if gun(gunid).secondobj>0
`  if object exist(gun(gunid).secondobj)=1 then hide object gun(gunid).secondobj
` endif
endif

rem Stop any gun sounds if free suddenly
if gunid>0
 for p=1 to 3
  if gunsound(gunid,p).soundid>0 then stop sound gunsound(gunid,p).soundid
  if gunsoundcompanion(gunid,p,0).soundid>0 then stop sound gunsoundcompanion(gunid,p,0).soundid
  if gunsoundcompanion(gunid,p,1).soundid>0 then stop sound gunsoundcompanion(gunid,p,1).soundid
  if gunsoundcompanion(gunid,p,2).soundid>0 then stop sound gunsoundcompanion(gunid,p,2).soundid
 next p
endif

rem Disassociate gun with player
gunselectionlockdown=0
currentgunobj=0

rem Hide support objects for gun
rem V109 - 060209 - not used OBJ as it may corrupt other subroutines (use TOBJ)
if gun(gunid).settings.flashlimb<>-1
 tobj=hudbankoffset+5
 if object exist(tobj)=1 then hide object tobj
endif
if gun(gunid).settings.brasslimb<>-1
 for o=6 to 20
  tobj=hudbankoffset+o
  if object exist(tobj)=1 then hide object tobj
 next o
endif
if gun(gunid).settings.brasslimb<>-1
 for o=21 to 30
  tobj=hudbankoffset+o
  if object exist(tobj)=1 then hide object tobj
 next o
endif

rem Hide cross hair
tobj=hudbankoffset+31
if object exist(tobj)=1 then hide object tobj

rem Clear basic gun vars
gunflash=0 : gunsmoke=0 : gunbrass=0 : gunshoot=0 : gunmode=5

return

_gun_scaninall_ref:

rem Scan entire guns folder
set dir "gamecore" : gunid=1
empty array filelist$()
buildfilelist("guns","")
set dir ".."
if array count(filelist$())>0
 dim gun(array count(filelist$())) as guntype
 for chkfile=0 to array count(filelist$())
  file$=filelist$(chkfile)
  if file$<>"." and file$<>".."
   if lower$(right$(file$,5))="hud.x"
    gun(gunid).name$=left$(file$,len(file$)-6)
    inc gunid
   endif
  endif
 next chkfile
 gunmax=gunid-1
 dim gun(gunmax+1) as guntype
 dim gunsound(gunmax+1,5) as gunsoundbanktype
 dim gunsoundcompanion(gunmax+1,5,2) as gunsoundbankcompaniontype
 dim gunsounditem(gunmax+1,50) as gunsounditemtype
endif

rem Now sort the gun list into alphabetical order (MP needs gunid identical on each PC)
for tgid1=1 to gunmax
 for tgid2=1 to gunmax
  if tgid1<>tgid2
   tname1$=lower$(gun(tgid1).name$)
   tname2$=lower$(gun(tgid2).name$)
   if tname1$>tname2$
    rem smallest at top
    gun(tgid1).name$=tname2$
    gun(tgid2).name$=tname1$
   endif
  endif
 next tgid2
next tgid1

return




rem
rem Lighting Routines
rem

`
` General Visual Settings
`

_lighting_init:
 `
 rem Set approporiate ambience (X10 not FPI controlled)
 guivisualsettings.ambience=10
 hudambiencered=255
 hudambiencegreen=255
 hudambienceblue=255
 color ambient light rgb(hudambiencered,hudambiencegreen,hudambienceblue) 
 `
 rem Lighting defaults
 guivisualsettings.shadows=1
 guivisualsettings.shadowstrength=128
 guivisualsettings.shadowshades=1
 guivisualsettings.dynamiclightcount=0
 guivisualsettings.updateflag=1
 `
 rem Initialize lighting objects
 if gdynamiclightingstate=1
  gosub _lighting_setupdynamiclights
  if gshowdebugtextingamestate=1
   activatedynamiclightsdebug=1
  else
   activatedynamiclightsdebug=0
  endif
 endif
 `
 rem Hero Light (used for source point for shadows and effects)
 set point light 0,20*100,25*100,-20*100
 color light 0,rgb(0,0,0)
 set light range 0,1
 hide light 0
 `
return

_lighting_postdefaults:

rem if no lights, set ambience to full
tokay=0
array index to top infinilight()
while array index valid(infinilight())
 if infinilight().islit=1
  tokay=1
 endif
 next array index infinilight()
 inc currentindex
endwhile
if tokay=0
 rem no lights, use full ambience (zero means no FPI aetting, go for defaults)
 guivisualsettings.ambience=75
 guivisualsettings.updateflag=1
 `x9if guseeffectonscenesstate=1
 ` guivisualsettings.ambience=25
 `else
 ` guivisualsettings.ambience=75
 `endif
endif
forceambientlightsetting=10

return

_lighting_ambientcontrol:

rem Irrespective of dynamic light setting
if inkey$()="," and guivisualsettings.ambience>0 then dec guivisualsettings.ambience : guivisualsettings.updateflag=1
if inkey$()="." and guivisualsettings.ambience<100 then inc guivisualsettings.ambience : guivisualsettings.updateflag=1

return

_lighting_control:
 `
 rem Direct keyboard control of adjustments
 tupdate=0
 if gdynamicshadowsstate=1
  if inkey$()="e" then guivisualsettings.shadows=0 : tupdate=1
  if inkey$()="r" then guivisualsettings.shadows=1 : tupdate=1
  if inkey$()="t" and guivisualsettings.shadowstrength>0 then dec guivisualsettings.shadowstrength : tupdate=1
  if inkey$()="y" and guivisualsettings.shadowstrength<255 then inc guivisualsettings.shadowstrength : tupdate=1
  if inkey$()="'" then guivisualsettings.shadowshades=1 : tupdate=1
  if inkey$()="#" then guivisualsettings.shadowshades=5 : tupdate=1
 endif
 if tupdate=1 then guivisualsettings.updateflag=1
 `
 rem Constantly handle spot lighting
 gosub _lighting_spotflash
 `
return

_lighting_controlupdate:
 `
 rem Automated update from force value
 if forceambientlightsetting>0 then guivisualsettings.updateflag=1 : dec forceambientlightsetting
 `
 rem Make adjustments to game settings
 if guivisualsettings.updateflag=1
  `
  rem make adjustments
  set ambient light guivisualsettings.ambience
  `
  rem x9 no shadows for now
  `if guivisualsettings.shadows=1
  ` set global shadows on
  `else
  ` set global shadows off
  `endif
  `set global shadow color 0,0,0,guivisualsettings.shadowstrength
  `set global shadow shades guivisualsettings.shadowshades
  `
  rem reset update flag
  guivisualsettings.updateflag=0
  `
 endif
 `
return

`
` Dynamic Light Handling
`

_lighting_setupdynamiclights:

rem Create dynamic hardware lights
if light exist(1)=1 then hide light 1
for lightindex=2 to 7
 if light exist(lightindex)=0
  make light lightindex
 endif
 color light lightindex,0,0,0
next lightindex

rem Hero Gun/Fire Light
if light exist(1)=0 then make light 1
if light exist(1)=1 then hide light 1

rem Reset dynamic light array
`x9activatedynamiclightscount=0
empty array infinilight(0)
testmarkerstart=50000
testmarker=testmarkerstart

return

_lighting_restore:

rem Delete all spare lights
for lightindex=1 to 7
 if light exist(lightindex)=1
  hide light lightindex
  delete light lightindex
 endif
next lightindex

rem Delete any test objects
for tobj=testmarkerstart to testmarker
 if object exist(tobj)=1 then delete object tobj
next tobj

rem Default directional light
color light 0,rgb(255,255,255)
set point light 0,20*100,25*100,-20*100
set light range 0,3000
show light 0

return


_lighting_adddynamiclight:

rem Add dynamic light
inc testmarker
`x9if lgtype=1 then inc activatedynamiclightscount
array insert at bottom infinilight()
infinilight().used=0
infinilight().type=lgtype
infinilight().x=lgx#
infinilight().y=lgy#
infinilight().z=lgz#
infinilight().colrgb.r=lgr#
infinilight().colrgb.g=lgg#
infinilight().colrgb.b=lgb#
infinilight().range=lgrange#
infinilight().id=testmarker
infinilight().islit=1
if activatedynamiclightsdebug=1
 make object sphere testmarker,20
 set object collision off testmarker
 position object testmarker,infinilight().x,infinilight().y,infinilight().z
 color object testmarker,rgb(infinilight().colrgb.r,infinilight().colrgb.g,infinilight().colrgb.b)
 set object diffuse testmarker,rgb(infinilight().colrgb.r,infinilight().colrgb.g,infinilight().colrgb.b)
 set object ambient testmarker,0
endif

rem return index for possible entity tie
infinilightindex=array count(infinilight())

return

_lighting_managedynamiclights:

rem Only if dynamic lights in scene
`x9if activatedynamiclightscount>0

rem Specify current location
mex#=camera position x(playercam)
mey#=camera position y(playercam)
mez#=camera position z(playercam)
mea#=camera angle y(playercam)

rem Fill list with six nearest lights
tnumlights=6
empty array infinilightshortlist(0)
worstoveralldist#=0
bestoveralldist#=999999
for l=1 to tnumlights
 if array count(infinilightshortlist(0))<tnumlights-1
  rem find nearest light
  currentindex=0
  bestdist#=999999 : bestindex=-1
  array index to top infinilight()
  while array index valid(infinilight())
   if activatedynamiclightsdebug=1
    if infinilight().id>0
     if object exist(infinilight().id)=1
      scale object infinilight().id,25,25,25
     endif
    endif
   endif
   `x9if infinilight().used=0 and infinilight().type=1
   if infinilight().used=0
    `
    rem And only those lights that are LIT
    if infinilight().islit=1
     `
     distx#=infinilight().x-mex#
     disty#=infinilight().y-mey#
     distz#=infinilight().z-mez#
     dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
     `tat#=atanfull(distx#,distz#)
     `if tat#<0 then tat#=tat#+360
     `tat#=abs(tat#-wrapvalue(mea#))
     `if tat#>180 then tat#=360-tat#
     tokay=0
     rem X10 range at which light is not considered (241007 doubled with graceful fade later using perc#)
     tdoublerange#=infinilight().range*2.0
     if dist#<tdoublerange# then tokay=1
     `x9if dist#<600.0 then tokay=1
     `if dist#>=600.0
     ` if tat#<90.0 then tokay=1
     `endif
     if tokay=1
      if dist#<bestdist#
       bestdist#=dist# : bestindex=currentindex
      endif
     endif
     `
    endif
    `
   endif
   next array index infinilight()
   inc currentindex
  endwhile
  if bestindex<>-1
   rem work out best and worst
   if bestdist#<bestoveralldist# then bestoveralldist#=bestdist#
   if bestdist#>worstoveralldist# then worstoveralldist#=bestdist#
   rem add to shortlist
   infinilight(bestindex).used=1
   infinilight(bestindex).dist=bestdist#
   array insert at bottom infinilightshortlist()
   infinilightshortlist()=bestindex
  endif
 endif
next l

rem X10 calculate average strongest light position
avlightcount#=0 : avlightposx#=0 : avlightposy#=0 : avlightposz#=0

rem Reveal lights in shortlist
lightindex=2
array index to top infinilightshortlist()
while array index valid(infinilightshortlist())
 `
 rem Place and configure light for this pass
 tindex=infinilightshortlist() : tobj=infinilight(tindex).id
 infinilight(tindex).used=0
 rem X10 - 241007 - lights are removed from render if plr outside TWICE their range,
 rem and we fade them in when the player enters the first half percent of their DOUBLE range
 distx#=infinilight(tindex).x-mex#
 disty#=infinilight(tindex).y-mey#
 distz#=infinilight(tindex).z-mez#
 dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
 thalfdoublerange#=infinilight(tindex).range
 perc#=1.0  : if dist#>thalfdoublerange# then perc#=1.0-((dist#-thalfdoublerange#)/thalfdoublerange#)
 set point light lightindex,infinilight(tindex).x,infinilight(tindex).y,infinilight(tindex).z
 color light lightindex,infinilight(tindex).colrgb.r*perc#,infinilight(tindex).colrgb.g*perc#,infinilight(tindex).colrgb.b*perc#
 set light range lightindex,infinilight(tindex).range
 rem X10 dynamic lights can miss out universe static polys
 set light static mode lightindex,infinilight(tindex).type
 next array index infinilightshortlist()
 show light lightindex
 `
 rem Show light as object if in debug mode
 distx#=infinilight(tindex).x-mex#
 disty#=infinilight(tindex).y-mey#
 distz#=infinilight(tindex).z-mez#
 if activatedynamiclightsdebug=1
  tat#=atanfull(distx#,distz#)
  if tat#<0 then tat#=tat#+360
  tat#=abs(tat#-wrapvalue(mea#))
  if tat#>180 then tat#=360-tat#
  if tobj>0
   if object exist(tobj)=1
    if object in screen(tobj)=1
     t$=strarr$(150)+str$(tindex)+strarr$(151)+str$(lightindex)+strarr$(152)+str$(int(tat#))
     center text object screen x(tobj),object screen y(tobj),t$
    endif
   endif
  endif
 endif
 `
 rem X10 average string light position
 dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
 tperc#=1.0-(dist#/infinilight(tindex).range+0.0001)
 tstrengthofthislighttoplayer#=100*tperc#
 if tstrengthofthislighttoplayer#>0
  inc avlightposx#,infinilight(tindex).x*tstrengthofthislighttoplayer#
  inc avlightposy#,infinilight(tindex).y*tstrengthofthislighttoplayer#
  inc avlightposz#,infinilight(tindex).z*tstrengthofthislighttoplayer#
  inc avlightcount#,tstrengthofthislighttoplayer#
 endif
 `
 rem Next light
 inc lightindex
 `
endwhile

rem Then Hide The Rest of the lights
while lightindex<=7
 if light exist(lightindex)=1
  hide light lightindex
 endif
 inc lightindex
endwhile

rem X10 finalise the average string light position
if avlightcount#>0
 avlightposx#=avlightposx#/avlightcount#
 avlightposy#=avlightposy#/avlightcount#
 avlightposz#=avlightposz#/avlightcount#
 set point light 0,avlightposx#,avlightposy#,avlightposz#
 show light 0
 `
 rem new shadow light position (higher for down casting)
 set shadow position -1,avlightposx#,avlightposy#+500,avlightposz#
 `
else
 `
 rem 210807 - if no lights, shadow comes from high above
 set shadow position -1,mex#,2500,mez#
 `
endif

rem can skip if ZERO dynamic lights anywhere
`x9endif

return

_lighting_managegloballightingreciever:

rem Optimisation Table for quick-re-reference of a particular grid location
recx=recx#/25
recy=recy#/100
recz=recz#/-25
if recx<0 then recx=0
if recy<0 then recy=0
if recz<0 then recz=0
if recx>viscolx then recx=viscolx
if recy>viscoly then recy=viscoly
if recz>viscolz then recz=viscolz
`if lighttable(recx,recy,recz).x>0
if lighttable(recx,recy,recz).x>0 and 0
 `
 rem Return quick info from pre-calculated table
 avlightposx#=lighttable(recx,recy,recz).x
 avlightposy#=lighttable(recx,recy,recz).y
 avlightposz#=lighttable(recx,recy,recz).z
 avlightcolr#=lighttable(recx,recy,recz).r
 avlightcolg#=lighttable(recx,recy,recz).g
 avlightcolb#=lighttable(recx,recy,recz).b
 `
else
 `
 rem Reset ready to store strongest point
 avlightposx#=0 : avlightposy#=0 : avlightposz#=0
 avlightcolr#=0 : avlightcolg#=0 : avlightcolb#=0
 tlightinfluencedbydynamiclight=0
 avlightrange#=0
 `
 rem Go through ALL scene lights
 titer=0 : tqty=0
 closestdist#=99999
 array index to top infinilight()
 while array index valid(infinilight())
  `
  rem Collect position of light
  ldistx#=infinilight().x-recx#
  ldisty#=infinilight().y-recy#
  ldistz#=infinilight().z-recz#
  ldist#=sqrt(abs(ldistx#*ldistx#)+abs(ldisty#*ldisty#)+abs(ldistz#*ldistz#))
  `
  rem for all lights within range
  if ldist#<infinilight().range and infinilight().islit=1
   `
   rem Relatve to overall distance (influence)
   tlightpower#=cos((ldist#/infinilight().range)*90)
   `
   rem Count visible illuminations
   avlightposx#=avlightposx#+infinilight().x
   avlightposy#=avlightposy#+infinilight().y
   avlightposz#=avlightposz#+infinilight().z
   avlightcolr#=avlightcolr#+(infinilight().colrgb.r*tlightpower#)
   avlightcolg#=avlightcolg#+(infinilight().colrgb.g*tlightpower#)
   avlightcolb#=avlightcolb#+(infinilight().colrgb.b*tlightpower#)
   avlightrange#=avlightrange#+(ldist#*tlightpower#)
   inc tqty
   `
   rem check for dynamic type
   if infinilight().type=1
    tlightinfluencedbydynamiclight=1
   endif
   `
  endif
  `
  next array index infinilight()
  `
 endwhile
 `
 rem Center to player for correct averaged single light position
 avlightposx#=avlightposx#/tqty
 avlightposy#=avlightposy#/tqty
 avlightposz#=avlightposz#/tqty
 `
 rem get correct average light color
 avlightcolr#=avlightcolr#/tqty
 avlightcolg#=avlightcolg#/tqty
 avlightcolb#=avlightcolb#/tqty
 `
 rem FPSCV104RC8 - ensure colours not maxed
 if avlightcolr#>255 then avlightcolr#=255
 if avlightcolg#>255 then avlightcolg#=255
 if avlightcolb#>255 then avlightcolb#=255
 `
 rem Record info in light table
 lighttable(recx,recy,recz).x=avlightposx#
 lighttable(recx,recy,recz).y=avlightposy#
 lighttable(recx,recy,recz).z=avlightposz#
 lighttable(recx,recy,recz).r=avlightcolr#
 lighttable(recx,recy,recz).g=avlightcolg#
 lighttable(recx,recy,recz).b=avlightcolb#
 `
 rem if ANY of the light is dynamically generated, cannot keep quick-ref as it might change
 if tlightinfluencedbydynamiclight=1
  lighttable(recx,recy,recz).x=0
 endif
 `
endif

return

_lighting_managegloballighting:
 `
 recx#=mex# : recy#=mey# : recz#=mez#
 gosub _lighting_managegloballightingreciever
 `
return

_lighting_applyplayerlighting:

rem Display test objects to show key markers
if activatedynamiclightsdebug=1
 tobj=49998 : if object exist(tobj)=0 then make object cone tobj,25 : xrotate object tobj,180
 set object collision off tobj
 position object tobj,avlightposx#,avlightposy#+20,avlightposz#
 if object in screen(tobj)=1
  center text object screen x(tobj),object screen y(tobj)-20,strarr$(153)
 endif
` if gdynamicshadowsstate=1
`  tsli=1
`  if array count(shadowlight())>=tsli
`   tobj=49999 : if object exist(tobj)=0 then make object cube tobj,25
`   set object collision off tobj
`   position object tobj,shadowlight(tsli).x#,shadowlight(tsli).y#,shadowlight(tsli).z#
`   if object in screen(tobj)=1
`    center text object screen x(tobj),object screen y(tobj)-20,strarr$(154)
`   endif
`  endif
` endif
endif

rem Apply averaged colour to player (avlightcolX#)
gosub _lighting_applyplayercolor

rem Shadow light controlled by most prominant light zero
`if gdynamicshadowsstate=1
` scene shadows disabled for V1.0
` for tsli=1 to array count(shadowlight())
`  set shadow light tsli,shadowlight(tsli).x#,shadowlight(tsli).y#,shadowlight(tsli).z#,shadowlight(tsli).range#
` next tsli
`endif

return

_lighting_applyplayercolor:
 `
 rem Apply player average colour to gun
 if gunid>0 then teffectid=gun(gunid).effectidused else teffectid=0
 if teffectid>0
  rem apply shader values
  r=make vector4(1)
  set vector4 1,avlightposx#,avlightposy#,avlightposz#,1.0
  set effect constant vector teffectid,"LightSource",1
  set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
  set effect constant vector teffectid,"SurfColor",1
  tamb#=guivisualsettings.ambience/100.0 : set vector4 1,tamb#,tamb#,tamb#,1.0
  set effect constant vector teffectid,"AmbiColor",1
  r=delete vector4(1)
 else
  rem illumonate player without shader
  if currentgunobj>0
   tcurrentguncolr=avlightcolr# : tcurrentguncolg=avlightcolg# : tcurrentguncolb=avlightcolb#
   if tcurrentguncolr<>currentguncolr or tcurrentguncolg<>currentguncolg or tcurrentguncolb<>currentguncolb
    currentguncolr=tcurrentguncolr : currentguncolg=tcurrentguncolg : currentguncolb=tcurrentguncolb
    set object emissive currentgunobj,rgb(avlightcolr#,avlightcolg#,avlightcolb#)
   endif
  endif
 endif
 `
return

_lighting_applyentitycolor:
 `
 rem Position of entity to calc light for
 recx#=entityelement(e).x
 recy#=entityelement(e).y
 recz#=entityelement(e).z
 `
 rem Optimise by only calculating light of entity shifts position
 tcurrentcolx=recx#/25
 tcurrentcoly=recy#/25
 tcurrentcolz=recz#/25
 if tcurrentcolx<>entityelement(e).colr or tcurrentcoly<>entityelement(e).colg or tcurrentcolz<>entityelement(e).colb
  `
  rem Record new color-light-calc position
  entityelement(e).colr=tcurrentcolx : entityelement(e).colg=tcurrentcoly : entityelement(e).colb=tcurrentcolz
  `
  rem calculate light from base position
  gosub _lighting_managegloballightingreciever
  `
  rem Apply average colour
  teffectid=entityelement(e).eleprof.usingeffect
  if teffectid>0
   rem apply shader values
   r=make vector4(1)
   set vector4 1,avlightposx#,avlightposy#,avlightposz#,1.0
   set effect constant vector teffectid,"LightSource",1
   set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
   set effect constant vector teffectid,"LightColor",1
   set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
   set effect constant vector teffectid,"SurfColor",1
   tamb#=guivisualsettings.ambience/100.0 : set vector4 1,tamb#,tamb#,tamb#,1.0
   set effect constant vector teffectid,"AmbiColor",1
   r=delete vector4(1)
  else
   rem no shader color for diffuse entities
   if activatedynamiclightsdebug=1 then entitydebug$(e)=str$(int(avlightcolr#))+","+str$(int(avlightcolg#))+","+str$(int(avlightcolb#))
   if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
    set object emissive entityelement(e).obj,rgb(255,255,255)
   else
    set object emissive entityelement(e).obj,rgb(avlightcolr#/2,avlightcolg#/2,avlightcolb#/2)
   endif
  endif
  `
 endif
 `
return

_lighting_applytoscene:

rem Set light zero for dynamic shadows of objects that cast them
`if gdynamicshadowsstate=1
` the old system for scene shadows, leave for next version
` disabled scene shadow for V1.0
` if array count(shadowlight(0))>0
` set global shadow color 0,0,0,128
`  tsli=1 : set point light 0,shadowlight(tsli).x#, shadowlight(tsli).y#, shadowlight(tsli).z#
`  shadowlight(tsli).range#
` endif
`endif

rem Constantly update hero light (for shadows and effects)
`set point light 0,camera position x(),camera position y(),camera position z()
rem for V1 need a way to handle this singular-light issue with SHADERS
rem for the physics tests, a fixed light zero for the shadows
rem ultimate problem solver for shadow distance is a Sun-Style Light
`ODE physics controls shadow light now
`set point light 0,-1500,3000,1500

rem Scene can have effects in play (which require general parameters passed in)
tamb#=guivisualsettings.ambience/100.0
r=make vector4(1)
for tef=1 to effectbankmax
 teffectid=effectbankoffset+tef
 set vector4 1,avlightcolr#/255.0,avlightcolg#/255.0,avlightcolb#/255.0,1.0
 set effect constant vector teffectid,"LightColor",1
 set vector4 1,tamb#,tamb#,tamb#,1.0
 set effect constant vector teffectid,"AmbiColor",1
next tef
r=delete vector4(1)

return

_lighting_spotflash:
 `
 rem Blunderbus mode (for large explosions)
 if spotflashbang>0
  dec spotflashbang
  spotflash=100
  spotmultiplier#=5.0
  tx#=spotflashbangx
  ty#=spotflashbangy
  tz#=spotflashbangz
  `X10 - 231007 - too yellow in screenshots tcolr=255 : tcolg=192 : tcolb=32
  tcolr=64 : tcolg=48 : tcolb=8
 else
  if spotmultiplier#=5.0 and spotflash=100 then spotflash=0
 endif
 `
 rem If flash, and NO other lights, do not move default global light (weird effect)
 if array count(infinilight())<0 and spotflash>0 then spotflash=0
 `
 rem Control spot flash
 if spotflash=100
  spotflash=99 : spotflashx#=tx# : spotflashy#=ty# : spotflashz#=tz#
  if light exist(1)=1
   set point light 1,spotflashx#,spotflashy#,spotflashz# : set light range 1,1000
   spotlightr#=tcolr : spotlightg#=tcolg : spotlightb#=tcolb
   color light 1,spotlightr#,spotlightg#,spotlightb#
   lastflashspeedtime=timer()
   show light 1
  endif
 endif
 if spotflash>0 and spotflash<100
  flashspeed#=(1.0/40.0)*(timer()-lastflashspeedtime) : lastflashspeedtime=timer()
  tfadetimer=20-(spotmultiplier#*3)
  dec spotflash,tfadetimer*flashspeed#
  if spotflash>0
   if light exist(1)=1
    spotfadeout#=spotflash/100.0
    spotfadeout#=spotfadeout#*spotmultiplier#
    color light 1,spotlightr#*spotfadeout#,spotlightg#*spotfadeout#,spotlightb#*spotfadeout#
   endif
  else
   spotflash=0 : spotmultiplier#=1.0
   if light exist(1)=1
    set point light 1,20*100,25*100,-20*100
    hide light 1
   endif
  endif
 endif
 `
return


rem
rem ENTITY
rem

_entity_validatearraysize:
 `
 rem ensure enough space in entity profile arrays
 if entidmaster+32>entidmastermax
  entidmastermax=entidmaster+32
  dim entitybodypart(entidmastermax,100) as integer
  dim entityanim(entidmastermax,animmax) as entityanimtype
  dim entityprofileheader(entidmastermax) as entityprofileheadertype
  dim entityprofile(entidmastermax) as entityprofiletype
  dim entitydecal$(entidmastermax,100) as string
  dim entitydecal(entidmastermax,100) as integer
  entitybankmax=entidmastermax
  dim entitybank$(entitybankmax)
 endif
 `
return

_entity_savebank:

rem FPSCV104RC6 - scan entire entityelement, delete all entitybank entries not used
if entidmaster>0
 dim entitybankused(entidmaster)
 for tttentid=1 to entidmaster
  entitybankused(tttentid)=0
 next tttentid
 for ttte=1 to entityelementlist
  tttentid=entityelement(ttte).bankindex
  if tttentid>0
   entitybankused(tttentid)=1
  endif
 next ttte
 for tttentid=1 to entidmaster
  if entitybankused(tttentid)=0
   rem remove entity entry if not used when save FPM
   entitybank$(tttentid)=""
  endif
 next tttentid
 rem shuffle to remove empty entries
 for tttentid=1 to entidmaster
  rem not used to record where entities have been moved to
  entitybankused(tttentid)=0
 next tttentid
 treadentid=1 : tlargest=0
 for tttentid=1 to entidmaster
  if treadentid<=entidmaster
   while entitybank$(treadentid)=""
    inc treadentid : if treadentid>entidmaster then exit
   endwhile
   if treadentid<=entidmaster
    entitybank$(tttentid)=entitybank$(treadentid)
    entityprofileheader(tttentid)=entityprofileheader(treadentid)
    entityprofile(tttentid)=entityprofile(treadentid)
    for tt=0 to 100 : entitybodypart(tttentid,tt)=entitybodypart(treadentid,tt) : next tt
    for tt=0 to animmax : entityanim(tttentid,tt)=entityanim(treadentid,tt) : next tt
    for tt=0 to 100 : entitydecal$(tttentid,tt)=entitydecal$(treadentid,tt) : next tt
    for tt=0 to 100 : entitydecal(tttentid,tt)=entitydecal(treadentid,tt) : next tt
    entitybankused(treadentid)=tttentid
    tlargest=tttentid
   else
    entitybank$(tttentid)=""
   endif
  else
   entitybank$(tttentid)=""
  endif
  inc treadentid
 next tttentid
 rem new list size
 if entidmaster<>tlargest
  entidmaster=tlargest
  entityorsegmententrieschanged=1
 endif
 rem update bank index numbers in entityelements
 for ttte=1 to entityelementlist
  tttentid=entityelement(ttte).bankindex
  if tttentid>0
   rem new entity entry place index
   entityelement(ttte).bankindex=entitybankused(tttentid)
  endif
 next ttte
 undim entitybankused()
endif

rem Save segment bank
if file exist(myownrootdir$+"mapbank\testmap\map.ent")=1 then delete file myownrootdir$+"mapbank\testmap\map.ent"
open to write 1,myownrootdir$+"mapbank\testmap\map.ent"
 write file 1,entidmaster
 if entidmaster>0
  for entid=1 to entidmaster
   write string 1,entitybank$(entid)
  next entid
 endif
close file 1

return

_entity_deletebank:

rem Destroy old entities
if entidmastermax>0
 rem V104RC6 changed from entidmaster
 for entid=1 to entidmastermax
  entobj=entitybankoffset+entid
  if object exist(entobj)=1 then delete object entobj
  entitybank$(entid)=""
 next entid
endif

rem Destroy profile data
undim entityprofile()
dim entityprofile(100) as entityprofiletype
entidmastermax=100
entidmaster=0

return

_entity_loadbank:

rem If ent file exists
filename$=levelmapptah$+"map.ent"
if file exist(filename$)=1
 `
 rem Destroy old entities
 gosub _entity_deletebank
 `
 rem Load entity bank
 open to read 1,levelmapptah$+"map.ent"
  read file 1,entidmaster
  if entidmaster>0
   gosub _entity_validatearraysize
   for entid=1 to entidmaster
    read string 1,entitybank$(entid)
   next entid
  endif
 close file 1
 `
 rem Load in all entity objects and data
 gosub _entity_loadentitiesnow
 `
rem No file
endif

return

_entity_loadentitiesnow:

rem Load images in support of entityprofles (for shadow blob and order icons for entities)
loadinternalimageexcompress("gamecore\decals\blob\blob.dds",attachmenticonimagestart+0,5)
loadinternalimageexcompress("gamecore\decals\teamfollow\decal.dds",attachmenticonimagestart+1,5)
loadinternalimageexcompress("gamecore\decals\teamgo\decal.dds",attachmenticonimagestart+2,5)
loadinternalimageexcompress("gamecore\decals\teamhold\decal.dds",attachmenticonimagestart+3,5)   
loadinternalimageexcompress("gamecore\decals\healthbar\healthbarbackground.png",attachmenticonimagestart+4,5)   
loadinternalimageexcompress("gamecore\decals\healthbar\healthbar.png",attachmenticonimagestart+5,5)   

rem Load glass normals for refraction patterns
dim glasstexarrslot(10)
for twindowglasstype=1 to 10
 ttexdir$="gamecore\glasstypes\x10glass"+str$(twindowglasstype)+"_N.dds"
 glasstexarrslot(twindowglasstype)=loadinternalimagecompressquality(ttexdir$,0,-1)
next twindowglasstype

rem Load entities specified by bank
entdir$="entitybank\"
if entidmaster>0
 for entid=1 to entidmaster
  ent$=entitybank$(entid)
  entpath$=getpath(ent$)
  gosub _entity_load
  if desc$=""
   rem where entities have been lost, delete from list
   entitybank$(entid)=""
  endif
 next entid
endif

rem X10 also load in global effect shader for ragdoll skinning (cannot use parent-slot shader)
if gskinningforagdolleffect=0
 gskinningforagdolleffect=loadinternaleffectunique("effectbank\skinning\skinning.fx",1)
endif
rem X10 global effect for all carried weapons (instance and non-instance)
if gsimpleinstancevweapeffect=0
 gsimpleinstancevweapeffect=loadinternaleffectunique("effectbank\simple\simple.fx",1)
endif
if gsimplevweapeffect=0
 gsimplevweapeffect=loadinternaleffectunique("effectbank\simple\simple.fx",1)
endif

return

_entity_updatebank:

rem If ent file exists
filename$=levelmapptah$+"map.ent"
if file exist(filename$)=1

rem Clear non-present entries
for entid=entidmaster+1 to entitybankmax
 entitybank$(entid)=""
next entid

rem Update entity bank
open to read 2,filename$
 read file 2,tvalmax
 if tvalmax>0
  for tvalindex=1 to tvalmax
   read string 2,tent$
   addentityfile$=tent$
   gosub _entity_adduniqueentity
  next tvalindex
 endif
close file 2

rem No file
endif

return

_entity_adduniqueentity:

rem Ensure 'entitybank\' is not part of entity filename
entdir$="entitybank\"
if lower$(left$(addentityfile$,11))="entitybank\"
 addentityfile$=right$(addentityfile$,len(addentityfile$)-11)
endif

rem Check if entity already loaded in
talreadyloaded=0
for t=1 to entidmaster
 if entitybank$(t)=addentityfile$ then talreadyloaded=1 : entid=t
next t
if talreadyloaded=0
 `
 rem Allocate one more entity item in array
 if entidmaster>entitybankmax-4
  dim tempentitybank$(entitybankmax)
  for t=0 to entitybankmax : tempentitybank$(t)=entitybank$(t) : next t
  inc entitybankmax
  undim entitybank$(0)
  dim entitybank$(entitybankmax)
  for t=0 to entitybankmax-1 : entitybank$(t)=tempentitybank$(t) : next t
 endif
 `
 rem Add entity to bank
 inc entidmaster : gosub _entity_validatearraysize
 entitybank$(entidmaster)=addentityfile$
 `
 rem Load extra entity
 entid=entidmaster
 ent$=entitybank$(entid)
 entpath$=getpath(ent$)
 gosub _entity_load
 `
endif

return

_entity_loadextra:

rem load if entity is unique (unloaded - uses addentityfile$)
gosub _entity_adduniqueentity

rem Allocate one more into entity element array too
if entityelementlist>entityelementmax-4
 dim tempentityelement(entityelementmax) as entitytype
 for t=0 to entityelementmax : tempentityelement(t)=entityelement(t) : next t
 undim entityelement()
 undim entitydebug$(0)
 inc entityelementmax
 dim entityelement(entityelementmax) as entitytype
 dim entitydebug$(entityelementmax)
 dim entityelementwhichslot(entityelementmax)
 dim entityelementusingode(entityelementmax)
 dim entityelementwhichobj(entityelementmax)
 dim entityelementtexarrayindex(entityelementmax)
 dim entityelementusingrefraction(entityelementmax)
 dim lastentityraycast(entityelementmax)
 dim lastentityraycast2#(entityelementmax)  
 dim lastentityshadowlength#(entityelementmax)
 for t=0 to entityelementmax-1 : entityelement(t)=tempentityelement(t) : next t
endif

rem Ensure we subtract the offset used by the entity(which would be part of the seg-info)
addentityx=addentityx-entityprofile(entid).offx
addentityz=addentityz-entityprofile(entid).offz
addentityy=addentityy-entityprofile(entid).offy

rem Add reference to entity as element
gosub _entity_addelement

return

_entity_addelement:
 `
 rem find spare
 for e=1 to entityelementlist
  if entityelement(e).bankindex=0 then exit
 next e
 if e>entityelementlist
  rem add new
  inc entityelementlist
  if entityelementlist>entityelementmax
   entityelementmax=entityelementlist
   dim entityelement(entityelementmax) as entitytype
   dim entitydebug$(entityelementmax)
   dim entityelementwhichslot(entityelementmax)
   dim entityelementusingode(entityelementmax)
   dim entityelementwhichobj(entityelementmax)   
   dim entityelementtexarrayindex(entityelementmax)
   dim entityelementusingrefraction(entityelementmax)
   dim lastentityraycast(entityelementmax)
   dim lastentityraycast2#(entityelementmax)  
   dim lastentityshadowlength#(entityelementmax)
  endif
  e=entityelementlist
 endif
 `
 rem create element entry data
 gosub _entity_fillelementfromprofile
 entityelement(e).editorfixed=0
 entityelement(e).maintype=1
 entityelement(e).bankindex=entid
 entityelement(e).x=addentityx+entityprofile(entid).offx
 entityelement(e).y=addentityy+entityprofile(entid).offy
 entityelement(e).z=addentityz+entityprofile(entid).offz
 entityelement(e).rx=addentityrx+entityprofile(entid).rotx
 entityelement(e).ry=addentityry+entityprofile(entid).roty
 entityelement(e).rz=addentityrz+entityprofile(entid).rotz
 `
return

_entity_loadtexturesandeffect:

rem If entity object not exist, reset var
if entobj>0
 if object exist(entobj)=0 then entobj=0
endif

rem Only characters need a higher quality texture, rest use divide standard settings
tfullorhalfdivide=0
if segobjusedformapeditor=0
 if entityprofile(entid).ischaracter=1
  tfullorhalfdivide=2
 else
  if entityprofile(entid).reducetexture<>0
   if entityprofile(entid).reducetexture=-1
    tfullorhalfdivide=1
   else
    tfullorhalfdivide=2
   endif
  endif
 endif
endif
`
rem Apply TEXTURE to entity object
tcanceltheeffect=0
tuseeffecttexture=0
tfile$=entityprofile(entid).texd$
tfilealt$=entityprofile(entid).texaltd$
if tfile$<>""
 `
 rem optional texture path for getting at any texture (gamecore gun textures, etc)
 if entityprofile(entid).texpath$<>""
  texdir$=entityprofile(entid).texpath$+tfile$
  texaltdir$=entityprofile(entid).texpath$+tfilealt$
 else
  texdir$=entdir$+entpath$+tfile$
  texaltdir$=entdir$+entpath$+tfilealt$
 endif
 if entityprofile(entid).transparency=0
  texuseid=loadinternaltextureex(texdir$,1,tfullorhalfdivide)
 else
  texuseid=loadinternaltextureex(texdir$,5,tfullorhalfdivide)
 endif
 if texuseid=0
  rem if not local texture, look in texture bank
  texdir$=entityprofile(entid).texd$
  texaltdir$=entityprofile(entid).texaltd$
 endif
 `
 rem X10 new texture system
 usetexturearrayforentity=0
 if entityprofile(entid).transparency=0
  texid=loadinternalimagecompressquality(texdir$,1,tfullorhalfdivide)
 else
  texid=loadinternalimagecompressquality(texdir$,5,tfullorhalfdivide)
 endif
 entityprofile(entid).texdid=texid
 if entobj>0
  ttexturenameD2orD=5 : rem X10 texture arrays can only be _1_D.TGA (not D2)
  ttexdir$=left$(texdir$,len(texdir$)-8)+"_1_N.dds"
  if file exist(ttexdir$)=1
   rem Texture Array pre-loads all five alternatives in a new texture-array-resource
   entityprofile(entid).texdid=1
   usetexturearrayforentity=2
  else
   ttexturenameD2orD=6
   ttexdir$=left$(texdir$,len(texdir$)-5)+"N.dds"
   if file exist(ttexdir$)=1
    rem ogre_D.TGA
    ttexturenameD2orD=5
   else
    ttexdir$=left$(texdir$,len(texdir$)-6)+"N.dds"
    if file exist(ttexdir$)=1
     rem ogre_D2.TGA
     ttexturenameD2orD=6
    else
     ttexdir$=left$(texdir$,len(texdir$)-7)+"N.dds"
     if file exist(ttexdir$)=1
      rem ai_1_D.TGA (but ai_N.TGA normal)
      ttexturenameD2orD=7
     else
      ttexdir$=left$(texdir$,len(texdir$)-8)+"N.dds"
      if file exist(ttexdir$)=1
       rem ai_1_D2.TGA (but ai_N.TGA normal)
       ttexturenameD2orD=8
      else
       rem X10 - 221007 - custom texture can be located in MYDOC folder
       rem so we need also to check for _N and _S next to a MYDOC based texture
       rem (for example assets\newtex_N and newtex_S) DDS BMP and JPG supported
       storetexdir$=texdir$
       texdir$=myownrootdir$+"\"+texdir$
       ttexdir$=left$(texdir$,len(texdir$)-5)+"N.dds"
       if file exist(ttexdir$)=1
        ttexturenameD2orD=5
       else
        ttexdir$=left$(texdir$,len(texdir$)-5)+"N.bmp"
        if file exist(ttexdir$)=1
         ttexturenameD2orD=5
        else
         ttexdir$=left$(texdir$,len(texdir$)-5)+"N.jpg"
         if file exist(ttexdir$)=1
          ttexturenameD2orD=5
         else
          rem X10 - 251007 - if not found in MYDOC, must restore original texdir or switches mess up
          texdir$=storetexdir$
         endif
        endif
       endif
      endif    
     endif    
    endif
   endif
  endif
  rem use N+S, just plane D?
  ttexdir$=left$(texdir$,len(texdir$)-ttexturenameD2orD)+"N.dds"
  if file exist(ttexdir$)=1
   rem using N and S textures for entity
   rem Base texture
   texture object entobj,0,texid
   rem texture array or not
   if usetexturearrayforentity=2
    rem texture arrays for all three D N and S
    entityprofile(entid).tex1id=0
    entityprofile(entid).tex2id=0
   else
    rem X10 - 121007 - static entities require D D S N layout of texture
    if configureobj<>0 : rem flag set in universe construction
     rem light map takes zero, 1-diffuse/alpha, 2-specular/illum, 3-normal/height
     ttexdir$=left$(texdir$,len(texdir$)-ttexturenameD2orD)+"D.dds"
     entityprofile(entid).tex1id=loadinternalimagecompressquality(ttexdir$,1,tfullorhalfdivide)
     texture object entobj,1,entityprofile(entid).tex1id
     ttexdir$=left$(texdir$,len(texdir$)-ttexturenameD2orD)+"S.dds"
     entityprofile(entid).tex2id=loadinternalimagecompressquality(ttexdir$,1,tfullorhalfdivide)
     texture object entobj,2,entityprofile(entid).tex2id
     ttexdir$=left$(texdir$,len(texdir$)-ttexturenameD2orD)+"N.dds"
     entityprofile(entid).tex3id=loadinternalimagecompressquality(ttexdir$,1,tfullorhalfdivide)
     texture object entobj,3,entityprofile(entid).tex3id
    else
     rem texture N and S if not using texture array
     ttexdir$=left$(texdir$,len(texdir$)-ttexturenameD2orD)+"N.dds"
     entityprofile(entid).tex1id=loadinternalimagecompressquality(ttexdir$,1,tfullorhalfdivide)
     texture object entobj,1,entityprofile(entid).tex1id
     ttexdir$=left$(texdir$,len(texdir$)-ttexturenameD2orD)+"S.dds"
     entityprofile(entid).tex2id=loadinternalimagecompressquality(ttexdir$,1,tfullorhalfdivide)
     texture object entobj,2,entityprofile(entid).tex2id
    endif
   endif
  else
   rem not using N and S by default
   rem X10 check if a window shader, if so, we use special normalmap and camera source
   if right$(lower$(entityprofile(entid).effect$),10)="cubeent.fx"
    rem use D + N + REFR
    texture object entobj,0,texid
    debugviewtext(175,entityprofile(entid).model$+" C")
    if goriginalglassobject=0
     set texture array entobj,1,glasstexarrslot(1),glasstexarrslot(2),glasstexarrslot(3),glasstexarrslot(4),glasstexarrslot(5),glasstexarrslot(6),glasstexarrslot(7),glasstexarrslot(8),glasstexarrslot(9),glasstexarrslot(10)
     goriginalglassobject=entobj
    else
     set texture array entobj,1,goriginalglassobject,1
    endif 
    debugviewtext(175,entityprofile(entid).model$+" D")
    texture object entobj,2,texid : rem overridden by IMAGE 8 later on
   else
    rem use use D on its own
    `texture object entobj,texid
    rem X10 - V109 - 120309 - but still uses shader D+N+S, so load defaults
    texture object entobj,0,texid
    ttexdir$="texturebank\common\defaultnormals.dds"
    if gdefaultnormalmap=0 then gdefaultnormalmap=loadinternalimagecompressquality(ttexdir$,1,tfullorhalfdivide)
    texture object entobj,1,gdefaultnormalmap
    ttexdir$="texturebank\common\defaultspecular.dds"
    if gdefaultspecularmap=0 then gdefaultspecularmap=loadinternalimagecompressquality(ttexdir$,1,tfullorhalfdivide)
    texture object entobj,2,gdefaultspecularmap
   endif
  endif
 endif 
 `
 rem Load ALT texture if available
 if len(texaltdir$)>3
  texaltdid=loadinternalimagecompressquality(texaltdir$,1,tfullorhalfdivide)
  entityprofile(entid).texaltdid=texaltdid
 else
  entityprofile(entid).texaltdid=0
 endif
 `
else
 `
 rem FPSCV101 - add texturenames from file into filecollection (or exes will not find them)
 if entobj>0
  limbtexturename$=findmaterialtexturesinmodelfile(entdir$+entpath$+entityprofile(entid).model$,entdir$+entpath$)
 endif
 `
endif
`
rem Only if entity is a character can we prepare shaders this soon
rem 250607 - too soon for non-instance status to be determined, so
rem we call this later now in createelements
if entityprofile(entid).ischaracter=1
 rem by default, treat as instance effects so we can instance
 rem properly, but if later 'characterinstancingmode' proves to be zero
 rem we can create the characters as regular clones and skinning
 entityprofile(entid).characterinstancingmode=1
 gosub _entity_setparententityshaders
endif
`
rem X10 store texture array usage
entityprofile(entid).usetexturearrayforentity=usetexturearrayforentity
`
rem X10 if entity uses 'alternate texture' use a texture array pair 
if entityprofile(entid).texaltdid>0 and usetexturearrayforentity=0
 `
 rem texture Array Pair - light switches and toggling entities
 if entobj>0
  rem NOTE: important, textures must be loaded with the -1 so they can be read (used to create texture array)
  texarrslot1=loadinternalimagecompressquality(texdir$,0,-1)
  texarrslot2=loadinternalimagecompressquality(texaltdir$,0,-1)
  set texture array entobj,0,texarrslot1,texarrslot2,0,0,0,0,0,0,0,0
  texture object entobj,0,0 : rem default to first in array
  if texarrslot1>0 then imagebank$(texarrslot1-imagebankoffset)="" : delete image texarrslot1
  if texarrslot2>0 then imagebank$(texarrslot2-imagebankoffset)="" : delete image texarrslot2
 endif
 `
else
 `
 rem X10 Texture Array pre-loads all five alternatives in a new texture-array-resource
 if usetexturearrayforentity>0
  `
  rem Do this for D, N and S (if flagged as all texture arrays, otherwise just D)
  if usetexturearrayforentity=2 then tsmax=2 else tsmax=0
  for s=0 to tsmax
   `
   rem DNS
   if s=0 then s$="D"
   if s=1 then s$="N"
   if s=2 then s$="S"
   `
   rem load temp images
   ttexdir$=left$(texdir$,len(texdir$)-7)+"1_"+s$+".dds"
   texarrslot1=loadinternalimagecompressquality(ttexdir$,0,-1)
   ttexdir$=left$(texdir$,len(texdir$)-7)+"2_"+s$+".dds"
   texarrslot2=loadinternalimagecompressquality(ttexdir$,0,-1)
   ttexdir$=left$(texdir$,len(texdir$)-7)+"3_"+s$+".dds"
   texarrslot3=loadinternalimagecompressquality(ttexdir$,0,-1)
   ttexdir$=left$(texdir$,len(texdir$)-7)+"4_"+s$+".dds"
   texarrslot4=loadinternalimagecompressquality(ttexdir$,0,-1)
   ttexdir$=left$(texdir$,len(texdir$)-7)+"5_"+s$+".dds"
   texarrslot5=loadinternalimagecompressquality(ttexdir$,0,-1)
   `
   rem make texture array
   if texarrslot5>0
    set texture array entobj,s,texarrslot1,texarrslot2,texarrslot3,texarrslot4,texarrslot5,0,0,0,0,0
    texture object entobj,s,0 : rem default to first in array
   endif
   `
   rem textures used to create array are temporary and can be deleted
   if texarrslot1>0 then imagebank$(texarrslot1-imagebankoffset)="" : delete image texarrslot1
   if texarrslot2>0 then imagebank$(texarrslot2-imagebankoffset)="" : delete image texarrslot2
   if texarrslot3>0 then imagebank$(texarrslot3-imagebankoffset)="" : delete image texarrslot3
   if texarrslot4>0 then imagebank$(texarrslot4-imagebankoffset)="" : delete image texarrslot4
   if texarrslot5>0 then imagebank$(texarrslot5-imagebankoffset)="" : delete image texarrslot5
   `
  next s
  `
 endif
 `
endif
`
rem Set any entity transparency
if entobj>0 then set object transparency entobj,entityprofile(entid).transparency
`
return

_entity_coreobjectsetup:
 `
 rem Prepare a master entity object
 rem called after loading or cloning a main object
 `
 rem until static bonemodel scales when not animaating, loop
 if entityprofile(coreentid).ischaracter=1
  loop object coreobj : stop object coreobj
 endif
 `
 rem Hide object away
 position object coreobj,100000,100000,100000
 `
 rem X10 V109 - 090309 - ensure scale is zero never
 if entityprofile(coreentid).scale=0 then entityprofile(coreentid).scale=100
 if entityprofile(coreentid).scale<30 then set object radius coreobj,0
 `
 rem X10 offset fro characters (there physics boxes must be above floor)
 if entityprofile(coreentid).ischaracter=1
  if gmultiplayergame=0 : rem 230907 arena chars sinking into floor
   `
   rem V109 - 060209 - account for the SCALE of characters (who float above floor when scale < 100)
   `if entityprofile(coreentid).scale<>0
   ` tlowercharactery#=(object size y(coreobj)/100.0)*(100.0-entityprofile(coreentid).scale)/2.0
   `else
   ` tlowercharactery#=0
   `endif
   `offset limb coreobj,0,0,((object size y(coreobj)/2)*-1)-tlowercharactery#,0
   offset limb coreobj,0,0,((object size y(coreobj,1)/2)*-1),0
   `
  endif
 endif
 `
 rem X10 set shadows for parent entity object
 rem which will be cloned so future cloning does not incur a tangent/shadow calculation (pauses gameplay)
 if entityprofile(coreentid).ischaracter=1
  if entityprofile(coreentid).ismarker=0
   rem only shadow none markers
   tobjshadowreach#=0 : set shadow shading on coreobj,-1,tobjshadowreach#,1
  endif
 else
  rem done later in seperate shader setup subroutine
  rem in call _entity_setparententityshaders
 endif
 `
return

_entity_load:

rem Entity Object Index
entobj=entitybankoffset+entid

rem debug info
mytimer=timer()

rem Load Entity profile data
gosub _entity_loaddata

rem Only load characters for entity-local-testing
desc$=entityprofileheader(entid).desc$
if scanforentitiescharactersonly=1
 if entityprofile(entid).ischaracter=0
  desc$=""
 endif
endif

rem Only if profile data exists
if desc$<>""
 `
 rem progress report as this is a slow phase
 debugviewtext(175,strarr$(136)+str$(entid)+"\"+str$(entidmaster)+" ("+entityprofile(entid).model$+")")
 `
 rem Load the model
 tfile$=entdir$+entpath$+entityprofile(entid).model$
 if lower$(right$(tfile$,2))=".x"
  tdbofile$=left$(tfile$,len(tfile$)-2)+".dbo"
  rem X10 - 261107 - remove last temp file from program files (DBO)
  tdbofile$=turnfilenameuserlocal(tdbofile$)
 else
  tdbofile$=""
 endif
 if tdbofile$<>"" and file exist(tdbofile$)=1 then tfile$=tdbofile$
 if file exist(tfile$)=0 then tfile$=entityprofile(entid).model$
 if file exist(tfile$)=1
  `
  rem if DBO version exists, use that (quicker)
  hardscalegeometrychange=0
  if file exist(tdbofile$)=1
   tfile$=tdbofile$
   tdbofile$=""
  else
   rem allowed to save DBO (once only)
   if entityprofile(entid).hardscalex>0
    rem when convert to DBO, use a hard scale to change the geometry before saving
    hardscalegeometrychange=1
   endif
  endif
  `
  rem X10 - 021207 - submit BINDBO file as relative (not absolute which filecollection ignores)
  `addfiletocollection(tfile$)
  if mid$(tfile$,2)=":"
   trelativeprofile$=right$(tfile$,len(tfile$)-len(myownrootdir$))
   addfiletocollection(trelativeprofile$)
  else
   addfiletocollection(tfile$)
  endif
  `
  rem X10 - 250308 - if a DBO is loaded that has no texture specified, there is no way to find
  rem the texture file from the BINFILES location, so we use a special case LOAD from the entity folder
  if len(entityprofile(entid).texd$)<3 and lower$(right$(tfile$,4))=".dbo"
   rem we will move to the entity folder so we can load the textures locally for the load
   if path exist(entdir$+entpath$)=0
    rem V110 - 080110 - if path does not exist (standalone), just load normally
    load object tfile$,entobj
   else
    rememberolddir$=get dir$()
    set dir entdir$+entpath$
    if file exist(tfile$)=0
     rem tfile must be relative, so use an absolute path to load it
     load object rememberolddir$+"\"+tfile$,entobj
    else
     rem assumed to be absolute path
     load object tfile$,entobj
    endif
    set dir rememberolddir$
   endif
  else
   rem default load object 
   load object tfile$,entobj
  endif
  `
  rem Load entity (compile does not need the dynamic objects)
  set object collision off entobj
  if object exist(entobj)=1
   `
   rem X10 - object only for main scene, refract scene and reflect scene (and shadow in shadow scene)
   set object mask entobj,%110010,%0100,%10
   `
   rem Save if DBO not exist for entity (for fast loading)
   if len(tdbofile$)>1
    `
    rem X10 - 161007 - hardscalegeometrychange
    if hardscalegeometrychange=1
     hardscalegeometrychange=0
     position object entobj,0,0,0
     scale object entobj,entityprofile(entid).hardscalex,entityprofile(entid).hardscaley,entityprofile(entid).hardscalez*10
     make mesh from object entobj,entobj
     delete object entobj
     make object entobj,entobj,0
     delete mesh entobj
    endif
    `
    rem Save the X file(obj) as DBO file (for subsequent loading)
    if 0
     rem X10 - 131107 - removed because a DBO saved in GAMEEXE will CRASH mapeditor,
     rem and if BUILD GAME right away, then load that level it will crash!!
     `save object tdbofile$,entobj : rem GAME EXE DOES NOT SAVE DBOS!!
    endif
    if file exist(tdbofile$)=1
     delete object entobj
     load object tdbofile$,entobj
     set object collision off entobj
    endif
    `
   endif
   `
   rem X10 create LOD variations if available (model.x > model_MED.x and model_LOW.x)
   rem and build them into the entity object (for later cloning)
   if 1 : rem allow any entity to have LOD - entityprofile(entid).ischaracter=1
    tspareobjectnumber=entityprofileslotclonestart : rem not used yet        
    rem X10 - 260907 - if using MED, remaining LOD should be LOW, LOW
    tlodmed$="med"
    tfile$=entdir$+entpath$+entityprofile(entid).model$
    if lower$(right$(entityprofile(entid).model$,6))="_med.x"
     tfile$=entdir$+entpath$+left$(entityprofile(entid).model$,len(entityprofile(entid).model$)-6)+".x"
     tlodmed$="low"
    endif
    rem Load LOD levels
    if lower$(right$(tfile$,2))=".x"
     rem first level of lod
     lodfile$=left$(tfile$,len(tfile$)-2)+"_"+tlodmed$+".dbo"
     rem X10 - 261107 - remove last temp file from program files (DBO)
     lodfile$=turnfilenameuserlocal(lodfile$)
     if file exist(lodfile$)=0 then lodfile$=left$(tfile$,len(tfile$)-2)+"_"+tlodmed$+".x"
     if file exist(lodfile$)=1
      load object lodfile$,tspareobjectnumber
      lodfile$=left$(tfile$,len(tfile$)-2)+"_"+tlodmed$+".dbo"
      rem X10 - 261107 - remove last temp file from program files (DBO)
      lodfile$=turnfilenameuserlocal(lodfile$)      
      if file exist(lodfile$)=0 then save object lodfile$,tspareobjectnumber
      add lod to object entobj,tspareobjectnumber,0,entityprofile(entid).ex.autolodmed
      delete object tspareobjectnumber
      addfiletocollection(lodfile$)
     endif
     rem second level of lod
     lodfile$=left$(tfile$,len(tfile$)-2)+"_low.dbo"
     rem X10 - 261107 - remove last temp file from program files (DBO)
     lodfile$=turnfilenameuserlocal(lodfile$)      
     if file exist(lodfile$)=0 then lodfile$=left$(tfile$,len(tfile$)-2)+"_low.x"
     if file exist(lodfile$)=1
      load object lodfile$,tspareobjectnumber
      lodfile$=left$(tfile$,len(tfile$)-2)+"_low.dbo"
      rem X10 - 261107 - remove last temp file from program files (DBO)
      lodfile$=turnfilenameuserlocal(lodfile$)      
      if file exist(lodfile$)=0 then save object lodfile$,tspareobjectnumber
      add lod to object entobj,tspareobjectnumber,1,entityprofile(entid).ex.autolodlow
      delete object tspareobjectnumber
      addfiletocollection(lodfile$)
     endif
    endif
   endif
   `
   rem Apply texture and effect to entity profile obj
   gosub _entity_loadtexturesandeffect
   `
   rem X10 parent applies any pivot
   if entityprofile(entid).fixnewy<>0
    rotate object entobj,0,entityprofile(entid).fixnewy,0
    fix object pivot entobj
   endif
   `
   rem Prepare a master entity object (scale,fixnewy,loop,pos,offsetlimb)
   coreobj=entobj : coreentid=entid : gosub _entity_coreobjectsetup
   `
   rem X10 entity profile clones (0-4)
   entityprofile(entid).slotcloneobj=0
   if entityprofile(entid).ischaracter=1
    rem entityprofile().slotcloneobj+0,1,2,3,4 = used as animation slots for instances
    rem LEE, make sure entityprofileslotclonestart is reset to entityprofileslotclonestartmaster each level!
    entityprofile(entid).slotcloneobj=entityprofileslotclonestart
    for o=0 to entityprofileslotclonequantity-1
     tscobj=entityprofile(entid).slotcloneobj+o
     clone object tscobj,entobj,1
     position object tscobj,10000,10000,10000
     gosub _slot_prepareclone
    next o
    inc entityprofileslotclonestart,entityprofileslotclonequantity
   endif
   `
   rem if entity has decals, find indexes to decals (which are already preloaded)
   entityprofile(entid).bloodscorch=0
   if entityprofile(entid).decalmax>0
    for tq=0 to entityprofile(entid).decalmax-1
     decal$=entitydecal$(entid,tq)
     if lower$(decal$)="blood"
      if bloodmode$="off"
       rem X10 - 101007 - if no blood, use another decal
       gosub _agerating_handleblood : rem decal$="kidblood" or nothing
      else 
       rem X10 - 251007 - only allow blood splat with real blood
       rem as kidblood looks quite gory when left on the walls!!
       entityprofile(entid).bloodscorch=1
      endif
     endif
     gosub _decal_find
     if decalid<0 then decalid=0
     entitydecal(entid,tq)=decalid
    next tq
   endif
   `
  endif
 else
  debugstring(right$(tfile$,70),strarr$(100))
 endif
 `
 rem Resolve default weapon gun ids
 if entityprofile(entid).isweapon$<>""
  findgun$=lower$(entityprofile(entid).isweapon$) : gosub _gun_findweaponindexbyname
  entityprofile(entid).isweapon=foundgunid
  if foundgunid>0 then gun(foundgunid).activeingame=1
 else
  entityprofile(entid).isweapon=0
 endif
 rem Finding hasweapon also in createlemenents (as eleprof may have changed the weapon!)
 if entityprofile(entid).hasweapon$<>""
  findgun$=lower$(entityprofile(entid).hasweapon$) : gosub _gun_findweaponindexbyname
  entityprofile(entid).hasweapon=foundgunid
  if foundgunid>0 and entityprofile(entid).isammo=0 then gun(foundgunid).activeingame=1
 else
  entityprofile(entid).hasweapon=0
 endif
 `
 rem see if we can find head automatically
 if entityprofile(entid).ischaracter=1
  if entityprofile(entid).headlimb=-1
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="bip01_head"
      entityprofile(entid).headlimb=tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif
  endif
  if entityprofile(entid).firespotlimb=-1
   if object exist(entobj)=1
    perform checklist for object limbs entobj
    for tc=1 to checklist quantity()
     if lower$(checklist string$(tc))="firespot"
      entityprofile(entid).firespotlimb=tc-1
      tc=checklist quantity()+1
     endif
    next tc
   endif
  endif
 endif
 `
 rem assign physics weight and friction (if not set)
 if entityprofile(entid).physics<>0
  tfriction=(object size x(entobj)*75)+(object size y(entobj)*75)+(object size z(entobj)*75)
  tweight=(object size x(entobj)*25)+(object size y(entobj)*25)+(object size z(entobj)*25)
  tweight=(tweight/50)*50 : tfriction=(tfriction/50)*50
  if tweight<200 then tweight=200
`  if entityprofile(entid).phyweight=0 then entityprofile(entid).phyweight=tweight
`  if entityprofile(entid).phyfriction=0 then entityprofile(entid).phyfriction=tfriction
  entityprofile(entid).phyweight=tweight
  entityprofile(entid).phyfriction=tfriction
 endif
 `
rem no profile exists endif
endif

rem debug info and timestamp list (if logging)
debugviewtext(-1,"Built "+ent$+" in "+str$(timer()-mytimer)+"ms")
timestampactivity(0,"Loaded "+str$(entid)+":"+ent$)

return

_entity_setupelementobject:

rem INSTANCE cannot have many of the old X9 variations
rem new system is required for this now

rem place entity at correct position and orientation
if object exist(obj)=1
 `
 rem V109 - 020209 - return scaling feature to X10
 tscale=entityprofile(entid).scale
 if tscale<>0 then scale object obj,tscale,tscale,tscale
 `
 `tscale=entityelement(e).eleprof.scale EA does not support SCALE value in eleprof!
 `tscale=entityprofile(entid).scale
`test if tscale<>0 then scale object obj,tscale,tscale,tscale
 `moved to parent entity creation
 `if entityprofile(entid).fixnewy<>0
 ` rotate object obj,0,entityprofile(entid).fixnewy,0
 ` fix object pivot obj
 `endif
 `
 position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
 rotate object obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
 `set object speed obj,125
 `
 rem setup lighting properties of entity
 `set object diffuse obj,rgb(128,128,128)
 `set object ambience obj,rgb(255,255,255)
 `set object emissive obj,0
 `set object specular obj,0
 `
 rem dynamic entity settings
 `if entityelement(e).staticflag=0
  `  
  remstart
  rem x9 - new x10 does not apply per element shaders (slow)
  rem Load and Apply ''unique'' FX effect
  if guseeffectonentitiesstate=1
   tfile$=entityelement(e).eleprof.effect$
   if tfile$<>""
    teffectid=loadinternaleffectunique(tfile$,1)
    entityelement(e).eleprof.usingeffect=teffectid
    entityelement(e).eleprof.uniqueelement=1
   endif
  else
   rem fastbone for quick speed test (if system supports Vertex Shader
   if entityprofile(entid).ischaracter=1
    tthisentobjshallbetextured=0
    if gignorefastbone=0
     if total object frames(obj)>1
      rem and MUST have animation to bone animate
      if object exist(obj)=1
       if get maximum vertex shader version()>=2.0
        teffectid=0
        teffectid=loadinternaleffectunique("effectbank\fastbone\fastbone.fx",1)
        if teffectid>0
         entityelement(e).eleprof.usingeffect=teffectid
         entityelement(e).eleprof.uniqueelement=1
         tthisentobjshallbetextured=1
        endif
       endif
      endif
     endif
    endif
    if tthisentobjshallbetextured=0
     rem this works, but if texture customised it gets wiped out I think (needs investigation)
     if entityelement(e).eleprof.texdid=0
      rem repair texture if not being uniquelement textured below
      entityelement(e).eleprof.texdid=entityprofile(entid).texdid
      texture object obj,entityelement(e).eleprof.texdid
     endif
    endif
   else
    rem when full shader mode not used (simple.fx)
    rem moved to profile obj
    `teffectid=loadinternaleffectunique("effectbank\simple\simple.fx",1)
    `if teffectid>0
    ` entityelement(e).eleprof.usingeffect=teffectid
    ` entityelement(e).eleprof.uniqueelement=1
    ` tthisentobjshallbetextured=1
    `endif 
    `rem replace texture (as we hacked in a LOAD)   
    `entityelement(e).eleprof.texdid=entityprofile(entid).texdid
    `texture object obj,entityelement(e).eleprof.texdid
    `rem should replace FULL SHADER EFFECT mode with
    `rem (a) for performance or (b) for visual quality
    `rem and remove flags like 'guseeffectonentitiesstate'
   endif
  endif
  remend
 `else
  rem if staic, universe needs this entity to be a shared FX (because the object will be deleted!)
  `x9 if guseeffectonentitiesstate=1
  ` if entityelement(e).eleprof.usingeffect>0
  `  entityelement(e).eleprof.uniqueelement=1
  `  for tstage=0 to entityelement(e).eleprof.texidmax
  `   if tstage=0 then texture object obj,tstage,entityelement(e).eleprof.texdid
  `   if tstage=1 then texture object obj,tstage,entityelement(e).eleprof.tex1id
  `   if tstage=2 then texture object obj,tstage,entityelement(e).eleprof.tex2id
  `   if tstage=3 then texture object obj,tstage,entityelement(e).eleprof.tex3id
  `   if tstage=4 then texture object obj,tstage,entityelement(e).eleprof.tex4id
  `  next tstage
  ` endif
  `endif
 `endif
 `
 rem If element unique, can take its own texture, effect and transparency
 `teletransparency=entityelement(e).eleprof.transparency
 `if entityelement(e).eleprof.uniqueelement=1
 ` teffectid=entityelement(e).eleprof.usingeffect
 ` if teffectid>0
 `  set object effect obj,teffectid
 ` else
 `  texture object obj,0,entityelement(e).eleprof.texdid
 ` endif
 `endif
 `
 rem Set entity element transparency also, so that it is placed correctly in render order
 `set object transparency obj,teletransparency
 `
 rem If transparent, no need to Z write
 `if teletransparency>0
 ` if teletransparency>=2
 `  disable object zwrite obj
 `  enable object zbias obj,0.0,-0.000001
 ` endif
 `endif
 `
 rem pre-use step for characters
 `if total object frames(obj)>0
 ` set object frame obj,0
 ` if entityprofile(entid).ischaracter=1
 `  if entityprofile(entid).animmax>=1
 `   teai=0 : if entityanim(entid,1).start>0 then teai=1
 `   tbaseframe=teai : gosub _entity_getactualframestart : tfstart=tactualframe
 `   tbaseframe=teai : gosub _entity_getactualframefinish : tffinish=tactualframe
 `   loop object obj,tfstart,tffinish
 `  else
 `   loop object obj : stop object obj
 `  endif
 ` endif
 `endif
 `
 rem weapon and ammo are none collidable
 if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
  entityelement(e).collisionactive=0
  set object collision off obj
 else
  set object collision on obj
 endif
 `
 rem do not allow player to stop at entity characters (so can run through them)
 if entityprofile(entid).ischaracter=1
  entityelement(e).collisionactive=0
  set object collision off obj
 endif
 `
endif

rem child spawns should remain invisible for now
if entityelement(e).spawn.leaderid>0
 if entityelement(e).spawn.leader=0
  if object exist(obj)=1
   entityelement(e).collisionactive=0
   set object collision off obj
   hide object obj
  endif
 endif
endif

rem makrers by default are hidden
if entityprofile(entid).ismarker>0
 if object exist(obj)=1
  entityelement(e).collisionactive=0
  set object collision off obj
  hide object obj
 endif
endif

return

_entity_createelementasobject:

rem preset entity data
entityelement(e).obj=obj

rem X10 - 031007 - moved from end of subroutine (need to give this clone a unique skinning shader or it will overwrite instanced skinning if put at end)
rem create a clone corpse here so we have smoother game in main loop
if entityelement(e).profileobj>0
 if object exist(entityelement(e).profileobj)=1
  if entityelement(e).staticflag=0 and entityprofile(entid).ischaracter=1
   preclonedcorpseobj=preclonedcorpseobjbase+e
   clone object preclonedcorpseobj,entitybankoffset+entid,2
   set object effect preclonedcorpseobj,gskinningforagdolleffect
   rem X10 - 251007 - ensure ragdoll corpses also use transparency (so render after sky)
   tmintransmode=entityprofile(entid).transparency
   if tmintransmode<2 then tmintransmode=2
   set object transparency preclonedcorpseobj,tmintransmode          
   rem do not attach clones-for-corpses to universe, as ragdolls have no universe position
   position object preclonedcorpseobj,0,0,0
   hide object preclonedcorpseobj
  endif
 endif
endif

rem X10 this will be set inside the entity properties (0-4 or random)
if loadsavedlevel$<>""
 rem X10 - 131007 - if in process of loading saved position, take texture array indez from there
 entityelementtexarrayindex(e)=saveloadgamepositionentity(e).texturearrayindex
else
 rem Generate texture array index a fresh
 if entityprofile(entid).ischaracter=1
  rem character
  if entityelement(e).eleprof.ex.texturearray>0 and entityelement(e).eleprof.ex.texturearray<=5
   entityelementtexarrayindex(e)=entityelement(e).eleprof.ex.texturearray-1
  else
   entityelementtexarrayindex(e)=rnd(4)
  endif
 else
  if entityelement(e).eleprof.ex.glassstyle>0 and entityelement(e).eleprof.ex.glassstyle<=10
   rem glass refraction style
   entityelementtexarrayindex(e)=entityelement(e).eleprof.ex.glassstyle-1
  else
   if entityprofile(entid).texaltdid>0
    rem switches default is zero
    entityelementtexarrayindex(e)=0
   else
    entityelementtexarrayindex(e)=rnd(9)
   endif
  endif
 endif
endif

rem delete any existing object and create new one
tgoaheadandsetup=0
if object exist(obj)=1 then delete object obj
if entityelement(e).profileobj>0
 if object exist(entityelement(e).profileobj)=1
  if entityelement(e).spawn.leader=1 and entityelement(e).spawn.max>0
   rem spawning entitiy leaders do not need visual obj (they are invisible makrings), but need obj for object XY ref
   make object triangle obj,0,0,0,0,0,0,0,0,0
   hide object obj
  else
   rem special clone which keeps the animation data in once place (smaller mem footprint)
   if entityelement(e).staticflag=1 and entityprofile(entid).ischaracter=1
    rem if static, and obj has animation (character) - hide it
    make object triangle obj,0,0,0,0,0,0,0,0,0
    hide object obj
   else
    rem FPSCV10X - old U57 clone does not copy multi-materials over
    rem V110 - 140110 - clone fixed for multimaterials, allow static entities
    rem with no texture specified to be cloned (Model Pack 3, etc)
    rem if entityprofile(entid).texd$="" or entityelement(e).staticflag=0
    if entityelement(e).staticflag=0
     te=e : tobj=obj : tentid=entid : gosub _entity_createdynamicentityobj
    else
     rem entity used for static building later (or dynamic entity with no texture specified)
     if 1
      rem make static entity from original
      clone object obj,entityelement(e).profileobj
     else
      `rem no static entities - test mode
      `make object triangle obj,0,0,0,0,0,0,0,0,0
      `hide object obj
     endif
    endif
    tgoaheadandsetup=1
   endif
  endif
 else
  rem some elements can be empty - result of editing
  make object triangle obj,0,0,0,0,0,0,0,0,0
  hide object obj
 endif
else
 rem some elements can be empty - result of editing
 make object triangle obj,0,0,0,0,0,0,0,0,0
 hide object obj
endif

rem Setup element object (position and orientations)
if tgoaheadandsetup=1
 gosub _entity_setupelementobject
else
 if obj>0
  if object exist(obj)=1
   position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
   rotate object obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
  endif
 endif
endif

rem FPSCV101 - static entities that "do not specify a texture" draw from local TGA (however when used inside UNIVERSE.DBO the relative location of the texture is lost)
rem so we must manually insert a texture so the static entity has the path to get the actual texture
if entityelement(e).staticflag=1 and entityprofile(entid).texd$=""
 if obj>0
  if object exist(obj)=1
   tprofileobjnum=entityelement(e).profileobj
   if tprofileobjnum>0
    if object exist(tprofileobjnum)=1
     tscanfile$=entdir$+entpath$+entityprofile(entid).model$
     if lower$(right$(tscanfile$,2))=".x"
      if file exist(tscanfile$)=0
       tscanfile$=left$(tscanfile$,len(tscanfile$)-2)+".dbo"
       rem X10 - 261107 - remove last temp file from program files (DBO)
       tscanfile$=turnfilenameuserlocal(tscanfile$)      
      endif
     endif
     ttrythisone$=findmaterialtexturesinmodelfile(tscanfile$,entdir$+entpath$)
     limbtexid=loadinternalimagecompressquality(ttrythisone$,5,0)
     if limbtexid>0
      entityelement(e).eleprof.texd$=ttrythisone$
      addfiletocollection(entityelement(e).eleprof.texd$)
      entityelement(e).eleprof.texdid=limbtexid
      texture object obj,limbtexid
     endif
    endif
   endif
  endif
 endif
endif

rem X10 - 120907 - if have weapon, and have melee weapins in model, hide melee weapons
if obj>0
 if entityelement(e).eleprof.hasweapon<>0
  tprofileobjnum=entityelement(e).profileobj
  if object exist(obj)=1 and object exist(tprofileobjnum)=1
   perform checklist for object limbs tprofileobjnum
   for tc=1 to checklist quantity()
    rem hide the bone and the mesh associated with the bone (+1)
    if upper$(checklist string$(tc))="MELEE-WEAPON-LEFT"
     hide limb tprofileobjnum,tc-1
     hide limb obj,tc-1
     hide limb tprofileobjnum,tc
     hide limb obj,tc
    endif
    if upper$(checklist string$(tc))="MELEE-WEAPON-RIGHT"
     hide limb tprofileobjnum,tc-1
     hide limb obj,tc-1
     hide limb tprofileobjnum,tc
     hide limb obj,tc
    endif
   next tc
  endif
 endif
endif

rem X10 V109 - 130309 - zero-cull if scale really small
if obj>0
 if entityprofile(entid).scale<30 then set object radius obj,0
endif

return

_entity_createdynamicentityobj:
 `
 rem protect vars (passed tobj,tentid,e in)
 storee=e : e=te
 storeobj=obj : obj=tobj
 storeentid=entid : entid=tentid
 `
 rem used above and also for when respawning previously cloned entities (controlspawn)
 if entityprofile(entid).ischaracter=1
  rem X10 initialise element by wiping out slot usage, and defining a new slot to use
  animslottype=0 : gosub _slot_default_create
 else
  rem X10 - 221007 - only instance if not been customised (custom texture/effect)
  gosub _entity_iseleprofunique
  if entityelement(e).eleprof.uniqueelement=1
   rem Non-instanced so we can have a custom version of this entity
   clone object obj,entityelement(e).profileobj
   rem X10 - 221007 - this is skipped in final element creation, so do it for custom elements
   entobj=tobj : gosub _entity_updatetextureandeffectfromeleprof
   rem X10 - 221007 - if custom shader, apply this now (as configure later does not do it, nor does parentshader which acts only on parent objects)
   if (len(entityprofile(entid).effect$)>0 or len(entityelement(e).eleprof.effect$)>0) and lower$(entityprofile(entid).effect$)<>lower$(entityelement(e).eleprof.effect$)
    teffectid=loadinternaleffect(entityelement(e).eleprof.effect$)
    set object effect entobj,teffectid
   endif
  else
   rem X10 GPU Instancing
   if entityprofile(entid).animmax>0
    rem X10 - 050208 - if entity is not a character, and animates, must be CLONE so can LOOP OBJECT on it
    clone object obj,entityelement(e).profileobj,2
   else
    rem instance everything else that does not animate
    instance object obj,entityelement(e).profileobj,entityelementtexarrayindex(e)
    `
    rem lee - 280308 - if instancing an entity, ensure profile object reflects instancing!
    rem not extensively tested with other levels and performance optimization possible here
    storeentobj=entobj : entobj=entityelement(e).profileobj
    gosub _entity_setparententityshaderonly
    entobj=storeentobj
    `
   endif
  endif
  rem 040807 - need to be part of scene culling otherwise massive slowdown
  attach object to static obj
 endif
 `
 rem restore
 e=storee : obj=storeobj : entid=storeentid
 `
return

_entity_getgunidandflakid:

rem Use Weapon Name to get GUNID and FLAKID
if tgunid$<>""
 findgun$=lower$(tgunid$)
 gosub _gun_findweaponindexbyname
 tgunid=foundgunid
 tflakid$=gun(tgunid).settings.flakname$
 if tflakid$<>""
  flak$=lower$(tflakid$) : gosub _flak_findindex
  tflakid=tindex
 else
  tflakid=0
 endif
else
 tgunid=0 : tflakid=0
endif

return

_entity_createattachment:
 `
 rem Load all VWEAPS for each entity that wants weapon attachments
 entid=entityelement(e).bankindex
 entityelement(e).attachmentobj=0
 entityelement(e).attachmentbaseobj=0
 entityelement(e).attachmentweapontype=0
 entityelement(e).attachmentobjfirespotlimb=0
 if entityprofile(entid).ischaracter=1
  if object exist(eleobj+e)=1
   if entityprofile(entid).firespotlimb>-1
    `
    rem all vweaps (that are active)
    rem FPSCV104 - changed so MULTIPLAYER=ALL weapons, SINGLEPLAYER=only weapon being held (quicker/bugfree/load)
    ttattachindex=0
    for tgindex=1 to gunmax
     if gun(tgindex).activeingame=1
      tweaponname$=gun(tgindex).name$
      if tweaponname$<>""
       `
       rem FPSCV104 - either multiplayer or single player entity has this gun in their hands
       tthasweapon$=lower$(entityelement(e).eleprof.hasweapon$)
       if tthasweapon$=tweaponname$ or gmultiplayergame=1
        `
        rem go and load this gun (attached to calling entity instance)
        inc ttattachindex
        inc entityattachmentindex
        ttobj=entityattachmentsoffset+entityattachmentindex
        if ttattachindex=1 then entityelement(e).attachmentbaseobj=ttobj
        if object exist(ttobj)=1 then delete object ttobj
        tfile$="gamecore\Guns\"+tweaponname$+"\vweap.x"
        rem FPSCV10X some weapons do not have vweap.x models
        if file exist(tfile$)=1
         if entityprofile(entid).characterinstancingmode=1
          if entityprofile(entid).objattachmentmaster=0
           load object tfile$,ttobj : addfiletocollection(tfile$)
           rem X10 possible instancing of guns
           entityprofile(entid).objattachmentmaster=ttobj
           rem X10 - 221007 - first object also needs to be part of static universe
           attach object to static ttobj
          else
           rem use an instance if already loaded (can save 15k ticks in scene with 50 chars)
           instance object ttobj,entityprofile(entid).objattachmentmaster
           rem 040807 - need to be part of scene culling otherwise massive slowdown
           attach object to static ttobj
          endif
         else
          rem faster to load if instances are less than X
          load object tfile$,ttobj : addfiletocollection(tfile$)
          rem 040807 - need to be part of scene culling otherwise massive slowdown
          attach object to static ttobj
          `made the gun disappear 300707 entityprofile(entid).objattachmentmaster=ttobj
          rem 010807 - need for texture to be retained during build though
          rem X10 - V109 - 110309 - find VWEAP texture if GUN_D2 too small
          texuseid=0
          tfile$="gamecore\Guns\"+tweaponname$+"\gun_D2.dds"
          if file exist(tfile$)=1
           if file size(tfile$)<2048
            tfile$=findvweaptexture(tfile$)
            texuseid=loadinternaltexture(tfile$)
            if texuseid=0 then tfile$="gamecore\Guns\"+tweaponname$+"\gun_D2.dds"
           endif
          endif
          if texuseid=0 then texuseid=loadinternaltexture(tfile$)
          addfiletocollection(tfile$)
          set object transparency ttobj,2
          set object collision off ttobj
          texture object ttobj,texuseid
         endif
        else
         rem invisible weapon attachment
         make object triangle ttobj,0,0,0,0,0,0,0,0,0
        endif
        hide object ttobj
        rem X10 - object only for main scene, refract scene and reflect scene (and shadow in shadow scene)
        set object mask ttobj,%110010,%0100,%10
        `
       endif
       `
      endif
     endif
    next tgindex
    rem Opportunity for default first weapon to be attached
    tobj=eleobj+e : gosub _entity_switchattachment
    `
   endif
  endif
 endif
 `
 rem Create blob shadow for characters (X10 and for team icon)
 entityelement(e).attachmentblobobj=0 : rem X10 - 011007 - clear for this element
 if entityprofile(entid).ischaracter=1
  if object exist(eleobj+e)=1
   `
   rem blob shadow / action-icon prompt (entityelement(e).attachmentblobobj+0)
   inc entityattachmentindex
   ttobj=entityattachmentsoffset+entityattachmentindex
   entityelement(e).attachmentblobobj=ttobj
   make object plain ttobj,40,40
   rem 040807 - need to be part of scene culling otherwise massive slowdown
   attach object to static ttobj 
   xrotate object ttobj,90
   set object light ttobj,0
   disable object zwrite ttobj
   set object cull ttobj,1
   position object ttobj,-50000,-50000,50000
   ttexid=attachmenticonimagestart+0
   texture object ttobj,ttexid
   set object transparency ttobj,2
   set object mask ttobj,%100010,%0000,%00
   `
   rem health bar border (entityelement(e).attachmentblobobj+1)
   inc entityattachmentindex : ttobj=ttobj+1
   make object plain ttobj,261/10.0,14/10.0
   rem 040807 - need to be part of scene culling otherwise massive slowdown
   attach object to static ttobj 
   set object light ttobj,0
   disable object zwrite ttobj
   set object cull ttobj,1
   position object ttobj,-50000,-50000,50000
   ttexid=attachmenticonimagestart+4
   texture object ttobj,ttexid
   set object transparency ttobj,2
   set object mask ttobj,%100000,%0000,%00
   if entityelement(e).eleprof.ex.showhealthbar=0 or gmultiplayergame=1 then hide object ttobj
   `
   rem health bar (entityelement(e).attachmentblobobj+2)
   inc entityattachmentindex : ttobj=ttobj+1
   make object plain ttobj,255/10.0,8/10.0
   rem 040807 - need to be part of scene culling otherwise massive slowdown
   attach object to static ttobj 
   set object light ttobj,0
   disable object zwrite ttobj
   set object cull ttobj,1
   position object ttobj,-50000,-50000,50000
   ttexid=attachmenticonimagestart+5
   texture object ttobj,ttexid
   set object transparency ttobj,2
   set object mask ttobj,%100000,%0000,%00
   if entityelement(e).eleprof.ex.showhealthbar=0 or gmultiplayergame=1 then hide object ttobj
   `
  endif
 endif
 `
return

_entity_switchattachment:
 `
 rem uses tobj, e, entid, [hasweapon$ can be changed]
 thasweapon$=lower$(entityelement(e).eleprof.hasweapon$)
 tvweapobj=entityelement(e).attachmentobj
 `
 rem unglue old VWEAP (if any)
 if tvweapobj>0
  rem re-hide object
  if object exist(tvweapobj)=1
   unglue object tvweapobj
   position object tvweapobj,0,0,0
   hide object tvweapobj
  endif
 endif
 `
 rem reset entity so not carrying
 entityelement(e).attachmentobjfirespotlimb=0
 entityelement(e).attachmentweapontype=0
 entityelement(e).attachmentobj=0
 entityelement(e).currentweapon=0
 `
 rem pick new VWEAP model to attach
 tvweapobj=0
 ttattachindex=0
 if gmultiplayergame=1
  rem arena characters have all guns attached to them
  for tgindex=1 to gunmax
   if gun(tgindex).activeingame=1
    if gun(tgindex).name$<>"" then inc ttattachindex
    if lower$(gun(tgindex).name$)=thasweapon$ then tvweapobj=entityelement(e).attachmentbaseobj+(ttattachindex-1) : exit
   endif
  next tgindex
 else
  rem FPSCV10X - single play characters have one gun - but still need to return gunindex
  ttattachindex=1
  for tgindex=1 to gunmax
   if gun(tgindex).activeingame=1
    if lower$(gun(tgindex).name$)=thasweapon$ then tvweapobj=entityelement(e).attachmentbaseobj+(ttattachindex-1) : exit
   endif
  next tgindex
 endif
 tentid=entityelement(e).bankindex
 if tvweapobj>0
  rem FPSCV10X - removing VWEAP.X no longer crashes
  if object exist(tvweapobj)=0
   tvweapobj=0
  else
   if entityprofile(tentid).firespotlimb=-1
    tvweapobj=0
   else
    if object exist(tobj)=1
     if limb exist(tobj,entityprofile(tentid).firespotlimb)=0
      tvweapobj=0
     endif
    else
     tvweapobj=0
    endif
   endif
  endif
 endif
 if tvweapobj>0
  entityelement(e).attachmentweapontype=gun(tgindex).weapontype
  entityelement(e).currentweapon=tgindex
 endif
 `
 rem if new gun selected
 if tvweapobj>0
  rem new attached object
  entityelement(e).attachmentobj=tvweapobj
  rem glue new VWEAP to entity(character)
  position object tvweapobj,0,0,0
  rem try manual position, not glue
  `x9glue object to limb tvweapobj,tobj,entityprofile(tentid).firespotlimb
  rem relocate firepsot within VWEAP model for entity use
  entityelement(e).attachmentobjfirespotlimb=0
  perform checklist for object limbs tvweapobj
  for tc=1 to checklist quantity()
   if lower$(checklist string$(tc))="firespot"
    entityelement(e).attachmentobjfirespotlimb=tc-1
    tc=checklist quantity()+1
   endif
  next tc
  rem finally show thw weapon (if not spawn child)
  if entityelement(e).spawn.leaderid=0
   show object tvweapobj
  else
   hide object tvweapobj
  endif
 endif
 `
return

_entity_iseleprofunique:
 `
 rem Entity unique if texture or effect different
 tokay=0
 if (len(entityprofile(entid).texd$)>0 or len(entityelement(e).eleprof.texd$)>0) and entityprofile(entid).texd$<>entityelement(e).eleprof.texd$ then tokay=1
 if (len(entityprofile(entid).texaltd$)>0 or len(entityelement(e).eleprof.texaltd$)>0) and entityprofile(entid).texaltd$<>entityelement(e).eleprof.texaltd$ then tokay=1
 if (len(entityprofile(entid).effect$)>0 or len(entityelement(e).eleprof.effect$)>0) and entityprofile(entid).effect$<>entityelement(e).eleprof.effect$ then tokay=1
 if tokay=1
  entityelement(e).eleprof.uniqueelement=1
 else
  entityelement(e).eleprof.uniqueelement=0
 endif
 `
return

_entity_updatetextureandeffectfromeleprof:
 `
 rem Texture and Effect (use entityprofile loader)
 storeentdefaults as entityprofiletype
 storeentdefaults=entityprofile(entid)
 entityprofile(entid).texd$=entityelement(e).eleprof.texd$
 entityprofile(entid).texaltd$=entityelement(e).eleprof.texaltd$
 entityprofile(entid).texdid=entityelement(e).eleprof.texdid
 entityprofile(entid).texaltdid=entityelement(e).eleprof.texaltdid
 entityprofile(entid).effect$=entityelement(e).eleprof.effect$
 entityprofile(entid).usingeffect=entityelement(e).eleprof.usingeffect
 entityprofile(entid).tex1id=entityelement(e).eleprof.tex1id
 entityprofile(entid).tex2id=entityelement(e).eleprof.tex2id
 entityprofile(entid).tex3id=entityelement(e).eleprof.tex3id
 entityprofile(entid).tex4id=entityelement(e).eleprof.tex4id
 entityprofile(entid).texidmax=entityelement(e).eleprof.texidmax
 entityprofile(entid).transparency=entityelement(e).eleprof.transparency
 entityprofile(entid).reducetexture=entityelement(e).eleprof.reducetexture
 gosub _entity_loadtexturesandeffect
 entityelement(e).eleprof.texd$=entityprofile(entid).texd$
 entityelement(e).eleprof.texaltd$=entityprofile(entid).texaltd$
 entityelement(e).eleprof.texdid=entityprofile(entid).texdid
 entityelement(e).eleprof.texaltdid=entityprofile(entid).texaltdid
 entityelement(e).eleprof.effect$=entityprofile(entid).effect$
 entityelement(e).eleprof.usingeffect=entityprofile(entid).usingeffect
 entityelement(e).eleprof.tex1id=entityprofile(entid).tex1id
 entityelement(e).eleprof.tex2id=entityprofile(entid).tex2id
 entityelement(e).eleprof.tex3id=entityprofile(entid).tex3id
 entityelement(e).eleprof.tex4id=entityprofile(entid).tex4id
 entityelement(e).eleprof.texidmax=entityprofile(entid).texidmax
 entityelement(e).eleprof.transparency=entityprofile(entid).transparency
 entityelement(e).eleprof.reducetexture=entityprofile(entid).reducetexture
 entityprofile(entid)=storeentdefaults
 `
return

_entity_isgrideleprofunique:
 `
 rem Entity unique if texture or effect different
 tokay=0
 if (len(entityprofile(entid).texd$)>0 or len(grideleprof.texd$)>0) and entityprofile(entid).texd$<>grideleprof.texd$ then tokay=1
 if (len(entityprofile(entid).texaltd$)>0 or len(grideleprof.texaltd$)>0) and entityprofile(entid).texaltd$<>grideleprof.texaltd$ then tokay=1
 if (len(entityprofile(entid).effect$)>0 or len(grideleprof.effect$)>0) and entityprofile(entid).effect$<>grideleprof.effect$ then tokay=1
 if tokay=1
  grideleprof.uniqueelement=1
 else
  grideleprof.uniqueelement=0
 endif
 `
return

_entity_updatetextureandeffectfromgrideleprof:
 `
 rem Texture and Effect (use entityprofile loader)
 storeentdefaults as entityprofiletype
 storeentdefaults=entityprofile(entid)
 entityprofile(entid).texd$=grideleprof.texd$
 entityprofile(entid).texaltd$=grideleprof.texaltd$
 entityprofile(entid).texdid=grideleprof.texdid
 entityprofile(entid).texaltdid=grideleprof.texaltdid
 entityprofile(entid).effect$=grideleprof.effect$
 entityprofile(entid).usingeffect=grideleprof.usingeffect
 entityprofile(entid).tex1id=grideleprof.tex1id
 entityprofile(entid).tex2id=grideleprof.tex2id
 entityprofile(entid).tex3id=grideleprof.tex3id
 entityprofile(entid).tex4id=grideleprof.tex4id
 entityprofile(entid).texidmax=grideleprof.texidmax
 entityprofile(entid).transparency=grideleprof.transparency
 entityprofile(entid).reducetexture=grideleprof.reducetexture
 gosub _entity_loadtexturesandeffect
 grideleprof.texd$=entityprofile(entid).texd$
 grideleprof.texaltd$=entityprofile(entid).texaltd$
 grideleprof.texdid=entityprofile(entid).texdid
 grideleprof.texaltdid=entityprofile(entid).texaltdid
 grideleprof.effect$=entityprofile(entid).effect$
 grideleprof.usingeffect=entityprofile(entid).usingeffect
 grideleprof.tex1id=entityprofile(entid).tex1id
 grideleprof.tex2id=entityprofile(entid).tex2id
 grideleprof.tex3id=entityprofile(entid).tex3id
 grideleprof.tex4id=entityprofile(entid).tex4id
 grideleprof.texidmax=entityprofile(entid).texidmax
 grideleprof.transparency=entityprofile(entid).transparency
 grideleprof.reducetexture=entityprofile(entid).reducetexture
 entityprofile(entid)=storeentdefaults
 `
return

_entity_configueelementforuse:
 `
 rem Resolve AI indexes from AI script filenames
 aifile$=entityelement(e).eleprof.aiinit$ : gosub _ai_findlibindex : entityelement(e).eleprof.aiinit=libindex
 aifile$=entityelement(e).eleprof.aimain$ : gosub _ai_findlibindex : entityelement(e).eleprof.aimain=libindex
 aifile$=entityelement(e).eleprof.aidestroy$ : gosub _ai_findlibindex : entityelement(e).eleprof.aidestroy=libindex
 aifile$=entityelement(e).eleprof.aishoot$ : gosub _ai_findlibindex : entityelement(e).eleprof.aishoot=libindex
 `
 rem prevent main AI from running in (multiplayer)
 if gmultiplayergame=1
  rem server entities by default
  entityelement(e).servercontrolled=1
  if entityprofile(entid).ischaracter=1
   rem characters are ALL possible players NO MAIN LOGIC - SERVER CONTROLLED ZOMBIE ENTITIES
   aifile$="default.fpi" : gosub _ai_findlibindex : entityelement(e).eleprof.aimain=libindex
  endif
 endif
 `
 rem Configure AI for element
 entityelement(e).active=1
 entityelement(e).dormant=1
 entityelement(e).collisionactive=1
 entityelement(e).ai.libinit=entityelement(e).eleprof.aiinit
 entityelement(e).ai.libmain=entityelement(e).eleprof.aimain
 entityelement(e).ai.libdestroy=entityelement(e).eleprof.aidestroy
 entityelement(e).ai.libshoot=entityelement(e).eleprof.aishoot
 entityelement(e).ai.libindex=entityelement(e).ai.libinit
 entityelement(e).mover.da=entityelement(e).ry
 entityelement(e).ai.waypoint.state=0
 entityelement(e).ai.alphafade=0
 entityelement(e).ai.state=0
 `
 rem Configure animation defaults
 if entityprofile(entid).ischaracter=1
  entityelement(e).animspeed=2.0
 else
  entityelement(e).animspeed=4.0
 endif
 `
 rem Spawn values
 entityelement(e).spawn.atstart=entityelement(e).eleprof.spawnatstart
 entityelement(e).spawn.max=entityelement(e).eleprof.spawnmax
 entityelement(e).spawn.delay=entityelement(e).eleprof.spawndelay
 entityelement(e).spawn.qty=entityelement(e).eleprof.spawnqty
 entityelement(e).spawn.upto=entityelement(e).eleprof.spawnupto
 entityelement(e).spawn.afterdelay=entityelement(e).eleprof.spawnafterdelay
 entityelement(e).spawn.whendead=entityelement(e).eleprof.spawnwhendead
 entityelement(e).spawn.delayrandom=entityelement(e).eleprof.spawndelayrandom
 entityelement(e).spawn.qtyrandom=entityelement(e).eleprof.spawnqtyrandom
 entityelement(e).spawn.vel=entityelement(e).eleprof.spawnvel
 entityelement(e).spawn.velrandom=entityelement(e).eleprof.spawnvelrandom
 entityelement(e).spawn.angle=entityelement(e).eleprof.spawnangle
 entityelement(e).spawn.anglerandom=entityelement(e).eleprof.spawnanglerandom
 entityelement(e).spawn.life=entityelement(e).eleprof.spawnlife
 `
 rem Spawn off means spawn-ready to be used, so..
 if entityelement(e).spawn.atstart=0 and entityelement(e).spawn.max=0
  entityelement(e).spawn.max=1
  if entityelement(e).spawn.afterdelay=0 and entityelement(e).spawn.whendead=0
   entityelement(e).spawn.afterdelay=1
  endif
  if entityelement(e).spawn.qty=0 then entityelement(e).spawn.qty=1
  if entityelement(e).spawn.upto=0 then entityelement(e).spawn.upto=1
 endif
 `
 rem Configure health from strength
 if entityelement(e).eleprof.strength>0
  entityelement(e).health=entityelement(e).eleprof.strength
 else
  entityelement(e).health=1
 endif
 `
 rem Moved from SETUP, as FX name can change here
 if guseeffectonentitiesstate=1
  tfile$=entityelement(e).eleprof.effect$
  if tfile$<>""
   if entityelement(e).staticflag=0
    rem dynamic entities cannot use scene FX, must be entity FX..
    rem for backwards EA compatibility with old entity eleprofs, bump.fx has become bumpent.fx
    if lower$(tfile$)="effectbank\bump\bump.fx" then tfile$="effectbank\bumpent\bumpent.fx"
    entityelement(e).eleprof.effect$=tfile$
    entityelement(e).eleprof.uniqueelement=1
   else
    rem if entity static, this routine called from UNIVERSE code to prepare static entities
    rem ENSURE the bumpent.fx is replaced with BUMP.FX as the former FX file would be wrong
    if lower$(tfile$)="effectbank\bumpent\bumpent.fx" then tfile$="effectbank\bump\bump.fx"
    if lower$(tfile$)="effectbank\bumpbone\bumpbone.fx" then tfile$="effectbank\bump\bump.fx"
    entityelement(e).eleprof.effect$=tfile$
   endif
  endif
 endif
 `
 rem Texture and Effect (use entityprofile loader)
 `gosub _entity_iseleprofunique 221007 - moved from here to when entity element 'created' (so we can clone instead of instance for custom elements)
 entobj=configureobj : gosub _entity_updatetextureandeffectfromeleprof
 `
 rem Resolve default weapon gun ids
 if entityelement(e).eleprof.hasweapon$<>""
  findgun$=lower$(entityelement(e).eleprof.hasweapon$) : gosub _gun_findweaponindexbyname
  entityelement(e).eleprof.hasweapon=foundgunid
  if foundgunid>0 and entityprofile(entid).isammo=0 then gun(foundgunid).activeingame=1
 else
  entityelement(e).eleprof.hasweapon=0
 endif
 `
return

_entity_setparententityshaderonly:
 `
 rem apply shader to entity profile object
 rem lee - 280308 - seperated here so I can call it after INSTANCING
 rem as the shader changes if the entity has instancing in effect
 entityprofile(entid).usingeffect=0
 if segobjusedformapeditor=0
  if entobj>0
   if object exist(entobj)=1
    rem Use default shaders
    if entityprofile(entid).ischaracter=1
     if entityprofile(entid).characterinstancingmode=1
      rem instanced skinning
      teffectid=loadinternaleffect("effectbank\skinning\skinning.fx")
     else
      rem non-instance skinning
      teffectid=gskinningforagdolleffect
     endif
    else
     if right$(lower$(entityprofile(entid).effect$),10)="cubeent.fx"
      dirbefore$=get dir$() : set dir commoneffects$
      tfile$="refract.fx" : teffectid=loadinternaleffect(tfile$)
      addfiletocollection(commoneffects$+tfile$)
      set dir dirbefore$
      rem X10 - refractive entities are not in refract/reflect or shadow scene
      grefractionshadereffect=teffectid
      set object mask entobj,%100000,%0,%0
     else
      teffectid=loadinternaleffect("effectbank\simple\simple.fx")
     endif
    endif
    if teffectid>0
     rem set the effect
     entityprofile(entid).usingeffect=teffectid
     set object effect entobj,teffectid
    endif
   endif
  endif
 endif
 `
return

_entity_setparententityshaders:
 `
 rem X10 Set all parent entity shaders
 rem this new 10 function is done 'after' map_load where universe constructs
 rem itself using unmodified static entities
 gosub _entity_setparententityshaderonly
 `
 rem Set shadow for thie entity too (now we know its not used as universe static entity)
 if entityprofile(entid).ischaracter=0
  if entobj>0
   if object exist(entobj)=1
    rem characters already have shadows set when originally loaded
    if entityprofile(entid).ismarker=0
     if entityprofile(entid).isimmobile=0
      rem only shadow none markers and dynamic
      tobjshadowreach#=0 : set shadow shading on entobj,-1,tobjshadowreach#,1
     endif
    endif
   endif
  endif   
 endif
 `
return

_entity_createelements:

rem add shaders and shadows to parent entity objects
for entid=1 to entidmaster
 entobj=entitybankoffset+entid
 gosub _entity_setparententityshaders
next entid

rem pre-create element data (load from eleprof)
for e=1 to entityelementlist
 entobj=0 : entid=entityelement(e).bankindex
 configureobj=0 : gosub _entity_configueelementforuse
next e

rem spawn all elements (one element with a max.spawn of 5 means we duplicate another 4 here)
countnewselementsize=0
for spawne=1 to entityelementlist
 if entityelement(spawne).staticflag=0
  inc countnewselementsize,1+entityelement(spawne).spawn.max
 endif
next spawne

dim newentityelement(countnewselementsize) as entitytype
newentityelementlist=0
for spawne=1 to entityelementlist
 if entityelement(spawne).staticflag=0
  for te=1 to 1+entityelement(spawne).spawn.max
   inc newentityelementlist
   newentityelement(newentityelementlist)=entityelement(spawne)
   if te=1
    rem leader
    newentityelement(newentityelementlist).spawn.leader=1
    newentityelement(newentityelementlist).spawn.leadercount=0
    newentityelement(newentityelementlist).spawn.leaderid=0
    newentityelement(newentityelementlist).spawn.x=entityelement(spawne).x
    newentityelement(newentityelementlist).spawn.y=entityelement(spawne).y
    newentityelement(newentityelementlist).spawn.z=entityelement(spawne).z
    newentityelement(newentityelementlist).active=1
    newentityelement(newentityelementlist).dormant=0
    theleader=newentityelementlist
   else
    rem follower - uses MAX range to group followers to each leader
    newentityelement(newentityelementlist).spawn.leader=0
    newentityelement(newentityelementlist).spawn.leadercount=0
    newentityelement(newentityelementlist).spawn.leaderid=theleader
    newentityelement(newentityelementlist).active=0
    newentityelement(newentityelementlist).dormant=1
    newentityelement(newentityelementlist).health=0
    newentityelement(newentityelementlist).eleprof.lives=0
   endif
  next te
 endif
next spawne
undim entityelement()
undim entitydebug$()
entityelementlist=newentityelementlist
entityelementmax=entityelementlist
dim entityelement(entityelementmax) as entitytype
dim entitybreadcrumbs(entityelementmax,50) as entitybreadcrumbstype
dim entitydebug$(entityelementmax)
for e=1 to entityelementmax
 entityelement(e)=newentityelement(e)
next e
undim newentityelement()
dim entityelementwhichslot(entityelementmax)
dim entityelementusingode(entityelementmax)
dim entityelementwhichobj(entityelementmax)
dim entityelementtexarrayindex(entityelementmax)
dim entityelementusingrefraction(entityelementmax)
dim lastentityraycast(entityelementmax)
dim lastentityraycast2#(entityelementmax)  
dim lastentityshadowlength#(entityelementmax)

rem create instances for all elements (create dynamic entities only)
debugviewtext(302,strarr$(102))
eleobj=entityobjectoffset
ttick=0 : ttickmax=entityelementlist/10
if ttickmax<1 then ttickmax=1
for e=1 to entityelementlist
 obj=eleobj+e
 if obj>0
  if entityelement(e).staticflag=0
   inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(302,strarr$(103)+str$(e)+"/"+str$(entityelementlist)+" ("+entityprofile(tentid).model$+")")
   entid=entityelement(e).bankindex
   if entityprofile(entid).ismarker=0
    entityelement(e).profileobj=entitybankoffset+entid
    gosub _entity_createelementasobject
   endif
  endif
 endif
next e

rem X10 set flag for all refraction entities
for e=1 to entityelementlist
 obj=eleobj+e
 if obj>0
  if object exist(obj)=1
   tentid=entityelement(e).bankindex
   if right$(lower$(entityprofile(tentid).effect$),10)="cubeent.fx"
    entityelementusingrefraction(e)=1
   else
    entityelementusingrefraction(e)=0
   endif
  endif
 endif
next e

rem after leader creations, do not need leader flag if entity does not spawn
for e=1 to entityelementlist
 if entityelement(e).spawn.leader=1
  tentid=entityelement(e).bankindex
  if entityelement(e).spawn.max=0
   entityelement(e).spawn.leader=0
  endif
 endif
next e

rem Create Entity Attachments
debugviewtext(304,strarr$(104))
entityattachmentindex=0
eleobj=entityobjectoffset
ttick=0 : ttickmax=entityelementlist/10
if ttickmax<1 then ttickmax=1
for e=1 to entityelementlist
 inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(306,str$(e)+"\"+str$(entityelementlist)+" "+entityelement(e).eleprof.name$)
 gosub _entity_createattachment
next e

rem X10 apply effects to gun attachments
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).objattachmentmaster<>0
  rem for instanced guns
  ttobj=entityprofile(entid).objattachmentmaster
  tweaponname$=lower$(entityelement(e).eleprof.hasweapon$)
  `
  rem X10 - V109 - 110309 - find VWEAP texture if GUN_D2 too small
  rem X10 - V110 - 070509 - fixed ttfile$ to tfile$ (VWEAP crash using instances)
  texuseid=0
  tfile$="gamecore\Guns\"+tweaponname$+"\gun_D2.tga"
  if file exist(tfile$)=1
   if file size(tfile$)<2048
    tfile$=findvweaptexture(tfile$)
    texuseid=loadinternaltexture(tfile$)
    if texuseid=0 then tfile$="gamecore\Guns\"+tweaponname$+"\gun_D2.tga"
   endif
  endif
  if texuseid=0 then texuseid=loadinternaltexture(tfile$)
  `
  if entityprofile(entid).characterinstancingmode=1
   teffectid=gsimpleinstancevweapeffect
  else
   teffectid=gsimplevweapeffect
  endif
  set object transparency ttobj,2
  set object collision off ttobj
  texture object ttobj,texuseid
  if teffectid>0 then set object effect ttobj,teffectid
 endif        
next e

rem if entity is server controlled, hide entity initially (multiplayer)
if gmultiplayergame=1
 for e=1 to entityelementlist
  if entityelement(e).servercontrolled=1
   obj=entityelement(e).obj
   if obj>0
    if object exist(obj)=1
     hide object tobj
    endif
   endif
  endif
 next e
endif

rem Assign characters as fake players and set default weapon
fakeplayercount=2
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ischaracter=1
  entityelement(e).fakeplayerid=fakeplayercount
  inc fakeplayercount
 endif
 entityelement(e).currentweapon=entityelement(e).eleprof.hasweapon
 entityelement(e).currentclipammo=9999
 entityelement(e).currentammo=0 : rem V110 - 130110 - filled later if flagged (startingentitiesoff)
next e
rem recreate array to new size
playermax=fakeplayercount-1
dim player(playermax) as playertype
dim playersound(playermax,520) as integer
dim playersoundset$(playermax) as string
dim playersoundsetindex(playermax) as integer
dim playermovementstep(playermax) as integer
dim playerinventory(playermax,100) as inventorytype

rem Transfer sound sets to player data
fakeplayercount=2
playersoundset$(1)=""
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ismarker=1 and entityprofile(entid).lives>0
  playersoundset$(1)=entityelement(e).eleprof.soundset$
 endif
 if entityprofile(entid).ischaracter=1
  playersoundset$(fakeplayercount)=entityelement(e).eleprof.soundset$
  entityelement(e).fakeplrindex=fakeplayercount
  inc fakeplayercount
 endif
next e

rem Activate any decals
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).decalmax>0
  for tq=0 to entityprofile(entid).decalmax-1
   `
   rem create particle 
   tdecal$=entitydecal$(entid,tq)
   if lower$(left$(tdecal$,15))="particles-smoke"
    particletype=1
    particlex#=entityelement(e).x
    particley#=entityelement(e).y
    particlez#=entityelement(e).z
    gosub _particles_create
   else
    if lower$(left$(tdecal$,15))="particles-steam"
     particletype=2
     particlex#=entityelement(e).x
     particley#=entityelement(e).y
     particlez#=entityelement(e).z
     gosub _particles_create
    else
     rem create regular decal
     decalid=entitydecal(entid,tq)
     if decalid>0
      decal(decalid).active=1
     endif
    endif
   endif
   `
  next tq
 endif
next e

rem V109 - 140109 - Only remove decals for particles after all particles created
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).decalmax>0
  for tq=0 to entityprofile(entid).decalmax-1
   `
   rem remove decals that produce a particle effect (as particles created for them)
   tdecal$=entitydecal$(entid,tq)
   if lower$(left$(tdecal$,15))="particles-smoke"
    rem remove placeholder decal
    entitydecal(entid,tq)=0
    tq=entityprofile(entid).decalmax
    entityprofile(entid).decalmax=0
   else
    if lower$(left$(tdecal$,15))="particles-steam"
     rem remove placeholder decal
     entitydecal(entid,tq)=0
     tq=entityprofile(entid).decalmax
     entityprofile(entid).decalmax=0
    endif
   endif
   `
  next tq
 endif
next e

rem Load any soundsets not belonging to characters or players
debugviewtext(306,strarr$(105))
for e=1 to entityelementlist
 entityelement(e).soundset=0
 entid=entityelement(e).bankindex
 tokay=0 : tsoundis3d=1
 if entityprofile(entid).ischaracter=0 and entityprofile(entid).ismarker=0 then tokay=1
 if entityprofile(entid).ismarker=1 and entityprofile(entid).lives=0 then tokay=1
 if entityprofile(entid).ismarker=3 or entityprofile(entid).ismarker=4 then tokay=1
 if lower$(entityprofile(entid).aimain$)="musicinzone.fpi" then tsoundis3d=0 : rem 200707 music zone
 if tokay=1
  if entityelement(e).eleprof.soundset$<>""
   rem load as 3D sound ready for playing or looping in game (generator)
   tfile$=entityelement(e).eleprof.soundset$
   if file exist(rootdir$+tfile$)=1 or file exist(myownrootdir$+tfile$)=1
    addfiletocollection(tfile$)
    entityelement(e).soundset=loadinternalsoundcore(rootdir$+tfile$,tsoundis3d)
   endif
  endif
  if entityelement(e).eleprof.soundset1$<>""
   rem load as 3D sound ready for playing or looping in game (generator)
   tfile$=entityelement(e).eleprof.soundset1$
   if file exist(rootdir$+tfile$)=1 or file exist(myownrootdir$+tfile$)=1
    addfiletocollection(tfile$)
    entityelement(e).soundset1=loadinternalsoundcore(rootdir$+tfile$,tsoundis3d)
   endif
  endif
 endif
next e

return

_entity_attachelementstogame:

rem associate dynamic entities with game universe (vislinking)
eleobj=entityobjectoffset
for e=1 to entityelementlist
 obj=eleobj+e
 if obj>0
  entid=entityelement(e).bankindex
  if entityelement(e).staticflag=0
   if object exist(obj)=1
    attach object to static obj
   endif
  endif
 endif
next e

rem was here
gosub _player_resetobjectives

return

_entity_calculateobjectivestotal:

rem count all objective entities
missiongoaltotal=0
for e=1 to entityelementlist
 mi=entityelement(e).eleprof.isobjective
 if missiongoaltotal<mi then missiongoaltotal=mi
next e

rem count all as complete
for mi=1 to 99 : playerobjective(mi)=1 : next mi

rem and clear those awaiting to be filled in my entity
for e=1 to entityelementlist
 mi=entityelement(e).eleprof.isobjective
 if mi>0 then playerobjective(mi)=0
next e

return

_entity_deleteelements:

rem Quick deletes
if entityelementlist>0
 delete objects entityobjectoffset+1, entityobjectoffset+entityelementlist
endif
if entityattachmentindex>0
 delete objects entityattachmentsoffset+1, entityattachmentsoffset+entityattachmentindex
endif

return

_entity_scanfornewentitiesnoload:

rem Scan for entities
entdir$="entitybank\"
empty array filelist$()
buildfilelist(entdir$,"")

rem If entities exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem entity name from folder
  ent$=filelist$(chkfile)
  `
  rem Check if filename valid
  if right$(ent$,4)=".fpe"
  `
  rem Check entity exists in bank
  tokay=1
  if entidmaster>0
   for entid=1 to entidmaster
    if entitybank$(entid)=ent$ then tokay=0
   next entid
  endif
  if tokay=1
    `
   rem Find Free entity Index
   freeentid=-1
   if entidmaster>0
    for entid=1 to entidmaster
     if entitybank$(entid)="" then freeentid=entid : exit
    next entid
   endif
   `
   rem New entity or Free One
   if freeentid=-1
    inc entidmaster : gosub _entity_validatearraysize
    entid=entidmaster
   else
    entid=freeentid
   endif
   `
   rem Load entity
   dim entitybank$(entid)
   entitybank$(entid)=ent$
   `
  endif
  `
  endif
  `
 next chkfile
endif

return


_entity_scanfornewentities:

rem Load all entity names
gosub _entity_scanfornewentitiesnoload

rem Load entities themselves
for entid=1 to endidmaster
 ent$=entitybank$(entid)
 entpath$=getpath(ent$)
 gosub _entity_load
next entid

return

_entity_addtoselection:

rem Load entity from file requester
set dir currententitydir$
ent$=browseropen$(9)
entdir$="entitybank\"
ent$=right$(ent$,len(ent$)-len(rootdir$+entdir$))
currententitydir$=get dir$()
set dir rootdir$
`
rem Check if filename valid
entnewloaded=0 : entid=0
if right$(ent$,4)=".fpe"
 `
 rem Check entity exists in bank
 tokay=1
 if entidmaster>0
  for entid=1 to entidmaster
   if entitybank$(entid)=ent$ then tokay=0 : tfoundid=entid : exit
  next entid
 endif
 if tokay=1
  `
  rem Find Free entity Index
  freeentid=-1
  if entidmaster>0
   for entid=1 to entidmaster
    if entityprofileheader(entid).desc$="" then freeentid=entid : exit
   next entid
  endif
  `
  rem New entity or Free One
  if freeentid=-1
   inc entidmaster : gosub _entity_validatearraysize
   entid=entidmaster
   entnewloaded=1
  else
   entid=freeentid
  endif
  `
  rem Load entity
  entitybank$(entid)=ent$
  entpath$=getpath(ent$)
  gosub _entity_load
  `
 else
  `
  rem already got, assign ID from existing
  entid=tfoundid
  `
 endif
 `
endif

return

_entity_delete:
 `
 rem Remove trace of entity (and object)
 tdelobj=entitybankoffset+entid
 if tdelobj>0
  if object exist(tdelobj)=1 then delete object tdelobj
  entityprofileheader(entid).desc$=""
  entitybank$(entid)=""
  entityprofile(entid).aiinit$=""
  entityprofile(entid).aimain$=""
  entityprofile(entid).aidestroy$=""
  entityprofile(entid).aishoot$=""
  entityprofile(entid).soundset$=""
  entityprofile(entid).soundset1$=""
  entityprofile(entid).usekey$=""
  entityprofile(entid).ifused$=""
  entityprofile(entid).ifusednear$=""
  entityprofile(entid).spawnatstart=0
  entityprofile(entid).spawnmax=0
  entityprofile(entid).spawnupto=0
  entityprofile(entid).spawnafterdelay=0
  entityprofile(entid).spawnwhendead=0
  entityprofile(entid).spawndelay=0
  entityprofile(entid).spawnqty=0
  entityprofile(entid).spawndelayrandom=0
  entityprofile(entid).spawnqtyrandom=0
  entityprofile(entid).spawnvel=0
  entityprofile(entid).spawnvelrandom=0
  entityprofile(entid).spawnangle=0
  entityprofile(entid).spawnanglerandom=0
  entityprofile(entid).spawnlife=0
  entityprofile(entid).model$=""
  entityprofile(entid).offx=0.0
  entityprofile(entid).offy=0.0
  entityprofile(entid).offz=0.0
  entityprofile(entid).rotx=0.0
  entityprofile(entid).roty=0.0
  entityprofile(entid).rotz=0.0
  entityprofile(entid).scale=0.0
  entityprofile(entid).fixnewy=0.0
  entityprofile(entid).forwardfacing=0
  entityprofile(entid).defaultheight=0.0
  entityprofile(entid).defaultstatic=0
  entityprofile(entid).collisionmode=0
  entityprofile(entid).materialindex=0
  entityprofile(entid).debrisshapeindex=0
  entityprofile(entid).coneheight=0.0
  entityprofile(entid).coneangle=0.0
  entityprofile(entid).hurtfall=0
  entityprofile(entid).texpath$=""
  entityprofile(entid).texd$=""
  entityprofile(entid).texdid=0
  entityprofile(entid).texaltd$=""
  entityprofile(entid).texaltdid=0
  entityprofile(entid).tex1id=0
  entityprofile(entid).tex2id=0
  entityprofile(entid).tex3id=0
  entityprofile(entid).tex4id=0
  entityprofile(entid).texidmax=0
  entityprofile(entid).effect$=""
  entityprofile(entid).usingeffect=0
  entityprofile(entid).castshadow=0
  entityprofile(entid).transparency=0
  entityprofile(entid).reducetexture=0
  entityprofile(entid).strength=0
  entityprofile(entid).lives=0
  entityprofile(entid).speed=0
  entityprofile(entid).isimmobile=0
  entityprofile(entid).ischaracter=0
  entityprofile(entid).cantakeweapon=0
  entityprofile(entid).isweapon$=""
  entityprofile(entid).isweapon=0
  entityprofile(entid).isammo=0
  entityprofile(entid).hasweapon$=""
  entityprofile(entid).hasweapon=0
  entityprofile(entid).ishealth=0
  entityprofile(entid).isflak=0
  entityprofile(entid).limbmax=0
  entityprofile(entid).headlimb=0
  entityprofile(entid).firespotlimb=0
  entityprofile(entid).animmax=0
  entityprofile(entid).quantity=0
  entityprofile(entid).ismarker=0
  entityprofile(entid).markerindex=0
  entityprofile(entid).isobjective=0
  entityprofile(entid).decalmax=0
  entityprofile(entid).bloodscorch=0
  entityprofile(entid).rateoffire=0
  entityprofile(entid).damage=0
  entityprofile(entid).accuracy=0
  entityprofile(entid).reloadqty=0
  entityprofile(entid).fireiterations=0
  entityprofile(entid).lifespan=0
  entityprofile(entid).throwspeed=0.0
  entityprofile(entid).throwangle=0.0
  entityprofile(entid).bounceqty=0
  entityprofile(entid).explodeonhit=0
  entityprofile(entid).weaponisammo=0
  entityprofile(entid).spare1=0
  entityprofile(entid).physics=0
  entityprofile(entid).phyalways=0
  entityprofile(entid).phyweight=0
  entityprofile(entid).phyfriction=0
  entityprofile(entid).phyforcedamage=0
  entityprofile(entid).rotatethrow=0
  entityprofile(entid).explodable=0
  entityprofile(entid).explodedamage=0
 endif
 `
return

`
` SLOT functions used to manage character clone instancing
`

_slot_default_create:
 tttentid=entityelement(e).bankindex
 if entityprofile(tttentid).characterinstancingmode=0
  rem no instancing
  ttentobj=entitybankoffset+tttentid
  clone object obj,ttentobj,1
  rem 040807 - need to be part of scene culling otherwise massive slowdown
  attach object to static obj
  rem Prepare a master entity object (scale,fixnewy,loop,pos,offsetlimb)
  coreobj=obj : coreentid=tttentid : gosub _entity_coreobjectsetup
  rem apply texture from array, if available
  if entityprofile(tttentid).usetexturearrayforentity>0
   if entityelementtexarrayindex(e)>=0
    rem X10 partial _D texture arrays used
    texture object obj,0,entityelementtexarrayindex(e)
    if entityprofile(tttentid).tex1id=0
     rem X10 full texture arrays used
     texture object obj,1,entityelementtexarrayindex(e)
     texture object obj,2,entityelementtexarrayindex(e)
    endif
   endif
  endif
 else
  entityelementusingode(e)=0
  entityelementwhichslot(e)=-1
  tttentid=entityelement(e).bankindex
  if entityprofile(tttentid).slotcloneobj>0
   gosub _slot_play_from_slot
  endif
 endif
return

_slot_playframe:
 tttentid=entityelement(e).bankindex
 if entityprofile(tttentid).characterinstancingmode=0
  rem no instancing speed test
  rem do nothing when frame change requested for now
 else
  rem does not play frame, simply sets the correct parentslot
  rem gets e and obj, and ''playframeanimset''
  if entityprofile(tttentid).slotcloneobj>0
   rem playframeanimset=-1 = special trigger, make object a clone and free slot
   rem only if a parent slot managed entity
   animslottype=playframeanimset
   tuseslot=entityelementwhichslot(e)
   if tuseslot>=0
    currentanimtype=entityprofileslot(tuseslot)
    if animslottype<>currentanimtype
     gosub _slot_play_from_slot
     parentslotjustcreated=1
    endif
   else
    rem currently a clone, try to play using regular parentslot resource
    if noslots=0
     gosub _slot_play_from_slot
     parentslotjustcreated=1
    endif
   endif
  endif
 endif
return

_slot_onlyifslotunique:
 `
 rem takes E from AI.dba, only needed for instanced based entities
 tokay=0
 if entityprofile(entid).characterinstancingmode=1
  rem when reload, ifweapon=0 must also ensure that instanced entities
  rem do not share the reload animation (same goes for other non-sharables)
  for onlyifs=0 to entityprofileslotclonequantity-1
   if entityprofileslot(onlyifs)=animslottype
    tokay=1
    exit
   endif
  next onlyifs
 else
  rem Also deny a non-instanced reload based on some random value
  rem so mass-characters all reload at slightly different times
  rem X10 - 131007 - changed from <190 as this was only 1 in 20 of being unique?!?
  if rnd(200)<150 then tokay=1
 endif
 `
return

_slot_play_from_slot:
 `
 rem if instance already using slot, remove it
 if entityelementwhichslot(e)<>-1
  gosub _slot_end_slot_use
 endif
 `
 rem only if looking for new slot
 if animslottype<>-1
  rem look for slot type
  useslot=-1
  for s=0 to entityprofileslotclonequantity-1
   if entityprofileslot(s)=animslottype
    useslot=s
    exit
   endif
  next s
  if useslot=-1
   rem use a new slot
   for s=0 to entityprofileslotclonequantity-1
    if entityprofileslot(s)=0
     useslot=s
     entityprofileslot(useslot)=animslottype
     exit
    endif
   next s
  endif
  if useslot<>-1
   rem find new or existing slot to run animation from
   noslots=0
  else
   rem no more anim resources, so use clone
   noslots=1
  endif
 else
  rem not looking for slot, want to force a clone (corpse/collapse?)
  noslots=1
 endif
 gosub _slot_make_new
 `
return

_slot_make_new:
 `
 rem if no slots left, just wait until one is free
 rem destroy if exists (but not if no slots to use)
 if object exist(obj)=1 and noslots=0
  ox#=object position x(obj)
  oy#=object position y(obj)
  oz#=object position z(obj)
  ry#=object angle y(obj)
  if entityelementusingode(e)>0
   ttobj=obj : gosub _physics_destroyjustragdoll
   entityelementusingode(e)=0
   if ragdollcountingame>0 then dec ragdollcountingame
  endif
  rem 090807 - ensure remove old objects from culling system
  detach object from static obj : delete object obj
 endif
 `
 rem create new instance from new parent slot
 whotoanimateobj=0
 if noslots=1 
  if 0
   `ttentobj=entitybankoffset+tttentid
   `clone object obj,ttentobj,1
   `texture object obj,0,entityelementtexarrayindex(e)
   `if entityprofile(tttentid).tex1id=0
   ` rem X10 full texture arrays used
   ` texture object obj,1,entityelementtexarrayindex(e)
   ` texture object obj,2,entityelementtexarrayindex(e)
   `endif
   `whotoanimateobj=obj
   `entityelementwhichslot(e)=-1
   `tscobj=obj : gosub _slot_prepareclone
  else
   rem keep using current object but free from slot
   whotoanimateobj=obj
  endif
 else
  rem X10 GPU Instancing (with texture array ID)
  rem there is an initial slowdown hit when first instance a new parent
  rem can defeat this by hitting the instance object for each parent at start of game
  instance object obj,entityprofile(tttentid).slotcloneobj+useslot,entityelementtexarrayindex(e)
  rem 040807 - need to be part of scene culling otherwise massive slowdown
  attach object to static obj 
  whotoanimateobj=entityprofile(tttentid).slotcloneobj+useslot
  entityprofileslotref(useslot)=entityprofileslotref(useslot)+1
  entityelementwhichslot(e)=useslot
  rem this gets wiped when delete/instance
  if entityprofile(tttentid).scale<30
   rem X10 - V109 - 160309 - avoids cull bug for very large objects out of view (offset)
   set object radius obj,0
  else
   set object radius obj,lastentityshadowlength#(e)
  endif
 endif
 position object obj,ox#,oy#,oz#
 set object collision off obj
 yrotate object obj,ry#
 `
 rem animate parent slot for new animation
 entityelementwhichobj(e)=whotoanimateobj
 `
return

_slot_prepareclone:
 rem tscobj=entityprofile().slotcloneobj+o
 set object collision off tscobj
 set object speed tscobj,1
 tmintransmode=entityprofile(entid).transparency
 if tmintransmode<2 then tmintransmode=2
 set object transparency tscobj,tmintransmode
 show object tscobj
return

_slot_end_slot_use:
 `
 tttentid=entityelement(e).bankindex
 if entityprofile(tttentid).slotcloneobj>0
  useslot=entityelementwhichslot(e)
  if useslot>=0
   entityelementwhichslot(e)=-1
   entityprofileslotref(useslot)=entityprofileslotref(useslot)-1
   if entityprofileslotref(useslot)<=0
    rem free slot so can be used a new
    entityprofileslotref(useslot)=0
    entityprofileslot(useslot)=0
    rem stop animation to save CPU time
    stop object entityprofile(tttentid).slotcloneobj+useslot
   endif
  endif
 endif
 `
return

_slot_ode_collapse:
 `
 rem entity id
 tttentid=entityelement(e).bankindex
 `
 rem gather exit info
 if object exist(obj)=1
  ox#=object position x(obj)
  oy#=object position y(obj)
  oz#=object position z(obj)
  ry#=object angle y(obj)
  if entityprofile(tttentid).characterinstancingmode=1
   useslot=entityelementwhichslot(e)
   if useslot>=0
    ff#=object frame(entityprofile(tttentid).slotcloneobj+useslot)
   else
    ff#=object frame(obj)
   endif
  else
   ff#=object frame(obj)
  endif
 endif
 `
 rem if instance already using slot, remove it
 if entityelementwhichslot(e)<>-1
  gosub _slot_end_slot_use
 endif
 `
 rem entitiy has no slot (clone)
 entityelementwhichslot(e)=-1
 `
 rem destroy if exists
 if object exist(obj)=1
  if entityelementusingode(e)>0
   ttobj=obj : gosub _physics_destroyjustragdoll
   entityelementusingode(e)=0
   if ragdollcountingame>0 then dec ragdollcountingame
  endif
  rem 090807 - ensure remove old objects from culling system
  `101007 - respawn speed - detach object from static obj : delete object obj
  detach object from static obj : hide object obj
 endif
 `
 ttentobj=entitybankoffset+tttentid
 rem 030707 - move the CLONE operation to a pre-game step
 rem so the clone activity does not slow down the game smoothness
 preclonedcorpseobj=preclonedcorpseobjbase+e
 entityelement(e).obj=preclonedcorpseobj
 obj=entityelement(e).obj
 show object obj
 rem X10 - 241007 - old ragdolls must be re-integrated for full update work
 exclude object off obj
 if entityprofile(tttentid).usetexturearrayforentity>0
  if entityelementtexarrayindex(e)>=0
   rem X10 partial _D texture arrays used
   texture object obj,0,entityelementtexarrayindex(e)
   if entityprofile(tttentid).tex1id=0
    rem X10 full texture arrays used
    texture object obj,1,entityelementtexarrayindex(e)
    texture object obj,2,entityelementtexarrayindex(e)
   endif
  endif
 endif
 offset limb obj,0,0,0,0
 oy#=oy#-(object size y(obj)/2)
 set object collision off obj
 yrotate object obj,ry#
 `
 rem X10 - V109 - 120309 - account for scale and raise object out of floor
 tscaleprop#=(100-entityprofile(tttentid).scale)/100.0
 traisefromfloor#=3.0+((object size y(obj)/2)*tscaleprop#)
 `
 rem Raise object slightly so feet not sticking in floor
 `position object obj,ox#,oy#+3,oz#
 position object obj,ox#,oy#+traisefromfloor#,oz#
 `
 rem X10 new parameter, 3 will force an immediate frame data
 rem update and take into account the world position of the object!
 set object frame obj,ff#,3
 `
 rem V109 - 110209 - return scaling feature to X10
 tscale=entityprofile(tttentid).scale
 if tscale<>0 then scale object obj,tscale,tscale,tscale
 `
 rem make entity collapse with clone (0.6 recommended by Paul)
 gosub _physics_createragdoll
 `
 tobj=obj : gosub _physics_ensurephysicsobjvalid
 inc ragdollcountingame
 phyobjele(obj)=e
 `
 rem then apply a force equal to the force that created the ragdoll
 if entityelement(e).force.active<>0
  tforce#=entityelement(e).force.active
  if tforce#<10 then tforce#=10
  if tforce#>700 then tforce#=700
  tdx#=entityelement(e).force.ix*tforce#*0.1
  tdy#=entityelement(e).force.iy*tforce#*0.1
  tdz#=entityelement(e).force.iz*tforce#*0.1
  tda1#=wrapvalue(atanfull(tdx#,tdz#))
  if tda1#>180 then tda1#=tda1#-360
  gosub _physics_limitforce
  tdx1#=tdx#*1.1 : tdy1#=tdy#*1.1 : tdz1#=tdz#*1.1
  if tdy#<0 then tdy#=0
  rem can be larger force for larger objects (characters)
  tdx#=entityelement(e).x-entityelement(e).force.originx
  tdy#=entityelement(e).y-entityelement(e).force.originy
  tdz#=entityelement(e).z-entityelement(e).force.originz
  tda2#=wrapvalue(atanfull(tdx#,tdz#))
  if tda2#>180 then tda2#=tda2#-360
  tda#=tda2#-tda1#
  rem ragdoll is forced back and spun based on force/origin angle and force direction
  if tda#<-20.0 then tda#=-20.0
  if tda#>20.0 then tda#=20.0
  ode set angular velocity obj,0,tda#/2.0,0
  ode set linear velocity obj,tdx1#*4,(tdy1#)-40,tdz1#*4 : rem magnify to set max. impact force ratio
  entityelement(e).force.active=0
 endif
 `
 rem X10 even though ragdoll force may move it, we place an undesirable flag
 rem down in the AI to avoid corpse standing, and to make the enemy aware
 rem of places they should not hang around
 entityelement(e).eleprof.aiss.corpsecontainer=((oy#+5.0)/100.0)
 entityelement(e).eleprof.aiss.corpsex=ox#
 entityelement(e).eleprof.aiss.corpsez=oz#
 if entityelement(e).eleprof.aiss.corpsecontainer>=0 and entityelement(e).eleprof.aiss.corpsecontainer<20
  AI SET UNDESIRABLE GRID SPACE entityelement(e).eleprof.aiss.corpsecontainer,entityelement(e).eleprof.aiss.corpsex,entityelement(e).eleprof.aiss.corpsez
 else
  entityelement(e).eleprof.aiss.corpsecontainer=-1
 endif
 `
 rem record position at time of ragdoll 
 entityelement(e).x=ox#
 entityelement(e).y=oy#
 entityelement(e).z=oz#
 `
 rem gravity on
 gosub _physics_gravityon
 `
 rem set this entity as a rag doll
 entityelement(e).active=0
 entityelementusingode(e)=100
 `
return

`
` FUNCTION TO FIND ENTITY ELEMENT INDEX FROM OBJ VALUE
`
function findentityfromobj(objclicked)
 entitytoselect=0
 for e=1 to entityelementlist
  if objclicked=entityelement(e).obj
   entitytoselect=e : exit
  endif
 next e
endfunction entitytoselect

`
` FUNCTION TO FIND ALL TEXTURES IN MODEL FILE (for file collection)
`
function findmaterialtexturesinmodelfile(file$,texpath$)
 `
 rem V110 - NOTE - ONLY works with X TEXT files!!
 rem To determine if a model file requires
 rem texture files, we scan the file for a
 rem match to the text .TGA or .JPG (and use texfile$)
 returntexfile$=""
 if file exist(file$)=1
 filesize=file size(file$)
 mbi=255
 open to read 11,file$
 make memblock from file mbi,11
 close file 11
 for b=0 to filesize-1
  if memblock byte(mbi,b+0)=asc(".")
   `
   tfoundpiccy=0
   if memblock byte(mbi,b+1)=asc("T") or memblock byte(mbi,b+1)=asc("t")
    if memblock byte(mbi,b+2)=asc("G") or memblock byte(mbi,b+2)=asc("g")
     if memblock byte(mbi,b+3)=asc("A") or memblock byte(mbi,b+3)=asc("a")
      tfoundpiccy=1
     endif
    endif
   endif
   if memblock byte(mbi,b+1)=asc("J") or memblock byte(mbi,b+1)=asc("j")
    if memblock byte(mbi,b+2)=asc("P") or memblock byte(mbi,b+2)=asc("p")
     if memblock byte(mbi,b+3)=asc("G") or memblock byte(mbi,b+3)=asc("g")
      tfoundpiccy=1
     endif
    endif
   endif
   `
   if tfoundpiccy=1
      rem trace back
      for c=b to b-255 step -1
       if memblock byte(mbi,c)>=asc(" ") and memblock byte(mbi,c)<=asc("z") and memblock byte(mbi,c)<>34
        rem part of filename
       else
        rem no more filename
        exit
       endif
      next c
      texfile$=""
      for d=c+1 to b+3
       texfile$=texfile$+chr$(memblock byte(mbi,d))
      next d
      addfiletocollection(texpath$+texfile$)
      if returntexfile$="" then returntexfile$=texpath$+texfile$
      inc b,4
   endif
   `
  endif
 next b
 delete memblock mbi
 endif
 `
endfunction returntexfile$


rem
rem MAP FILE FORMAT
rem

`
` Blank New
`

_mapfile_newmap:
 `
 rem Free arrays
 undim map()
 undim mapolay()
 undim olaylist()
 `
 rem Defaults
 layermax=20 : maxx=40 : maxy=40
 olaylistmax=100
 `
 rem Create arrays
 dim map(layermax,maxx,maxy)
 dim mapolay(layermax,maxx,maxy)
 dim olaylist(olaylistmax,50) as DWORD
 `
return

`
` Get volume values from level1 (for final games)
`

_mapfile_gettitleandloadingvolumes:
 `
 rem Extract level1 to folder
 levelmapptah$=myownrootdir$+"levelbank\testlevel\"
 gosub _mapfile_load_fpl
 `
 rem Now level is extracted, load header
 levelmapptah$=myownrootdir$+"levelbank\testlevel\"
 gosub _mapfile_loadmap
 ` 
 rem Get volume values (sets hudmusicvolume before enter FPI system)
 globaltitlepagevolume=volumemeter(0)
 globalloadingpagevolume=volumemeter(1)
 `
 rem reset variables to ensure non interference
 projectfilename$=""
 levelmapptah$=""
 `
return

`
` Load
`

_mapfile_loadmap:
 `
 rem Free arrays
 undim map()
 undim mapolay()
 undim olaylist()
 `
 rem Load header data (need main mapdata for visdata)
 filename$=levelmapptah$+"header.dat"
 if file exist(filename$)=1
  if file size(filename$)=16
   rem V-EA Header
   open to read 1,filename$
    read file 1,layermax
    read file 1,maxx
    read file 1,maxy
    read file 1,olaylistmax
   close file 1
  endif
  if file size(filename$)=32
   rem V-V1 Header
   open to read 1,filename$
    read file 1,layermax
    read file 1,maxx
    read file 1,maxy
    read file 1,olaylistmax
    read file 1,gmultiplayergame
    read file 1,temp
    read file 1,temp
    read file 1,temp
   close file 1
  endif
  if file size(filename$)>32
   rem X10 versioning
   usewaterlevelfromprevioussession#=-1
   open to read 1,filename$
    rem version number
    read file 1,x10headerversion
    rem standard
    read file 1,layermax
    read file 1,maxx
    read file 1,maxy
    read file 1,olaylistmax
    read file 1,gmultiplayergame
    read file 1,temp
    read file 1,temp
    read file 1,temp
    rem extra data
    if x10headerversion>=1
     rem x10 effects and volume values
     rem strings
     read string 1,res$ 
     read string 1,res$
     read string 1,res$
     read string 1,res$
     read string 1,res$
     rem x10effects
     for t=0 to 19
      read file 1,a : x10effectmenu(t)=a
     next t
     rem volumes
     for t=0 to 4
      read file 1,a : volumemeter(t)=a
     next t
     rem V110 - 140110 - feed volume data into soundvolumes (for initial player and entity scripts)
     if volumemeter(3)>0
      soundvolumes(0)=80+(volumemeter(3)/5)
     else
      soundvolumes(0)=0
     endif
     if volumemeter(4)>0
      soundvolumes(1)=80+(volumemeter(4)/5)
     else
      soundvolumes(1)=0
     endif    
     rem reserved
     read file 1,a : waterlevel#=a : usewaterlevelfromprevioussession#=waterlevel#
     read file 1,a
     read file 1,a
     read file 1,a
     read file 1,a
    endif
   close file 1
  endif
 else
  layermax=20 : maxx=40 : maxy=40
  olaylistmax=100
 endif
 `
 rem Create arrays
 dim map(layermax,maxx,maxy)
 dim mapolay(layermax,maxx,maxy)
 dim olaylist(olaylistmax,50) as DWORD
 `
 rem Dump main map data
 filename$=levelmapptah$+"map.fpmb"
 if file exist(filename$)=1 then load array filename$,map()
 `
 rem Dump array data
 if file exist(myownrootdir$+"mapbank\testmap\map.fpmo")=1 then load array myownrootdir$+"mapbank\testmap\map.fpmo",mapolay()
 if file exist(myownrootdir$+"mapbank\testmap\map.fpml")=1 then load array myownrootdir$+"mapbank\testmap\map.fpml",olaylist()
 `
return

`
` Save
`

_mapfile_savemap:
 `
 rem Store old folder
 old$=get dir$()
 `
 rem Enter folder
 set dir myownrootdir$+"mapbank\testmap\"
 `
 rem Clear old files out (TEMP)
 `if file exist(myownrootdir$+"map.fpmb")=1 then delete file myownrootdir$+"map.fpmb"
 `if file exist(myownrootdir$+"header.dat")=1 then delete file myownrootdir$+"header.dat"
 `if file exist(myownrootdir$+"map.fpmo")=1 then delete file myownrootdir$+"map.fpmo"
 `if file exist(myownrootdir$+"map.fpml")=1 then delete file myownrootdir$+"map.fpml"
 if file exist("map.fpmb")=1 then delete file "map.fpmb"
 if file exist("header.dat")=1 then delete file "header.dat"
 if file exist("map.fpmo")=1 then delete file "map.fpmo"
 if file exist("map.fpml")=1 then delete file "map.fpml"
 `
 rem Restore
 set dir old$
 `
 rem header file write
 headername$="header.dat" : gosub _mapfile_savemap_justheader
 `
 rem Enter folder
 set dir myownrootdir$+"mapbank\testmap\"
 `
 rem Dump array data
 save array "map.fpmb",map()
 save array "map.fpmo",mapolay()
 save array "map.fpml",olaylist()
 `
 rem Restore
 set dir old$
 `
return

_mapfile_savemap_justheader:
 `
 rem Store old folder
 old$=get dir$()
 `
 rem Enter folder
 set dir myownrootdir$+"mapbank\testmap\"
 `
 rem used by test game to save the settings from the menus
 rem X10 version header (contains values from testgame menus)
 x10headerversion=1
 `
 rem Create header file
 if file exist(headername$)=1 then delete file headername$
 open to write 1,headername$
  `
  rem X10 version number
  if x10headerversion>0
   write file 1,x10headerversion
  endif
  `
  rem EA
  write file 1,layermax
  write file 1,maxx
  write file 1,maxy
  write file 1,olaylistmax
  `
  rem V1
  write file 1,gmultiplayergame
  write file 1,0
  write file 1,0
  write file 1,0
  `
  rem X10 versioning
  if x10headerversion>=1
   rem strings
   write string 1,""
   write string 1,""
   write string 1,""
   write string 1,""
   write string 1,""
   rem x10effects
   for t=0 to 19
    a=x10effectmenu(t) : write file 1,a
   next t
   rem volumes
   for t=0 to 4
    a=volumemeter(t) : write file 1,a
   next t
   rem reserved
   rem X10 - 071007 - only manual water level change can change it for level data
   if usewaterlevelfromprevioussession#<>-1
    rem if water was not manually altered (and usewaterlevelfromprevioussession# set to -1)
    rem restore it to the original water level from session before test game
    waterlevel#=usewaterlevelfromprevioussession#
   endif
   a=waterlevel# : write file 1,a
   write file 1,0
   write file 1,0
   write file 1,0
   write file 1,0
  endif
  `
 rem end of header
 close file 1
 `
 rem Restore
 set dir old$
 `
return

`
` ProjectFilename FPM Saver (ZIP)
`

_mapfile_saveproject_fpm:
 `
 rem Delete any olf file
 if file exist(projectfilename$)=1 then delete file projectfilename$
 `
 rem Copy CFG to testgame area for saving with other files
 rem 240907 - changed from get dir$() to myownrootdir$
 tttfile$="cfg.cfg"
 if file exist(myownrootdir$+"\editors\gridedit\"+tttfile$)=1
  if file exist(myownrootdir$+"mapbank\testmap\"+tttfile$)=1 then delete file myownrootdir$+"mapbank\testmap\"+tttfile$
  copy file myownrootdir$+"\editors\gridedit\"+tttfile$,myownrootdir$+"mapbank\testmap\"+tttfile$
 endif
 `
 rem Create a FPM (zipfile)
 create file block 1, projectfilename$
 set file block key 1, "mypassword"
 told$=get dir$()
 set dir myownrootdir$
 set dir "mapbank\testmap\"
 add file to block 1, "header.dat"
 add file to block 1, "map.ele"
 add file to block 1, "map.ent"
 add file to block 1, "map.seg"
 add file to block 1, "map.way"
 add file to block 1, "map.fpmb"
 add file to block 1, "map.fpmo"
 add file to block 1, "map.fpml"
 add file to block 1, "cfg.cfg"
 set dir "..\.."
 set dir told$ 
 save file block 1
 `
return

_mapfile_loadgamemap_fpm:
 `
 rem FPM for level loaded into mapbank\testmap
 projectfilename$=myownrootdir$+"\"+level$(level).fpm$
 `
 rem Load the FPM
 gosub _mapfile_loadproject_fpm
 `
return

_mapfile_loadproject_fpm:
 `
 rem Ensure FPM exists
 if file exist(projectfilename$)=1
  `
  rem Store and switch folders
  tdirst$=get dir$() : set dir myownrootdir$+"mapbank\testmap\"
  `
  rem Delete key testmap file (if any)
  if file exist("header.dat")=1
   delete file "header.dat"
  endif
  `
  rem Retore folder to Files (for extraction)
  set dir tdirst$
  `
  rem Read FPM into testmap area
  open file block projectfilename$,1,"mypassword"
  perform checklist for file block data 1
  tpath$=myownrootdir$+"mapbank\testmap\"
  for i = 1 to checklist quantity( )
   extract file from block 1, checklist string$( i ), tpath$
  next i
  close file block 1
  `
  rem If file still not present, extraction failed
  set dir myownrootdir$+"\mapbank\testmap\"
  if file exist("header.dat")=0
   rem inform user the FPM could not be loaded (corrupt file)
   tloadsuccessfully=0
  endif
  `
  rem X10 if replacement header exists (from test game save), use that instead
  rem or header being loaded, replacing it via a rename
  if file exist("header(new).dat")=1
   if file exist("header.dat")=1
    delete file "header.dat"
    rename file "header(new).dat","header.dat"
   endif
  endif  
  `
  rem if CFG file present, copy to editor folder for later use (stores FPG for us)
  rem 240907 - changed get dir$() to myownrootdir$
  if tloadsuccessfully=1
   tttfile$="cfg.cfg"
   if file exist(tttfile$)=1
    if file exist(myownrootdir$+"\editors\gridedit\"+tttfile$)=1 then delete file myownrootdir$+"\editors\gridedit\"+tttfile$
    copy file tttfile$,myownrootdir$+"\editors\gridedit\"+tttfile$
   endif
  endif
  `
  rem Retore and switch folders
  set dir tdirst$
  `
 else
  tloadsuccessfully=0
 endif
 `
return

_mapfile_save_fpl:
 `
 rem Delete any old file before saving
 told$=get dir$()
 set dir myownrootdir$
 levelfilename$="levelbank\level"+str$(level)+".zip"
 if file exist(levelfilename$)=1 then delete file levelfilename$
 create file block 1, levelfilename$
 set file block key 1, "mypassword"
 set dir "levelbank\testlevel\"
 add file to block 1, "header.dat"
 add file to block 1, "map.ent"
 add file to block 1, "map.way"
 add file to block 1, "map.fpmb"
 if 1
  for t=0 to 19
   tblockfile$="map"+str$(t)+".obs"
   add file to block 1, tblockfile$
  next t 
 else
  add file to block 1, "map.obs"
  add file to block 1, "map.obsh"
 endif
 add file to block 1, "universe.eff"
 add file to block 1, "universe.dbo"
 add file to block 1, "universephy.dbo"
 add file to block 1, "universe.dbu"
 add file to block 1, "universe.ele"
 add file to block 1, "universe.lgt"
 tdds=0
 while tdds<65535
  if file exist("lightmaps\"+str$(tdds)+".dds")=1
   add file to block 1,"lightmaps\"+str$(tdds)+".dds"
  else
   if file exist("lightmaps\"+str$(tdds)+".png")=1
    add file to block 1,"lightmaps\"+str$(tdds)+".png"
   else
    exit
   endif
  endif
  inc tdds
 endwhile
 set dir "..\.."
 save file block 1
 set dir told$
 addfiletocollection(levelfilename$)
 `
return

_mapfile_load_fpl:
 `
 rem Load if exists
 levelfilename$=myownrootdir$+"levelbank\level"+str$(level)+".zip"
 if file exist(levelfilename$)=1
  `
  rem Read FPL into testlevel area
  open file block levelfilename$,1,"mypassword"
  perform checklist for file block data 1
  tpath$=myownrootdir$+"levelbank\testlevel\"
  for i = 1 to checklist quantity( )
   extract file from block 1, checklist string$( i ), tpath$
  next i
  close file block 1
  `
 endif
 `
return



rem
rem GAMEFLOW (DEFAULT PIPELINE FOR FPSC-V1)
rem

_gameflow_default:
 `
 rem Test Game Mode - hide camera until ready
 if gtestgamemodefromeditor=1
  gtestgamemodefromeditorokaypressed=0
  set camera view playercam,0,0,1,1
  rem Ready With Test Game Engine
  open file map 1, "FPSTESTGAMEDIALOG"
  wait for file map event 1
  if get file map dword( 1, 0 ) = 1
   set file map dword 1, 12, 1
   set file map string$ 1, 1000, strarr$(377)
   wait for file map event 1
   while get file map dword ( 1, 12 ) = 1
    wait for file map event 1
   endwhile
  endif
  close file map 1
 endif
 rem Build Executable Game Mode
 if gcompilestandaloneexe=1
  rem Ready With Build Game Engine
  open file map 1, "FPSBUILDGAME"
  set file map dword 1, 40, 12
  set file map dword 1, 44, 1
  set file map string$ 1, 1000, strarr$(378)
  wait for file map event 1
  while get file map dword ( 1, 44 ) = 1
   wait for file map event 1
  endwhile
  close file map 1
 endif
 `
 rem X10 effects menu assets
 tfile$="gamecore\huds\border.png" : load image tfile$,x10effectmenuimagestart+0 : addfiletocollection(tfile$)
 tfile$="gamecore\huds\bar.png" : load image tfile$,x10effectmenuimagestart+1 : addfiletocollection(tfile$)
 tfile$="gamecore\huds\colorbar.png" : load image tfile$,x10effectmenuimagestart+2 : addfiletocollection(tfile$)
 tfile$="gamecore\huds\colorbar.dat" : load array tfile$,hudcolorbar() : addfiletocollection(tfile$)
 hudcolorbar(0)=rgb(255,255,255) 
 tfile$="gamecore\huds\handle.png" : load image tfile$,x10effectmenuimagestart+3 : addfiletocollection(tfile$)
 tfile$="gamecore\huds\bar.png" : load image tfile$,x10effectmenuimagestart+4 : addfiletocollection(tfile$)
 sprite x10effectmenuimagestart+0,-10000,-10000,x10effectmenuimagestart+0
 sprite x10effectmenuimagestart+1,-10000,-10000,x10effectmenuimagestart+1
 sprite x10effectmenuimagestart+2,-10000,-10000,x10effectmenuimagestart+2
 sprite x10effectmenuimagestart+3,-10000,-10000,x10effectmenuimagestart+3
 sprite x10effectmenuimagestart+4,-10000,-10000,x10effectmenuimagestart+4
 size sprite x10effectmenuimagestart+1,204,7
 size sprite x10effectmenuimagestart+2,204,7
 size sprite x10effectmenuimagestart+3,19,19
 size sprite x10effectmenuimagestart+4,24,20
 set sprite alpha x10effectmenuimagestart+0,255
 set sprite alpha x10effectmenuimagestart+1,210
 set sprite alpha x10effectmenuimagestart+2,210
 set sprite alpha x10effectmenuimagestart+3,255
 set sprite alpha x10effectmenuimagestart+4,255 
 `
 rem X10 label texts
 for t=0 to 16
  if t=0 then t$="skyvalue.png"
  if t=1 then t$="ambientlight.png"
  if t=2 then t$="fogcolor.png"
  if t=3 then t$="fogrange.png"
  if t=4 then t$="bloomsize.png"
  if t=5 then t$="bloomstrength.png"
  if t=6 then t$="waterspeed.png"
  if t=7 then t$="watersmoothness.png"
  if t=8 then t$="watercolor.png"
  if t=9 then t$="underwatercolor.png"
  if t=10 then t$="waterreflectivity.png"
  if t=11 then t$="waterrefractivity.png"
  if t=12 then t$="waterfresnelterm.png"
  if t=13 then t$="waterlevel.png"
  if t=14 then t$="shadowstrength.png"
  if t=15 then t$="shadowquantity.png"
  if t=16 then t$="windowrefractivity.png"
  tfile$="languagebank\"+language$+"\gamecore\huds\"+t$
  load image tfile$,x10effectmenuimagestart+5+t : addfiletocollection(tfile$)
  sprite x10effectmenuimagestart+5+t,-10000,-10000,x10effectmenuimagestart+5+t
  size sprite x10effectmenuimagestart+5+t,128,8
  set sprite alpha x10effectmenuimagestart+5+t,255
 next t
 `
 rem Load numerics for X10 effect menu
 tfile$="gamecore\huds\numeric3.png" : load image tfile$,x10effectmenuimagestart+31 : addfiletocollection(tfile$)
 `
 rem Record Icon
 tfile$="gamecore\huds\R-icon.png" : load image tfile$,x10effectmenuimagestart+32 : addfiletocollection(tfile$)
 sprite x10effectmenuimagestart+32,-10000,-10000,x10effectmenuimagestart+32
 set sprite alpha x10effectmenuimagestart+32,255
 size sprite x10effectmenuimagestart+32,16,16
 `
 rem Resource Meter Assets
 img=x10effectmenuimagestart+33
 tfile$="languagebank\"+language$+"\gamecore\huds\"
 if file exist(tfile$+"resmeter\resource-panel.png")=1
  load image tfile$+"resmeter\resource-panel.png",img+1
  load image tfile$+"resmeter\glass-tube.png",img+2
  sprite img+1,-10000,-10000,img+1
  sprite img+2,-10000,-10000,img+2
  size sprite img+1,238,335
  size sprite img+2,207,14
  imgbase=img+3
  for rmi=0 to 4
   if rmi=0 then t$="yellow" : n$="label-polygons.png"
   if rmi=1 then t$="green" : n$="label-physics.png"
   if rmi=2 then t$="blue" : n$="label-ai.png"
   if rmi=3 then t$="red" : n$="label-entity.png"
   if rmi=4 then t$="orange" : n$="label-memory.png"
   load image tfile$+"resmeter\"+n$,imgbase+0,1 : sprite imgbase+0,-10000,-10000,imgbase+0
   load image tfile$+"resmeter\bar-"+t$+"-start.png",imgbase+1,1 : sprite imgbase+1,-10000,-10000,imgbase+1
   load image tfile$+"resmeter\bar-"+t$+".png",imgbase+2,1 : sprite imgbase+2,-10000,-10000,imgbase+2
   load image tfile$+"resmeter\bar-"+t$+"-end.png",imgbase+3,1 : sprite imgbase+3,-10000,-10000,imgbase+3
   size sprite imgbase+0,150,8
   size sprite imgbase+1,5,10
   size sprite imgbase+2,10,10
   size sprite imgbase+3,5,10
   inc imgbase,4
  next rmi
 endif
 `
 rem Volume Menu Assets
 img=x10effectmenuimagestart+56
 tfile$="languagebank\"+language$+"\gamecore\huds\"
 load image tfile$+"volumes\volume-panel.png",img+1
 addfiletocollection(tfile$+"volumes\volume-panel.png")
 sprite img+1,-10000,-10000,img+1
 size sprite img+1,238,255
 imgbase=img+2
 for rmi=0 to 4
  if rmi=0 then n$="label-titlemusic.png"
  if rmi=1 then n$="label-loadingmusic.png"
  if rmi=2 then n$="label-ingamemusic.png"
  if rmi=3 then n$="label-playersounds.png"
  if rmi=4 then n$="label-ingamesounds.png"
  load image tfile$+"volumes\"+n$,imgbase+0,1 : sprite imgbase+0,-10000,-10000,imgbase+0
  load image tfile$+"volumes\bar.png",imgbase+1,1 : sprite imgbase+1,-10000,-10000,imgbase+1
  load image tfile$+"volumes\handle.png",imgbase+2,1 : sprite imgbase+2,-10000,-10000,imgbase+2
  addfiletocollection(tfile$+"volumes\"+n$)
  addfiletocollection(tfile$+"volumes\bar.png")
  addfiletocollection(tfile$+"volumes\handle.png")
  size sprite imgbase+0,150,8
  size sprite imgbase+1,204,7
  size sprite imgbase+2,19,19
  inc imgbase,3
 next rmi
 ` 
 rem X10 default settings
 x10effectmenu(0)=10 : rem ambient
 x10effectmenu(1)=0 : rem fog color
 x10effectmenu(2)=50 : rem fog dist
 x10effectmenu(3)=50 : rem bloom size
 x10effectmenu(4)=25 : rem bloom str
 x10effectmenu(5)=25 : rem water speed
 x10effectmenu(6)=50 : rem water smooth
 x10effectmenu(7)=100.0/rgb(0,0,255) : rem water color
 x10effectmenu(8)=50 : rem water refl
 x10effectmenu(9)=50 : rem water refr
 x10effectmenu(10)=50 : rem water fresnel
 x10effectmenu(11)=25 : rem water level
 x10effectmenu(12)=100 : rem shadow shadow
 x10effectmenu(13)=3 : rem shadow qty
 x10effectmenu(14)=50 : rem window refr
 `
 rem App Loop
 loopapp=1
 while loopapp=1
  `
  rem Preapp Init
  gosub _ai_setkeywords
  gosub _ai_scanfornewscriptsonly
  gosub _ai_reset
  `
  rem X10 - 270907 - load level1 to get title volume and loading volume
  if grealgameviewstate=1
   gosub _mapfile_gettitleandloadingvolumes
  endif
  `
  rem Title screen
  controlSPACE=1
  controlESCAPE=1
  hudmusicvolume=globaltitlepagevolume
  if gtestgamemodefromeditor=0
   gosub _screen_title_init
  else
   gosub _screen_title_init
   aiindex=screenai : gosub _ai_getmusicactionfromscript : gvolumetitlemusic$=tfile$
   gosub _screen_close
  endif
  if grealgameviewstate=1
   continueokay=0
   while continueokay=0
    gosub _screen_control
    sync
   endwhile
  else
   rem in test mode, we are the 'host'
   if gtestgamemodefromeditor<>0 then createorjoin=1
  endif
  `
  rem Obtain title screen info (multiplayer)
  if gmultiplayergame=1
   if gtestgamemodefromeditor<>0
    rem Test Game Mode
    playername$="testarenaplr"
    ipaddress$=""
   else
    rem Scan HUD array for name [and ip]
    for hudid=1 to hudmax
     if hud(hudid).maintype=8
      if hud(hudid).typemode=21 then playername$=hud(hudid).text$ : hudhaveplayername=1
      if hud(hudid).typemode=22 then ipaddress$=hud(hudid).text$
     endif
    next hidid
   endif
   rem Early init sets up connection (if it can)
   gosub _multi_earlyinit
  endif
  `
  rem until editor has flag set when building arena exe..
  gosub _multi_assetloader
  `
  rem Close title screen
  if gtestgamemodefromeditor=0 then gosub _screen_close
  `
  rem if not quitting
  if loopapp=1
   `
   rem Set first level
   controlSPACE=1
   controlESCAPE=0
   level=1
   `
   rem Start level loop
   looplevel=1
   while looplevel=1
    `
    rem [OPTIONAL] Triggers a 'saved game' dataset to load
    if loadsavedlevel$<>""
     saveloadfile$=loadsavedlevel$
     gosub _saveload_loadgame
     saveloadfile$=""
    endif
    `
    rem Loading level
    hudmusicvolume=globalloadingpagevolume
    if gtestgamemodefromeditor=0
     gosub _screen_loading_init
    else
     gosub _screen_loading_init
     aiindex=screenai : gosub _ai_getmusicactionfromscript : gvolumeloadingmusic$=tfile$     
     gosub _screen_close
    endif   
    if grealgameviewstate=1
     gosub _screen_control
     sync
    endif
    `
    rem CORE : LOAD GAME DATA
    gosub _ai_reset
    gosub _ai_scanfornewscriptsonly
    gosub _main_game_loadgamedata
    `
    rem Only play if not building the executable
    if gcompilestandaloneexe=1
     `
     rem First action of core is to finishing loading of level
     gosub _load_game_scene
     gosub _main_game_freeleveldata
     `
     rem Review FPI screens
     gosub _screen_game_init
     gosub _screen_levelcomplete_init
     gosub _screen_gameover_init
     `
     rem Will load all levels to gather all files required for standalone
     inc level : if level>glevelmax then looplevel=0
     `
    else
     `
     rem First action of core is to finishing loading of level
     gosub _load_game_scene
     `
     rem Repeat an arema game
     repeatsamelevel=0
     repeat
      `
      rem Flag to control the repeat (multiaplayer)
      if gmultiplayergame=1
       if repeatsamelevel<>0
        rem Game has been repeated, so reset some small elements to reproduce exact restart (quicker than reload)
        gosub _multiplayer_repeatresetgame
        rem Reset flag for another new game
        repeatsamelevel=0
       else
        rem copy entire entityelement states at start (for repeat renewgame)
        tcopyorrestart=0 : gosub _gun_resetgunsettings
        tcopyorrestart=0 : gosub _entity_resetentitiestorestartstates
       endif
      endif
      `
      rem Prepare Game HUD After Loading
      gosub _screen_close
      gosub _screen_game_init
      `
      rem Give entities a blast of logic
      rem (but after HUD-creation of status-panels) (entAI adds HUDS)
      gosub _entity_blastinitentities
      `
      rem [OPTIONAL] saveload data overwrite default level settings
      if loadsavedlevel$<>""
       gosub _saveload_retrievesavedata
       loadsavedlevel$=""
      endif
      `
      rem X10 - this ensures physics calculations only start from here
      gosub _physics_ensurephysicsisreset
      `
      rem X10 - clear ghost run values ( can quit out or be killed mid-ghost run )
      if gghostrunmode=1 then ghostrunstage=0 : ghostrunmarkerindex=0
      `
      rem X10 - 071007 - capture x10 effect settings in case testgame messes them up
      if gtestgamemodefromeditor=1
       dim storex10effectmenu(20)
       for t=0 to 20 : storex10effectmenu(t)=x10effectmenu(t) : next t
      endif
      `
      rem CORE : PLAY LEVEL
      controlSPACE=0
      controlESCAPE=2
      showgamemenu=0
      levelwon=0
      startofgametime=timer()
      continueokay=0
      gamewarmupcount=30
      while continueokay=0
       if showgamemenu=0
        gosub _main_game_core
       else
        if gmultiplayergame=1 then gosub _main_game_core
        gosub _screen_control
        rem V110 - 080110 - prevent ODE jumping on game pause
        `if len(loadsavedlevel$)<2 then sync : gosub _physics_updatesmall
        if len(loadsavedlevel$)<2 then sync
        if showgamemenu=0 then ode update 0.001
       endif
      endwhile
      controlSPACE=1
      controlESCAPE=0
      `
      rem Any exit of level must terminate key events (no matter if test or real)
      if gvideofootagecapture<>0
       rem ends possible video capture (and prevents crash)
       gvideofootagecapture=0 : set capture mode 0 : ghidehudgraphics=0
      endif
      `
      rem If arena, pop up game win/lose screens (and repeat game choice)
      if gtestgamemodefromeditor<>0
       `
       rem Quick Exit from test arena mode
       repeatsamelevel=0
       `
      else
       `
       if gmultiplayergame=1
        `
        rem Stop ALL sounds from game
        for s=1 to 65535 : if sound exist(s)=1 : stop sound s : endif : next s
        `
        rem Ensure mouse button released totally
        while mouseclick()<>0 : sync : endwhile
        `
        rem X10 - 291007 - hide the HUDS that are visible (to restore later)
        gosub _ai_hud_hideandstore
        `
        rem ARENA GAME FINISHED
        rem levelwon (0-lost,1-won,2-skip)
        if levelwon=0 or levelwon=1
         if levelwon=0 then gosub _screen_gameover_init
         if levelwon=1 then gosub _screen_levelcomplete_init
         continueokay=0
         while continueokay=0
          gosub _screen_control
          sync
         endwhile
        endif
        `
        rem X10 - 291007 - show the HUDS that we hid (to restore for game session)
        gosub _ai_hud_showandrestore        
        `
        rem Absolutely leave leveloop after arena game
        looplevel=0
        `
       else
        `
        rem SINGLE PLAYER GAME FINISHED
        rem Record any player states
        gosub _player_savestate
        `
       endif
       `
      endif
      `
      rem Close down all HUDs
      gosub _screen_close
      `
     rem if AI has chosen to repeat level, repeatsamelevel will be set to 1
     until repeatsamelevel=0
     `
     rem CORE : FREE LEVEL DATA
     if gtestgamemodefromeditor<>0
      rem if test game, leave and let heap be removed entirely
      levelwon=2
      rem but multiplayer still needs freeing manually (or crash)
      if gmultiplayergame<>0 then gosub _multi_free
     else
      rem level free, or game free
      leavegamedataalone=1
      rem game free instead (removes usually retained AI and WEAPON arrays, etc)
      if levelwon=0 or levelwon=2 or (levelwon=1 and level+1>glevelmax)
       leavegamedataalone=0
      endif
      gosub _main_game_freeleveldata
     endif
     `
     rem If single player, do gameover/complete/nextlevel
     if gmultiplayergame=0
      `
      if levelwon=0
       `
       rem Game Over
       continueokay=0
       gosub _screen_gameover_init
       while continueokay=0
        gosub _screen_control
        sync
       endwhile
       gosub _screen_close
       `
       rem End level loop
       looplevel=0
       `
      endif
      if levelwon=1
       `
       rem Next level
       inc level : if level>glevelmax then levelwon=2
       `
      endif
      if levelwon=2
       `
       rem Game Complete
       if level>1 and level>glevelmax and gtestgamemodefromeditor=0
        continueokay=0
        gosub _screen_levelcomplete_init
        while continueokay=0
         gosub _screen_control
         sync
        endwhile
        gosub _screen_close
       endif
       `
       rem Level Quit - end level loop
       looplevel=0
       `
      endif
     endif
     `
    endif
    `
    rem TestGameFromEditor Mode
    if grealgameviewstate=0 and gcompilestandaloneexe=0
     rem Always terminate after the level has been won/lost
     looplevel=0 : loopapp=0
    endif
    `
   endwhile
   `
   rem QUICK-TEST-MODE : Leave after one pass
   if grealgameviewstate=0
    rem If no RESTARTING TEST GAME
    if grestarttestgame=1
     rem we want to restart
     rem lee - 230807 - will require some serious extra code to do this properly!
     loopapp=1
    else
     loopapp=0
    endif
   endif
   `
  endif
  `
 endwhile
 `
 rem Instruct Map Editor To Relaunch and Reload Settings
 if gtestgamemodefromeditor=1
  rem Inform user of potentiall ylong delay while unloading
  `x9 set current bitmap 0
  remstart 
  old X9 programmer art text prompt
  set text font "Verdana" : set text size 24 : ink rgb(255,255,255),0
  for sss=0 to 3
   center text screen width()/2,screen height()/2,strarr$(379)
   sync
  next sss
  remend
  rem X10 added now processmessages removed from syncon 
  sync off
  `
  rem X10 save header at end of test game (contains menu value settings)
  if gtestgamemodefromeditor=1
   if waterisbelowplayer=2
    rem X10 - 071007 - do not save x10 menu values (underwater transition messed them up)
    rem so restore from before we entered the test game
    for t=0 to 20 : x10effectmenu(t)=storex10effectmenu(t) : next t
   endif
  endif
  x10effectmenu(19)=1 : rem flag effect values to be retained in next session
  headername$="header(new).dat" : gosub _mapfile_savemap_justheader
  ` 
  rem TestGameFromEditor Mode
  open file map 1, "FPSEXCHANGE"
  set file map string$ 1, 1000, "bin\FPSC-MapEditor.exe"
  set file map string$ 1, 1256, "-r"
  set file map dword 1, 994, 0
  set file map dword 1, 924, 1
  wait for file map event 1
  close file map 1
  rem Terminate
  timestampactivity(0,"Test Game Delete Exit")
  end
 endif
 `
return


rem
rem SCREEN TEMPLATES
rem

`
` TITLE
`
_screen_title_init:
 aifile$=titlefpi$
 gosub _screen_init
return

`
` LOADING
`
_screen_loading_init:
 aifile$=level$(level).fpi$
 gosub _screen_init
return

`
` GAME
`
_screen_game_init:
 aifile$=setupfpi$
 gosub _screen_init
return

`
` LEVEL COMPLETE
`
_screen_levelcomplete_init:
 aifile$=gamewonfpi$
 gosub _screen_init
return

`
` GAMEOVER
`
_screen_gameover_init:
 aifile$=gameoverfpi$
 gosub _screen_init
return

`
` SCREEN INPUT CONTROL
`
_screen_init:
 `
 rem Load AIFILE for screen
 inc aiindexmaster
 dim scriptbank$(aiindexmaster)
 aiindex=aiindexmaster : scriptbank$(aiindex)=aifile$
 aidir$="" : ai$=aifile$ : gosub _ai_load
 screenai=aiindex
 `
 rem Prepare Entity Zero
 obj=0 : e=0
 if array count(entityelement())<=0
  dim entityelement(e) as entitytype
 endif
 entityelement(e).active=1
 entityelement(e).ai.state=0
 `
 rem HUD Control
 hudselectionmade=0
 `
return

_screen_control:
 `
 rem Run Global AI Script (in entity element zero)
 if screenai>0
  obj=0 : e=0 : aiindex=screenai : gosub _ai_control
  if entityelement(e).active=0
   rem FPI has been ended
   continueokay=1
  endif
 endif
 `
 rem Run Any HUD activity
 gosub _ai_hud_view
 `
return

_screen_close:
 `
 rem Terminate screen AI
 if screenai>0
  aiindex=screenai
  gosub _ai_free
  screenai=0
 endif
 `
 rem Free HUDs
 hudmax=0
 `
 rem Reset HUD dependent vars
 internalloaderhud=0
 hudfadeoutoneatatime=0
 internalloaderhud=0
 internaleyehud=0
 internalfaderhud=0
 `
return


rem
rem UNIVERSE
rem

_universe_construct_skip:
 `
 rem compare this universe with last saved universe 
 rem return flag as true if the universe is the same
 universeconstructskip=1
 `
 rem if no old file, no old data so no skip
 if file exist(myownrootdir$+"levelbank\testlevel\old.dat")=0 then universeconstructskip=0 : return
 `
 rem check static entities/lights
 open to read 1,myownrootdir$+"levelbank\testlevel\old.dat"
  read file 1,oldolaylistmax
  read file 1,oldentityelementlist
  dim oldentityelement(oldentityelementlist) as entitytype 
  for i=1 to oldentityelementlist
   read file 1,e
   if e>0
    read float 1,a# : oldentityelement(e).x=a#
    read float 1,a# : oldentityelement(e).y=a#
    read float 1,a# : oldentityelement(e).z=a#
    read float 1,a# : oldentityelement(e).rx=a#
    read float 1,a# : oldentityelement(e).ry=a#
    read float 1,a# : oldentityelement(e).rz=a#
    read float 1,a# : oldentityelement(e).eleprof.light.range=a#
    read file 1,tcolr
    read file 1,tcolg
    read file 1,tcolb
    tcol=rgb(tcolr,tcolg,tcolb)
    oldentityelement(e).eleprof.light.color=tcol
    rem current entity must be static, and be identical to old otherwise cannot skip
    if e<=entityelementlist
     if entityelement(e).staticflag=1
      if entityelement(e).x<>oldentityelement(e).x then universeconstructskip=0
      if entityelement(e).y<>oldentityelement(e).y then universeconstructskip=0
      if entityelement(e).z<>oldentityelement(e).z then universeconstructskip=0
      if entityelement(e).rx<>oldentityelement(e).rx then universeconstructskip=0
      if entityelement(e).ry<>oldentityelement(e).ry then universeconstructskip=0
      if entityelement(e).rz<>oldentityelement(e).rz then universeconstructskip=0
      if entityelement(e).eleprof.light.range<>oldentityelement(e).eleprof.light.range then universeconstructskip=0
      if entityelement(e).eleprof.light.color<>oldentityelement(e).eleprof.light.color then universeconstructskip=0
     else
      tuentid=entityelement(e).bankindex
      if entityprofile(tuentid).ismarker<>2
       universeconstructskip=0 : i=oldentityelementlist
      endif
     endif
    else
     universeconstructskip=0 : i=oldentityelementlist
    endif
   endif
  next i
  if universeconstructskip=1
   if entityelementlist>oldentityelementlist
    for e=i to entityelementlist
     rem any new static entities must be used in new construction
     if entityelement(e).staticflag=1
      universeconstructskip=0
     endif
     rem any new light entities must be used in new construction
     tuentid=entityelement(e).bankindex
     if entityprofile(tuentid).ismarker=2
      universeconstructskip=0
     endif
    next e
   endif
  endif
 close file 1  
 `
 rem check map and overlays
 if universeconstructskip=1
  dim oldmap(layermax,maxx,maxy)
  dim oldolaylist(oldolaylistmax,50) as DWORD
  load array myownrootdir$+"levelbank\testlevel\oldmap.dat",oldmap()
  load array myownrootdir$+"levelbank\testlevel\oldolaylist.dat",oldolaylist()
  for lay=0 to layermax
   for y=0 to maxy-1
    for x=0 to maxx-1
     for olay=0 to 1
      if olay=0 then tolaymax=0
      if olay=1
       tolaymax=0 : olayindex=mapolay(lay,x,y)
       while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
       dec tolaymax
      endif
      if tolaymax>=0
       for olayti=0 to tolaymax
        if olay=0 then mapid=map(lay,x,y)
        if olay=1 then mapid=olaylist(olayindex,olayti)
        if olay=0 then oldmapid=oldmap(lay,x,y)
        if olay=1 then oldmapid=oldolaylist(olayindex,olayti)
        if mapid<>oldmapid
         rem there is a difference, must not skip construction
         universeconstructskip=0
        endif
       next olayti
      endif
     next olay
    next x
   next y
  next lay
 endif
 `
 rem free usages
 undim oldentityelement()
 undim oldmap()
 undim oldolaylist()
 `
return

_universe_saveforskipcheck:
 `
 rem save map, overlay and static entity info
 rem for above check as to whether to skip universe construction
 tfile$=myownrootdir$+"levelbank\testlevel\old.dat" : if file exist(tfile$)=1 then delete file tfile$
 open to write 1,tfile$
  write file 1,olaylistmax
  write file 1,entityelementlist
  for e=1 to entityelementlist
   tuentid=entityelement(e).bankindex
   if entityelement(e).staticflag=1 or entityprofile(tuentid).ismarker=2
    write file 1,e
    write float 1,entityelement(e).x
    write float 1,entityelement(e).y
    write float 1,entityelement(e).z
    write float 1,entityelement(e).rx
    write float 1,entityelement(e).ry
    write float 1,entityelement(e).rz
    write float 1,entityelement(e).eleprof.light.range
    write file 1,rgbr(entityelement(e).eleprof.light.color)
    write file 1,rgbg(entityelement(e).eleprof.light.color)
    write file 1,rgbb(entityelement(e).eleprof.light.color)    
   else
    write file 1,0
   endif
  next e
 close file 1
 tfile$=myownrootdir$+"levelbank\testlevel\oldmap.dat" : if file exist(tfile$)=1 then delete file tfile$
 save array tfile$,map()
 tfile$=myownrootdir$+"levelbank\testlevel\oldolaylist.dat" : if file exist(tfile$)=1 then delete file tfile$
 save array tfile$,olaylist()
 `
return

_universe_construct:

rem Set size of possible node tree (cubeshaped)
set static universe maxx*100,(layermax+1)*100,maxy*100

rem Reset any lighting information
delete light map lights

rem Some global statistics for game world
totalnumberofcollisionboxes=0

rem Lightmapping
activatelightmapping=glightmappingstate
if segobjusedformapeditor=1 then activatelightmapping=0

rem Shadow maps for processing data
dim mapobj(layermax,maxx,maxy)
dim mapcsg(layermax,maxx,maxy)

rem Free old objects if any
if lastsegobj>=segobjstart then delete objects segobjstart,lastsegobj

rem Construct scene
csgpassmax=3
staticlightcount=0
for csgpass=1 to csgpassmax
`
rem debug info
if csgpass=1 then debugviewtext(200,strarr$(155))
if csgpass=2 then debugviewtext(210,strarr$(156))
if csgpass=3 then debugviewtext(220,strarr$(157))
`
rem Reset workvars
segobj=segobjstart
highesty=0
`
rem Feature to fill void with floor/landscape/horizon
if 1 and segobjusedformapeditor=0
 `
 rem Fill void tiles with floor
 if csgpass=1
  `
  rem if default floor switched on
  if gusefloorstate=1
   `
   `rem get map tile ID
   `mapid=map(0,0,0) : mapselection=1
   `if mapid>0 then gosub _gridedit_getmapvalues
   `
   rem void tile filler (automatic floor is at layer zero)
   mapselection=1
   mapscaler = 0 : mapground = 3 : maprotate = 0
   maporient = 0 : mapsymbol = 0 : maptile = 0
   gosub _universe_makemapvalues
   `
   rem get map tile ID to see if we need to override
   rem Ensure full segment info is used (otherwise floor of room becomes rooms everywhere)
   if map(0,0,0)>0 then mapid=map(0,0,0) : gosub _gridedit_getmapvalues
   `   
   floormapid=mapid : lay=0
   for y=0 to maxy-1
    for x=0 to maxx-1
     if map(lay,x,y)=0
      map(lay,x,y)=mapid
     endif
    next x
   next y
   `
   rem create horizonplanes
   gosub _universe_createhorizonplanes
   `
  endif
  `
 endif
 if csgpass>1
  rem Skip horizon objects
  if gusefloorstate=1
   inc segobj,4
  endif
 endif
 `
endif
`
rem X10 cloning timers
clonetimerlast as DWORD : clonetimerlast=0
clonetimercount as DWORD : clonetimercount=0
clonetimerrest as DWORD : clonetimerrest=0
`
rem Start traversal through universe tiles
for lay=0 to layermax
 for y=0 to maxy-1
  for x=0 to maxx-1
   for olay=0 to 1
    `
    rem MAP and MAPOLAY
    if olay=0 then tolaymax=0
    if olay=1
     tolaymax=0 : olayindex=mapolay(lay,x,y)
     while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
     dec tolaymax
    endif
    if tolaymax>=0
     `
     for olayti=0 to tolaymax
      if olay=0 then mapid=map(lay,x,y)
      if olay=1 then mapid=olaylist(olayindex,olayti)
      if mapid<>0
       `
       gosub _gridedit_getmapvalues
       if object exist(selectionbankoffset+mapselection)=1
        `
        rem Set segment identity
        seg=mapselection
        `
        rem Pass 1 - Create
        if csgpass=1
         `
         rem report progress
         if treportprogressonlayer<>lay or treportprogressonlayerslice<>y
          tproggy#=(9.0/layermax)*lay
          tdebugtiming$="CLONETIME:"+str$(clonetimercount/1000)+" REMAINDER:"+str$(clonetimerrest/1000)
          debugviewtext(201+tproggy#,"["+str$(csgpass)+"] "+strarr$(158)+str$(lay)+strarr$(159)+str$(y)+"..."+tdebugtiming$)
          treportprogressonlayer=lay : treportprogressonlayerslice=y
          clonetimercount=0
          clonetimerrest=0
         endif
         `
         rem check if segment uses CSG, in which case clone not instance
         tusingcsgforthisegment=0
         for tp=segmentprofileheader(seg).lastmeshmax to segmentprofileheader(seg).partmax
          if segmentprofile(seg,tp).partmode=1
           if segmentprofile(seg,tp).csgmode=0
            tusingcsgforthisegment=1
           endif
          endif
         next tp
         `
         rem clone for manipulation of segment
         rem 100807 - added new cloning mode for fast cloning suited to this process (,3)
         inc clonetimerrest,(perftimer()-clonetimerlast)
         clonetimerlast=perftimer()
         if ghsrmode=1
          clone object segobj,selectionbankoffset+mapselection,3
         else
          rem when instance, transparent details come from origin (not for mapeditor preview though)
          if segobjusedformapeditor=0
           set object transparency selectionbankoffset+mapselection,4
          endif
          clone object segobj,selectionbankoffset+mapselection,3
         endif
         inc clonetimercount,(perftimer()-clonetimerlast)
         clonetimerlast=perftimer()
         `
         rem setup segment for universe conversion
         set object collision off segobj
         position object segobj,50+(x*100),50+(lay*100),((y*-100)-50)
         if (100+(lay*100))>highesty then highesty=(100+(lay*100))
         mapatl=lay : mapatx=x : mapaty=y
         obj=segobj : gosub _segment_customisesinglesegment
         if olay=0 then mapobj(lay,x,y)=obj
         `
         rem initially hide all non-basic meshes
         for tlimb=segmentprofileheader(seg).lastmeshmax+1 to segmentprofileheader(seg).partmax
          if limb exist(segobj,tlimb)=1
           hide limb segobj,tlimb
          endif
         next tlimb
         `
         rem show multimesh replacements, hide base mesh in those cases
         for tlimb=0 to segmentprofileheader(seg).lastmeshmax
          tmultimesh=segmentprofile(seg,tlimb).multimeshmode
          if tmultimesh=1
           if limb visible(segobj,tlimb)=1
            if segmentprofile(seg,tlimb).multimeshstart>0
`             r=0 : rem rnd(2) hmm why did I rem this out :)
             r=rnd(2)
             if r=0 then tlimbchange=tlimb
             if r=1 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+0
             if r=2 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+1
             if limb exist(segobj,tlimbchange)=0 then tlimbchange=tlimb
             hide limb segobj,tlimb : show limb segobj,tlimbchange
            endif
           endif
          endif
         next tlimb
         `
        endif
        `
        rem Pass 2 - Add CSG, Lights and Entities
        if csgpass=2
         `
         rem add any csg punch references
         for tp=segmentprofileheader(seg).lastmeshmax to segmentprofileheader(seg).partmax
          if segmentprofile(seg,tp).partmode=1
           if segmentprofile(seg,tp).csgmode=0
            rem check boundbox of CSGPUNCH with surrounding segments
            for surrl=lay-1 to lay+1
             for surry=y-1 to y+1
              for surrx=x-1 to x+1
               if surrl>=0 and surrl<layermax
                if surry>=0 and surry<40
                 if surrx>=0 and surrx<40
                   `
                   rem for each segment-limb (not this seg though)
                   mapid=map(surrl,surrx,surry)
                   if mapid<>0
                    gosub _gridedit_getmapvalues
                    if object exist(selectionbankoffset+mapselection)=1
                     surrseg=mapselection
                     surrobj=mapobj(surrl,surrx,surry)
                     for surrlimb=0 to segmentprofileheader(surrseg).lastmeshmax
                      rem only non-immune meshes
                      if segmentprofile(surrseg,surrlimb).csgimmune=0
                       rem first ensure meshes affected by a CSG must use base mesh, not multimesh
                       if segmentprofile(surrseg,surrlimb).multimeshstart>0
                        if limb visible(surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+0)=1 or limb visible(surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+1)=1
                         show limb surrobj,surrlimb
                         hide limb surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+0
                         hide limb surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+1
                        endif
                       endif
                       rem if punch limb collides with surrounding segment-limb
                       tpactual=segmentprofile(seg,tp).actuallimb
                       if limb collision(segobj,tpactual,surrobj,surrlimb)=1 and limb visible(surrobj,surrlimb)=1
                        `
                        rem report progress
                        tproggy#=(9.0/layermax)*lay
                        debugviewtext(211+tproggy#,strarr$(160)+str$(lay)+","+str$(x)+","+str$(y))
                        `
                        rem make new limb
                        ttempobj1=lastsegobj+0
                        ttempobj2=lastsegobj+1
                        if object exist(ttempobj1)=1 then delete object ttempobj1
                        if object exist(ttempobj2)=1 then delete object ttempobj2
                        make object from limb ttempobj1,segobj,tpactual
                        make object from limb ttempobj2,surrobj,surrlimb
                        `
                        rem recreate object from CSG PUNCH MESH
                        lgx#=limb position x(segobj,tpactual)
                        lgy#=limb position y(segobj,tpactual)
                        lgz#=limb position z(segobj,tpactual)
                        position object ttempobj1,lgx#,lgy#,lgz#
                        texture object ttempobj1,segmentprofile(seg,tpactual).texid
                        `
                        rem recreate object from DEST NEIGHBOR MESH
                        lgx#=limb position x(surrobj,surrlimb)
                        lgy#=limb position y(surrobj,surrlimb)
                        lgz#=limb position z(surrobj,surrlimb)
                        position object ttempobj2,lgx#,lgy#,lgz#
                        texture object ttempobj2,segmentprofile(surrseg,surrlimb).texid
                        `
                        rem perform CSG Punch on neighboring limb now
                        perform csg difference ttempobj2,ttempobj1
                        `
`                        rem CSG meshes must cast shadows (unless flagged as off)
`                        if glightshadowsstate=1 then tshadow=3 else tshadow=0

`                        rem scene scadow casting disabled (for performance)
`                        if gdynamicshadowsstate=1 then tshadow=2
                        `
                        rem reapply effect if have one
                        `x10 applies the universe effect later on, after construction!
                        `if segmentprofile(surrseg,surrlimb).effectid>0
                        ` texture object ttempobj2,0,segmentprofile(surrseg,surrlimb).texdid
                        ` if segmentprofile(surrseg,surrlimb).texiid<>0 then texture object ttempobj2,1,segmentprofile(surrseg,surrlimb).texiid
                        ` if segmentprofile(surrseg,surrlimb).texnid<>0 then texture object ttempobj2,2,segmentprofile(surrseg,surrlimb).texnid
                        ` if segmentprofile(surrseg,surrlimb).texsid<>0 then texture object ttempobj2,3,segmentprofile(surrseg,surrlimb).texsid
                        ` set object effect ttempobj2,segmentprofile(surrseg,surrlimb).effectid
                        `endif
                        `
                        rem add new limb to node tree now (polycol after csg)
                        tarbvalue=segmentprofile(surrseg,surrlimb).material.index
                        if tarbvalue=0 then tarbvalue=1
                        set object transparency ttempobj2,4
                        make static object ttempobj2,0,tarbvalue,tshadow,1
                        `
                        rem remove temp object
                        delete object ttempobj1
                        delete object ttempobj2
                        `
                        rem hide the segment-limb
                        hide limb surrobj,surrlimb
                        `
                       endif
                      endif
                     next surrlimb
                    endif
                   endif
                   `
                 endif
                endif
               endif
              next surrx
             next surry
            next surrl
           endif
          endif
         next tp
         `
         rem restore map data
         if olay=0 then mapid=map(lay,x,y)
         if olay=1 then mapid=olaylist(olayindex,olayti)
         gosub _gridedit_getmapvalues
         `
        endif
        `
        rem Pass 3 - Add To NodeTree
        if csgpass=3
         `
         rem prepare object with HSR process
         usesegobj=0
         if ghsrmode=1
          `
          rem report progress
          tproggy#=(9.0/layermax)*lay
          debugviewtext(221+tproggy#,strarr$(161)+str$(lay)+","+str$(x)+","+str$(y))
          `
          rem create super-ground-punch (arbitary usage)
`         groundpunchobj=64998
`         if object exist(groundpunchobj)=0
`          make object box groundpunchobj,80000,100,80000
`          position object groundpunchobj,0,-50,0
`          hide object groundpunchobj
`         endif
          `
          rem check boundbox of CSGPUNCH with surrounding segments
          for surrl=lay-1 to lay+1
           for surry=y-1 to y+1
            for surrx=x-1 to x+1
             if surrl>=0 and surrl<layermax
              if surry>=0 and surry<40
               if surrx>=0 and surrx<40
                 mapid=map(surrl,surrx,surry)
                 if mapid<>0
                  gosub _gridedit_getmapvalues
                  if object exist(selectionbankoffset+mapselection)=1
                   rem object bounding object to add to universe
                   surrobj=mapobj(surrl,surrx,surry)
                   if surrobj>0
                    perform csg clip segobj,surrobj
                   endif
                  endif
                 endif
               endif
              endif
             endif
            next surrx
           next surry
          next surrl
          `
          rem Now punch out ground (arbitary usage)
`         perform csg clip segobj,groundpunchobj
          `
         endif
         `
         rem make node tree addition
         for tlimb=0 to segmentprofileheader(seg).partmax
          `
          rem only visible meshes are used to make universe
          if limb exist(segobj,tlimb)=1
          if limb visible(segobj,tlimb)=1
           `
           rem shadow all except floor,wall,ceiling (and meshes with shadow switched off)
`           if glightshadowsstate=1 then tshadow=3 else tshadow=0
`           if gdynamicshadowsstate=1 then tshadow=2

           if tlimb=segmentprofile(seg).vis.f then tshadow=0
           if tlimb=segmentprofile(seg).vis.r then tshadow=0
           if tlimb=segmentprofile(seg).vis.wb then tshadow=0
           if tlimb=segmentprofile(seg).vis.wr then tshadow=0
           if tlimb=segmentprofile(seg).vis.wf then tshadow=0
           if tlimb=segmentprofile(seg).vis.wl then tshadow=0
           if tlimb=segmentprofile(seg).vis.wl then tshadow=0
           if tlimb=segmentprofile(seg).vis.owb then tshadow=0
           if tlimb=segmentprofile(seg).vis.owr then tshadow=0
           if tlimb=segmentprofile(seg).vis.owf then tshadow=0
           if tlimb=segmentprofile(seg).vis.owl then tshadow=0
           if tlimb=segmentprofile(seg).vis.owl then tshadow=0
           if tlimb=segmentprofile(seg).vis.octl then tshadow=0
           if tlimb=segmentprofile(seg).vis.octr then tshadow=0
           if tlimb=segmentprofile(seg).vis.ocbr then tshadow=0
           if tlimb=segmentprofile(seg).vis.ocbl then tshadow=0
           `
           rem set transparency for universe add
`           set object transparency segobj,segmentprofile(seg,tlimb).transparency
`           set object transparency segobj,1 `need alpha test active (depth-sort-via-alpha-test)
           rem x10 universe deals with alphatest in shader
           `set object transparency segobj,4
           rem so we can set all segments to solid (allowing blood static entity to be recognised by lightmapper as a real transparent poly)
           set object transparency segobj,0
           `
           rem add mesh to universe
           tcolmode=segmentprofile(seg,tlimb).colmode
           tarbvalue=segmentprofile(seg,tlimb).material.index
           if segmentprofile(seg,tlimb).transparency=2 then tarbvalue=0 : rem FPSCV101 - no bullethole in trasparent(2) static
           if tcolmode=1 then inc totalnumberofcollisionboxes
           if segmentprofile(seg).vis.overlay=0
            if segmentprofile(seg).properties.kindof>0
             rem currently only corridors are true for this, and ARE ALL solid!
             rem 1straight,2corner,3tjunc,4cross,5deadend
             rem V110 - 190110 - ventilation meshes are different, so no portal culling on these!
             tsegname$=getfile(selectionbank$(seg))
             if left$(lower$(tsegname$),16)="ventilation duct"
              tportalblocker=0
             else
              tportalblocker=2
             endif
            else
             tportalblocker=1
            endif
           else
            tportalblocker=0
           endif
           make static limb segobj,tlimb,tcolmode,tarbvalue,tshadow,tportalblocker
           `
           rem X10 270807 - large corner peices should be added as extra AI obstacle
           tisacorner=0
           if tlimb=segmentprofile(seg).vis.ctl then tisacorner=1
           if tlimb=segmentprofile(seg).vis.ctr then tisacorner=1
           if tlimb=segmentprofile(seg).vis.cbr then tisacorner=1
           if tlimb=segmentprofile(seg).vis.cbl then tisacorner=1
           if tlimb=segmentprofile(seg).vis.octl then tisacorner=1
           if tlimb=segmentprofile(seg).vis.octr then tisacorner=1
           if tlimb=segmentprofile(seg).vis.ocbr then tisacorner=1
           if tlimb=segmentprofile(seg).vis.ocbl then tisacorner=1
           if tisacorner=1
            rem use segobj as temp object while we create AI OBS
            useobj=universebuildobjstartoffset-1
            make object box useobj,40,100,40
            position object useobj,limb position x(segobj,tlimb),limb position y(segobj,tlimb),limb position z(segobj,tlimb)
            AI ADD STATIC OBSTACLE useobj,1,object position y(useobj)/100.0
            delete object useobj
           endif
           `
          endif
          endif
          `
         next tlimb
         `
         rem hide original object (still used for SURROBJ HSR culling)
         hide object segobj
         `
        endif
        `
        rem PassEnd
        `
        rem Increment segment objid
        inc segobj
        `
        rem When run out of segments to build map, leave immediately
        if segobj>=universebuildobjendoffset
         rem end all loop conditions - no crash - just shortened level
         lay=layermax : y=maxy-1 : x=maxx-1
         olay=1 : olayti=tolaymax
        endif
        `
       endif
      endif
     next olayti
    endif
   next olay
  next x
 next y
next lay
`
rem When all objecta added (first pass)
if csgpass=1
 rem add a zero-size high object for top of universe (need clearance for player on roofs)
 make object box segobj,0,100,0 : position object segobj,0,highesty+50,0 : inc segobj
 rem record last segment object
 lastsegobj=segobj
endif
if csgpass=3
 if object exist(segobj)=1
  set object transparency segobj,4
  make static object segobj,0,0,0,1
  hide object segobj : inc segobj
 endif
endif
`
rem next pass
next csgpass

rem V102RC6 remove all segment objects to free up memory for next phase ( except the horizon polys )
if gusefloorstate=1 then inc segobjstart,4
if lastsegobj>=segobjstart then delete objects segobjstart,lastsegobj
if gusefloorstate=1 then dec segobjstart,4

rem FPSCV104RC7 - new lightmapper
rem FPSCV105RC1 - added new flag 'glightmappingold'
useoldlightmapper=glightmappingold
usedarklightmapper=1-glightmappingold
if usedarklightmapper=1
 rem DarkLIGHTS Settings
 LM Start
endif

rem debug info
debugviewtext(230,strarr$(162))

rem add pure static entities to node tree now
eleobj=entityobjectoffset
ttick=0 : ttickmax=entityelementlist/10 : ttickmax=1
for e=1 to entityelementlist
 obj=eleobj+e
 entid=entityelement(e).bankindex
 tentid=entityelement(e).bankindex
 if obj>0 and entid>0
  rem add static entities to node tree now (x10 excludes static characters)
  if entityelement(e).staticflag=1 and entityprofile(tentid).ischaracter=0
   inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(232,strarr$(163)+str$(e)+"/"+str$(entityelementlist)+" ("+entityprofile(tentid).model$+")")
   if entityprofile(tentid).ismarker=0
    `
    rem V110 - 080110 - ensure static entities dont mess up dynamic parent objects
    ttempobj1=lastsegobj+0
    if object exist(ttempobj1)=1 then delete object ttempobj1
    clone object ttempobj1,entitybankoffset+entid
    entityelement(e).profileobj=ttempobj1
    configureobj=ttempobj1
    `   
    rem this next routine should texture, but because entobj is zero, no, need to use OBJ!!!
    `configureobj=entitybankoffset+entid (see above)
    gosub _entity_configueelementforuse
    gosub _entity_createelementasobject
    configureobj=0
    `
    rem V110 - 080110 - and once out of config, restore ptr to parent obj
    entityelement(e).profileobj=entitybankoffset+entid
    `
    if object exist(obj)=1
     `
     rem collision mode for static entities (0-poly,1-box,2-reduced) dynamic (3-cylinder,4-sphere)
     tcolmode=2 : rem default is to use a reduced mesh
     if entityprofile(tentid).collisionmode>0 and entityprofile(tentid).collisionmode<3
      tcolmode=entityprofile(tentid).collisionmode-1
     endif
     rem static entities must cast shadows (unless flagged as off)
`     if glightshadowsstate=1 then tshadow=3 else tshadow=0
`     if gdynamicshadowsstate=1 then tshadow=2
     tarbvalue=entityprofile(tentid).materialindex
     rem always write z as alpha test ensures draw order not needed
     rem x10 static entity blood zclashes in x9 code
     `enable object zwrite obj
     if entityprofile(tentid).transparency>1
      rem transparent static entities are sorted to render in a second pass now
      set object transparency obj,4
      disable object zwrite obj
      rem disabled zwrite has a built-in zbias (for X10)
     else
      rem Most x9 entities are transparency 1, but universe treats these as solid
      set object transparency obj,0
      enable object zwrite obj
     endif
     `
     rem create static object from static entity
     useobj=obj
     make static object useobj,tcolmode,tarbvalue,tshadow,0
     rem then create an AI obstacle from the static entity (+sizey ensures if sunk into floor they still work)
     `270807AI ADD STATIC OBSTACLE useobj,1,(object position y(useobj)+5)/100.0
     taddtocontainer=(object position y(useobj)+object size y(useobj))/100.0
     rem V110 - 151209 - fixes AI container crash
     if taddtocontainer<0 then taddtocontainer=0
     if taddtocontainer>19 then taddtocontainer=19
     AI ADD STATIC OBSTACLE useobj,1,taddtocontainer
     taddtocontainer2=(object position y(useobj)+5)/100.0
     if taddtocontainer<>taddtocontainer2 and object size y(useobj)>10
      rem ensure we add OBS data for large ceiling items not already covered by above
      rem V110 - 151209 - fixes AI container crash
      if taddtocontainer2<0 then taddtocontainer2=0
      if taddtocontainer2>19 then taddtocontainer2=19
      AI ADD STATIC OBSTACLE useobj,1,taddtocontainer2
     endif
     rem then delete the un-needed static entity
     delete object useobj
     `
    endif
   endif
  endif
  rem add dynamic and static lights from entities
  if entityprofile(tentid).ismarker=2
   lgx#=entityelement(e).x
   lgy#=entityelement(e).y
   lgz#=entityelement(e).z
   lgrange#=entityelement(e).eleprof.light.range
   lgr#=rgbr(entityelement(e).eleprof.light.color)
   lgg#=rgbg(entityelement(e).eleprof.light.color)
   lgb#=rgbb(entityelement(e).eleprof.light.color)
   if entityelement(e).staticflag=0
    if gdynamiclightingstate=1
     lgtype=1 : gosub _lighting_adddynamiclight
     entityelement(e).eleprof.light.index=infinilightindex
    endif
   else
    if activatelightmapping=1
     if useoldlightmapper=1
      add light map light lgx#, lgy#, lgz#, lgrange#, lgr#, lgg#, lgb#, 100, 1
     endif
     if usedarklightmapper=1
      size# = lgrange#
      falloff# = size#/2
      radius# = size#+falloff#
      zerorange# = ( radius# * glightzerorange ) / 100.0
      atten# = glightatten / (radius#*radius#)
      outer# = 1.0 + falloff#
      brighter# = radius# / outer#
      lgr#=lgr#*brighter#
      lgg#=lgg#*brighter#
      lgb#=lgb#*brighter#
      LM Add Custom Point Light lgx#, lgy#, lgz#, radius#, zerorange#, atten#,lgr#/255.0, lgg#/255.0, lgb#/255.0
     endif
     lgtype=0 : gosub _lighting_adddynamiclight
     inc staticlightcount
    endif
    if gdynamicshadowsstate=1
     array insert at bottom shadowlight()
     shadowlight().x# = lgx#
     shadowlight().y# = lgy#
     shadowlight().z# = lgz#
     shadowlight().range# = lgrange#
    endif
   endif
  endif
 endif
next e

rem New portals section of game runner
debugviewtext(240,strarr$(164))
build static portals

rem Apply shadow lights to scene (which will compute shadows direct from node tree
if gdynamicshadowsstate=1
 debugviewtext(250,strarr$(165))
 set global shadow shades 1
 set global shadow color 0,0,0,128
` disabled scene shadows for performance reasons
` for tsli=1 to array count(shadowlight(0))
`  set shadow light tsli, shadowlight(tsli).x#, shadowlight(tsli).y#, shadowlight(tsli).z#, shadowlight(tsli).range#
` next tsli
endif

rem New lightmapping section of game runner
if activatelightmapping=1 and staticlightcount>0
 rem delete old lightmaps
 debugviewtext(259,strarr$(166))
 tl=0
 while tl<65535
  tl$=myownrootdir$+"levelbank\testlevel\lightmaps\"+str$(tl)+".dds"
  if file exist(tl$)=1 then delete file tl$ else exit
  tl$=myownrootdir$+"levelbank\testlevel\lightmaps\"+str$(tl)+".png"
  if file exist(tl$)=1 then delete file tl$ else exit
  inc tl
 endwhile
 rem add universe for lightmapping
 debugviewtext(260,strarr$(167))
 `x9if useoldlightmapper=1
 ` add static objects to light map pool
 ` debugviewtext(270,strarr$(168))
 ` if glightmapsize>0
 `  create light maps glightmapsize,glightmapquality,myownrootdir$+"levelbank\testlevel\lightmaps\"
 ` else
 `  create light maps 8,100,myownrootdir$+"levelbank\testlevel\lightmaps\"
 ` endif
 `endif
endif

rem Must be done 'after' lightmapping phase
if grealgameviewstate=0 and segobjusedformapeditor=0 and goptimizemode=1
 `
 rem Saving effects (as some scene geometry needs setting changes)
 debugviewtext(273,strarr$(169))
 filename$=myownrootdir$+"levelbank\testlevel\universe.eff"
 if file exist(filename$)=1 then delete file filename$
 open to write 1,filename$
  write file 1,effectbankmax
  for eff=1 to effectbankmax
   write string 1,effectbank$(eff)
  next eff
  write string 1,thorizonplanetex$
 close file 1
 `
 rem Builds final universe reload file (even when test game)
 debugviewtext(275,strarr$(170))
 universefile$=myownrootdir$+"levelbank\testlevel\universe.dbu" : if file exist(universefile$)=1 then delete file universefile$
 universefile$=myownrootdir$+"levelbank\testlevel\universe.dbo" : if file exist(universefile$)=1 then delete file universefile$
 save static objects universefile$
 `
 rem FPSCV104RC9 - pregenerate physics universe (faster loading)
 phyunimesh$=myownrootdir$+"levelbank\testlevel\universephy.dbo" : if file exist(phyunimesh$)=1 then delete file phyunimesh$
 universeobj=universebuildobjstartoffset-1
 load object myownrootdir$+"levelbank\testlevel\universe.dbo",universeobj
 make mesh from object universeobj,universeobj
 convert mesh to vertexdata universeobj
 delete object universeobj
 make object universeobj,universeobj,0
 delete mesh universeobj
 save object phyunimesh$,universeobj
 delete object universeobj
 `
 rem If DarkLIGHT lightmapper used
 `x9 if activatelightmapping=1 and staticlightcount>0 and usedarklightmapper=1
 if usedarklightmapper=1
  `
  rem load and lightmap static universe
  universeobj=universebuildobjstartoffset-1
  if object exist(universeobj)=1 then delete object universeobj
  load object universefile$,universeobj
  if glightshadowsstate=0
   rem Quick Lightmapping
   LM Add Collision Object universeobj
  else
   rem Full Lightmapping
   LM Add Transparent Collision Object universeobj,1
  endif
  rem 0,0,1=flatshaded (calculates normal based on face)
`  LM Add Light Map Object universeobj,0,0,1
  rem V110 - 140110 - uses mesh geometry normals where available
  LM Add Light Map Object universeobj,0,0,0
  LM Build collision Data
  `
  rem ambient setting (full ambient control in scene)
  LM Set Ambient Light glightambientr/100.0,glightambientg/100.0,glightambientb/100.0
  if glightsunr<>0 or glightsung<>0 or glightsunb<>0
   LM Add Directional Light glightsunx,glightsuny,glightsunz,glightsunr/100.0,glightsung/100.0,glightsunb/100.0
  endif
  `
  rem settings
  LM Boost Curved Surface Quality glightmaxsize,(glightboost*1.0)
  `
  rem start the light mapping thread
  lm set light map name ""
  lm set light map file format 1 : rem DDS
  lm set light map folder myownrootdir$+"levelbank\testlevel\lightmaps\"
  quality#=glightquality/100.0
  LM Build Light Maps Thread glighttexsize,quality#,glightblurmode,glightthreadmax
  load dll "Kernel32.dll",1
  while LM Get Complete()=0
   debugviewtext(276,LM Get Status( )+"  "+str$(int(LM Get Percent()))+"%")
   call dll 1,"Sleep",1
  endwhile
  delete dll 1
  `
  rem close lightmapper
  LM Reset
  `
  rem save lightmapped universe
  if file exist(universefile$)=1 then delete file universefile$
  set object light universeobj,1
  `X10 not needed set light mapping on universeobj,0,1
  save object universefile$,universeobj
  delete object universeobj
  `
  rem load static universe back in
  load static objects universefile$,gdividetexturesize
  `
 endif
 `
` moved to game_load rem X10 If universe has no effect load on, and apply it
` if guniverseeffectindex=0
`  guniverseeffectindex=loadinternaleffectunique("effectbank\universe\universe.fx",1)
`  set static objects effect guniverseeffectindex
` endif
 `
 rem Only perform these saves if BUILDING EXE
 if gcompilestandaloneexe=1
  `
  rem X10 - 240907 - standalone requires AISS OBS data to be calculated soon
  gosub _aiss_level : gosub _aiss_free
  `
  rem Version control on EXE Building
  gosub _version_universe_construct
  `
 else
  `
  rem Not building final EXE, but need to retain infinilight data (for construction skip)
  gosub _version_universe_savelightdata
  `
 endif
 `
 rem X10 save old map, overlay and static entity data for future test game pass
 gosub _universe_saveforskipcheck
 `
endif

return

_universe_recreateinfinilights:
 `
 rem V109 BETA3 - 210408 - when use DBU-skip, new elements do not tally with inifnilight LGT data, so recreate
 rem for the test gamwe quick rebuild feature
 `
 rem Reset dynamic light array
 activatedynamiclightscount=0
 empty array infinilight(0)
 testmarkerstart=50000
 testmarker=testmarkerstart
 staticlightcount=0
 infinilightindex=0
 `
 rem Lighting flag
 activatelightmapping=glightmappingstate
 if segobjusedformapeditor=1 then activatelightmapping=0
 `
 rem Rebuild inifnilights
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  tentid=entityelement(e).bankindex
  rem add dynamic and static lights from entities
  if entityprofile(tentid).ismarker=2
   lgx#=entityelement(e).x
   lgy#=entityelement(e).y
   lgz#=entityelement(e).z
   lgrange#=entityelement(e).eleprof.light.range
   lgr#=rgbr(entityelement(e).eleprof.light.color)
   lgg#=rgbg(entityelement(e).eleprof.light.color)
   lgb#=rgbb(entityelement(e).eleprof.light.color)
   if entityelement(e).staticflag=0
    if gdynamiclightingstate=1
     lgtype=1 : gosub _lighting_adddynamiclight
     entityelement(e).eleprof.light.index=infinilightindex
    endif
   else
    if activatelightmapping=1
     if usedarklightmapper=1
      size# = lgrange#
      falloff# = size#/2
      radius# = size#+falloff#
      zerorange# = ( radius# * glightzerorange ) / 100.0
      atten# = glightatten / (radius#*radius#)
      outer# = 1.0 + falloff#
      brighter# = radius# / outer#
      lgr#=lgr#*brighter#
      lgg#=lgg#*brighter#
      lgb#=lgb#*brighter#
     endif
     lgtype=0 : gosub _lighting_adddynamiclight
     inc staticlightcount
    endif
   endif
  endif
 next e
 `
return

_universe_destruct:

rem Remove universe and all constructed preview assets
delete static objects : set static universe maxx*100,(layermax+1)*100,maxy*100

return

_universe_camera:

rem Input source
tkeystate30=0 : tkeystate32=0 : tkeystate17=0 : tkeystate31=0 : tkeystate44=0
if inputsys.kscancode=87 then tkeystate17=1
if inputsys.kscancode=83 then tkeystate31=1
if inputsys.kscancode=65 then tkeystate30=1
if inputsys.kscancode=68 then tkeystate32=1
if inputsys.kscancode=90 then tkeystate44=1
cammovex#=inputsys.xmousemove
cammovey#=inputsys.ymousemove

rem Camera old information
cox#=camera position x(playercam)
coy#=camera position y(playercam)
coz#=camera position z(playercam)

rem Control camera movement
movement=0 : speed#=6.0
x#=camera angle x(playercam) : z#=camera angle z(playercam) : sy#=camera angle y(playercam) : y#=sy#
if tkeystate30=1 then dec y#,90 : movement=1
if tkeystate32=1 then inc y#,90 : movement=1
rotate camera playercam,0,y#,0
if tkeystate17=1 or tkeystate30=1 or tkeystate32=1 then move camera playercam,speed# : movement=1
if tkeystate31=1 then move camera playercam,speed#*-1.0 : movement=1
rotate camera playercam,x#,sy#,z#

rem Float Key
if tkeystate44=1 then position camera playercam,camera position x(playercam),camera position y(playercam)+4.0,camera position z(playercam) : grav#=-1.0

rem Camera new information
cmx#=camera position x(playercam)
cmy#=camera position y(playercam)-grav#
cmz#=camera position z(playercam)

rem Overall ellipse collision for camera
tcameraeyey#=20.0
if deactivatecollision=0
 if static volume(cox#,coy#-tcameraeyey#,coz#,cmx#,cmy#-tcameraeyey#,cmz#,1.0)=1
  cmx#=cox#+get static collision x()
  cmy#=coy#+get static collision y()
  cmz#=coz#+get static collision z()
  tcolmaterialtype=get static collision value()-1
  colmaterialtype=tcolmaterialtype
  grav#=1
 else
  inc grav#,1
 endif
endif

rem Non node tree collision floor stopper (and edge of universe stopper)
if cmx#<0.0 then cmx#=0.0
if cmx#>maxx*100.0 then cmx#=maxx*100.0
if cmy#<45.0 then cmy#=45.0
if cmz#<maxy*-100.0 then cmz#=maxy*-100.0
if cmz#>0.0 then cmz#=0.0

rem Update camera position
position camera playercam,cmx#,cmy#,cmz#
zrotate camera playercam,curveangle(0,camera angle z(playercam),1.75)
position listener cmx#/10.0,cmy#/10.0,cmz#/10.0
rotate listener 0,camera angle y(playercam),0

rem Camera rotation speeds
t=abs(cammovex#)+abs(cammovey#)
if t=1 then camrotspeed#=0.05
if t=2 then camrotspeed#=0.1
if t=3 then camrotspeed#=0.15
if t=4 then camrotspeed#=0.2
if t>=5 then camrotspeed#=0.25

rem Control camera view
camangx#=camera angle x(playercam)+(cammovey#*camrotspeed#)
camangy#=camera angle y(playercam)+(cammovex#*camrotspeed#)
if wrapvalue(camangx#)>85 and wrapvalue(camangx#)<180 then camangx#=85.0
if wrapvalue(camangx#)>180 and wrapvalue(camangx#)<275 then camangx#=275.0
rotate camera playercam,camangx#,camangy#,camera angle z(playercam)

return

_universe_preparelimbflags:

rem Create limb flag array
limbflagmax=segmentprofileheader(seg).lastmeshmax
undim limbflag()
dim limbflag(limbflagmax)

rem Fill array with null limbs
for tlimb=0 to limbflagmax
 limbflag(tlimb)=0
next tlimb

return

_universe_createhorizonplanes:
 `
 rem TODO take MAXX and MAXY into account!
 `
 rem Load texture for horizon plane
 thorizonplanetex$=""
 thorizonplanetexid=segmentprofile(mapselection,0).texid
 if thorizonplanetexid<>0
  thorizonplanetex$=segmentprofile(mapselection,0).tex$
 else
  thorizonplanetexid=segmentprofile(mapselection,0).texdid
  if thorizonplanetexid<>0
   thorizonplanetex$=segmentprofile(mapselection,0).texd$
  else
   thorizonplanetex$="texturebank\common\ground_D2.tga"
   thorizonplanetexid=loadinternalimage(thorizonplanetex$)
  endif
 endif
 `
 rem Place horizon planes on four sides
 tdim=(40*100)/2.0 : tdimneg=tdim*-1 : tdimlong=tdim*3 : lay=0
 rem Left
 make object box segobj,tdim*2,10,tdimlong*2 : position object segobj,tdimneg,(lay*100)-5,(maxy*-50)
 scale object texture segobj,40,120
 texture object segobj,thorizonplanetexid : inc segobj
 rem Right
 make object box segobj,tdim*2,10,tdimlong*2 : position object segobj,(maxx*100)+tdim,(lay*100)-5,(maxy*-50)
 scale object texture segobj,40,120
 texture object segobj,thorizonplanetexid : inc segobj
 rem Top
 make object box segobj,tdim*2,10,tdim*2 : position object segobj,(maxx*50),(lay*100)-5,tdim
 scale object texture segobj,40,40
 texture object segobj,thorizonplanetexid : inc segobj
 rem Bottom
 make object box segobj,tdim*2,10,tdim*2 : position object segobj,(maxx*50),(lay*100)-5,(maxy*-100)+tdimneg
 scale object texture segobj,40,40
 texture object segobj,thorizonplanetexid : inc segobj
 `
 rem And place fog to finish horizon blur to sky (by colour)
 rem FPSCV104RC3 - fog is controlled by FPI elsewhere
 `fog on : fog distance 2000.0,4000.0 : fog color 0,0,0
 `
return

_universe_makemapvalues:
 `
 mapid = 0
 mapid = mapid + ( ( mapselection && %111111111111 ) << 20 )
 mapid = mapid + ( ( mapscaler && %1111 ) << 16 )
 mapid = mapid + ( ( mapground && %11 ) << 14 )
 mapid = mapid + ( ( maprotate && %11 ) << 12 )
 mapid = mapid + ( ( maporient && %11 ) << 10 )
 mapid = mapid + ( ( mapsymbol && %111111 ) << 4 )
 mapid = mapid + ( ( maptile && %1111 ) )
 rem mapid out
 `
return



`
` Player and AI Shared Code
`

_entity_getactualframe:
 `
 rem X10 - 081107 - if 12+ TEEN mode, and using death animations, use stills instead
 rem V110 - 120210 - corrupted behaviour of some model packs (need legacy support)
 tusestillsinsteadofdeathanim=0
 `if 1
 ` if tbaseframe=11 or tbaseframe=14 or tbaseframe=17 or tbaseframe=20
 `  tusestillsinsteadofdeathanim=1
 ` endif
 `endif
 `
 rem work out actual frame from base frame and entity-character state and weapon used
 rem only applies to characters with weapons
 if entityprofile(entid).ischaracter=1
  rem X10 (tbaseframe>0) so that the anim0 values are not iky, even if char holding weapon (monster roar)
  if entityelement(e).attachmentweapontype>0 and tbaseframe>0
   rem if weapon, use 50-99 range
   if tusestillsinsteadofdeathanim=1
    tactualframe=entityanim(entid,50+tbaseframe).start+2
   else
    if tbasetype=1 then tactualframe=entityanim(entid,50+tbaseframe).start
    if tbasetype=2 then tactualframe=entityanim(entid,50+tbaseframe).finish
   endif
   rem if greater than pistol, apply an offset to final frame number
   if tbaseframe>=10 and tbaseframe<=22
    if tbaseframe=13 or tbaseframe=16
     tokay=1
    else
     tokay=0
    endif
   else
    tokay=1
   endif
   if tokay=1
    if entityelement(e).attachmentweapontype=2 then tactualframe=tactualframe+389
    if entityelement(e).attachmentweapontype=3 then tactualframe=tactualframe+778
    if entityelement(e).attachmentweapontype=4 then tactualframe=tactualframe+1167
    if entityelement(e).attachmentweapontype=5 then tactualframe=tactualframe+1556
   endif
  else
   rem if no weapon, we are done (NOWEAP)
   if tusestillsinsteadofdeathanim=1
    tactualframe=entityanim(entid,tbaseframe).start+2
   else
    if tbasetype=1 then tactualframe=entityanim(entid,tbaseframe).start
    if tbasetype=2 then tactualframe=entityanim(entid,tbaseframe).finish
   endif
  endif
  rem assign crouch flag (profile of character for hit detect)
  if tbaseframe>=31 and tbaseframe<40 then entityelement(e).crouchprofile=1 else entityelement(e).crouchprofile=0
 else
  if tusestillsinsteadofdeathanim=1
   tactualframe=entityanim(entid,tbaseframe).start+2
  else
   if tbasetype=1 then tactualframe=entityanim(entid,tbaseframe).start
   if tbasetype=2 then tactualframe=entityanim(entid,tbaseframe).finish
  endif
 endif
 `
return

_entity_getactualframestart:
 tbasetype=1 : gosub _entity_getactualframe
return

_entity_getactualframefinish:
 tbasetype=2 : gosub _entity_getactualframe
return

_player_determinevisibility:

rem used by an entity when looking at mex#,mey#,mez#
rem determine if player exposed to be visible to tmpx#,tmpy#,tmpz#,dist# and (e)
tvisibility=1
tvisibilityifbreak=0 : tvisibilityifbreakdist#=9999.99

rem deduct from 100 percent visible, if drop below zero, enemy cannot see plr
visprobcount=100

rem instant block if other object obstructs it
for tte=1 to entityelementlist
 if tte<>e
  if entityelement(tte).active=1 and entityelement(tte).dormant=0 and entityelement(tte).collisionactive=1
   tdistx#=entityelement(e).x-entityelement(tte).x
   tdisty#=entityelement(e).y-entityelement(tte).y
   tdistz#=entityelement(e).z-entityelement(tte).z
   ttdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
   if ttdist#<=dist# and entityelement(tte).obj>0
    ttdst#=intersect object(entityelement(tte).obj,tmpx#,tmpy#,tmpz#,mex#,mey#,mez#)
    if ttdst#>0
     if entityelement(tte).eleprof.transparency=0 then tvisibility=0
     if entityelement(tte).eleprof.transparency>0 and entityelement(tte).eleprof.strength>0
      if ttdst#<tvisibilityifbreakdist#
       tvisibilityifbreak=tte
       tvisibilityifbreakdist#=ttdst#
      endif
     endif
     if tvisibility=0 then tte=entityelementlist+1
    endif
   endif
  endif
 endif
next tte

rem loose accuracy on exposure of player (if peeking, crouched, moving)
if tvisibility=1
 if peeklean#<>0.0 then dec visprobcount,10
 if movement=0 then dec visprobcount,25
 if crouchmode<>0 then dec visprobcount,10
endif

rem loose accuracy on distance
if tvisibility=1
 if dist#>1000 then dec visprobcount,10
 if dist#>2000 then dec visprobcount,50
endif

rem loose accuracy on light level of player
if tvisibility=1
 if dist#>200
  if array count(infinilight())>0
   tavlightcol#=(avlightcolr#+avlightcolg#+avlightcolb#)/3.0
   tavlightcol#=tavlightcol#/2.5
   tavlightcol=100-tavlightcol# : if tavlightcol<1 then tavlightcol=1
   tavlightcol=tavlightcol/2
   dec visprobcount,tavlightcol
  endif
 endif
endif

rem use visual probability count for final visibile check
if tvisibility=1
 if visprobcount<0 then tvisibility=0
endif

return

_entity_determinevisibility:

rem As above but trimmed down for vis check between entity and a coordinate
rem ray = tmpx#,tmpy#,tmpz#,ttox#,ttoy#,ttoz#,dist#
tvisibility=1
tvisibilityifbreak=0 : tvisibilityifbreakdist#=9999.99

rem range of ray
tdistx#=tmpx#-ttox#
tdisty#=tmpy#-ttoy#
tdistz#=tmpz#-ttoz#
traydist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))

rem instant block if other object obstructs it
for tte=1 to entityelementlist
 if tte<>e
  if entityelement(tte).active=1 and entityelement(tte).collisionactive=1
   tdistx#=entityelement(e).x-entityelement(tte).x
   tdisty#=entityelement(e).y-entityelement(tte).y
   tdistz#=entityelement(e).z-entityelement(tte).z
   ttdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
   if ttdist#<=traydist# and entityelement(tte).obj>0
    `
    rem X10 - 111007 - three intersect tests is expensive, only do if door/window (pseudo static)
    if entityelement(tte).eleprof.physics=3
     `
     ttdst#=intersect object(entityelement(tte).obj,tmpx#,tmpy#,tmpz#,ttox#,ttoy#,ttoz#)
     if ttdst#=0 then ttdst#=intersect object(entityelement(tte).obj,tmpx#,tmpy#-20,tmpz#,ttox#,ttoy#-20,ttoz#)
     if ttdst#=0 then ttdst#=intersect object(entityelement(tte).obj,tmpx#,tmpy#+20,tmpz#,ttox#,ttoy#+20,ttoz#)
     if ttdst#>0
      rem block if solid, do not block if transparent but record the breakable obstruction     
      if entityelement(tte).eleprof.transparency=0 then tvisibility=0
      if entityelement(tte).eleprof.transparency>0
       if ttdst#<tvisibilityifbreakdist#
        tvisibilityifbreak=tte
        tvisibilityifbreakdist#=ttdst#
       endif
      endif
      if tvisibility=0 then tte=entityelementlist+1
     endif
     `
    endif
    `
   endif
  endif
 endif
next tte

rem raycast for solid wall collisions (if still visible)
if tvisibility=1
 `x9tvisibility=1-static raycast(tmpx#,tmpy#,tmpz#,ttox#,ttoy#,ttoz#)
 tvisibility#=AI ray cast(tmpx#,tmpy#,tmpz#,ttox#,ttoy#,ttoz#)
 if tvisibility#<>-1
  rem hit something solid, not visible
  tvisibility=0
 endif 
endif

return

_player_leavetrail:
 `
 rem leave trail one per tile
 if trailaction=0
  trax1=trailx#/100
  tray1=traily#/100
  traz1=trailz#/100
  trax2=playertrial(playertrailmax).x/100
  tray2=playertrial(playertrailmax).y/100
  traz2=playertrial(playertrailmax).z/100
 else
  trax1=trailx#/5
  tray1=traily#/50
  traz1=trailz#/5
  trax2=playertrial(playertrailmax).x/5
  tray2=playertrial(playertrailmax).y/50
  traz2=playertrial(playertrailmax).z/5
 endif
 if trax1<>trax2 or tray1<>tray2 or traz1<>traz2
  `
  rem deposit new trail blob
  inc playertrailmax
  if playertrailmax>100 then playertrailmax=1
  playertrial(playertrailmax).time=timer()
  playertrial(playertrailmax).x=trailx#
  playertrial(playertrailmax).y=traily#
  playertrial(playertrailmax).z=trailz#
  `
  rem if in debug, create object to illustrate blob
  `not reuqired for X10 280807 
  `if gshowdebugtextingamestate=1
  ` `
  ` rem create fresh new blob
  ` tobj=gamdebugobjoffset+playertrailmax
  ` if object exist(tobj)=0 then make object cube tobj,10 : set object collision off tobj
  ` position object tobj,trailx#,traily#,trailz#
  ` set object emissive tobj,rgb(255,200,0)
  ` scale object tobj,100,100,100
  ` `
  ` rem discolour rest of blobs by their age
  ` tai=playertrailmax
  ` for ta=1 to 99
  `  dec tai : if tai<1 then tai=100
  `  tobj=gamdebugobjoffset+tai
  `  if object exist(tobj)=1
  `   set object emissive tobj,rgb(255-(ta*2.5),200-(ta*2),0)
  `   scale object tobj,100.0-(ta*0.95),100,100.0-(ta*0.95)
  `  endif
  ` next ta
  ` `
  `endif
  `
 endif
 `
return

`
` Entities and AI Shared Code
`

_entity_controlrecalcdist:
 ttokay=0
 if entityelement(e).active=1
  if gmultiplayergame=0 then ttokay=1
  if gmultiplayergame=1 and PlayerCanStart=1 then ttokay=1
 endif
 if ttokay=1
  distx#=mex#-entityelement(e).x
  disty#=(mey#-phyeyeheight#)-entityelement(e).y
  distz#=mez#-entityelement(e).z
  dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  diffangle#=atanfull(distx#,distz#)
  if diffangle#<0 then diffangle#=diffangle#+360
 else
  dist#=9999999
 endif
return

_entity_conescanforentity:
 `
 rem e looking for another e of type tentitytype (1=weapon)
 entityelement(e).mover.viewconeused=10
 tfounde=0
 telex#=entityelement(e).x
 teley#=entityelement(e).y+65.0
 telez#=entityelement(e).z
 for te=1 to entityelementlist
  tokay=0
  if entityelement(te).active=1
   tentid=entityelement(te).bankindex
   if tentitytype=1
    if entityprofile(tentid).isweapon<>0 then tokay=1
   endif
  endif
  if tokay=1
   tdistx#=telex#-entityelement(te).x
   tdisty#=teley#-entityelement(te).y+10.0
   tdistz#=telez#-entityelement(te).z
   tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
   if tdist#<1000.0
    tmpx#=entityelement(te).x
    tmpy#=entityelement(te).y+6.0
    tmpz#=entityelement(te).z
    if static raycast(telex#,teley#,telez#,tmpx#,tmpy#,tmpz#)=0
     tfounde=te : te=entityelementlist
    endif
   endif
  endif
 next te
 `
return

_entity_playerhavekey:
 rem Is USEKEY Collected?
 tokay=0
 for te=1 to entityelementlist
  if entityelement(te).collected=1
   if lower$(entityelement(te).eleprof.name$)=lower$(entityelement(e).eleprof.usekey$)
    tokay=1 : exit
   endif
  endif
 next te
return

_entity_activatename:
 rem Activate All Entities that share tname$ (using tstate)
 for te=1 to entityelementlist
  if entityelement(te).active=1
   if lower$(entityelement(te).eleprof.name$)=lower$(tname$)
    entityelement(te).activated=tstate
    entityelement(te).logiccount=0 : entityelement(te).logiccountburst=5
    entityelement(te).dormant=0
   endif
  endif
 next te
return

_entity_activateallinzone:
 for te=1 to entityelementlist
  if entityelement(te).active=1 or entityelement(te).spawn.atstart=0
   tex=entityelement(te).x
   tey=entityelement(te).y
   tez=entityelement(te).z
   if tex>condx1 and tex<condx2
    if tey>condy1-5 and tey<condy2+5
     if tez<condz1 and tez>condz2
      entityelement(te).activated=tactivated
      entityelement(te).logiccount=0 : entityelement(te).logiccountburst=5
      entityelement(te).dormant=0
     endif
    endif
   endif
  endif
 next te
return

_entity_findname:
 rem Activate All Entities that share tname$ (using tstate)
 foundte=0
 for te=1 to entityelementlist
  if entityelement(te).active=1
   if lower$(entityelement(te).eleprof.name$)=lower$(tname$)
    foundte=te : exit
   endif
  endif
 next te
return


`
` AI and HUD Shared Code
`

_ai_hud_view:
 `
 rem Fill HUD with data based on type
 if ghidehudgraphics=0
 for hudid=1 to hudmax
  `
  rem STATUS or NUMERIC
  if hud(hudid).maintype=4 or hud(hudid).maintype=6
   if hud(hudid).typemode=1 then hud(hudid).text$=str$(player(1).lives)
   if hud(hudid).typemode=2 then hud(hudid).text$=str$(player(1).health)
   if hud(hudid).typemode=3
    if weaponammoindex>0
     if gun(gunid).settings.reloadqty>0
      if gun(gunid).settings.weaponisammo=1
       hud(hudid).text$=str$(weaponammo(weaponammoindex))
      else
       hud(hudid).text$=str$(weaponammo(weaponammoindex))+"\"+str$(weaponclipammo(weaponammoindex))
      endif
     else
      hud(hudid).text$=""
     endif
    else
     hud(hudid).text$=""
    endif
   endif
   if hud(hudid).typemode=4
    rem frags
    if ggameobjectivetype<>1
     fr$=str$(frags(iLocalEL))
     if ggameobjectivetype=2 then fr$=fr$+"\"+str$(ggameobjectivevalue)
    else
     fr$=""
    endif
    hud(hudid).text$=fr$
   endif
   if hud(hudid).typemode=5
    rem time
    if ggameobjectivetype=3
     `x9fr$=str$((timer()-dwStartTime)/1024)+"\"+str$(ggameobjectivevalue)
     rem X10 - 291007 - a count down is much better and keep zero when negative
     tthetimeleft=ggameobjectivevalue-(timer()-dwStartTime)/1024
     if tthetimeleft<0 then tthetimeleft=0
     if tthetimeleft>ggameobjectivevalue then tthetimeleft=ggameobjectivevalue
     fr$=str$(tthetimeleft)
    else
     fr$=""
    endif
    hud(hudid).text$=fr$
   endif
   if hud(hudid).typemode=7 then hud(hudid).text$=str$(player(1).air)
   if hud(hudid).typemode=8 then hud(hudid).text$=str$(player(1).score)
  endif
  `
  rem WEAPON IMAGE
  if hud(hudid).maintype=4
   if hud(hudid).typemode=3
    if weaponammoindex>0
     if weaponhud(weaponammoindex)>0
      if hud(hudid).image<>weaponhud(weaponammoindex)
       hud(hudid).image=weaponhud(weaponammoindex)
       if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
      endif
     endif
    else
     hud(hudid).image=0
    endif
   endif
  endif
  `
  rem WEAPON ZOOMSCOPE OVERRIDE
  if hud(hudid).maintype=5
   if hud(hudid).typemode=4
    if gun(gunid).zoomscope<>0
     hud(hudid).image=gun(gunid).zoomscope
    else
     hud(hudid).image=internalzoomhudimage
    endif
    if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
   endif
  endif
  `
  rem ANIM
  if hud(hudid).maintype=7
   if hud(hudid).typemode=1 then tnum#=(player(1).lives/100.0)*10.0
   if hud(hudid).typemode=2 then tnum#=(player(1).health/100.0)*10.0
   tnum=tnum#
   if tnum<0 then tnum=0
   if tnum>10 then tnum=10
   hud(hudid).image=hud(hudid).baseanim+tnum
   if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
  endif
  `
  rem IPLIST BOX
  if hud(hudid).maintype=9
   if hud(hudid).hide=0
    rem refresh list auto periodically (8 seconds)
    if timer()>refreshipaddresstimer
     refreshipaddresstimer=timer()+8000
     gosub _ai_hud_refreshiplist
    endif
    rem display list
    `x9set text size 30
    set text size 24
    if hudiplistmax=-1
     center text screen width()/2,(screen height()/2)-10,strarr$(631)
    else
     `x9tipx=hud(hudid).posx
     `tipy=hud(hudid).posy+88
     tipx=screen width()/2 : tipx#=screen width()/5
     tipy=screen height()/3
     for ty=0 to hudiplistmax
      `x9text tipx+45,tipy+(ty*20),str$(1+ty)
      `text tipx+100,tipy+(ty*20),hudiplist$(ty,0)
      `center text tipx+400,tipy+(ty*20),hudiplist$(ty,1)
      if screen width()=800
       text tipx-tipx#-100,tipy+(ty*20),str$(1+ty)
       text tipx-tipx#-50,tipy+(ty*20),hudiplist$(ty,0)
      else
       text tipx-tipx#-50,tipy+(ty*20),str$(1+ty)
       text tipx-tipx#,tipy+(ty*20),hudiplist$(ty,0)
      endif
      center text tipx+tipx#,tipy+(ty*20),hudiplist$(ty,1)
     next ty
    endif
   endif
  endif
  `
  rem CROSSHAIR
  if hud(hudid).maintype=31
   if hud(hudid).hide=0
    if hudcrosshair<>hud(hudid).image
     hud(hudid).image=hudcrosshair
     if hud(hudid).image>0
      sprite hudid,-10000,-10000,hud(hudid).image
      size sprite hudid,image width(hud(hudid).image),image height(hud(hudid).image)
      hud(hudid).posx=((gdisplaywidth/100.0)*50)-(image width(hud(hudid).image)/2)
      hud(hudid).posy=((gdisplayheight/100.0)*50)-(image height(hud(hudid).image)/2)
     endif
    endif
    if hud(hudid).image>0
     rem X10 - 251007 - ensure crosshair uses correct image size!
     size sprite hudid,image width(hud(hudid).image),image height(hud(hudid).image)
    endif
   endif
  endif
  `
  rem FADEOUT control
  if hud(hudid).fadeout>0
   if hudfadeoutoneatatime=0 then hudfadeoutoneatatime=hudid
   if hudid=hudfadeoutoneatatime
    hud(hudid).fadeout=hud(hudid).fadeout-(timebasepercycle#*3)
    if hud(hudid).fadeout>0
     if hud(hudid).fadeout>100
      talpha#=255.0
     else
      talpha#=(255.0/100.0)*hud(hudid).fadeout
     endif
    else
     rem hudfadeoutoneatatime allows one at a time
     hudfadeoutoneatatime=0
     hud(hudid).fadeout=0
     hud(hudid).hide=1
     talpha#=0.0
    endif
    if hud(hudid).image>0 then set sprite alpha hudid,talpha#
   else
    if hud(hudid).image>0 then set sprite alpha hudid,0
   endif
  endif
  `
 next hudid
 `
 rem Display using direct paste (fastest)
 ink rgb(255,255,255),0
 for hudid=1 to hudmax
  if hud(hudid).hide=0
   if hud(hudid).maintype=6
    rem NUMERIC
    tokay=1
    if gmultiplayergame=0
     rem X10 some hud displays can deactivate if healthmax, scoremax or airmax are zero
     if hud(hudid).typemode=1 and player(1).livesmax=0 then tokay=0      
     if hud(hudid).typemode=2 and player(1).healthmax=0 then tokay=0      
     if hud(hudid).typemode=7 and player(1).airmax=0 then tokay=0      
     if hud(hudid).typemode=8 and player(1).scoremax=0 then tokay=0
    endif
    if tokay=1
     rem X10 actual text width for spacing
     `120907 - tactualtextwidth=(hud(hudid).sizex/4)*3
     tactualtextwidth=((hud(hudid).sizex*gratiox#)/4)*3     
     rem center for centering text (with small offset for default interface huds)
     tcenterx#=((len(hud(hudid).text$)*tactualtextwidth)/2)+2
     for tt=1 to len(hud(hudid).text$)
      ttnum=-1
      if mid$(hud(hudid).text$,tt)="." then ttnum=10
      if mid$(hud(hudid).text$,tt)="\" then ttnum=11
      if ttnum=-1 then ttnum=asc(mid$(hud(hudid).text$,tt))-asc("0")
      if ttnum<>-1
       rem X10 the 16 and 64 are merely relative, describing any 4x4 grided texture (as X10 is 32 and 128)
       ttnumy=ttnum/4 : ttnum=ttnum-(ttnumy*4) : ttbitx#=(1.0/64.0)*16 : ttbity#=(1.0/64.0)*16
       if hud(hudid).image>0
        set sprite texture coord hudid,0,(ttbitx#*ttnum),(ttbity#*ttnumy)
        set sprite texture coord hudid,1,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)
        set sprite texture coord hudid,2,(ttbitx#*ttnum),(ttbity#*ttnumy)+ttbity#
        set sprite texture coord hudid,3,(ttbitx#*ttnum)+ttbitx#,(ttbity#*ttnumy)+ttbity#
        `130907 - account for screen size size sprite hudid,hud(hudid).sizex,hud(hudid).sizey
        size sprite hudid,hud(hudid).sizex*gratiox#,hud(hudid).sizey*gratioy#
        paste sprite hudid,(hud(hudid).posx-tcenterx#)+((tt-1)*tactualtextwidth),hud(hudid).posy
       endif
      endif
     next tt
    endif
   else
    rem IMAGE+TEXT
    if hud(hudid).image>0
     tokay=1
     if gmultiplayergame=0
      rem X10 some hud displays can deactivate if healthmax, scoremax or airmax are zero
      if hud(hudid).maintype=1 and hud(hudid).typemode>0
       if hud(hudid).typemode=1 and player(1).livesmax=0 then tokay=0      
       if hud(hudid).typemode=2 and player(1).healthmax=0 then tokay=0      
       if hud(hudid).typemode=7 and player(1).airmax=0 then tokay=0      
       if hud(hudid).typemode=8 and player(1).scoremax=0 then tokay=0
      endif
     else
      if hud(hudid).maintype=1 and hud(hudid).typemode>0
       if hud(hudid).typemode=1 and goneshotkills=0 then tokay=0
       if hud(hudid).typemode=2 and ggameobjectivetype<>1 then tokay=0
       if hud(hudid).typemode=5 and ggameobjectivetype<>3 then tokay=0
      endif
     endif
     if tokay=1
      if hud(hudid).fadeout>0
       tfadeout=hud(hudid).fadeout : if tfadeout>100 then tfadeout=100
       paste sprite hudid,hud(hudid).posx,hud(hudid).posy-(100-tfadeout)
      else
       paste sprite hudid,hud(hudid).posx,hud(hudid).posy
      endif
     endif
    endif
    if hud(hudid).text$<>"" and hud(hudid).image=0
     tfont$=hud(hudid).font$ : if tfont$<>"" and tfont$<>tlastfont$ then set text font tfont$ : tlastfont$=tfont$
     tfontsize=hud(hudid).fontsize : if tfontsize<>0 and tfontsize<>tlastfontsize then set text size tfontsize : tlastfontsize=tfontsize
     center text hud(hudid).posx+(hud(hudid).sizex/2),(hud(hudid).posy+hud(hudid).sizey)+(hud(hudid).fadeout/5.0),hud(hudid).text$
    endif
   endif
  else
   if hud(hudid).image>0 then sprite hudid,-10000,-10000,hud(hudid).image
  endif
 next hudid
 `
 rem After Image Text pasting
 for hudid=1 to hudmax
  `
  rem EDIT BOX
  if hud(hudid).maintype=8
   if hud(hudid).hide=0

    if hud(hudid).typemode<10
     hud(hudid).typemode=hud(hudid).typemode+10
    else
     if hud(hudid).typemode<20
      `
      rem show current entry
      string$=entry$() : length=15
      if len(string$)>length then string$=left$(string$,length)
      tcursor$=" " : if rnd(1)=1 then tcursor$="_"
      if len(string$)=0
       center text screen width()/2,hud(hudid).posy+22,tcursor$
      else
       center text screen width()/2,hud(hudid).posy+22,string$
      endif
`      tleftofcenter=(screen width()/2)-(text width(string$)/2)
`      set cursor tleftofcenter,hud(hudid).posy+22
`      print string$;
`      if rnd(1)=1 then print "_" else print ""
      `
      rem if IP selection not valid
      if returnkey()=1
       if hud(hudid).typemode=12
        tnc=0
        for tn=1 to len(string$)
         if mid$(string$,tn)="." then inc tnc
        next tn
        if tnc=3
         rem valid IP address - use this
        else
         rem numerical selection
         tnv=val(string$)
         if hudiplistmax>=0
          if tnv>=1 and tnv<=1+hudiplistmax
           rem valid entry using ID - obtain IPaddress from list
           string$=hudiplist$(tnv-1,1)
          else
           rem not a valid entry
           string$=""
          endif
         else
          rem not a valid entry
          string$=""
         endif
        endif
       endif
       hud(hudid).text$=string$
       if len(string$)>0
        hud(hudid).typemode=hud(hudid).typemode+10
       else
        hud(hudid).typemode=hud(hudid).typemode-10
       endif
      endif
      `
     endif
    endif
   endif
  endif
  `
  rem IPADDRESS BOX
  if hud(hudid).maintype=11
   if hud(hudid).hide=0
    set text size 24
    ink rgb(8,8,8),0
    center text hud(hudid).posx,hud(hudid).posy-8,serveripaddress$
    if left$(serveripaddress$,8)<>"192.168."
     if left$(localipaddress$,8)="192.168."
      set text size 24
      center text hud(hudid).posx,screen height()-21,"PLAY L.A.N USING IP: "+localipaddress$
     endif
    endif
    ink rgb(255,255,255),0
   endif
  endif
  `
  rem WINNERSNAME BOX
  if hud(hudid).maintype=12
   if hud(hudid).hide=0
    set text size 24
    rem list of players
    tylinevalue=hud(hudid).posy
    for el=1 to multiplayermax
     if multiplayeridlink(el)<>1
      center text hud(hudid).posx,tylinevalue,multiplayername$(el)+"    "+str$(frags(el))
      inc tylinevalue,30
     endif
    next el
   endif
  endif
  `
 next hudid
  `
 rem Handle HUD control
 for hudid=1 to hudmax
  `
  rem Special HUD Pointer
  if hud(hudid).maintype=2
   rem Can Display At Mouse Coordinate
   hud(hudid).posx=mousex()-((hud(hudid).width/2)*gratiox#)
   hud(hudid).posy=mousey()-((hud(hudid).height/2)*gratioy#)
   aihudpointerimagestore=hud(hudid).image
   rem Can Detect When Select HUD Item
   for thudid=1 to hudmax
    rem Only selectables
    hud(thudid).highlighted=0
    if hud(thudid).maintype=3
     if hud(hudid).posx>hud(thudid).posx
      if hud(hudid).posx<hud(thudid).posx+(hud(thudid).width*gratiox#)
       if hud(hudid).posy>hud(thudid).posy
        if hud(hudid).posy<hud(thudid).posy+(hud(thudid).height*gratioy#)
         hud(thudid).highlighted=1
        endif
       endif
      endif
     endif
    endif
   next thudid
   if mouseclick()=1
    for thudid=1 to hudmax
     if hud(thudid).highlighted=1
      hudselectionmade=hud(thudid).typemode
     endif
    next thudid
    rem X10 - 280907 - if click in ghost mode (game menu, it cancels)
    if gghostrunmode=1 then gghostrunmode=0
   else
    rem X10 - 280907 - ghost run mode automatically selects NEW GAME
    if gghostrunmode=1 and hudselectionmade=0
     rem will keep the game executable running in a loop (for stress testing and demoing)
     hudselectionmade=1
    endif
   endif
  endif
  `
  rem Delayed display, then hide
  if hud(hudid).hidedelay>0
   hud(hudid).hidedelay=hud(hudid).hidedelay-timebasepercycle#
   if hud(hudid).hidedelay<=0
    hud(hudid).hidedelay=0
    hud(hudid).hide=1
   endif
  endif
  `
  rem Radar Blip (v1.1)
  if hud(hudid).maintype=4 and hud(hudid).typemode=11
   `
   rem Mimic radar blip
   for e=1 to entityelementlist
    if entityelement(e).health>0
     tentid=entityelement(e).bankindex
     if entityprofile(tentid).ischaracter=1
      fundx#=entityelement(e).x-camera position x(playercam)
      fundy#=camera position z(playercam)-entityelement(e).z
      funangle#=atanfull(fundy#,fundx#)
      rrr#=funangle#-camera angle y(playercam)
      if hud(hudid).image>0
       paste sprite hudid,hud(hudid).posx-8+(cos(rrr#)*40),hud(hudid).posy-8+(sin(rrr#)*40)
      endif
     endif
    endif
   next e
   `
  endif
  `
 next hudid
 endif
 `
return

_ai_hud_refreshiplist:
 `
 rem update list from file(for now)
 gosub _ai_gamelist_refresh
 `
return

_ai_gamelist_add:
 `
 rem server adds to gamelist, uses addip$ and addname$
 action$="action=add&"
 serverid$="server_id="+guniquegamecode$+"&"
 ip$="ip="+addip$+"&" : ipfromadd$=ip$
 title$="title="+addname$+"&"
 data$="data=none"
 HTTP CONNECT strarr$(619)
 tryattempts=10
 repeat
  tryagain=0
  idfromadd$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$+ip$+title$+data$)
  if val(idfromadd$)=0 then tryagain=1
  dec tryattempts
 until tryagain=0 or tryattempts<=0
 HTTP DISCONNECT
 `
return

_ai_gamelist_delete:
 `
 rem server deletes from gamelist
 HTTP CONNECT strarr$(619)
 tryattempts=10
 repeat
  tryagain=0
  action$="action=delete&"
  serverid$="server_id="+guniquegamecode$+"&"
  return$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$+ipfromadd$+"id="+idfromadd$)
  if return$="1" then serverhasremoveditselffromonlinelist=1
  if return$<>"1" then tryagain=1
  dec tryattempts
 until tryagain=0 or tryattempts<=0
 HTTP DISCONNECT
 `
return

_ai_gamelist_keepalive:
 `
 rem send this to keep game item listed in database
 HTTP CONNECT strarr$(619)
 action$="action=keepalive&"
 serverid$="server_id="+guniquegamecode$+"&"
 return$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$+ipfromadd$+"id="+idfromadd$)
 HTTP DISCONNECT
 `
return

_ai_gamelist_refresh:
 `
 rem client views gamelist choices, fill array
 HTTP CONNECT strarr$(619)
 tryattempts=10
 repeat
  tryagain=0
  action$="action=list&"
  serverid$="server_id="+guniquegamecode$
  return$=HTTP REQUEST DATA("POST", "gamehost/index.php",action$+serverid$)
  if return$<>""
   c=1 : hudiplistmax=-1 : fromc=0
   repeat
    if asc(mid$(return$,c))=10
     if fromc>0
      thudiplist$=left$(return$,c-1)
      thudiplist$=right$(thudiplist$,len(thudiplist$)-fromc)
     else
      thudiplist$=left$(return$,c-1)
     endif
     for c1=1 to len(thudiplist$)
      if mid$(thudiplist$,c1)="," then exit
     next c1
     thudiplist1$=left$(thudiplist$,c1-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c1))
     for c2=1 to len(thudiplist$)
      if mid$(thudiplist$,c2)="," then exit
     next c2
     thudiplist2$=left$(thudiplist$,c2-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c2))
     for c3=1 to len(thudiplist$)
      if mid$(thudiplist$,c3)="," then exit
     next c3
     thudiplist3$=left$(thudiplist$,c3-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c3))
     for c4=1 to len(thudiplist$)
      if mid$(thudiplist$,c4)="," then exit
     next c4
     thudiplist4$=left$(thudiplist$,c4-1)
     thudiplist$=right$(thudiplist$,len(thudiplist$)-(c4))
`     if thudiplist1$=thisgamecode$
      inc hudiplistmax
      hudiplist$(hudiplistmax,0)=thudiplist4$
      hudiplist$(hudiplistmax,1)=thudiplist3$
 `    endif
     fromc=c+1
    else
     rem skip char, finding end
    endif
    inc c
   until c>len(return$)
  else
   tryagain=1
   dec tryattempts
  endif
 until tryagain=0 or tryattempts<=0
 HTTP DISCONNECT
 `
return

_ai_gamelist_checkforfirewall:
 `
 rem FSCV105RC2 - server has a script to give is the real machine IP
 `http://www.fpscreator.com/gamehost/whatismyip.php
 serveripaddress$=""
 `
 rem added for 090307
 rem check three times to connect to FPSC gamelist server
 HTTP CONNECT strarr$(619)
 tryattempts=3
 repeat
  action$=""
  return$=HTTP REQUEST DATA("POST", "gamehost/whatismyip.php",action$)
  errorcodestring$=return$
  return$=lower$(return$)
  checkfor$="error code"
  if return$<>""
   for n=0 to len(return$)-len(checkfor$)-1
    if left$(right$(return$,(len(return$)-n)),len(checkfor$))=checkfor$
     rem error code returned when attempted to access HTTP command
     errorcode$=errorcodestring$
    endif
   next n
   if errorcode$="" and len(return$)>0
    rem FPSCV105RC2 - 100307 - puts the actual HOSTable IP address in serveripaddress$
    serveripaddress$=return$
    tryattempts=0
   endif
  endif
  dec tryattempts
 until tryattempts<=0 or len(errorcode$)=0
 HTTP DISCONNECT
 `
 rem if fail, report and exit
 if errorcode$<>""
  s$="Failed to establish a connection with the gamelist server. "
  s$=s$+"This could be caused by loss of internet connectivity, or the presence of a firewall."
  exit prompt s$,errorcode$
  end
 endif
 `
return

_ai_hud_add:

rem HUD Types based on name
workhudmake$=lower$(workhudmake$)

rem Existing HUD
if workhudname$>""
 for thudi=1 to hudmax
  if lower$(workhudname$)=lower$(hud(thudi).name$)
   hudid=thudi : exit
  endif
 next thudi
else
 thudi=hudmax+1
endif
if thudi>hudmax
 `
 rem New HUD
 inc hudmax : hudid=hudmax
 dim hud(hudmax) as hudtype
 `
 rem HUD Type
 hud(hudid).maintype=0
 if workhudmake$="display"
  hud(hudid).maintype=1
  hud(hudid).typemode=workhudtype : rem 0always,X-objectivetype(mutliplayer)
 endif
 if workhudmake$="pointer"
  hud(hudid).maintype=2
  aihudpointerimagestore=workhudimage
 endif
 if workhudmake$="button"
  hud(hudid).maintype=3
  hud(hudid).typemode=workhudtype : rem 1new,2load,3save,4continue,5exit
 endif
 if workhudmake$="status"
  hud(hudid).maintype=4
  hud(hudid).typemode=workhudtype : rem 1lives,2health,etc
 endif
 if workhudmake$="internal"
  hud(hudid).maintype=5
  hud(hudid).typemode=workhudtype : rem 1loader,2eyehud,3fader,4zoom
  if workhudtype=1 then internalloaderhud=hudid
  if workhudtype=2 then internaleyehud=hudid
  if workhudtype=3 then internalfaderhud=hudid
  if workhudtype=4 then internalzoomhud=hudid : internalzoomhudimage=workhudimage
 endif
 if workhudmake$="numeric"
  hud(hudid).maintype=6
  hud(hudid).typemode=workhudtype : rem 1lives,2health,3ammo,etc
 endif
 if workhudmake$="anim"
  hud(hudid).maintype=7
  hud(hudid).typemode=workhudtype : rem 1lives,2health,3ammo,11blip
  hud(hudid).baseanim=workhudimage
 endif
 if workhudmake$="edit"
  hud(hudid).maintype=8
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="list"
  hud(hudid).maintype=9
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="ipaddress"
  hud(hudid).maintype=11
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="winnersname"
  hud(hudid).maintype=12
  hud(hudid).typemode=workhudtype
 endif
 if workhudmake$="textprompt"
  hud(hudid).maintype=21
  hud(hudid).typemode=0
 endif
 if workhudmake$="crosshair"
  hud(hudid).maintype=31
  hud(hudid).typemode=workhudtype : rem reserved
 endif
 `
 rem HUD Data
 hud(hudid).name$=workhudname$
 hud(hudid).posx=workhudx
 hud(hudid).posy=workhudy
 hud(hudid).posz=workhudz
 hud(hudid).sizex=workhudsizex
 hud(hudid).sizey=workhudsizey
 hud(hudid).sizez=workhudsizez
 hud(hudid).red=workhudred
 hud(hudid).green=workhudgreen
 hud(hudid).blue=workhudblue
 hud(hudid).image=workhudimage
 hud(hudid).font$=workhudfont$
 hud(hudid).fontsize=workhudsize
 hud(hudid).text$=workhudtext$
 hud(hudid).hide=workhudhide
 hud(hudid).hidedelay=0
 hud(hudid).highlighted=0
 `
 rem Calculate bounds of HUD (for selectability)
 if workhudsizex>0
  hud(hudid).width=workhudsizex
 else
  if hud(hudid).image>0
   hud(hudid).width=image width(hud(hudid).image)
  else
   if hud(hudid).font$<>"" then set text font hud(hudid).font$
   if hud(hudid).fontsize<>0 then set text size hud(hudid).fontsize
   hud(hudid).width=text width(hud(hudid).text$)
  endif
 endif
 if workhudsizey>0
  hud(hudid).height=workhudsizey
 else
  if hud(hudid).image>0
   hud(hudid).height=image height(hud(hudid).image)
  else
   if hud(hudid).font$<>"" then set text font hud(hudid).font$
   if hud(hudid).fontsize<>0 then set text size hud(hudid).fontsize
   hud(hudid).height=text height(hud(hudid).text$)
  endif
 endif
 `
 rem Offset position with size if image
 if hud(hudid).image>0
  hud(hudid).posx=hud(hudid).posx-((hud(hudid).width/2)*gratiox#)
  hud(hudid).posy=hud(hudid).posy-((hud(hudid).height/2)*gratioy#)
 endif
 `
 rem X10 if numeric, store the size of the image for later
 if hud(hudid).maintype=6
  hud(hudid).sizex=image width(hud(hudid).image)/4
  hud(hudid).sizey=image height(hud(hudid).image)/4
 endif
 `
 rem Update HUD sprites
 gosub _ai_hud_update
 `
endif

return

_ai_hud_update:
 `
 rem HUD Sprites
 set sprite 1,0,1
 sprite 1,-10000,-10000,1
 for hudid=1 to hudmax
  if hud(hudid).image>0
   sprite hudid,-10000,-10000,hud(hudid).image
   if hud(hudid).sizex>0
    size sprite hudid,hud(hudid).sizex*gratiox#,hud(hudid).sizey*gratioy#
   else
    size sprite hudid,hud(hudid).width*gratiox#,hud(hudid).height*gratioy#
   endif
   set sprite diffuse hudid,hud(hudid).red,hud(hudid).green,hud(hudid).blue
   if hud(hudid).fadeout>0
    rem else where
   else
    set sprite alpha hudid,255
   endif
  endif
 next hudid
 `
return

_ai_hud_hideandstore:
 `
 rem X10 - 291007 - used by PLAY ARENA AGAIN mini-AI loop
 dim rememberhudhide(hudmax)
 dim rememberhudimage(hudmax)
 rememberhudmax=hudmax
 for hudid=1 to hudmax
  rememberhudimage(hudid)=hud(hudid).image
  rememberhudhide(hudid)=hud(hudid).hide
  hud(hudid).image=0
  hud(hudid).hide=1
 next hudid
 `
return

_ai_hud_showandrestore:
 `
 rem X10 - 291007 - used by PLAY ARENA AGAIN mini-AI loop
 hudmax=rememberhudmax
 for hudid=1 to hudmax
  hud(hudid).image=rememberhudimage(hudid)
  hud(hudid).hide=rememberhudhide(hudid)
 next hudid
 `
return

rem
rem VERSIONS (Full)
rem

_version_commandlineprompt:
 `
 rem Triggers use of file map messaging
 if lower$(cl$())="-t"
  gtestgamemodefromeditor=1
 endif
 `
 rem Flag to enable/disable PHYSX EDITION (set in FPSC-Full.DBA)
 rem Use different DBP project for the PHYSX version (includes FPSC-PHYSX.DBA)
 physxedition=0
 `
return

_version_endofinit:

rem Ensure full game flag never set!!
`grealgameviewstate=0 `demo versions with noEXEsave do this

 rem Game Engine Demo would send this into filemap of OS
` filemapname$="FPSCComm"
` write filemap value filemapname$,42
` write filemap string filemapname$,"demo version"

return

_version_setresolution:

`X10 now picks up resolution from windows desktop size (for now)
`rem And finally switch the resolution if different from default
`if gdisplaywidth<>800 or gdisplayheight<>600 or gdisplaydepth<>32
` triggerdisplaymodechange=1
`endif
`rem Set the display if triggered
`if triggerdisplaymodechange=1
` if gdisplaywidth=0
`  gdisplaywidth=800
`  gdisplayheight=600
`  gdisplaydepth=32
` endif
` set display mode gdisplaywidth,gdisplayheight,gdisplaydepth
` triggerdisplaymodechange=0
`endif

rem V109 - 100209 - resolve widescreen issue
twideratio#=gdisplaywidth
twideratio#=twideratio#/gdisplayheight
global gdisplayratio# : gdisplayratio#=twideratio#

return

_version_splashtext:
 `
 rem Update Splash Text
 open file map 2, "FPSSPLASH"
 set file map dword 2, 4, 1
 set file map string$ 2, 1000, strarr$(392)
 set file map dword 2, 8, 1
 wait for file map event 2
 close file map 2
 `
return

_version_onscreenlogos:
return

_version_permittestgame:
 `
 rem Map Editor launches test game
 open file map 1,"FPSEXCHANGE"
 set file map string$ 1, 1000, "bin\FPSC-Game.exe"
 set file map string$ 1, 1256, "-t"
 set file map dword 1, 920, 1
 wait for file map event 1
 close file map 1
 `
return

_version_resourcewarning:
return

_version_universe_savelightdata:
  `
  filename$=myownrootdir$+"levelbank\testlevel\universe.lgt"
  if file exist(filename$)=1 then delete file filename$
  open to write 1,filename$
   tinfinimax=array count(infinilight())
   write file 1,tinfinimax
   for i=0 to tinfinimax
    write file 1,infinilight(i).used
    write file 1,infinilight(i).type
    write float 1,infinilight(i).x
    write float 1,infinilight(i).y
    write float 1,infinilight(i).z
    write float 1,infinilight(i).range
    write file 1,infinilight(i).id
    write float 1,infinilight(i).dist
    write file 1,infinilight(i).colrgb.r
    write file 1,infinilight(i).colrgb.g
    write file 1,infinilight(i).colrgb.b
    write file 1,infinilight(i).islit
   next i
  close file 1
  `
return

_version_universe_construct:
  `
  rem Save newer elements list (that includes scene dynamic entities)
  elementsfilename$=myownrootdir$+"levelbank\testlevel\universe.ele" : gosub _entity_saveelementsdata
  `
  rem Save light data
  gosub _version_universe_savelightdata
  `
  rem New entities may have been aded, resave map.ent for transfer to level area
  gosub _entity_savebank
  `
  rem Copy over key map data files this level required
  for tkey=1 to 4
   if tkey=1 then tfile$=myownrootdir$+"levelbank\testlevel\header.dat" : tfile2$=myownrootdir$+"mapbank\testmap\header.dat"
   if tkey=2 then tfile$=myownrootdir$+"levelbank\testlevel\map.fpmb" : tfile2$=myownrootdir$+"mapbank\testmap\map.fpmb"
   if tkey=3 then tfile$=myownrootdir$+"levelbank\testlevel\map.ent" : tfile2$=myownrootdir$+"mapbank\testmap\map.ent"
   if tkey=4 then tfile$=myownrootdir$+"levelbank\testlevel\map.way" : tfile2$=myownrootdir$+"mapbank\testmap\map.way"
   if file exist(tfile$)=1 then delete file tfile$
   copy file tfile2$,tfile$
  next tkey
  `
  rem Save ALL data in leveltest under a level file FPL (for use to extract new levels to play)
  gosub _mapfile_save_fpl
  `
return

_version_buildgame:
 `
 rem Is called when BUILD GAME selected from file menu
 gosub _interface_openbuildgame : gosub _interface_handlebuildgame :  gosub _interface_closebuildgame
 `
return

_version_main_game_buildexe:

rem Despot file collection
if file exist(myownrootdir$+"buildfiles.ini")=1 then delete file myownrootdir$+"buildfiles.ini"
save array myownrootdir$+"buildfiles.ini",filecollection$()

rem Store root folder
rootpath$=get dir$()

rem Name without EXE
exename$=gbuildname$
if lower$(right$(exename$,4))=".exe"
 exename$=left$(exename$,len(exename$)-4)
endif

rem Path to EXE
if mid$(gbuildpath$,2)=":"
 exepath$=gbuildpath$
else
 exepath$=exedir$
endif
if right$(exepath$,1)<>"\" then exepath$=exepath$+"\"
if path exist(exepath$)=0
 exepath$=mydocumentsdir$+myfpscx10files$+"\X10 executables\"
endif

rem X10 new Vista destination for games
if path exist(exepath$)=0
 rem this should not happen as the files are copied each new install per user
 set dir mydocumentsdir$
 if path exist(myfpscx10files$)=0
  make directory myfpscx10files$
  set dir myfpscx10files$
  make directory "X10 executables"
 endif
endif

rem Create game folder
set dir exepath$
make directory exename$
set dir exename$
make directory "Files"
set dir "Files"

rem FPSCV10X, ensure gamesaves files are removed (if any)
if path exist("gamesaves")=1
 set dir "gamesaves"
 perform checklist for files
 for c=1 to checklist quantity()
  tfile$=checklist string$(c)
  if len(tfile$)>2
   if file exist(tfile$)=1 then delete file tfile$
  endif
 next c
 set dir ".."
else
 make directory "gamesaves"
endif

rem Make sure there is a videobank folder (for movie capture results in standalone games)
if path exist("videobank")=0
 make directory "videobank"
endif

rem ensure file path exists (by creating folders)
filesmax=array count(filecollection$())
for fileindex=0 to filesmax
 olddir$=get dir$()
 src$=filecollection$(fileindex)
 srcstring$=src$
 while len(srcstring$)>0
  for c=1 to len(srcstring$)
   if mid$(srcstring$,c)="\" or mid$(srcstring$,c)="/"
    chunk$=left$(srcstring$,c-1)
    if len(chunk$)>0
     if path exist(chunk$)=0 then make directory chunk$
     set dir chunk$
    endif
    srcstring$=right$(srcstring$,len(srcstring$)-c)
    exit
   endif
  next c
  if c>len(srcstring$) then exit
 endwhile
 set dir olddir$
next fileindex

rem X10 trace files 110407
dim getall$(filesmax+32) : getall=0

rem copy file collection to exe folder
rem Vista has fun here, copying virtual files I since deleted :) 110407
set dir rootpath$
debugviewtext(-1,strarr$(393))
for fileindex=0 to filesmax
 `
 rem Start with local relative path to required file
 src$=filecollection$(fileindex) : srcorig$=src$
 `
 rem X10 always defer to mydoc folder
 if file exist(myownrootdir$+srcorig$)=1 then src$=myownrootdir$+srcorig$
 `
 rem X10 if preferred HUD colour scheme, defer if scheme file exists
 colorscheme$="Grey"
 if len(colorscheme$)>0
  mainhudfolder$=lower$("languagebank\"+language$+"\gamecore\")
  tchoppy$=lower$(left$(srcorig$,len(mainhudfolder$)))
  if tchoppy$=mainhudfolder$
   tchoppy$=lower$(right$(srcorig$,len(srcorig$)-len(mainhudfolder$)))
   tchoppysrc$="languagebank\"+language$+"\gamecore\colorschemes\"+colorscheme$+"\"+tchoppy$
   if file exist(tchoppysrc$)=1 then src$=tchoppysrc$
  endif
 endif
 `
 rem copy to detination
 dest$=exepath$+exename$+"\Files\"+srcorig$
 if file exist(dest$)=1 then delete file dest$
 if file exist(src$)=1
  copy file src$,dest$
 endif
 `
 rem trace activity
 if file exist(srcorig$)=0 and file exist(src$)=0
  getall$(getall)=srcorig$+" not found in core or mydoc folder - "+get dir$()  
 else
  if file exist(myownrootdir$+srcorig$)=1
   getall$(getall)=srcorig$+" copied from mydoc."
  else
   getall$(getall)=srcorig$+" copied from core."
  endif
 endif
 inc getall
 `
next fileindex

rem X10 trace un copied files 110407
ttfile$=exepath$+exename$+"\manifest.txt"
if file exist(ttfile$)=1 then delete file ttfile$
save array ttfile$,getall$()

rem x10 copy extra shader files
if 1
 set dir rootpath$
 dest$=exepath$+exename$+"\Files\effectbank\simple\basepool.fx"
 if file exist(dest$)=1 then delete file dest$
 copy file "effectbank\simple\basepool.fx",dest$
 dest$=exepath$+exename$+"\Files\effectbank\skinning\basepool.fx"
 if file exist(dest$)=1 then delete file dest$
 copy file "effectbank\skinning\basepool.fx",dest$
 dest$=exepath$+exename$+"\Files\effectbank\universe\basepool.fx"
 if file exist(dest$)=1 then delete file dest$
 copy file "effectbank\universe\basepool.fx",dest$
endif

rem copy game engine and rename it
set dir rootpath$ : set dir ".."
dest$=exepath$+exename$+"\"+exename$+".exe"
if file exist(dest$)=1 then delete file dest$
copy file "bin\FPSC-Game.exe",dest$

rem create a setup.ini file here reflecting game
dim setuparr$(999)
setupfile$=exepath$+exename$+"\Files\setup.ini" : i=0
setuparr$(i)="[GAMERUN]" : inc i
setuparr$(i)="realgameview=1" : inc i
`x9setuparr$(i)="dynamiclighting="+str$(gdynamiclightingstate) : inc i
setuparr$(i)="defaultwaterlevel="+str$(gdefaultwaterlevelstate) : inc i
setuparr$(i)="dynamicshadows="+str$(gdynamicshadowsstate) : inc i
setuparr$(i)="useeffects="+str$( guseeffectstate ) : inc i
setuparr$(i)="useeffectsonguns="+str$( guseeffectongunsstate ) : inc i
setuparr$(i)="useeffectsonscene="+str$( guseeffectonscenesstate ) : inc i
setuparr$(i)="useeffectsonentities="+str$( guseeffectonentitiesstate ) : inc i
setuparr$(i)="useeffectsonessentials="+str$( guseeffectsonessentials ) : inc i
setuparr$(i)="dividetexturesize="+str$( gdividetexturesize ) : inc i
setuparr$(i)="disablecamerasmoothing="+str$( gdisablecamerasmoothing ) : inc i
setuparr$(i)="" : inc i
`
setuparr$(i)="[VISUALS]" : inc i
`x9setuparr$(i)="width="+str$( gdisplaywidth ) : inc i
`setuparr$(i)="height="+str$( gdisplayheight ) : inc i
`setuparr$(i)="depth="+str$( gdisplaydepth ) : inc i
setuparr$(i)="bloodmode="+bloodmode$ : inc i
setuparr$(i)="capturecodec="+gx10settingcapturecodec$ : inc i
setuparr$(i)="capturecompression="+str$( gx10settingcapturecompression ) : inc i
setuparr$(i)="capturewidth="+str$( gx10settingcapturewidth ) : inc i
setuparr$(i)="captureheight="+str$( gx10settingcaptureheight ) : inc i
setuparr$(i)="capturefps="+str$( gx10settingcapturefps ) : inc i
setuparr$(i)="capturethreaded="+str$( gx10settingcapturethreaded ) : inc i
setuparr$(i)="capturewait="+str$( gx10settingcapturewait ) : inc i
`
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEMULTIPLAYER]" : inc i
setuparr$(i)="multiplayergame="+str$(gmultiplayergame) : inc i
setuparr$(i)="gameobjectivetype="+str$(ggameobjectivetype) : inc i
setuparr$(i)="gameobjectivevalue="+str$(ggameobjectivevalue) : inc i
setuparr$(i)="oneshotkills="+str$(goneshotkills) : inc i
setuparr$(i)="maxplayers="+str$(numberofplayers) : inc i
setuparr$(i)="spawnrandom="+str$(gspawnrandom) : inc i
setuparr$(i)="uniquegamecode="+guniquegamecode$ : inc i
`
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEDEBUG]" : inc i
setuparr$(i)="usesky=1" : inc i
setuparr$(i)="usefloor="+str$( gusefloorstate ) : inc i
setuparr$(i)="useenvsounds=1" : inc i
setuparr$(i)="useweapons=1" : inc i
setuparr$(i)="" : inc i
setuparr$(i)="[GAMEPROFILE]" : inc i
setuparr$(i)="title="+titlefpi$ : inc i
setuparr$(i)="global="+setupfpi$ : inc i
setuparr$(i)="gamewon="+gamewonfpi$ : inc i
setuparr$(i)="gameover="+gameoverfpi$ : inc i
for num=1 to 11
 setuparr$(i)="key"+str$(num)+"="+str$(listkey(num)) : inc i
next num
for num=1 to 9
 setuparr$(i)="slot"+str$(num)+"="+gunslots$(num) : inc i
next num
setuparr$(i)="levelmax="+str$(glevelmax) : inc i
for num=1 to glevelmax
 setuparr$(i)="levelfpm"+str$(num)+"="+level$(num).fpm$ : inc i
 setuparr$(i)="levelfpi"+str$(num)+"="+level$(num).fpi$ : inc i
next num
if file exist(setupfile$)=1 then delete file setupfile$
save array setupfile$,setuparr$()
undim setuparr$()
`
rem Also save out the localisation ptr file
dim setuparr$(2)
setupfile$=exepath$+exename$+"\userdetails.ini"
setuparr$(0)="[LOCALIZATION]"
setuparr$(1)="language="+language$
save array setupfile$,setuparr$()
undim setuparr$()
`
rem Restore directory
set dir rootpath$

return

_version_includesplashfile:
 remstart
 if 0
  rem not for EnglishDVD version, but is in OEM
  addfiletocollection("splash.jpg")
 endif
 remend
return

_version_dosplash:
 `
 rem FREEWARE OEM VERSION REQUIRES THIS
 rem SHAREWARE AND COMMERCIAL VERSIONS DO NOT REQUIRE THIS
 remstart
 if 0
  `
  rem need to have the file present
  if file exist("splash.jpg")=0
   exit prompt "Splash Screen Data Missing!","Protection Error" : end
  endif
  `
  rem file size must match
  if lower$(language$)="english"
   splashimagesize=64259
   if file size("splash.jpg")<>splashimagesize
    exit prompt "Splash Screen Data Has Been Altered!","Protection Error" : end
   endif
  endif
  `
  rem pass in delay to look at this screen dosplashdelay
  if dosplashdelay>0
   sync mask %1
   cls 0 : sync : cls 0 : sync
   if file exist("splash.jpg")=1
    load image "splash.jpg",1
    if image exist(1)=1
     set sprite 1,0,1
     sprite 1,0,0,1
     set sprite alpha 1,0
     size sprite 1,screen width(),screen height()
     for f=0 to 255 step 10
      cls 0 : set sprite alpha 1,f
      sync
     next f
     set sprite alpha 1,255
     while dosplashdelay>0 and scancode()=0
      dec dosplashdelay
      sleep 2
     endwhile
     cls 0 : sync : cls 0 : sync
    endif
   endif
  endif
  `
 endif
 remend
 `
return

rem
rem Particles (debris, fragments, particles, damage)
rem

_part_init:

rem Setup particles
gosub _part_initexploders

rem Setup fragment objects

rem SCIFI
rem Crate
debrisshapeindex=1
i=debrisshapeindex
bitdetails(debrisshapeindex).max=6
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\scifi\scenery\furniture\cratec\crate_c"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=15 : bitoffset(i,2).z#=-15
bitoffset(i,3).x#=15 : bitoffset(i,3).y#=15 : bitoffset(i,3).z#=0
bitoffset(i,4).x#=0 : bitoffset(i,4).y#=15 : bitoffset(i,4).z#=15
bitoffset(i,5).x#=-15 : bitoffset(i,5).y#=15 : bitoffset(i,5).z#=0
bitoffset(i,6).x#=0 : bitoffset(i,6).y#=30 : bitoffset(i,6).z#=0
rem Gas Canister
debrisshapeindex=2
i=debrisshapeindex
bitdetails(debrisshapeindex).max=2
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\scifi\scenery\furniture\cylindera\cylinder_a"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=24 : bitoffset(i,2).z#=0
rem Cylinder
debrisshapeindex=3
i=debrisshapeindex
bitdetails(debrisshapeindex).max=5
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\scifi\scenery\furniture\cylinderb\cylinder_b"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=3 : bitoffset(i,2).y#=17 : bitoffset(i,2).z#=6
bitoffset(i,3).x#=-8 : bitoffset(i,3).y#=17 : bitoffset(i,3).z#=3
bitoffset(i,4).x#=-3 : bitoffset(i,4).y#=17 : bitoffset(i,4).z#=-8
bitoffset(i,5).x#=8 : bitoffset(i,5).y#=17 : bitoffset(i,5).z#=-5
`
rem WW2
rem Bottle
debrisshapeindex=4
i=debrisshapeindex
bitdetails(debrisshapeindex).max=3
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\itemb\item_b"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=7 : bitoffset(i,2).z#=0
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=14 : bitoffset(i,3).z#=0
rem CrateC
debrisshapeindex=5
i=debrisshapeindex
bitdetails(debrisshapeindex).max=7
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cratec\crate_c"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=-15 : bitoffset(i,2).y#=15 : bitoffset(i,2).z#=0
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=15 : bitoffset(i,3).z#=-15
bitoffset(i,4).x#=15 : bitoffset(i,4).y#=15 : bitoffset(i,4).z#=0
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=15 : bitoffset(i,5).z#=15
bitoffset(i,6).x#=0 : bitoffset(i,6).y#=15 : bitoffset(i,6).z#=15
bitoffset(i,7).x#=0 : bitoffset(i,7).y#=30 : bitoffset(i,7).z#=0
rem CrateE
debrisshapeindex=6
i=debrisshapeindex
bitdetails(debrisshapeindex).max=6
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cratee\crate_e"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=-15 : bitoffset(i,2).y#=15 : bitoffset(i,2).z#=0
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=15 : bitoffset(i,3).z#=-15
bitoffset(i,4).x#=15 : bitoffset(i,4).y#=15 : bitoffset(i,4).z#=0
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=15 : bitoffset(i,5).z#=15
bitoffset(i,6).x#=0 : bitoffset(i,6).y#=30 : bitoffset(i,6).z#=0
rem CrateF
debrisshapeindex=7
i=debrisshapeindex
bitdetails(debrisshapeindex).max=5
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cratef\crate_f"
bitoffset(i,1).x#=-16 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=-11
bitoffset(i,2).x#=-16 : bitoffset(i,2).y#=2 : bitoffset(i,2).z#=6
bitoffset(i,3).x#=16 : bitoffset(i,3).y#=1 : bitoffset(i,3).z#=0
bitoffset(i,4).x#=0 : bitoffset(i,4).y#=10 : bitoffset(i,4).z#=2
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=5 : bitoffset(i,5).z#=-4
rem CylinderF
debrisshapeindex=8
i=debrisshapeindex
bitdetails(debrisshapeindex).max=5
bitdetails(debrisshapeindex).collisionmode=2
bitdetails(debrisshapeindex).file$="meshbank\ww2\scenery\furniture\cylinderf\cylinder_f"
bitoffset(i,1).x#=0 : bitoffset(i,1).y#=0 : bitoffset(i,1).z#=0
bitoffset(i,2).x#=0 : bitoffset(i,2).y#=12 : bitoffset(i,2).z#=-6
bitoffset(i,3).x#=0 : bitoffset(i,3).y#=13 : bitoffset(i,3).z#=5
bitoffset(i,4).x#=0 : bitoffset(i,4).y#=24 : bitoffset(i,4).z#=-10
bitoffset(i,5).x#=0 : bitoffset(i,5).y#=24 : bitoffset(i,5).z#=8

rem Load the fragment objects (three sets of each)
fragmento=fragmentobjectoffset
for debrisshapeindex=1 to 8
 `
 rem use original to get fragment complete size
 o$=bitdetails(debrisshapeindex).file$+".x"
 addfiletocollection(o$)
 load object o$,fragmento
 bitdetails(debrisshapeindex).sizex=object size x(fragmento)
 bitdetails(debrisshapeindex).sizey=object size y(fragmento)
 bitdetails(debrisshapeindex).sizez=object size z(fragmento)
 delete object fragmento
 `
 rem mark start of fragment objects sequence (seeder,3xallfragments)
 bitdetails(debrisshapeindex).fragmentobjstart=fragmento
 `
 rem create object seeder
 make object cone fragmento,10
 make mesh from object fragmento,fragmento
 for o=1 to 8 : add limb fragmento,o,fragmento : next o
 delete mesh fragmento
 hide object fragmento
 inc fragmento
 `
 rem load original
 for o=1 to bitdetails(debrisshapeindex).max
  o$=bitdetails(debrisshapeindex).file$+"_chunk"+str$(o)+".x"
  addfiletocollection(o$)
  load object o$,fragmento
  hide object fragmento
  inc fragmento
 next o
 `
 rem instance two more sets
 for n=1 to 2
  for o=1 to bitdetails(debrisshapeindex).max
   fragmentorig=bitdetails(debrisshapeindex).fragmentobjstart+1+(o-1)
   clone object fragmento,fragmentorig
   hide object fragmento
   inc fragmento
  next o
 next n
 `
next debrisshapeindex
fragmentobjectoffsetmax=fragmento-1

return

_part_free:
 `
 rem Delete particles and fragments
 for o=fragmentobjectoffset to fragmentobjectoffsetmax
  if object exist(o)=1
   tobj=o : gosub _physics_deleteentity
   delete object o
  endif
 next o
 `
 rem Delete explosion objects
 gosub _part_freeexploders
 `
return

_part_movedebrisifinray:
 `
 rem ray is x1#,y1#,z1#,wallhitx#,wallhity#,wallhitz#
 for o=fragmentobjectoffset to fragmentobjectoffsetmax
  if object visible(o)=1
   if intersect object(o,x1#,y1#,z1#,wallhitx#,wallhity#,wallhitz#)<>0
    tix#=wallhitx#-x1# : tiy#=wallhity#-y1# : tiz#=wallhitz#-z1#
    tnorm#=(abs(tix#)+abs(tiy#)+abs(tiz#))/3.0
    tix#=tix#/tnorm# : tiy#=tiy#/tnorm# : tiz#=tiz#/tnorm#
    ttobj=o : ttx#=tix#*tforce# : tty#=tiy#*tforce# : ttz#=tiz#*tforce#
    gosub _physics_setvelocity
   endif
  endif
 next o
 `
return

_part_createfragment:
 `
 rem takes debrisshapeindex,frox,y,z,a#,debrissize,x,y,z# (and new froobjtocopy)
 debrisscalex#=(debrissizex#/bitdetails(debrisshapeindex).sizex)*100.0
 debrisscaley#=(debrissizey#/bitdetails(debrisshapeindex).sizey)*100.0
 debrisscalez#=(debrissizez#/bitdetails(debrisshapeindex).sizez)*100.0
 `
 rem seeder obj placement
 frbo=bitdetails(debrisshapeindex).fragmentobjstart
 position object frbo,frox#,froy#,froz#
 `yrotate object frbo,froa#
 set object to object orientation frbo,frocopyorientfrom
 scale object frbo,debrisscalex#,debrisscaley#,debrisscalez#
 `
 rem cycle through fragment instances (3 copies avail)
 fragmentchoose=bitdetails(debrisshapeindex).choice+1
 if fragmentchoose>2 then fragmentchoose=0
 bitdetails(debrisshapeindex).choice=fragmentchoose
 fragmentchoose=fragmentchoose*bitdetails(debrisshapeindex).max
 `
 rem place fragments using seeder limbs
 frchi=bitdetails(debrisshapeindex).choice
 stparte=e : stparttobj=tobj
 for o=1 to bitdetails(debrisshapeindex).max
  fragmento=bitdetails(debrisshapeindex).fragmentobjstart+1+(o-1)+fragmentchoose
  tobj=fragmento : gosub _physics_deleteentity
  tfx#=bitoffset(debrisshapeindex,o).x#
  tfy#=bitoffset(debrisshapeindex,o).y#
  tfz#=bitoffset(debrisshapeindex,o).z#
  offset limb frbo,o,tfx#,tfy#,tfz#
  position object fragmento,limb position x(frbo,o),limb position y(frbo,o),limb position z(frbo,o)
  rotate object fragmento,limb direction x(frbo,o),limb direction y(frbo,o),limb direction z(frbo,o)
  rem maybe a scale of *0.9 will reduce fling-away effect
  scale object fragmento,debrisscalex#*0.8,debrisscaley#*0.8,debrisscalez#*0.8
  gosub _physics_createdebrisshape
  if debristextureused=0
   rem 200807 - no texture (likely a texture array entity, so blacken!)
   texture object fragmento,explosionscorchsolid
   set object transparency fragmento,2
  else
   texture object fragmento,debristextureused
   if debrisexplodable=1
    set blend mapping on fragmento, 1, explosionscorch, 3, 6
   else
    set blend mapping on fragmento, 1, explosionstressed, 3, 7
   endif
  endif
  tobj=fragmento : e=0
  gosub _physics_ensurephysicsobjvalid
  show object fragmento
 next o
 `
 `rem X10 ground dust effect
 `rem moved to any explosion, for better soft particle presence
 `if particlegrounddust<>0
 ` inc particlegrounddust
 ` if particlegrounddust>10 then particlegrounddust=6
 ` rem emissions are switched off, can create them individually using new command
 ` emit particle particlegrounddust,frox#,froy#,froz#
 `endif
 `
 e=stparte : tobj=stparttobj
 `
return

_part_initexploders:
 `
 rem Load spark, fire and smoke
 tfile$="gamecore\debris\spark.tga" : explodedecalspark=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\fire.tga" : explodedecalfire=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\smoke.tga" : explodedecalsmoke=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\scorched.tga" : explosionscorch=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\stressed.tga" : explosionstressed=loadinternalimagecompressquality(tfile$,5,1)
 tfile$="gamecore\debris\scorched_solid.tga" : explosionscorchsolid=loadinternalimagecompressquality(tfile$,5,1)
 `
 rem X10 apply a soft decal shader for all decals (depth-buffer-read)
 tfile$="effectbank\common\softdecal.fx"
 gsoftdecalshader=loadinternaleffectunique(tfile$,0)
 `
 rem Create Explosion Decals
 texplodersnd=1
 o=explodedecalobjstart
 tsndid=explodesoundoffset
 for exploderindex=1 to explodermax
  `
  rem Set vars and load sound
  exploder(exploderindex).obj=o
  exploder(exploderindex).explode=0
  tfile$="gamecore\debris\explosionfuel"+str$(texplodersnd)+".wav" : addfiletocollection(tfile$)
  inc texplodersnd : if texplodersnd>5 then texplodersnd=1
  load sound tfile$,tsndid
  exploder(exploderindex).explodesound=tsndid
  inc tsndid
  `
  rem Create planes for mapping explosion/smoke images to
  for oi=0 to 16
   make object plain o,100,100
   if oi=0 then texture object o,explodedecalspark : set object light o,0
   if oi>=1 and oi<=3 then texture object o,explodedecalfire : set object light o,0
   if oi>=4 then texture object o,explodedecalsmoke
   set object transparency o,2
   disable object zwrite o
   set object cull o,0
   rem X10 apply the soft decal effect to all decals
   set object effect o,gsoftdecalshader
   hide object o
   inc o
  next oi
  `
 next exploderindex
 explodedecalobjmax=o-1
 explodesoundmax=tsndid-1
 `
return

_part_freeexploders:
 `
 rem Delete Explosion Decals
 for o=explodedecalobjstart to explodedecalobjmax
  if object exist(o)=1
   tobj=o : gosub _physics_deleteentity
   delete object o
  endif
 next o
 `
 rem Delete sounds
 for tsndid=explodesoundoffset to explodesoundmax
  if sound exist(tsndid)=1
   delete sound tsndid
  endif
 next tsndid
 `
return

_part_areexplosionsmaxedout:
 `
 tmaxedoutyes=0
 for exploderindex=1 to explodermax
  if exploder(exploderindex).explode=0 then exit
 next exploderindex
 if exploderindex>=explodermax
  tmaxedoutyes=1
 endif
 `
return

_part_triggerexplosion:
 `
 rem Find free exploder
 for exploderindex=1 to explodermax
  if exploder(exploderindex).explode=0 then exit
 next exploderindex
 if exploderindex<explodermax
  rem visual
  exploder(exploderindex).explode=1
  exploder(exploderindex).x=frox#
  exploder(exploderindex).y=froy#
  exploder(exploderindex).z=froz#
  rem audio
  ts=exploder(exploderindex).explodesound
  if sound exist(ts)=1
   rem make explosion X times larger (ie closer)
   tscamx#=camera position x(playercam)
   tscamy#=camera position y(playercam)
   tscamz#=camera position z(playercam)
   tscamx#=(frox#-tscamx#)
   tscamy#=(froy#-tscamy#)
   tscamz#=(froz#-tscamz#)
   tvol=100-(sqrt(abs(tscamx#*tscamx#)+abs(tscamy#*tscamy#)+abs(tscamz#*tscamz#))/200.0)
   if tvol<0 then tvol=0
   if tvol>100 then tvol=100
   broadcast3dsound(frox#,froy#,froz#,100.0)
   set sound volume ts,tvol
   play sound ts
  endif
  rem dynamic light spot flash
  spotflashbang=5
  spotflashbangx=frox#
  spotflashbangy=froy#+10.0
  spotflashbangz=froz#
  gosub _lighting_spotflash  
  rem X10 - 270907 - create a soft particle smoke at explosion epicentre
  if particlegrounddust<>0
   inc particlegrounddust
   if particlegrounddust>10 then particlegrounddust=6
   rem emissions are switched off, can create them individually using new command
   emit particle particlegrounddust,frox#,froy#,froz#
  endif  
 endif
 `
return

_part_controlexploders:
 `
 rem X10 timer based speed - Use a timer based effect for machine independence
 explodespeed#=(1.0/40.0)*(timer()-lastexplodespeedtime) : lastexplodespeedtime=timer()
 `
 rem Handle all explosions in progress
 for exploderindex=1 to explodermax
  select exploder(exploderindex).explode
   case 1:
    o=exploder(exploderindex).obj
    show object o+0 : position object o+0,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    show object o+1 : position object o+1,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    show object o+2 : position object o+2,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    show object o+3 : position object o+3,exploder(exploderindex).x,exploder(exploderindex).y,exploder(exploderindex).z
    for oi=4 to 13
     o=exploder(exploderindex).obj+oi
     position object o,exploder(exploderindex).x+(cos(((o-5)*20)-180)*50),exploder(exploderindex).y+((sin(((o-5)*20)-180)*20)),exploder(exploderindex).z
     scale object o,25+rnd(25),25+rnd(25),25+rnd(25)
     zrotate object o,rnd(360)
     show object o
    next oi
    for oi=14 to 16
     o=exploder(exploderindex).obj+oi
     position object o,exploder(exploderindex).x+(cos(((o-15)*20)-180)*25),exploder(exploderindex).y+rnd(10),exploder(exploderindex).z
     scale object o,50+rnd(50),50+rnd(50),50+rnd(50)
     zrotate object o,rnd(360)
     show object o
    next oi
    for oi=0 to 16
     o=exploder(exploderindex).obj+oi
     point object o,camera position x(playercam),camera position y(playercam),camera position z(playercam)
     move object o,20 : rem get out of flat wall
    next oi
    exploder(exploderindex).explode=2
    exploder(exploderindex).dist#=15
    exploder(exploderindex).smoke#=0
    exploder(exploderindex).fade#=100
   endcase
  endselect
  if exploder(exploderindex).explode>0
   rem flash
   exploder(exploderindex).fade#=exploder(exploderindex).fade#-(10*explodespeed#)
   if exploder(exploderindex).fade#<1 then exploder(exploderindex).fade#=0
   sparkfade#=100-((90-exploder(exploderindex).fade#)*40)
   if sparkfade#<0 then sparkfade#=0
   if sparkfade#>100 then sparkfade#=100
   set alpha mapping on exploder(exploderindex).obj+0,sparkfade#
   set alpha mapping on exploder(exploderindex).obj+1,exploder(exploderindex).fade#/1.1
   s#=200+(25-(exploder(exploderindex).fade#/2))
   scale object exploder(exploderindex).obj+1,s#,s#,s#
   set alpha mapping on exploder(exploderindex).obj+2,exploder(exploderindex).fade#/1.5
   s#=150+(25-(exploder(exploderindex).fade#/3))
   scale object exploder(exploderindex).obj+2,s#,s#,s#
   set alpha mapping on exploder(exploderindex).obj+3,exploder(exploderindex).fade#/2.0
   s#=80+(25-(exploder(exploderindex).fade#/4))
   scale object exploder(exploderindex).obj+3,s#,s#,s#
   rem smoke
   exploder(exploderindex).dist#=exploder(exploderindex).dist#+(0.1*explodespeed#)
   exploder(exploderindex).smoke#=exploder(exploderindex).smoke#+(2.0*explodespeed#)
   if exploder(exploderindex).smoke#>=100
    rem end smoke
    for oi=0 to 16
     o=exploder(exploderindex).obj+oi
     hide object o
    next oi
    exploder(exploderindex).explode=0
   else
    rem move smoke upwards
    for oi=4 to 16
     o=exploder(exploderindex).obj+oi
     if oi>=14 then up#=0.3 else up#=0.05
     position object o,object position x(o),object position y(o)+up#,object position z(o)
     set alpha mapping on o,100.0-exploder(exploderindex).smoke#
    next oi
   endif
  endif
 next exploderindex
 `
return

`
` Soft Particles
`

_particles_init:
 `
 rem start with no particles in scene
 particleindex=0
 `
 remstart
 experiment to test oparticle commands
 `set particle speed p,0.04
 `particlespeed#=1500 : rem steam
 img$="smokevol1.dds"
 imgid=loadinternalimage(img$)
 particlesize#=10.0
 make particles 1,imgid,50,particlesize#
 position particles 1,450,525,-350
 set particle mask 1,%110010
 color particles 1,255,255,255
 show particles 1
 if 0
  rem soft billowing smoke (small)
  particlespeed#=150.0
  particlelife#=500.0
  particleemissionsdelay#=100.0
  particlechaos#=100.0
  particlespeedofexpand#=5.0
 endif
 if 1
  rem violent steam (small)
  particlespeed#=1000.0
  particlelife#=50.0
  particleemissionsdelay#=5.0
  particlechaos#=5.0
  particlespeedofexpand#=2.0
 endif
 set particle velocity 1,particlespeed#
 set particle life 1,particlelife#
 set particle emissions 1,particleemissionsdelay#
 set particle chaos 1,particlechaos#
 set particle speed 1,particlespeedofexpand#
 remend
 `
 rem create five particles for gunsmoke
 particlegunsmoke=1
 for p=1 to 5
  particletype=3
  particlex#=0
  particley#=0
  particlez#=0
  gosub _particles_create
 next p
 `
 rem create five particles for ground dust
 particlegrounddust=6
 for p=6 to 10
  particletype=4
  particlex#=0
  particley#=0
  particlez#=0
  gosub _particles_create
 next p
 `
 rem create five particles for corpse disappearing
 particlecorpsedust=11
 for p=11 to 15
  particletype=5
  particlex#=0
  particley#=0
  particlez#=0
  gosub _particles_create
 next p
 `
return

_particles_create:
 `
 rem choose type
 if particletype=1
  rem soft billowing smoke
  particlesize#=10.0-rnd(2)
  particlespeed#=150.0-rnd(25)
  particlelife#=500.0-rnd(100)
  particleemissionsdelay#=100.0-rnd(10)
  particlechaos#=100.0-rnd(10)
  particlespeedofexpand#=5.0-rnd(1)
 endif
 if particletype=2
  rem violent steam
  particlesize#=4.0
  particlespeed#=1250.0
  particlelife#=100.0
  particleemissionsdelay#=5.0
  particlechaos#=5.0
  particlespeedofexpand#=2.0
 endif
 if particletype=3
  rem soft gun smoke (none emitting)
  particlesize#=5.0
  particlespeed#=150.0
  particlelife#=200.0
  particlechaos#=200.0
  particlespeedofexpand#=5
  particleemissionsdelay#=0
 endif
 if particletype=4
  rem ground dust (non emitting)
  particlesize#=30.0 : rem 15 280907
  particlespeed#=50.0 : rem 75
  particlelife#=400.0 : rem 300
  particlechaos#=50.0
  particlespeedofexpand#=7
  particleemissionsdelay#=0
 endif
 if particletype=5
  rem corpse dust (non emitting)
  particlesize#=20.0
  particlespeed#=350.0
  particlelife#=200.0
  particlechaos#=200.0
  particlespeedofexpand#=5
  particleemissionsdelay#=0
 endif
 `
 rem create particle
 inc particleindex
 img$="gamecore\softdecals\smoke\smokevol1.dds"
 imgid=loadinternalimage(img$)
 make particles particleindex,imgid,50,particlesize#
 position particles particleindex,particlex#,particley#,particlez#
 set particle mask particleindex,%110010
 color particles particleindex,255,255,255
 show particles particleindex
 `
 rem set particle details
 set particle velocity particleindex,particlespeed#
 set particle life particleindex,particlelife#
 set particle emissions particleindex,particleemissionsdelay#
 set particle chaos particleindex,particlechaos#
 set particle speed particleindex,particlespeedofexpand#
 `
return

_particles_control:
 `
 rem hide/show particles, in time
 `
return

_particles_free:

rem Handle any debris
for p=1 to particleindex
 if particles exist(p)=1
  delete particles p
 endif
next p
particleindex=0

return

rem
rem MULTIPLAYER
rem

`
` Init
`
_multi_earlyinit:
 `
 rem Validate playername here
 for c=1 to len(playername$)
  if c>1 and asc(mid$(playername$,c))=10 or asc(mid$(playername$,c))=13
   playername$=left$(playername$,c-1)
   exit
  endif
 next c
 `
 rem Used to get Network Detect and Firewall permission as soon as possible
 if createorjoin=1
  rem create a tcp server
  MULTIPLAYER CREATE TCP SERVER servername$
  if glocalserveroverride$=""
   rem FPSCV105RC2 - use already validated server IP address
   `ipaddress$=MULTIPLAYER GET IP ADDRESS() ` sometimes returned local or router IP (no good)
   `for c=1 to len(ipaddress$)
   ` if mid$(ipaddress$,c)=":" then ipaddress$=left$(ipaddress$,c-1) : exit
   `next c
   ipaddress$=serveripaddress$
  else
   ipaddress$=glocalserveroverride$
  endif
  rem add to gamelist
  addip$=ipaddress$
  addname$=playername$
  gosub _ai_gamelist_add
 else
  rem join a tcp server
  MULTIPLAYER CONNECT TO TCP SERVER playername$, ipaddress$
 endif
 `
 rem Create Deadreckoning vectors
 for t=10+0 to 10+(16*5) : r=make vector3(t) : next t
 `
 rem Memblock allocations for vary-byte tranfser
 mb_move=101 : make memblock mb_move, 48
 mb_write=102 : make memblock mb_write, 48
 `
return

_multi_assetloader:
 `
 rem Load talk sound ping
 talkpingsound=loadinternalsoundcore(rootdir$+"audiobank\misc\talkping.wav",0)
 lastplayedtalkindex=talkindex
 `
return

_multi_start:
 `
 rem optional visuals
 if createorjoin=1
  if left$(ipaddress$,8)="192.168."
   set window title strarr$(632)+" ["+ipaddress$+"] "+strarr$(633)
  else
   set window title strarr$(632)+" ["+ipaddress$+"] "+strarr$(634)
  endif
 else
  set window title playername$+" ["+ipaddress$+"]"
 endif
 `
 rem Scan all start positions of characters (these will be the respawn points)
 gosub _multi_initrespawnarray
 `
 rem parts that are re-called if game session is repeated
 gosub _multi_restart
 `
return

_multi_restartprepare:
 `
 rem hide all characters initially in MP game
 for e=1 to entityelementmax
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1
   entityelement(e).active=0
   entityelement(e).dormant=1
   entityelement(e).eleprof.cantakeweapon=0
   obj=entityelement(e).profileobj
   if obj>0
    if object exist(obj)=1
     hide object obj
    endif
   endif
   obj=entityelement(e).obj
   if obj>0
    if object exist(obj)=1
     hide object obj
    endif
   endif
   tobj2=entityelement(e).attachmentobj
   if tobj2>0
    if object exist(tobj2)=1
     hide object tobj2
    endif
   endif
  endif
 next e
 `
return

_multi_restart:
 `
 rem called after start and any restarting of game session
 rem Init var
 lagmon#=200
 dwLocalPlayerID=0
 iLocalEL=0
 PlayerCanStart=0
 PlayerCanStartStage=0
 Servergameisfull=0
 gtalkytoaster=0
 gterminationcountdown=0
 `
 rem Wipe out talk array
 talkindex=0 : for ti=0 to 10 : talkscript$(ti)="" : talkscriptcount(ti)=0 : next ti
 `
 rem Clear multiplayer link list
 for el=1 to 16 : multiplayeridlink(el)=1 : next el
 for el=1 to 16 : multiplayerplrindex(el)=0 : next el
 for el=1 to 16 : characterchosen(el)=0 : characterchoiceentityindex(el)=0 : next el
 `
 rem Clear out all STATE data (as old game if any might mess new game)
 for el=1 to 16
  stategetready(el)=0
  statex(el)=0
  statey(el)=0
  statez(el)=0
  statea(el)=0
  stateanim(el)=0
  stateanimdir(el)=0
  statecolmaterialtype(el)=0
  stateanimwait(el)=0
  statewhodidit(el)=0
  stateplayagain(el)=0
  stateviewy(el)=0
  statesviewdy(el)=0
  stateweapon(el)=0
  stateannounce(el)=0
  statesx(el)=0
  statesy(el)=0
  statesz(el)=0
  statesa(el)=0
  statesvel(el)=0
  statetx(el)=0
  statety(el)=0
  statetz(el)=0
  statedx(el)=0
  statedy(el)=0
  statedz(el)=0
  statemove(el)=0
  statelag(el)=0
  statemsgap(el)=0
  statemytimer(el)=0
  statecodeupdate(el,0)=0
  statecodeupdate(el,1)=0
  statecodeupdate(el,2)=0
  statecodeupdate(el,3)=0
  statecodeupdate(el,4)=0
  stateraycastpace(el)=0
 next el
 `
 rem Reset frag and laststore counts
 for el=1 to multiplayermax
  frags(el)=0 : for ti=0 to 4 : statecodeupdate(el,ti)=-1 : next ti
 next el
 `
 rem begin the multiplayer game INIT
 if createorjoin=1
  rem setup server player
  multiplayeridlinkmax=1 : iLocalEL=1
  multiplayeridlink(iLocalEL)=0
  multiplayername$(iLocalEL)=playername$
  multiplayerplrindex(iLocalEL)=1
  gosub _multi_identifycharactersinentities
  gosub _multi_andwho
  characterchosen(iLocalEL)=characterchoice
  characterchoiceentityindex(iLocalEL)=characterlistentity(characterchoice)
  rem player position and angle from player() data
  gosub _multi_setlocalstart
  rem set new server players health on server
  plrindex=multiplayerplrindex(iLocalEL) : te=characterchoiceentityindex(iLocalEL)
  player(plrindex).health=entityelement(te).eleprof.strength
  rem if test game, give a fake health in case no character to use
  if gtestgamemodefromeditor=1 then player(plrindex).health=100
  rem hoster can be part of game now
  PlayerCanStart=1 : dwStartTime=timer()
 else
  rem join a tcp server
  setupvoicechat=0
 endif
 `
 rem init burst time (lagmon# bursts)
 dwBurstTime=timer()
 `
 rem set as initialised
 multiplayerinitialised=1
 `
return

_multi_initrespawnarray:
 `
 rem init
 respawnmax=0
 for e=1 to entityelementmax
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1
   rem record psosition
   inc respawnmax
   rem X10 - 291007 - ensure array large enough
   if respawnmax>array count(respawn())
    dim respawn(respawnmax) as respawntype
   endif
   respawn(respawnmax).e=e
   respawn(respawnmax).x=entityelement(e).x
   respawn(respawnmax).y=entityelement(e).y
   respawn(respawnmax).z=entityelement(e).z
   respawn(respawnmax).ry=entityelement(e).ry
  endif
 next e
 `
return

_multi_playertorespawnpos:
 `
 rem if no respawn data, use an available place to start from
 if respawnmax=0
  rem Find player start location
  playerstartx#=0 : gosub _player_setstartposonly
 else
  rem uses TE, return to origin, or random
  ttries=9
  rsiadd=0
  while ttries>0
   rsi=0
   if gspawnrandom=0 or randomposnotworkatlocalstart=1
    for rsi=1 to respawnmax
     if respawn(rsi).e=te then exit
    next rsi
   else
    rsi=trandomvalue
   endif
   if rsi>0
    rem start pos
    rsi=rsi+rsiadd : rsi=1+((rsi-1) mod respawnmax)
    if rsi<1 then rsi=1
    if rsi>respawnmax then rsi=respawnmax
    playerstartx#=respawn(rsi).x
    playerstarty#=respawn(rsi).y
    playerstartz#=respawn(rsi).z
    playerstartrx#=0
    playerstartry#=respawn(rsi).ry
    rem ensure it is not filled, exclude self from check
    tokay=1
    for ttel=1 to multiplayermax
     if ttel<>iLocalEL
      if multiplayeridlink(ttel)<>1
       tte=characterchoiceentityindex(ttel)
       ttdx#=abs(entityelement(tte).x-playerstartx#)
       ttdy#=abs(entityelement(tte).y-playerstarty#)
       ttdz#=abs(entityelement(tte).z-playerstartz#)
       ttdd#=sqrt((ttdx#*ttdx#)+(ttdy#*ttdy#)+(ttdz#*ttdz#))
       if ttdd#<100 then tokay=0 : exit
      endif
     endif
    next ttel
    if tokay=1
     ttries=0
    else
     inc rsiadd
    endif
   endif
   dec ttries
  endwhile
 endif
 `
return

_multi_setlocalstart:
 `
 rem have characterchoiceentityindex(iLocalEL)
 te=characterchoiceentityindex(iLocalEL)
 if te>0
  rem assign weapon to player
  tentid=entityelement(te).bankindex
  weaponindex=entityprofile(tentid).hasweapon
  tqty=10 : pi=0
  gosub _player_obtainaweapon
  autoloadgun=weaponindex
 endif
 `
 rem Copy again to make sure the weapon is given back after repos (die and spawn)
 tcopyorrestart=0 : gosub _gun_resetgunsettings
 `
 rem Place player at start position (randomize and lifecode using TE ensures identical LOCALSTARTs)
 randomize te
 trandomvalue=1+rnd(respawnmax-1)
 tlifecode=te
 randomposnotworkatlocalstart=1
 el=iLocalEL : gosub _multi_resetplrpos
 randomposnotworkatlocalstart=0
 camerapositionx=statex(iLocalEL)
 camerapositiony=statey(iLocalEL)+phyeyeheight#+21.0
 camerapositionz=statez(iLocalEL)
 position camera playercam,camerapositionx,camerapositiony,camerapositionz
 `
return

_multi_free:
 `
 rem Free Deadreckoning vectors
 for t=10+0 to 10+(16*5) : r=delete vector3(t) : next t
 `
 rem Delet memblocks
 if mb_move>0
  if memblock exist(mb_move)=1
   delete memblock mb_move
  endif
  mb_move=0
 endif
 if mb_write>0
  if memblock exist(mb_write)=1
   delete memblock mb_write
  endif
  mb_write=0
 endif
 `
 rem terminate connection session
 MULTIPLAYER DISCONNECT
 multiplayerinitialised=0
 `
 rem delete from gamelist
 if createorjoin=1
  gosub _ai_gamelist_delete
 endif
 createorjoin=0
 `
 rem Restore normal text
 set text to normal
 `
return

_multiplayer_repeatresetgame:
 `
 rem remove weapon from characters of previous game
 for el=1 to multiplayermax
  if multiplayeridlink(el)<>1
   rem Remove old weapon from model
   e=characterchoiceentityindex(el)
   entityelement(e).eleprof.hasweapon$=""
   gosub _entity_switchattachment
   rem Hide characters initially
   tobj=entityelement(e).obj
   if tobj>0
    if object exist(tobj)=1
     hide object tobj
    endif
   endif
  endif
 next el
 `
 rem clear viscolmap
 gosub _entity_fillviscolmap
 `
 rem Game has been repeated, so reset some small elements to reproduce exact restart (quicker than reload)
 gosub _player_resetobjectives
 gosub _player_startpos
 `
 rem Reset weapons
 tcopyorrestart=1 : gosub _gun_resetgunsettings
 `
 rem Reset entities
 tcopyorrestart=1 : gosub _entity_resetentitiestorestartstates
 `
 rem Restart multiplayer game session (causes all players to reselect characters)
 gosub _multi_restart
 `
 rem restore text to in-game style and size
 set text size 16 : set text to normal
 `
return


`
` Control
`

_multi_control:
 `
 if gterminationcountdown=0
  `
  rem unmark
  gosub _multi_unmark
  `
  rem Feed local data into states
  if multiplayerprototest=0
   if iLocalEL>0
    plrindex=multiplayerplrindex(iLocalEL)
    if weaponammoindex>0
     stateweapon(iLocalEL)=gunid
    else
     stateweapon(iLocalEL)=0
    endif
    if stateanimwait(iLocalEL)>0
     rem and wait for click to respawn
     player(plrindex).health=0
     if mouseclick()<>0 or (spacekey()=1 and gtalkytoaster=0)
      stateplayagain(iLocalEL)=1
      if createorjoin=2
       rem if client, send this click to server
       MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
       write memblock byte 102, 0, 212
       write memblock byte 102, 2, stateplayagain(iLocalEL)
       write memblock dword 102, 4, multiplayeridlink(iLocalEL)
       MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
       inc guarenteedbytes,8 : inc unreliablebytes,0
      endif
     endif
    else
     if stategetready(iLocalEL)>0
      rem regular activity frozen until player touches ground
      stategetready(iLocalEL)=stategetready(iLocalEL)-1
     else
      statex(iLocalEL)=camerapositionx
      statey(iLocalEL)=(camerapositiony-phyeyeheight#)-20.0
      statez(iLocalEL)=camerapositionz
      statedx(iLocalEL)=statex(iLocalEL)
      statedy(iLocalEL)=statey(iLocalEL)
      statedz(iLocalEL)=statez(iLocalEL)
      stateviewy(iLocalEL)=wrapvalue(camera angle y(playercam))
     endif
     rem 1-spanw,2-idle,3-walk,4-strafeL,5-strafeR,6-run,32-crouchidle,33-crouchmove,12-'a' death,92-freeformidle,7-reload
     te=characterchoiceentityindex(iLocalEL)
     stateanimdir(iLocalEL)=0
     if player(plrindex).health>0
      if jumpaction<>0
       stateanim(iLocalEL)=92
      else
       statecolmaterialtype(iLocalEL)=colmaterialtype
       if crouchmode<>0
        if movement=1
         stateanim(iLocalEL)=33
         if (plrkeyS)=1 then stateanimdir(iLocalEL)=1
        else
         stateanim(iLocalEL)=32
        endif
       else
        if movement=1
         if (plrkeyA)=1
          stateanim(iLocalEL)=4
         else
          if (plrkeyD)=1
           stateanim(iLocalEL)=5
          else
           if (plrkeySHIFT)=1
            stateanim(iLocalEL)=6
           else
            stateanim(iLocalEL)=3
           endif
           if (plrkeyS)=1 then stateanimdir(iLocalEL)=1
          endif
         endif
        else
         if gunmode>=121 and gunmode<131
          stateanim(iLocalEL)=7
         else
          stateanim(iLocalEL)=2
         endif
        endif
       endif
      endif
     endif
    endif
   endif
  endif
  `
  rem Can detect NEW PLAYER here
  dwid as DWORD
  for i = 0 to MULTIPLAYER GET PLAYER COUNT()
   if i>0
    dwid=MULTIPLAYER GET PLAYER ID( i-1 )
   else
    dwid=0
   endif
   gotel=0 : freeel=0
   for el=1 to 16
    if multiplayeridlink(el)=1 and freeel=0 then freeel=el
    if multiplayeridlink(el)=dwid
     gotel=el : exit
    endif
   next el
   if gotel=0
    if freeel>0
     rem New Player for multiplayer-server-player list
     multiplayeridlink(freeel)=dwid
     multiplayeri(freeel)=i-1
     multiplayerisnew(freeel)=3
     tname$=MULTIPLAYER GET PLAYER NAME( i-1 )
     for c=1 to len(tname$)
      if asc(mid$(tname$,c))=10 or asc(mid$(tname$,c))=13
       tname$=left$(tname$,c-1)
       exit
      endif
     next c
     multiplayername$(freeel)=tname$
     if freeel>multiplayeridlinkmax then multiplayeridlinkmax=freeel
     rem add player() and update multiplayerplrindex
     el=freeel : gosub _multi_addplayer
     rem joining prompt, only if later in game
     if PlayerCanStart=1
      stateannounce(el)=500
     endif
     rem reset frag for new plr
     frags(el)=0
    else
     rem a 17th DP-plr tried to get into my 16 plr max session
    endif
   else
    rem continually refresh internal index reference
    if i>0
     rem when a client leave and reenters, the playerlist() list is changed!
     multiplayeri(gotel)=i-1
    endif
   endif
  next i
  rem clean up players no longer in game
  for el=1 to multiplayeridlinkmax
   if multiplayeridlink(el)<>1
    if el>1 and getindexfromid(multiplayeridlink(el))=0
     rem this player EL left the game or was kicked out
     multiplayeridlink(el)=1
     multiplayeri(el)=-1
     rem leaving prompt
     stateannounce(el)=-500
     rem remove visual player from game
     te=characterchoiceentityindex(el)
     rem ensure cannot shoot entity after plr gone from game
     entityelement(te).collisionactive=0
     tobj=entityelement(te).obj
     if tobj>0 then hide object tobj
     tobj2=entityelement(te).attachmentobj
     if tobj2>0 then hide object tobj2
     tobj3=entityelement(te).attachmentblobobj
     if tobj3>0
      hide object tobj3
      rem 220807 - extra objects associated with character
      hide object tobj3+1+0
      hide object tobj3+1+1
     endif
     rem remove players identity from character list and allow the slot to be reused
     if characterchosen(el)>0
      characterchosen(el)=0 : Servergameisfull=0
      characterchoiceentityindex(el)=0
     endif
    endif
   endif
  next el
  `
  rem server or client
  gosub _common
  if createorjoin=1
   gosub _server
  else
   gosub _client
  endif
  gosub _playersend
  `
  rem Handle dead reckoning
  for el=1 to multiplayeridlinkmax
   if el<>iLocalEL
    if multiplayeridlink(el)<>1
     if statelag(el)>0 then gosub _packet_move_dedrec
     gosub _packet_rotate_dedrec
    endif
   endif
  next el
  `
  rem this is where we assign server-controlled EL data to actual entity drones
  if multiplayerprototest=0 and showgamemenu=0
   if showfpsinrealgame=1 or showfpsinrealgame=2 then set cursor 0,100
   for el=1 to multiplayeridlinkmax
    if showfpsinrealgame=2 then print el;" - ISNEW:";multiplayerisnew(el);" - ";
    if multiplayerisnew(el)=0 or el=iLocalEL
     te=characterchoiceentityindex(el)
     tentid=entityelement(te).bankindex
     if showfpsinrealgame=2 then print "ID:";multiplayeridlink(el);
     if multiplayeridlink(el)<>1 and te>0
      plrindex=multiplayerplrindex(el)
      tobj=entityelement(te).obj
      if showfpsinrealgame=1 then print multiplayername$(el);" ";str$(frags(el));" (";statelag(el);")"
      if showfpsinrealgame=2 then print " - H:";player(plrindex).health;" - TE:";te;" ";tobj;" ";multiplayername$(el);
      if tobj>0
       entityelement(te).x=statex(el)
       entityelement(te).y=statey(el)
       entityelement(te).z=statez(el)
       `x9entityelement(te).mover.da=stateviewy(el)
       rem 220807 - due to odd pivot problem, rotate by 180 here to solve pivot!! (aiko)
       entityelement(te).mover.da=stateviewy(el)+180
       if stateanim(el)<>1+entityelement(te).animdo
        entityelement(te).animonce=0
        entityelement(te).animset=stateanim(el)
        entityelement(te).animdir=stateanimdir(el)
        if stateanimwait(el)>0 then entityelement(te).animonce=1
       endif
       if el=iLocalEL
        hide object tobj
        set object collision off tobj
        entityelement(te).active=0
        entityelement(te).dormant=1
        entityelement(te).collisionactive=0
        te=characterchoiceentityindex(el)
        tobj2=entityelement(te).attachmentobj
        if tobj2>0 then hide object tobj2
       else
        show object tobj
        entityelement(te).active=1
        entityelement(te).dormant=0
        if player(plrindex).health>0
         entityelement(te).collisionactive=1
        else
         entityelement(te).collisionactive=0
        endif
        rem if this plr entity is dead, make sure the corpse finds the floor
        if player(plrindex).health=0
         rem pause dead character
         stte=e : stentid=entid
         e=te : entid=entityelement(e).bankindex
         tbaseframe=entityelement(e).animdo : gosub _entity_getactualframefinish : tffinish=tactualframe
         e=stte : entid=stentid
         if object frame(tobj)>=tffinish-2.0 and object frame(tobj)<=tffinish
          stop object tobj
         endif
         rem set dead guy final resting pose
         tppy#=entityelement(te).y
         tppa#=entityelement(te).ry
         if entityelement(te).animdo=14
          tpmb#=55.0
         else
          tpmb#=-55.0
         endif
         tppx#=newxvalue(entityelement(te).x,tppa#,tpmb#)
         tppz#=newzvalue(entityelement(te).z,tppa#,tpmb#)
         tdst#=static raycast(tppx#,tppy#+70.0,tppz#,tppx#,tppy#-505.0,tppz#)
         tlowestmove=0
         if abs(tdst#-70.0)>5.0
          if tdst#<70
           rem head through slope - push away
           tlowestmove=1
          else
           rem head hovering in thin air - push fore
           tlowestmove=2
          endif
         endif
         if tlowestmove<>0
          if tlowestmove=1
           entityelement(te).x=newxvalue(entityelement(te).x,tppa#,(tpmb#/15.0)*-1)
           entityelement(te).z=newzvalue(entityelement(te).z,tppa#,(tpmb#/15.0)*-1)
          else
           entityelement(te).x=newxvalue(entityelement(te).x,tppa#,(tpmb#/15.0))
           entityelement(te).z=newzvalue(entityelement(te).z,tppa#,(tpmb#/15.0))
          endif
          tppx#=entityelement(te).x : tppz#=entityelement(te).z
          tdst#=static raycast(tppx#,tppy#+5.0,tppz#,tppx#,tppy#-505.0,tppz#)
          tthisy#=tppy#-(tdst#-5.0)
          if tthisy#<entityelement(te).y
           entityelement(te).y=entityelement(te).y-6
           if entityelement(te).y<tthisy#
            entityelement(te).y=tthisy#
           endif
          endif
          statex(el)=entityelement(te).x
          statey(el)=entityelement(te).y
          statez(el)=entityelement(te).z
         endif
        endif
        if showfpsinrealgame=2
         if object in screen(tobj)=1
          center text object screen x(tobj),object screen y(tobj)-40,multiplayername$(el)+"["+str$(stateanim(el))+"] "+characterlist$(characterchosen(el))+"("+str$(characterchoiceentityindex(el))+")"
          if createorjoin=1
           center text object screen x(tobj),object screen y(tobj)-10,"HEALTH="+str$(player(plrindex).health)+"FRAGS="+str$(frags(el))
          endif
         endif
        else
         if object in screen(tobj)=1 and object visible(tobj)=1
          if stateraycastpace(el)=0
           tokay=1 : gosub _multi_caniseeplr
           if tokay=1 then stateraycastpace(el)=1
          endif
          if stateraycastpace(el)>=1
           stateraycastpace(el)=stateraycastpace(el)+1
           if stateraycastpace(el)>10
            tokay=1 : gosub _multi_caniseeplr
            if tokay=1
             stateraycastpace(el)=1
            else
             stateraycastpace(el)=0
            endif
           endif
          endif
          if stateraycastpace(el)>0
           center text object screen x(tobj),object screen y(tobj),multiplayername$(el)
          endif
         else
          stateraycastpace(el)=0
         endif
        endif
       endif
      endif
     endif
    endif
    if showfpsinrealgame=2 then print
   next el
   if showfpsinrealgame=2
    el=iLocalEL : center text screen width()/2,screen height()-40,multiplayername$(el)+"["+str$(stateanim(el))+"] "+str$(characterchosen(el))+":"+characterlist$(characterchosen(el))+"("+str$(characterchoiceentityindex(el))+")"+" FRAGS="+str$(frags(el))
   endif
   `
  endif
  `
  rem mark positions in viscolmap
  gosub _multi_mark
  `
 endif
 `
 rem announcements
 anngap=25
 if showgamemenu=0
  tylinevalue=screen height()-(anngap*2)
  if gterminationcountdown>0
   set cursor 0,tylinevalue
   print strarr$(635);
   dec gterminationcountdown
   if gterminationcountdown<2
    tserverendsreason=1
    gosub _multi_serverendedgame
    mpgameinprogress=0
    continueokay=1
   endif
  else
   if PlayerCanStart=0
    set cursor 0,tylinevalue
    print strarr$(636);
`    if gmultiplayergame=1 and multiplayerinitialised=1 and multiplayersystemdisabled=0 then print "OK..";
`    print "(";str$(PlayerCanStartStage);","+str$(MULTIPLAYER GET PLAYER COUNT())+","+str$(dwLocalPlayerID)+","+str$(gterminationcountdown)+")";
   else
    for el=1 to multiplayeridlinkmax
     if multiplayeridlink(el)=1
      if stateannounce(el)<0
       set cursor 0,tylinevalue
       stateannounce(el)=stateannounce(el)+1
       print multiplayername$(el)+" "+strarr$(637)+" (";stateannounce(el);")";
       dec tylinevalue,anngap
      endif
     else
      if stateannounce(el)=0
       rem X killed Y (Y represents this)
       if stateanimwait(el)>=10
        set cursor 0,tylinevalue
        sourceel=statewhodidit(el)
        print multiplayername$(sourceel)+" "+strarr$(638)+" "+multiplayername$(el);
        dec tylinevalue,anngap
       endif
      else
       if el<>iLocalEL
        rem slowly joining game
        if stateannounce(el)>0
         set cursor 0,tylinevalue
         stateannounce(el)=stateannounce(el)-1
         print multiplayername$(el)+" "+strarr$(639);
         dec tylinevalue,anngap
        endif
       else
        stateannounce(el)=0
       endif
      endif
     endif
    next el
    rem Click to restart
    if stateanimwait(iLocalEL)>0
     set cursor 0,tylinevalue
     print strarr$(640);str$(stateanimwait(iLocalEL));
     dec tylinevalue,anngap
    endif
    rem Talk scripts (going backwards)
    if talkindex>0
     for ti=talkindex-1 to 0 step -1
      if talkscriptcount(ti)>0
       talkscriptcount(ti)=talkscriptcount(ti)-1
       set cursor 0,tylinevalue
       print multiplayername$(talkscriptwho(ti))+talkscript$(ti);
       dec tylinevalue,anngap
      endif
     next ti
    endif
    for ti=10 to talkindex step -1
     if talkscriptcount(ti)>0
      talkscriptcount(ti)=talkscriptcount(ti)-1
      set cursor 0,tylinevalue
      print multiplayername$(talkscriptwho(ti))+talkscript$(ti);
      dec tylinevalue,anngap
     endif
    next ti
    rem Monitor for ping
    if talkpingsound>0
     if talkindex<>lastplayedtalkindex
      lastplayedtalkindex=talkindex
      if sound exist(talkpingsound)=1
       play sound talkpingsound
      endif
     endif
    endif
   endif
  endif
 endif
 `
 rem capture and kill local player if they fall out of universe MP style
 if camerapositiony<-200
  tdamage=65535 : e=characterchoiceentityindex(iLocalEL)
  if entityelement(e).health>0
   gosub _multi_dealentityedamage
  endif
 endif
 `
return

_multi_caniseeplr:
 `
 rem can i see the plr to write their name on screen (tokay=0=no)
 if static raycast(camerapositionx,camerapositiony,camerapositionz,entityelement(te).x,entityelement(te).y+5.0,entityelement(te).z)=0
  tokay=1
  for tte=1 to entityelementlist
   if entityelement(tte).active=1
    if entityelement(tte).eleprof.isimmobile=1
     if entityelement(tte).collisionactive=1
      ttentid=entityelement(tte).bankindex
      if entityprofile(ttentid).isweapon=0 and entityprofile(ttentid).isammo=0 and entityprofile(ttentid).ischaracter=0
       ttobj=entityelement(tte).obj
       if ttobj>0
        tdst#=intersect object(ttobj,camerapositionx,camerapositiony,camerapositionz,entityelement(te).x,entityelement(te).y+5.0,entityelement(te).z)
        if tdst#<>0 then tokay=0 : exit
       else
        rem some entities are zero OBJ value
       endif
      endif
     endif
    endif
   endif
  next tte
 else
  tokay=0
 endif
 `
return

_multi_unmark:
 `
 rem remove old marker from viscolmap
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   tx=statetx(el) : ty=statety(el) : tz=statetz(el)
   if viscolmap(tx,ty,tz)=-1 then viscolmap(tx,ty,tz)=0
  endif
 next el
 `
return

_multi_mark:
 `
 rem write new marker to viscolmap
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   tx=statedx(el)/25 : ty=statedy(el)/100 : tz=statedz(el)/-25
   if ty>=0 and ty<=viscoly
    if tx>=0 and tz>=0
     if tx<=viscolx and tz<=viscolz
      if viscolmap(tx,ty,tz)=0
       statetx(el)=tx : statety(el)=ty : statetz(el)=tz
       viscolmap(tx,ty,tz)=-1
      endif
     endif
    endif
   endif
  endif
 next el
 `
return

`
` MP Subroutines
`

_common:
 `
 rem update MSgap counts
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   `
   rem keep tabs on players lag
   statemsgap(el)=timer()-statemytimer(el)
   `
   rem when looping sound too old, stop it
   e=characterchoiceentityindex(el)
   if entityelement(e).firesoundloopremote<>0
    if timer()-entityelement(e).firesoundlooptime>500
     stop sound entityelement(e).firesoundloopremote
     entityelement(e).firesoundloopremote=0
    endif
   endif
   `
   rem auto-footfalls when players in motion
   if (stateanim(el)>=3 and stateanim(el)<=6) or (stateanim(el)>=33 and stateanim(el)<=36)
    movement=1
    if stateanim(el)=6 then basespeed#=70 else basespeed#=50
    if stateanim(el)>=33 and stateanim(el)<=36 then basespeed#=15 : movement=2
    colmaterialtype=statecolmaterialtype(el) : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
    if plrid>1 then gosub _player_playfootfall
   endif
   `
   rem reduce invincibility counter
   if entityelement(e).invincibleactive>0
    entityelement(e).invincibleactive=entityelement(e).invincibleactive-1
   endif
   `
  endif
 next el
 `
 rem CAPTURE for debug purposes CONTROLS
 if showfpsinrealgame=2
  set cursor 0,0
  print "startlogging=";startlogging;" (";loginfoindex;")"
  if inkey$()="#" and startlogging=0 then startlogging=1
  if inkey$()="'" and startlogging=2 then startlogging=3
  if startlogging=1
   dim loginfo$(1001)
   loginfoindex=0
   startofrecording=timer()
   startlogging=2
  endif
  rem startlogging=2 inside message loop reporting activity
  if startlogging=3
   if file exist("multiplayerlogfile.txt")=1 then delete file "multiplayerlogfile.txt"
   save array "multiplayerlogfile.txt",loginfo$(0)
   undim loginfo$(0)
   startlogging=0
  endif
 endif
 `
 rem CAPTURE FORMATTING
 if startlogging=2
  if MULTIPLAYER MESSAGE EXISTS ( )
   loginfo$(loginfoindex)="["+str$((timer()-startofrecording)/1000)+"s]"
   inc loginfoindex : if loginfoindex>=1000 then startlogging=3
  endif
 endif
 `
 rem Reset so server will always send to ALL clients
 MULTIPLAYER SEND MESSAGE TO 0
 `
 rem get messages (clientplayers(createorjoin=0) also accepts server messages)
 while MULTIPLAYER MESSAGE EXISTS ( )
  `
  rem One message at a time
  MULTIPLAYER GET MESSAGE
  dwPlayerID = MULTIPLAYER GET MESSAGE PLAYER FROM( )
  `
  rem Message memblock slice up
  dwMessageCode=0
  if MULTIPLAYER GET MESSAGE TYPE( ) = 3
   MULTIPLAYER GET MESSAGE MEMBLOCK mb_move
   dwCode = memblock byte( mb_move, 0 )
   dwMessageCode=3
  endif
  `
  rem CAPTURE for debug purposes
  treportonmessage=0
  if startlogging=2
   if treportonmessage=0
    el=getelfromid(dwPlayerID) : tt$=" from "+multiplayername$(el)
    loginfo$(loginfoindex)=str$(dwMessageCode)+" "+right$(str$(1000+dwCode),3)+" "+tt$
    inc loginfoindex
    if loginfoindex>=1000
     startlogging=3
    endif
   endif
  endif
  `
  rem Handle both server and client comms here
  if (createorjoin=1 and dwPlayerID<>0) or createorjoin=2
   `
   rem message from server to client only
   if createorjoin=2
    if MULTIPLAYER GET MESSAGE TYPE( ) = 2
     tname$=MULTIPLAYER GET MESSAGE STRING()
     if left$(tname$,2)<>">>"
      el=getelfromid(0)
      for c=1 to len(tname$)
       if asc(mid$(tname$,c))=10 or asc(mid$(tname$,c))=13
        tname$=left$(tname$,c-1)
        exit
       endif
      next c
      multiplayername$(el)=tname$
     endif
    endif
   endif
   `
   rem string can also be a talkytoaster message
   if MULTIPLAYER GET MESSAGE TYPE( ) = 2
    ttalk$=MULTIPLAYER GET MESSAGE STRING()
    if left$(ttalk$,2)=">>"
     for c=1 to len(ttalk$)
      if asc(mid$(ttalk$,c))=10 or asc(mid$(ttalk$,c))=13
       ttalk$=left$(ttalk$,c-1)
       exit
      endif
     next c
     rem copy rest of talk to string
     talkscript$(talkindex)=ttalk$
     talkscriptcount(talkindex)=200
     el=getelfromid(dwPlayerID) : talkscriptwho(talkindex)=el
     inc talkindex : if talkindex>10 then talkindex=0
     if createorjoin=1
      rem if server receives talkmessage, must send out to all clients
      el=getelfromid(dwPlayerID)
      MULTIPLAYER SEND FROM PLAYER dwPlayerID
      MULTIPLAYER SEND MESSAGE STRING ttalk$,0x0080
     endif
    endif
   endif
   `
   rem message changes states on server
   if dwMessageCode=3 and (dwCode=0 or dwCode=4 or dwCode=5 or dwCode=9)
    el=getelfromid(dwPlayerID)
    if el>0
     if createorjoin=2 and dwPlayerID=dwLocalPlayerID
      rem a quick and easy report on received packet times
      locallagtime=timer()-timestampforlagtest
      timestampforlagtest=timer()
     else
      `
      rem MESSAGE FROM OTHER CLIENTS/SERVER
      ttransmitpos=0 : ttransmitanim=0 : ttransmitshot=0
      `
      rem Take new data and update state data
      if dwCode=0
       rem movement
       a = memblock byte( mb_move, 1 )*2
       x = memblock word( mb_move, 2 )
       y = memblock word( mb_move, 4 )
       z = memblock word( mb_move, 6 )*-1
       rem movement
       if multiplayeridlink(el)<>1
        statelag(el)=statemsgap(el)
        statemytimer(el)=timer()
        px#=x : py#=y : pa#=a : pz#=z
        rem If this plr is newly joined, reset to this new position coming in
        if multiplayerisnew(el)=3 then multiplayerisnew(el)=2
        gosub _packet_move
        ttransmitpos=1
       endif
      endif
      if dwCode=4
       rem anim and viewy and colmaterialtype
       viewy = memblock byte( mb_move, 1 )*2
       anim = memblock byte( mb_move, 2 )
       tcolmattype = memblock byte( mb_move, 3 )
       animdir = memblock byte( mb_move, 4 )
       statecolmaterialtype(el)=tcolmattype-1
       stateanim(el)=anim : pviewy#=viewy
       stateanimdir(el)=animdir
       gosub _packet_viewyanim
       ttransmitanim=1
      endif
      if dwCode=5
       rem player shot gun event
       ttransmitshot=1
       rem discharge sound (single fire, or automatic loop sound)
       e=characterchoiceentityindex(el)
       tgunid=entityelement(e).currentweapon
       tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
       if tsndid>0
        if gun(tgunid).action.automatic.s>0
         if entityelement(e).firesoundloopremote>0
          if entityelement(e).firesoundloopremote<>tsndid
           stop sound entityelement(e).firesoundloopremote
           entityelement(e).firesoundloopremote=0
          endif
         endif
         if entityelement(e).firesoundloopremote=0
          play sound tsndid,gun(tgunid).sound.fireloopend
          loop sound tsndid,0,gun(tgunid).sound.fireloopend
          entityelement(e).firesoundloopremote=tsndid
         endif
         entityelement(e).firesoundlooptime=timer()
        else
         play sound tsndid
        endif
        posinternal3dsound(tsndid,entityelement(e).x,entityelement(e).y,entityelement(e).z)
        broadcast3dsound(entityelement(e).x,entityelement(e).y,entityelement(e).z,25.0)
       endif
       rem visual decal
       tdecalmode=6
       entityelement(e).decalindex=1
       entityelement(e).decalmode=tdecalmode
       if entityelement(e).currentweapon>0
        rem override decal if gun specifies non-fire-flare
        tgunid=entityelement(e).currentweapon
        if gun(tgunid).decalid>0
         entityelement(e).decalindex=gun(tgunid).decalid*-1
        endif
       else
        entityelement(e).decalindex=0
       endif
      endif
      if dwCode=9
       rem movement
       if multiplayeridlink(el)<>1
        a = memblock byte( mb_move, 1 )*2
        x = memblock word( mb_move, 2 )
        y = memblock word( mb_move, 4 )
        z = memblock word( mb_move, 6 )*-1
        statelag(el)=statemsgap(el)
        statemytimer(el)=timer()
        px#=x : py#=y : pa#=a : pz#=z
        rem If this plr is newly joined, reset to this new position coming in
        if multiplayerisnew(el)=3 then multiplayerisnew(el)=2
        gosub _packet_move
        ttransmitpos=1
        rem and anim
        viewy = memblock byte( mb_move, 8 )*2
        anim = memblock byte( mb_move, 9 )
        tcolmattype = memblock byte( mb_move, 10 )
        animdir = memblock byte( mb_move, 11 )
        statecolmaterialtype(el)=tcolmattype-1
        stateanim(el)=anim : pviewy#=viewy
        stateanimdir(el)=animdir
        gosub _packet_viewyanim
        ttransmitanim=1
       endif
      endif
      `
      rem If server intercepts this, send new client data out to other clients
      if createorjoin=1
       if ttransmitpos=1 or ttransmitanim=1 or ttransmitshot=1
        MULTIPLAYER SEND FROM PLAYER dwPlayerID
        MULTIPLAYER SEND MESSAGE TO (2+multiplayeri(el))*-1
        gosub _multi_transmitplayerdata
        MULTIPLAYER SEND MESSAGE TO 0
        rem ensure this non-prioritystuff gets sent at least one in five
        if guarenteedloadonmove>4 then guarenteedloadonmove=0
       endif
      endif
      `
     endif
    endif
   endif
   `
  endif
  `
  rem
  rem MEMBLOCK COMMUNICATIONS
  rem
  if dwMessageCode=3
   `
   rem
   rem SERVER Only Actions
   rem
   if createorjoin=1
    `
    rem INIT - server inits everything to requesting client
    if dwCode=1
     rem server will reject init immediately if game is FULL
     MULTIPLAYER SEND FROM PLAYER dwPlayerID
     if Servergameisfull=0
      rem name of server player (priority)
      MULTIPLAYER SEND MESSAGE STRING multiplayername$(1),0x0080
      rem show client list of available characters
      gosub _multi_showlistofavailchars
     else
      rem server game is full
      rem no more slots, max players reached (copied from below)
      write memblock byte 102, 0, 103
      write memblock dword 102, 4, 1
      MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
      inc guarenteedbytes,8 : inc unreliablebytes,0
     endif
    endif
    rem REQUEST CHARACTER - server sends permission to client to use requested character
    if dwCode=3
     rem server says yes you can use that character
     tokay=1 : tfreeslot=0
     tcl = memblock dword( mb_move, 4 )
     for tcc=0 to numberofplayers-1
      if characterchosen(1+tcc)=tcl
       tokay=0
      endif
      if characterchosen(1+tcc)=0 then tfreeslot=1
     next tcc
     MULTIPLAYER SEND FROM PLAYER dwPlayerID
     if tfreeslot=1
      if tokay=1
       rem record clients choice on the server
       el=getelfromid(dwPlayerID) : characterchosen(el)=tcl
       gosub _multi_identifycharactersinentities
       characterchoiceentityindex(el)=characterlistentity(tcl)
       rem set new joiner players health on server
       te=characterchoiceentityindex(el)
       plrindex=multiplayerplrindex(el) : player(plrindex).health=entityelement(te).eleprof.strength
       rem if test game, give a fake health in case no character to use
       if gtestgamemodefromeditor=1 then player(plrindex).health=100
       rem go ahead and start clients game
       write memblock byte 102, 0, 102
       write memblock dword 102, 4, tcl
       MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
       inc guarenteedbytes,8 : inc unreliablebytes,0
       rem transmit health values of all players too
       for tel=1 to multiplayeridlinkmax
        if multiplayeridlink(tel)<>1
         plrindex=multiplayerplrindex(tel) : tvalue=player(plrindex).health
         MULTIPLAYER SEND FROM PLAYER multiplayeridlink(tel)
         write memblock byte 102, 0, 201
         write memblock dword 102, 4, multiplayeridlink(tel)
         write memblock dword 102, 8, tvalue
         rem priority communication
         MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
         inc guarenteedbytes,12 : inc unreliablebytes,0
        endif
       next tel
       rem transmit positions and other player details as they are right now
       for el=1 to multiplayeridlinkmax
        if multiplayeridlink(el)<>1
         rem transmit position and anim (playercode specifies the WHO)
         for tfourtimes=1 to 4
          guarenteedloadonmove=5 : rem ensure inital positions guarenteed
          ttransmitpos=1 : ttransmitanim=0
          MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
          gosub _multi_transmitplayerdata
         next tfourtimes
         guarenteedloadonmove=5 : rem ensure inital positions guarenteed
         ttransmitpos=0 : ttransmitanim=1
         MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
         gosub _multi_transmitplayerdata
         te=characterchoiceentityindex(el)
         rem update all clients with this change (sneak lifecode in as well) (send from server)
         MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
         write memblock byte 102, 0, 211
         write memblock byte 102, 1, entityelement(te).lifecode
         write memblock dword 102, 4, multiplayeridlink(el)
         write memblock dword 102, 8, stateweapon(el)
         MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
         inc guarenteedbytes,12 : inc unreliablebytes,0
        endif
       next el
       rem restore EL just in case
       el=getelfromid(dwPlayerID)
       rem update Servergameisfull flag
       tfreeslot=0
       for tcc=0 to numberofplayers-1
        if characterchosen(1+tcc)=0 then tfreeslot=1
       next tcc
       if tfreeslot=0 then Servergameisfull=1
      else
       rem client cannot have this character, ask client to choose another
       gosub _multi_showlistofavailchars
      endif
     else
      rem no more slots, max players reached
      write memblock byte 102, 0, 103
      write memblock dword 102, 4, 1
      MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
      inc guarenteedbytes,8 : inc unreliablebytes,0
     endif
    endif
    rem REQUEST A HIT
    if dwCode=21
     rem shot and damage
     tlifecode = memblock byte( mb_move, 1 )
     te = memblock word( mb_move, 2 )
     tdamage = memblock word( mb_move, 4 )
     sourcee = memblock word( mb_move, 6 )
     rem only deal remote damage if lifecode of current entity and shot-id is same
     if entityelement(te).lifecode=tlifecode
      gosub _multi_dealdamagedirect
     else
      el=getelfromid(dwPlayerID)
      tlifecodenotmatch=el
      tlifecodenotmatcha=entityelement(te).lifecode : tlifecodenotmatchb=tlifecode
     endif
    endif
    rem FINISHEDGAME - server is informed of client winning by local mission AI
    if dwCode=105
     rem broadcast to clients
     winnerel=getelfromid(memblock dword(mb_move, 4))
     tbroadcastresult=winnerel
     gosub _multi_informallplayersofcomplete
     rem declare winner/loser
     gosub _multi_declarewinorlose
    endif
    rem HEALTHUPDATE (also handled below for all)
    if dwCode=201
     rem newcode - server can never be told the players health is subzero
     tplayerhealth=memblock dword(mb_move, 8)
     if tplayerhealth<=0
      rem Server was informed by Client that its health was subzero
      el=getelfromid(memblock dword(mb_move, 4))
      tclientinformedhealthsubzero=el
     else
      rem get for benefit of server
      gosub _get_playerhealth
     endif

` other clients do NOT need to know their fellows health values
`     rem from server so do not need to broadcast back out
`     if dwPlayerID<>dwLocalPlayerID
`      rem update all clients with this players new health
`      MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
`      rem Update client player health
`      write memblock byte 102, 0, 201
`      write memblock dword 102, 4, multiplayeridlink(el)
`      write memblock dword 102, 8, player(plrindex).health
`      MULTIPLAYER SEND MESSAGE TO (2+multiplayeri(el))*-1
`      MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
`      MULTIPLAYER SEND MESSAGE TO 0
`      inc guarenteedbytes,12 : inc unreliablebytes,0
`     endif

    endif
    rem WEAPONCHANGED - client changed weapon
    if dwCode=211
     rem get plr affected and store in state (on server)
     tlifecode=memblock byte(mb_move, 1)
     el=getelfromid(memblock dword(mb_move, 4))
     stateweapon(el)=memblock dword(mb_move, 8)
     te=characterchoiceentityindex(el)
     entityelement(te).lifecode=tlifecode
     rem update all clients with this change
     MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
     write memblock byte 102, 0, 211
     write memblock byte 102, 1, entityelement(te).lifecode
     write memblock dword 102, 4, multiplayeridlink(el)
     write memblock dword 102, 8, stateweapon(el)
     MULTIPLAYER SEND MESSAGE TO (2+multiplayeri(el))*-1
     MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
     MULTIPLAYER SEND MESSAGE TO 0
     inc guarenteedbytes,12 : inc unreliablebytes,0
     rem handle weapon change in game
     gosub _multi_changeweapon
    endif
    if dwCode=212
     rem get plr affected and store in state (on server)
     el=getelfromid(memblock dword(mb_move, 4))
     stateplayagain(el)=memblock byte(mb_move, 2)
    endif
    rem REQUEST TRIGGER SEND - client used an mptrigger
    if dwCode=251
     rem get trigger and perform on server first
     mptrigger=memblock byte(mb_move,1)
     mptriggervalue1=memblock word(mb_move, 2)
     rem server performs directly (for server player)
     gosub _multi_performtrigger
     rem server sends all triggers to clients (using dwPlayerID to show who did triggering)
     gosub _multi_serversendtriggers
    endif
    `
   endif
   `
   rem
   rem CLIENT
   rem
   if createorjoin=2
    `
    rem Messages JUST for this one client (or all clients)
    if dwPlayerID=dwLocalPlayerID
     rem POPULATE - client updates entities with server-controlled-entities
     if dwCode=2
      PlayerCanStartStage=3
      x = memblock dword( mb_move,  4 )
      y = memblock dword( mb_move,  8 )
      z = memblock dword( mb_move, 12 )
      e = memblock dword( mb_move, 16 )
      entityelement(e).servercontrolled=1
      entityelement(e).x=x
      entityelement(e).y=y
      entityelement(e).z=z
     endif
     rem ASKIFCANUSECHARACTER - client chooses character
     if dwCode=101
      rem Choose which character you want to be
      numberofplayers=memblock byte( mb_move, 4 )
      if numberofplayers>0
       tdwplr as DWORD
       for tcc=0 to numberofplayers-1
        tdwplr=memblock dword( mb_move, 5+(tcc*5) )
        tcl=memblock byte( mb_move, 9+(tcc*5) )
        el=getelfromid(tdwplr) : characterchosen(el)=tcl
        gosub _multi_identifycharactersinentities
        characterchoiceentityindex(el)=characterlistentity(tcl)
       next tcc
       rem select from character selection screen
       gosub _multi_andwho
       rem client asks server if can use this character
       MULTIPLAYER SEND FROM PLAYER dwPlayerID
       write memblock byte 102, 0, 3
       write memblock dword 102, 4, characterchoice
       MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
       inc guarenteedbytes,8 : inc unreliablebytes,0
      else
       rem odd error server has a game of zero players
       exit prompt "MPError","Zero Players" : end
      endif
     endif
     rem READY - client is told if it can use the selected character
     if dwCode=102
      rem JOIN PLAYER STARTS - create space in player array
      characterchosen(iLocalEL)=characterchoice
      te=characterlistentity(characterchoice)
      characterchoiceentityindex(iLocalEL)=te
      multiplayerplrindex(iLocalEL)=1
      multiplayername$(iLocalEL)=playername$
      rem start position of this local dude
      gosub _multi_setlocalstart
      rem start joiners game
      PlayerCanStartStage=4
      PlayerCanStart=1
     endif
     rem CANNOT PLAY - client is told they cannot play for some reason
     if dwCode=103
      tcannotplayreason=memblock byte( mb_move, 4 )
      gosub _multi_cannotplay
      mpgameinprogress=0
      continueokay=1
     endif
     rem FINISHEDGAME - client is told a winner has been found (and pass in final frag count too)
     if dwCode=104
      el=getelfromid(dwPlayerID)
      frags(el)=memblock word(mb_move, 2)
      winnerel=getelfromid(memblock dword(mb_move, 4))
      gosub _multi_declarewinorlose
     endif
    else
     rem Messages for all clients (not original client sender though)
     rem CHARACTER CONFIRM - intercept character confirmation, so other clients know what identity the player uses
     if dwCode=102
      el=getelfromid(dwPlayerID)
      tcharacterchoice=memblock byte( mb_move, 4 )
      characterchosen(el)=tcharacterchoice
      characterchoiceentityindex(el)=characterlistentity(tcharacterchoice)
     endif
     if dwCode=252
      rem TRIGGER EVENT - using trigger code and value(s)
      mptrigger=memblock byte(mb_move,1)
      mptriggervalue1=memblock word(mb_move, 2)
      gosub _multi_performtrigger
     endif
    endif
    `
    rem PLAYER DETAIL CHANGE - player health change
    if dwCode=201
     rem simply update health (also handled above for broadcast by server)
     gosub _get_playerhealth
    endif
    if dwCode=202
     rem PLAYDIEANIM - usually from being killed
     el=getelfromid(memblock dword(mb_move, 4))
     sourceel=getelfromid(memblock dword(mb_move, 8))
     gosub _multi_dieanim
    endif
    if dwCode=203
     rem update health negatively, and if local player, arg and redhud
     gosub _get_playerhurt
    endif
    if dwCode=204
     rem REPOSIITON - usually after die anim
     trandomvalue=memblock byte(mb_move, 1)
     tlifecode=memblock byte(mb_move, 2)
     el=getelfromid(dwPlayerID)
     gosub _multi_resetplrpos
     rem restart weapon inventory
     if el=iLocalEL
      tcopyorrestart=1 : gosub _gun_resetgunsettings
     endif
     rem update entities locally around player
     tupdatelocalentities=el
    endif
    if dwCode=205
     rem NEWFRAGVALUE - informs who has new frag value and who they killed to get the update
     tnewfrag=memblock byte(mb_move,1)
     killerel=getelfromid(memblock dword(mb_move, 4))
     victimel=getelfromid(memblock dword(mb_move, 8))
     frags(killerel)=tnewfrag
    endif
    if dwCode=211
     rem simply update weapon used by plr (also handled above for broadcast by server)
     tlifecode=memblock byte(mb_move,1)
     el=getelfromid(memblock dword(mb_move, 4))
     stateweapon(el)=memblock dword(mb_move, 8)
     rem also lifecode piggy backs a ride
     te=characterchoiceentityindex(el)
     entityelement(te).lifecode=tlifecode
     rem handle weapon change in game
     gosub _multi_changeweapon
    endif
    `
   endif
   `
   rem
   rem BOTH
   rem
`   rem Messages JUST for this one client (or all clients)
`   if dwPlayerID=dwLocalPlayerID
`    rem From itself - ignore
`   else
`    rem ROCKET FIRED - client updates FLAK with rocket event
`    if dwCode=11
`     a = memblock byte( mb_move, 1 ) * 2
`     x = memblock word( mb_move, 2 )
`     y = memblock word( mb_move, 4 )
`     riaplr = memblock dword( mb_move, 6 )
`     rix#=x : riy#=y : ria#=a : rii=memblock byte( mb_move, 10 )
`     rem do not remote-fire own rockets!!
`     if riaplr<>dwLocalPlayerID
``      gosub _proto_fire
`     endif
`     rem if server intercepts a fire, send to other clients
`     if createorjoin=1
`      iLocalELAction=ri
`     endif
`    endif
`   endif
`   rem ROCKET COLLIDED - so trigger explosion
`   if dwCode=12
`    rii = memblock dword( mb_move, 4 )
`    for ri=1 to rocketmax
`     if rocket(ri).owner=dwPlayerID
`      if rocket(ri).rii=rii
`       rocket(ri).rocketmode=2 : rocket(ri).exploderadius=2 : exit
`      endif
`     endif
`    next ri
`   endif
   `
  endif
  `
  rem update entities locally around player
  if tupdatelocalentities>0
   el=tupdatelocalentities
   if el=iLocalEL
    mex#=statex(el) : mey#=statey(el) : mez#=statez(el)
    gosub _entity_blastinitentities
   endif
   tupdatelocalentities=0
  endif
  `
 endwhile
 `
 if showfpsinrealgame=2
  set cursor 0,250
  if tlifecodenotmatch<>0
   print "lifecodenotmatch(el=";tlifecodenotmatch;") ";multiplayername$(tlifecodenotmatch)
   print "entis:";tlifecodenotmatcha
   print "asked:";tlifecodenotmatchb
  endif
  if tclientinformedhealthsubzero<>0
   print "tclientinformedhealthsubzero(el=";tclientinformedhealthsubzero;") ";multiplayername$(tclientinformedhealthsubzero)
  endif
 endif
 `
 rem Restore all server sends (so no client is excluded)
 MULTIPLAYER SEND MESSAGE TO 0
 `
return

_multi_changeweapon:
 `
 rem uses el
 tgunid=stateweapon(el)
 e=characterchoiceentityindex(el)
 tweap$=gun(tgunid).name$
 tobj=entityelement(e).obj
 entid=entityelement(e).bankindex
 if entityprofile(entid).ischaracter=1
  if object exist(tobj)=1
   if entityprofile(entid).firespotlimb>-1
    rem switch weapon carried and force reset of animation account for possible weapon
    entityelement(e).eleprof.hasweapon$=tweap$
    gosub _entity_switchattachment
    entityelement(e).animset=entityelement(e).animdo+1
   endif
  endif
 endif
 `
return

_multi_transmitplayerdata:
 `
 rem prepare
 if ttransmitpos=1
  a=wrapvalue(statea(el))/2
  x=statedx(el) : if x>65535 : x=65535 : endif : if x<0 : x=0 : endif
  y=statedy(el) : if y>65535 : y=65535 : endif : if y<0 : y=0 : endif
  z=statedz(el)*-1 : if z>65535 : z=65535 : endif : if z<0 : z=0 : endif
 endif
 if ttransmitanim=1
  viewy=wrapvalue(stateviewy(el))/2
  anim=stateanim(el)
  tcolmat=1+statecolmaterialtype(el)
  animdir=stateanimdir(el)
 endif
 `
 rem if both pos and anim/viewy, ship as single packet
 if ttransmitpos=1 and ttransmitanim=1
  `
  rem Both POS+ANIM message
  write memblock byte mb_move, 0, 9
  write memblock byte mb_move, 1, a
  write memblock word mb_move, 2, x
  write memblock word mb_move, 4, y
  write memblock word mb_move, 6, z
  write memblock byte mb_move, 8, viewy
  write memblock byte mb_move, 9, anim
  write memblock byte mb_move, 10, tcolmat
  write memblock byte mb_move, 11, animdir
  if guarenteedloadonmove>4
   MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,0x0080,12
   inc guarenteedbytes,12 : inc unreliablebytes,0
  else
   MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,12
   inc guarenteedbytes,0 : inc unreliablebytes,12
  endif
  `
 else
  `
  rem send out position (non-priority)
  if ttransmitpos=1
   write memblock byte mb_move, 0, 0
   write memblock byte mb_move, 1, a
   write memblock word mb_move, 2, x
   write memblock word mb_move, 4, y
   write memblock word mb_move, 6, z
   if guarenteedloadonmove>4
    rem ensure at least one out of five move messages will be guarenteed if bombed with priority traffic
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,0x0080,8
    inc guarenteedbytes,8 : inc unreliablebytes,0
   else
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
    inc guarenteedbytes,0 : inc unreliablebytes,8
   endif
  endif
  `
  rem send out viewy and animation (non-priority)
  if ttransmitanim=1
   write memblock byte mb_move, 0, 4
   write memblock byte mb_move, 1, viewy
   write memblock byte mb_move, 2, anim
   write memblock byte mb_move, 3, tcolmat
   if guarenteedloadonmove>4
    rem ensure at least one out of five move messages will be guarenteed if bombed with priority traffic
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,0x0080,8
    inc guarenteedbytes,8 : inc unreliablebytes,0
   else
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
    inc guarenteedbytes,0 : inc unreliablebytes,8
   endif
  endif
  `
 endif
 `
 rem send out the shot-event (non-priority)
 if ttransmitshot=1
  write memblock byte mb_move, 0, 5
  MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
  inc guarenteedbytes,0 : inc unreliablebytes,8
 endif
 `
return

_multi_showlistofavailchars:
 `
 rem send list of chars to client from server
 MULTIPLAYER SEND FROM PLAYER dwPlayerID
 write memblock byte 102, 0, 101
 rem server also sends who client has picked as their character
 write memblock byte 102, 4, numberofplayers
 for tcc=0 to numberofplayers-1
  write memblock dword 102, 5+(tcc*5), multiplayeridlink(1+tcc)
  write memblock byte 102, 9+(tcc*5), characterchosen(1+tcc)
 next tcc
 amount=4+4+(numberofplayers*5)
 MULTIPLAYER SEND MESSAGE memblock 102,0x0080,amount
 inc guarenteedbytes,amount : inc unreliablebytes,0
 `
return

_multi_addplayer:
 `
 rem find free 'used' server player slot
 plrindex=0
 for ti=1 to playermax
  if player(ti).serverplayer=2
   plrindex=ti
  endif
 next ti
 if plrindex=0
  rem add player to array (use el)
  playermax=playermax+1
  dim player(playermax) as playertype
  dim playersound(playermax,220) as integer
  dim playersoundset$(playermax) as string
  dim playersoundsetindex(playermax) as integer
  dim playermovementstep(playermax) as integer
  dim playerinventory(playermax,100) as inventorytype
  plrindex=playermax
 endif
 rem set new player and slot
 multiplayerplrindex(el)=plrindex
 player(plrindex).serverplayer=1
 `
return

_server:
 `
 rem pretent FPI script tailoed for arena logic
 for e=1 to entityelementmax
  if entityelement(e).servercontrolled=1
   rem go through server-linked-players
   for mel=1 to multiplayeridlinkmax
    if multiplayeridlink(mel)<>1
     `
     rem Entity Info
     entid=entityelement(e).bankindex
     `
     rem pause while death/respawn happens (animwait set when death occurs)
     if entityprofile(entid).ischaracter=1
      if stateanimwait(mel)>0
       stateanimwait(mel)=stateanimwait(mel)-1
       if stateplayagain(mel)<>1 and stateanimwait(mel)=0 then stateanimwait(mel)=1
       if stateanimwait(mel)=0
        stateplayagain(mel)=0
        el=mel : plrindex=multiplayerplrindex(el)
        player(plrindex).health=100
        trandomvalue=1+rnd(respawnmax-1)
        tlifecode=rnd(255)
        gosub _multi_resetplrpos
        rem restart weapon inventory
        if el=iLocalEL
         tcopyorrestart=1 : gosub _gun_resetgunsettings
        endif
        rem update entities locally around player
        tupdatelocalentities=el
        rem server sends out 204 (to trigger respawn of dead player)
        MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
        write memblock byte 102, 0, 204
        write memblock byte 102, 1, trandomvalue
        write memblock byte 102, 2, tlifecode
        write memblock dword 102, 4, multiplayeridlink(el)
        MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
        inc guarenteedbytes,8 : inc unreliablebytes,0
        rem update all clients with this players new health
        tvalue=player(plrindex).health
        for tel=1 to multiplayeridlinkmax
         if multiplayeridlink(tel)<>1
          MULTIPLAYER SEND FROM PLAYER multiplayeridlink(tel)
          rem Update client player health
          write memblock byte 102, 0, 201
          write memblock dword 102, 4, multiplayeridlink(el)
          write memblock dword 102, 8, tvalue
          MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
          inc guarenteedbytes,12 : inc unreliablebytes,0
         endif
        next tel
       endif
      endif
     endif
     `
    endif
   next mel
  endif
 next e
 `
 rem update entities locally around player
 if tupdatelocalentities>0
  el=tupdatelocalentities
  if el=iLocalEL
   mex#=statex(el) : mey#=statey(el) : mez#=statez(el)
   gosub _entity_blastinitentities
  endif
  tupdatelocalentities=0
 endif
 `
 rem Server Monitors for objective completion
 tnumberofcurrentplayers=0
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   inc tnumberofcurrentplayers
  endif
 next el
 `
 tbroadcastresult=0
 if ggameobjectivetype=1
  rem any client/serverplayer can signal they have completed the mission (local AI message)
 endif
 if ggameobjectivetype=2
  rem server ends game when a player reaches desired frags
  if tnumberofcurrentplayers>1
   for el=1 to multiplayeridlinkmax
    if multiplayeridlink(el)<>1
     if frags(el)>=ggameobjectivevalue
      tbroadcastresult=el
      exit
     endif
    endif
   next el
  endif
 endif
 if ggameobjectivetype=3
  rem server monitors time and ends game when time expired
  if ((timer()-dwStartTime)/1024)>=ggameobjectivevalue
   highestel=1
   if tnumberofcurrentplayers>1
    for el=2 to multiplayeridlinkmax
     if multiplayeridlink(el)<>1
      if frags(el)>frags(highestel) then highestel=el
     endif
    next el
   endif
   tbroadcastresult=highestel
  endif
 endif
 if tbroadcastresult>0
  rem and then broadcast to clients
  winnerel=tbroadcastresult
  gosub _multi_informallplayersofcomplete
  rem announce as winner/loser directly
  gosub _multi_declarewinorlose
 endif
 `
 rem Send a keepalive trigger to master database every 10 minutes
 if (timer()-tenminutetimer)>600000
  gosub _ai_gamelist_keepalive
  tenminutetimer=timer()
 endif
 `
return

_multi_mptrigger:
 `
 if createorjoin=1
  rem if server player does trigger, direct do and send triggers out
  dwPlayerID=multiplayeridlink(iLocalEL)
  gosub _multi_serversendtriggers
 else
  rem send trigger message to server
  MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
  write memblock byte 102, 0, 251
  write memblock byte 102, 1, mptrigger
  write memblock word 102, 2, mptriggervalue1
  MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
  inc guarenteedbytes,8 : inc unreliablebytes,0
 endif
 `
return

_multi_serversendtriggers:
 `
 rem uses mptrigger, mptriggervalue1
 rem send trigger message to all clients (from server)
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   MULTIPLAYER SEND FROM PLAYER dwPlayerID
   write memblock byte 102, 0, 252
   write memblock byte 102, 1, mptrigger
   write memblock word 102, 2, mptriggervalue1
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
   inc guarenteedbytes,8 : inc unreliablebytes,0
  endif
 next el
 `
return

_multi_performtrigger:
 `
 rem perform locally, immediately
 `
 rem 1 - plrtake
 if mptrigger=1
  te=mptriggervalue1
  if te>0
   rem hide object
   tobj=entityelement(te).obj
   if tobj>0
    if object exist(tobj)=1 then hide object tobj : set object collision off tobj
   endif
   rem if child of spawn leader, reset spawn count
   tspawne=entityelement(te).spawn.leaderid
   if tspawne=0 then tspawne=te
   entityelement(tspawne).spawn.leadercount=entityelement(tspawne).spawn.delay
   rem remove entity
   `entityelement(te).beenkilled=1
   storee=e : e=te : gosub _entity_setbeenkilledflag : e=storee
   entityelement(te).active=0
   rem clear entity from col map
   tx=entityelement(te).x/25
   ty=entityelement(te).y/100
   tz=entityelement(te).z/-25
   if tx>=0 and ty>=0 and tz>=0
    if tx<=viscolx and ty<=viscoly and tz<=viscolz
     if viscolmap(tx,ty,tz)=te then viscolmap(tx,ty,tz)=0
    endif
   endif
  endif
 endif
 `
 rem 2 - process logic instantly (colon/coloff)
 if mptrigger=2
  rem Command entity to process logic immediately (open doors/close doors/etc)
  te=mptriggervalue1
  if te>0
   entityelement(te).active=1
   entityelement(te).dormant=0
   entityelement(te).logiccount=0
   entityelement(te).logictimestamp=timer()
   ste=e : e=te : gosub _entity_addetoprioritylist : e=ste
  endif
 endif
 `
return

_client:
 `
 rem go through server-linked-players
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   te=characterchoiceentityindex(el)
   entid=entityelement(te).bankindex
   if entityprofile(entid).ischaracter=1
    if stateanimwait(el)>10
     stateanimwait(el)=stateanimwait(el)-1
    endif
   endif
  endif
 next mel
 `
 rem Handle local ID assignment when client comes online
 if MULTIPLAYER GET PLAYER COUNT()>=1
  if dwLocalPlayerID=0
   rem AT VERY START OF JOINING STAGE
   PlayerCanStartStage=1
   rem establish local player ID
   dwLocalPlayerID=MULTIPLAYER GET PLAYER ID(0)
   dwStartJoinTime=timer()
   rem Trigger server to send all init states (priority)
   write memblock byte 102, 0, 1
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,4
   inc guarenteedbytes,4 : inc unreliablebytes,0
  else
   rem find and fill local player index
   PlayerCanStartStage=2
   if iLocalEL=0
    for el=1 to multiplayeridlinkmax
     if multiplayeridlink(el)=dwLocalPlayerID
      iLocalEL=el : statemytimer(el)=timer() : exit
     endif
    next el
   endif
`  rem server ends (only when actually started game) - also wanted if host gone when joiner arrives
`  if PlayerCanStart=1
   rem server ends 5 second after started the join phase (or could have never been there)
   if timer()-dwStartJoinTime>5000
    if MULTIPLAYER GET CONNECTION()=0
     rem Terminate game if server player leaves
     gterminationcountdown=10
    endif
   endif
  endif
  rem if not voice setup, do it now
  if setupvoicechat=0
   setupvoicechat=1
  endif
 endif
 `
return

_playersend:
 `
 rem player sends data to server (only sends if client data changed since last send)
 if PlayerCanStart=1 or createorjoin=1
  `
  rem Regular burst of moveanim info
  if timer()-dwBurstTime>lagmon#
   rem reset bursttime counter (non-priority)
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
   dwBurstTime=timer()
   rem movement (if changed)
   tsendpos=0
   tcodesignaturex=(statex(iLocalEL)-(int(statex(iLocalEL)/500)*500))*1
   tcodesignaturey=(statey(iLocalEL)-(int(statey(iLocalEL)/500)*500))*500
   tcodesignaturez=(statez(iLocalEL)-(int(statez(iLocalEL)/500)*500))*25000
   tcodesignature=tcodesignaturex+tcodesignaturey+tcodesignaturez
   if statecodeupdate(iLocalEL,0)<>tcodesignature
    statecodeupdate(iLocalEL,0)=tcodesignature : tsendpos=1
   endif
   rem angle and animation and materialstoodon (if changed)
   tsendanim=0
   tcodesignature=stateviewy(iLocalEL)+(statecolmaterialtype(iLocalEL)*256)+(stateanim(iLocalEL)*(256*256))+(stateanimdir(iLocalEL)*123)
   if statecodeupdate(iLocalEL,4)<>tcodesignature
    statecodeupdate(iLocalEL,4)=tcodesignature : tsendanim=1
   endif
   if tsendpos=1 and tsendanim=1
    rem send both in one packet
    write memblock byte mb_move, 0, 9
    write memblock byte mb_move, 1, wrapvalue(statea(iLocalEL))/2
    x=statex(iLocalEL) : if x>65535 : x=65535 : endif : if x<0 : x=0 : endif
    y=statey(iLocalEL) : if y>65535 : y=65535 : endif : if y<0 : y=0 : endif
    z=abs(statez(iLocalEL)) : if z>65535 : z=65535 : endif : if z<0 : z=0 : endif
    write memblock word mb_move, 2, x
    write memblock word mb_move, 4, y
    write memblock word mb_move, 6, z
    write memblock byte mb_move, 8, wrapvalue(stateviewy(iLocalEL))/2
    write memblock byte mb_move, 9, stateanim(iLocalEL)
    write memblock byte mb_move, 10, 1+statecolmaterialtype(iLocalEL)
    write memblock byte mb_move, 11, stateanimdir(iLocalEL)
    MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,12
    inc guarenteedbytes,0 : inc unreliablebytes,12
   else
    rem one or the other
    if tsendpos=1
     write memblock byte mb_move, 0, 0
     write memblock byte mb_move, 1, wrapvalue(statea(iLocalEL))/2
     x=statex(iLocalEL) : if x>65535 : x=65535 : endif : if x<0 : x=0 : endif
     y=statey(iLocalEL) : if y>65535 : y=65535 : endif : if y<0 : y=0 : endif
     z=abs(statez(iLocalEL)) : if z>65535 : z=65535 : endif : if z<0 : z=0 : endif
     write memblock word mb_move, 2, x
     write memblock word mb_move, 4, y
     write memblock word mb_move, 6, z
     MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
     inc guarenteedbytes,0 : inc unreliablebytes,8
    endif
    if tsendanim=1
     write memblock byte mb_move, 0, 4
     write memblock byte mb_move, 1, wrapvalue(stateviewy(iLocalEL))/2
     write memblock byte mb_move, 2, stateanim(iLocalEL)
     write memblock byte mb_move, 3, 1+statecolmaterialtype(iLocalEL)
     write memblock byte mb_move, 4, stateanimdir(iLocalEL)
     MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
     inc guarenteedbytes,0 : inc unreliablebytes,8
    endif
   endif
   rem current health (if changed locally - if changed by server, update() is also updated)
   plrindex=multiplayerplrindex(iLocalEL)
   tcodesignature=player(plrindex).health
   if statecodeupdate(iLocalEL,2)<>tcodesignature
    statecodeupdate(iLocalEL,2)=tcodesignature
    rem client cannot send a health of zero (it could interfere with respawn)
    if player(plrindex).health>0
     write memblock byte 102, 0, 201
     write memblock dword 102, 4, multiplayeridlink(iLocalEL)
     write memblock dword 102, 8, player(plrindex).health
     MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
     inc guarenteedbytes,12 : inc unreliablebytes,0
    endif
   endif
   rem current weapon (if changed)
   plrindex=multiplayerplrindex(iLocalEL)
   tcodesignature=stateweapon(iLocalEL)
   if statecodeupdate(iLocalEL,3)<>tcodesignature
    statecodeupdate(iLocalEL,3)=tcodesignature
    te=characterchoiceentityindex(iLocalEL)
    write memblock byte 102, 0, 211
    write memblock byte 102, 1, entityelement(te).lifecode
    write memblock dword 102, 4, multiplayeridlink(iLocalEL)
    write memblock dword 102, 8, stateweapon(iLocalEL)
    MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
    inc guarenteedbytes,12 : inc unreliablebytes,0
   endif
   `
  endif
  `
 endif
 `
return

_multi_playershoots:
 `
 rem Trigger a shot flash and sound on other clients
 MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
 write memblock byte mb_move, 0, 5
 MULTIPLAYER SEND MESSAGE MEMBLOCK mb_move,8
 inc guarenteedbytes,0 : inc unreliablebytes,8
 `
return

_multi_dieanim:
 rem work out relative direction to throw entity from entity angle
 sourcete=characterchoiceentityindex(sourceel)
 brayx1#=entityelement(sourcete).x
 brayz1#=entityelement(sourcete).z
 tdir=0
 te=characterchoiceentityindex(el)
 distx#=entityelement(te).x-brayx1# : distz#=entityelement(te).z-brayz1#
 tentitya#=wrapvalue(atanfull(distx#,distz#))-wrapvalue(stateviewy(el))
 if tentitya#<0.0 then tentitya#=tentitya#+360.0
 if tentitya#>=360.0 then tentitya#=tentitya#-360.0
 if tentitya#>180-45 and tentitya#<180+45
  tdir=1
 else
  if tentitya#>315 or tentitya#<45
   tdir=2
  else
   if tentitya#>45 and tentitya#<180-45
    tdir=4
   else
    tdir=3
   endif
  endif
 endif
 rem Choose a good die anim (based on direction of shooter)
 stateanim(el)=12 : stateanimdir(el)=0
 if tdir=1 then stateanim(el)=12
 if tdir=2 then stateanim(el)=15
 if tdir=3 then stateanim(el)=21
 if tdir=4 then stateanim(el)=18
 rem Wipe out local health (so corpose can switch off radial collision)
 tplrindex=multiplayerplrindex(el) : player(tplrindex).health=0
 rem EL play die animation, timing it to end before a restart
 stateanimwait(el)=200
 rem ensure cannot respawn until plr has clicked to respawn
 stateplayagain(el)=0
 rem store who did it
 statewhodidit(el)=sourceel
 rem and freeze activity of states (which counts down after animwait is zero)
 stategetready(el)=50
 rem trigger sound for death-froan (excluded from regular takedamage subroutine)
 tplrid=entityelement(te).fakeplayerid : tsnd=15
 if playersound(tplrid,tsnd)>0
  if tplrid=1
   broadcast3dplrsound(camera position x(playercam),camera position y(playercam),camera position z(playercam),10.0)
   play sound playersound(tplrid,tsnd)
  else
   playinternal3dsoundfactor(playersound(tplrid,tsnd),entityelement(te).x,entityelement(te).y,entityelement(te).z,10.0)
  endif
 endif
return

_multi_resetplrpos:
 `
 rem find spawn points from multiplayer spawn array (uses trandomvalue) (uses randomposnotworkatlocalstart=1)
 te=characterchoiceentityindex(el)
 gosub _multi_playertorespawnpos
 `
 rem give lifecode to plr
 entityelement(te).lifecode=tlifecode
 `
 rem make plr invincible at start for a while
 entityelement(te).invincibleactive=150
 `
 rem Spawn sound (using real entity plr index (for sound))
 plrindex=entityelement(te).fakeplrindex
 gosub _player_spawnsound
 `
 rem uses el
 statex(el)=playerstartx#
 statey(el)=playerstarty#
 statez(el)=playerstartz#
 statea(el)=playerstartry#
 stateanim(el)=2
 stateanimdir(el)=0
 stateanimwait(el)=0
 stateweapon(el)=0
 statesx(el)=statex(el)
 statesy(el)=statey(el)
 statesz(el)=statez(el)
 statesa(el)=statea(el)
 statedx(el)=statex(el)
 statedy(el)=statey(el)
 statedz(el)=statez(el)
 multiplayerisnew(el)=1
 px#=statex(el)
 py#=statey(el)
 pz#=statez(el)
 pa#=statea(el)
 gosub _packet_move
 if el=iLocalEL
  rem local plr - remove old plr marker and restart to new position
  gosub _player_unmark
  gosub _player_restart
 else
  rem non-local plr repositioning, ensure object is updated here (to defeat universe cull)
  tobj=entityelement(te).obj
  if tobj>0
   if object exist(tobj)=1
    position object tobj,statex(el),statey(el),statez(el)
   endif
  endif
 endif
 `
 rem Fill updates with blanks to repeat playersend info (fixes firing with no gun bug)
 for ti=0 to 4 : statecodeupdate(el,ti)=-1 : next ti
 `
return

_multi_dealdamagedirect:
 `
 rem find out which player was hit (TE) (takes sourcee)
 plrindex=0 : plrel=0 : tplrcntmax=0
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   if characterchoiceentityindex(el)=te and plrel=0 then plrindex=multiplayerplrindex(el) : plrel=el
   inc tplrcntmax
  endif
 next el
 el=plrel
 rem no damage needed if being respawned (so do not get killed twice in close proximity)
 if plrel>0 and stateanimwait(plrel)>0 then plrindex=0
 rem update all clients with new health reading
 if plrindex>0
  player(plrindex).health=player(plrindex).health-tdamage
  if player(plrindex).health<=0 or (goneshotkills=1 and tdamage>0)
   `
   rem Server Registers a Kill
   sourceel=0
   if sourcee>0
    rem increment frag count
    for sourceel=1 to multiplayeridlinkmax
     if characterchoiceentityindex(sourceel)=sourcee then exit
    next sourceel
    rem only if you did not kill yourself
    if sourceel<>el then frags(sourceel)=frags(sourceel)+1
    `
    rem only need to send frag to the guy who wants to know what he has
    MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
    write memblock byte 102, 0, 205
    write memblock byte 102, 1, frags(sourceel)
    write memblock dword 102, 4, multiplayeridlink(sourceel)
    write memblock dword 102, 8, multiplayeridlink(el)
    MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
    inc guarenteedbytes,12 : inc unreliablebytes,0
    `
   endif
   `
   rem Play die animation
   player(plrindex).health=0
   gosub _multi_dieanim
   rem inform player that they have been killed (who triggers dieanim)
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
   write memblock byte 102, 0, 202
   write memblock dword 102, 4, multiplayeridlink(el)
   write memblock dword 102, 8, multiplayeridlink(sourceel)
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
   inc guarenteedbytes,12 : inc unreliablebytes,0
   `
  endif
  `
  rem Update client player health
  if tplrcntmax>1
   tvalue=player(plrindex).health
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
   write memblock byte 102, 0, 203
   write memblock dword 102, 4, multiplayeridlink(el)
   write memblock dword 102, 8, tvalue
   MULTIPLAYER SEND MESSAGE TO 2+multiplayeri(el)
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,12
   MULTIPLAYER SEND MESSAGE TO 0
   inc guarenteedbytes,12 : inc unreliablebytes,0
  endif
  `
  rem if EL was hit, and is local, show damage by visual and sound
  if el=iLocalEL then gosub _multi_showplrdamage
  `
 endif
 `
return

_multi_dealentityedamage:
 `
 rem damage comes from caller of this subroutine
 sourcee=characterchoiceentityindex(iLocalEL)
 `
 rem replaces direct entity damage, by sending message to server (which will deduct the health)
 if createorjoin=1
  rem server player can deal damage direct, and then inform clients
  te=e : gosub _multi_dealdamagedirect
 else
  rem uses E which is the entity that has been damaged (client tells server to deal damage)
  MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
  write memblock byte 102, 0, 21
  write memblock byte 102, 1, entityelement(e).lifecode
  write memblock word 102, 2, e
  write memblock word 102, 4, tdamage
  write memblock word 102, 6, sourcee
  MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
  inc guarenteedbytes,8 : inc unreliablebytes,0
 endif
 `
return

_get_playerhealth:
 rem can be assigned high and low (any value)
 el=getelfromid(memblock dword(mb_move, 4))
 plrindex=multiplayerplrindex(el)
 tplayerhealth=memblock dword(mb_move, 8)
 player(plrindex).health=tplayerhealth
 if el=iLocalEL
  rem when own health adjusted remotely, ensure now sent BACK to server
  statecodeupdate(iLocalEL,2)=tplayerhealth
 endif
return

_multi_showplrdamage:
 rem hurt sound and visual
 tpe=characterchoiceentityindex(el)
 plrindex=entityelement(tpe).fakeplrindex
 tdamage=0 : gosub _player_takedamage
 rem no lives (multiplayer)
 if player(plrindex).lives<1 then player(plrindex).lives=1
return

_get_playerhurt:
 rem can only be assigned lower (as though shot)
 el=getelfromid(memblock dword(mb_move, 4))
 plrindex=multiplayerplrindex(el)
 tplayerhealth=memblock dword(mb_move, 8)
 if tplayerhealth>player(plrindex).health and memblock dword(mb_move, 4)=dwLocalPlayerID
  rem damage dealt by server to affected player cannot go UP
  rem fixes health value glitch where server messages are higher than latest local value
 else
  player(plrindex).health=tplayerhealth
  if el=iLocalEL
   rem when own health adjusted remotely, ensure now sent BACK to server
   statecodeupdate(iLocalEL,2)=tplayerhealth
  endif
 endif
 if el=iLocalEL then gosub _multi_showplrdamage
return

_multi_plrradial:
 `
 if multiplayerinitialised=1
  raddmin#=30
  for radel=1 to multiplayermax
   if radel<>iLocalEL
    if multiplayeridlink(radel)<>1
     tplrindex=multiplayerplrindex(radel)
     if tplrindex>0
      if player(tplrindex).health>0
       tte=characterchoiceentityindex(radel)
       if entityelement(tte).invincibleactive=0
        radx#=statedx(radel)-camerapositionx
        rady#=statedy(radel)-(camerapositiony-phyeyeheight#)
        radz#=statedz(radel)-camerapositionz
        if abs(rady#)<75
         radd#=sqrt(abs(radx#*radx#)+abs(radz#*radz#))
         if radd#<raddmin#
          rada#=atanfull(radx#,radz#)
          camvelx#=newxvalue(0,rada#,-5.0)
          camvelz#=newzvalue(0,rada#,-5.0)
          exit
         endif
        endif
       endif
      endif
     endif
    endif
   endif
  next radel
 endif
 `
return

_packet_move:
 `
 rem if newly joined, no history to curve from (avoids crazy rush across universe from 0,0,0)
 if multiplayerisnew(el)>0 and multiplayerisnew(el)<3
  statesx(el)=px# : statesy(el)=py# : statesz(el)=pz#
  statedx(el)=px# : statedy(el)=py# : statedz(el)=pz#
  multiplayerisnew(el)=multiplayerisnew(el)-1
 endif
 `
 rem move or no move
 if abs(statex(el)-px#)>1.0 or abs(statey(el)-py#)>1.0 or abs(statez(el)-pz#)>1.0
  eloff=((el-1)*5) : debugel=el
  statedx(el)=px# : statedy(el)=py# : statedz(el)=pz#
  statex(el)=statesx(el) : statey(el)=statesy(el) : statez(el)=statesz(el)
  cpx#(1)=statex(el) : cpy#(1)=statey(el) : cpz#(1)=statez(el) : set vector3 10+eloff,cpx#(1),cpy#(1),cpz#(1)
  tdx#=px#-statex(el)
  tdz#=statez(el)-pz#
  td#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))/2.0
  if statesvel(el)=0.0 then statesa(el)=atanfull(tdx#,tdz#)
  ix#=newxvalue(statex(el),statesa(el),td#)
  iy#=statey(el)
  iz#=newzvalue(statez(el),statesa(el)+180,td#)
  cpx#(2)=ix# : cpy#(2)=iy# : cpz#(2)=iz# : set vector3 11+eloff,cpx#(2),cpy#(2),cpz#(2)
  cpx#(3)=px# : cpy#(3)=py# : cpz#(3)=pz# : set vector3 12+eloff,cpx#(3),cpy#(3),cpz#(3)
  ix#=newxvalue(px#,pa#,td#)
  iy#=py#
  iz#=newzvalue(pz#,pa#+180,td#)
  cpx#(4)=ix# : cpy#(4)=iy# : cpz#(4)=iz# : set vector3 13+eloff,cpx#(4),cpy#(4),cpz#(4)
  statesx(el)=px# : statesy(el)=py# : statesz(el)=pz# : statesa(el)=pa#
  statesvel(el)=1.0
  statemsgap(el)=0
  statemove(el)=1
 else
  rem no movement, but update direction from static pose
  statesx(el)=px# : statesy(el)=py# : statesz(el)=pz# : statesa(el)=pa#
  statesvel(el)=0.0
  statemsgap(el)=0
  statemove(el)=0
 endif
 `
return

_packet_viewyanim:
 `
 rem turn or no turn
 statesviewdy(el)=pviewy#
 `
return

_packet_move_dedrec:
 `
 rem move position to follow spline based on time
 if statemove(el)=1
  if 1
   rem direct point to point
   timespan#=(1.0/200.0)*statemsgap(el)
   if timespan#>1.0 then timespan#=1.0 : statemove(el)=0
   eloff=((el-1)*5)
   cpx#=x vector3(10+eloff)
   cpy#=y vector3(10+eloff)
   cpz#=z vector3(10+eloff)
   rem move position of plr
   statex(el)=cpx#+((statesx(el)-cpx#)*timespan#)
   statey(el)=cpy#+((statesy(el)-cpy#)*timespan#)
   statez(el)=cpz#+((statesz(el)-cpz#)*timespan#)
  else
   rem catmulrom spline (changed vector numbers since)
`   lastx#=statex(el) : lasty#=statez(el)
`   timespan#=(2.0/statelag(el))*statemsgap(el)
`   eloff=((el-1)*5)
`   if timespan#>=0.0 and timespan#<1.0
`    CATMULLROM VECTOR3 5+eloff,1+eloff,1+eloff,2+eloff,3+eloff,timespan#
`    statex(el)=x vector3(5+eloff)
`    statey(el)=y vector3(5+eloff)
`    statez(el)=z vector3(5+eloff)
`    dfx#=statex(el)-lastx#
`    dfy#=lasty#-statez(el)
`    if abs(dfx#)+abs(dfy#)>0.01
`     statea(el)=wrapvalue(atanfull(dfx#,dfy#))
`    endif
`   else
`    if timespan#>=1.0 and timespan#<2.0
`     CATMULLROM VECTOR3 5+eloff,1+eloff,2+eloff,3+eloff,4+eloff,timespan#-1.0
`     statex(el)=x vector3(5+eloff)
`     statey(el)=y vector3(5+eloff)
`     statez(el)=z vector3(5+eloff)
`     dfx#=statex(el)-lastx#
`     dfy#=lasty#-statez(el)
`     if abs(dfx#)+abs(dfy#)>0.01
 `     statea(el)=wrapvalue(atanfull(dfx#,dfy#))
 `    endif
 `   endif
 `  endif
  endif
 endif
 `
return

_packet_rotate_dedrec:
 rem turn angle over time
 stateviewy(el)=curveangle(statesviewdy(el),stateviewy(el),8.0)
return

`
` User Interface Subroutines (screens/prompts)

_multi_identifycharactersinentities:
 `
 rem fill characters with names from characters in level
 tcharid=0
 characterlistentity(0)=0
 for te=1 to entityelementmax
  tentid=entityelement(te).bankindex
  if entityprofile(tentid).ischaracter=1
   inc tcharid : characterlist$(tcharid)=entityelement(te).eleprof.name$
   characterlistentity(tcharid)=te
   rem X10 - 291007 - if get to MAX characters, do not add any more (otherwise crash!)
   if tcharid=numberofplayers then te=entityelementmax : exit
  endif
 next te
 rem and adjust max players if not enough characters in level
 if numberofplayers>tcharid then numberofplayers=tcharid
 if tcharid>=2 and numberofplayers<2 then numberofplayers=2
 `
return

_multi_andwho:
 `
 rem first determine which entities the characters are
 gosub _multi_identifycharactersinentities
 `
 rem who is left
 characterlist(0)=0
 for tcl=1 to multiplayermax
  characterlist(tcl)=0
  for tcc=0 to numberofplayers-1
   if characterchosen(1+tcc)=tcl
    characterlist(tcl)=1
   endif
  next tcc
 next tcl
 `
 rem set text for choice
 set text size 12+((screen width()-320.0)/320.0)*6.0
 set text to normal
 `
 rem offer choice
 gap#=screen height()/20
 characterchoice=0
 if numberofplayers>=2
  repeat
   t$=strarr$(641)
   `x9ink rgb(0,0,0),0 : center text screen width()/2,(gap#*2),t$
   ink rgb(255,255,255),0 : center text (screen width()/2)-1,(gap#*2)-1,t$
   for tcl=1 to numberofplayers
    t$=str$(tcl)+". "+characterlist$(tcl)
    if characterlist(tcl)=0
     `x9ink rgb(0,0,0),0 : center text screen width()/2,(gap#*5)+((tcl-1)*gap#),t$
    `x9if characterlist(tcl)=0 then ink rgb(255,255,255),0 else ink rgb(64,64,64),0
    `center text (screen width()/2)-1,(gap#*5)+((tcl-1)*gap#)-1,t$
     rem only show selection of those available to select
     center text (screen width()/2)-1,(gap#*5)+((tcl-1)*gap#)-1,t$
    endif
   next tcl
   k$=inkey$() : if k$>="1" and k$<="8" then characterchoice=(asc(k$)-asc("0"))
   sync
  until characterchoice>=1 and characterchoice<=numberofplayers
 else
  rem choose only character (if any)
  if numberofplayers=1
   characterchoice=1
  else
   characterchoice=0
  endif
 endif
 `
 rem restore text to in-game style and size
 set text size 16 : set text to normal
 `
return

_multi_cannotplay:
 `
 rem input tcannotplayreason
 repeat
  if tcannotplayreason=1 then t$=strarr$(642)
  if tcannotplayreason=2 then t$=strarr$(643)
  cls 0 : center text screen width()/2,(screen height()/2)-20,t$
  center text screen width()/2,(screen height()/2)+20,strarr$(644)
  sync
 until spacekey()=1
 `
return

_multi_missioncomplete:
 `
 rem announce as winner/loser directly
 winnerel=iLocalEL
 tbroadcastresult=iLocalEL
 if createorjoin=1
  rem broadcast that server has won to other players
  gosub _multi_informallplayersofcomplete
 else
  rem client must tell server to tell other players
  MULTIPLAYER SEND FROM PLAYER multiplayeridlink(iLocalEL)
  write memblock byte 102, 0, 105
  write memblock dword 102, 4, multiplayeridlink(tbroadcastresult)
  MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
  inc guarenteedbytes,8 : inc unreliablebytes,0
 endif
 `
 rem declare last after broascast(s)
 gosub _multi_declarewinorlose
 `
return

_multi_informallplayersofcomplete:
 `
 rem takes tbroadcastresult as EL winner
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)<>1
   MULTIPLAYER SEND FROM PLAYER multiplayeridlink(el)
   write memblock byte 102, 0, 104
   write memblock word 102, 2, frags(el)
   write memblock dword 102, 4, multiplayeridlink(tbroadcastresult)
   MULTIPLAYER SEND MESSAGE memblock 102,0x0080,8
   inc guarenteedbytes,8 : inc unreliablebytes,0
  endif
 next el
 `
return

_multi_declarewinorlose:
 `
 rem uses winnerel to determine winner identity
 if winnerel=iLocalEL
  tserverendsreason=2
 else
  tserverendsreason=3
 endif
 gosub _multi_serverendedgame
 mpgameinprogress=0
 continueokay=1
 `
return

_multi_serverendedgame:
 `
 rem setup vars for win/lose channel (0-lost,1-skip,2-won)
 if tserverendsreason=1
  levelwon=2 : rem skip
 else
  if tserverendsreason=2
   levelwon=1 : rem won
  else
   if tserverendsreason=3
    levelwon=0 : rem lost
   else
    levelwon=2 : rem skip
   endif
  endif
 endif
 `
return

`
` MP Functions
`

function getindexfromid(idin as dword)
 index=0
 for i = 1 to MULTIPLAYER GET PLAYER COUNT( )
  if MULTIPLAYER GET PLAYER ID( i-1 )=idin
   index=i : exit
  endif
 next i
endfunction index

function getelfromid(idin as dword)
 gotel=0
 for el=1 to multiplayeridlinkmax
  if multiplayeridlink(el)=idin
   gotel=el : exit
  endif
 next el
endfunction gotel

`
` SAVE LOAD SUBROUTINES
`
_saveload_maindialogloop:
 `
 rem loop to control save/load dialog
 gosub _saveload_savebox_load
 saveload.slotselected=0
 saveloadmousex=(screen width()/4)*3
 saveloadmousey=screen height()/2
 sync mask %1
 while saveload.slotselected=0
  gosub _saveload_savebox_run
  inc saveloadmousex,mousemovex() : inc saveloadmousey,mousemovey()
  if saveloadmousex<saveload.saveloadx then saveloadmousex=saveload.saveloadx
  if saveloadmousex>saveload.saveloadx+560 then saveloadmousex=saveload.saveloadx+560
  if saveloadmousey<saveload.saveloady then saveloadmousey=saveload.saveloady
  if saveloadmousey>saveload.saveloady+310 then saveloadmousey=saveload.saveloady+310
  pasteimage(aihudpointerimagestore,saveloadmousex,saveloadmousey,1)
  sync
 endwhile
 aifreezemouseclicks=0
 if saveload.loadswitch=1
  if saveload.slotselected>0 then gosub _saveload_savebox_doload
 else
  if saveload.slotselected>0 then gosub _saveload_savebox_dosave
 endif
 gosub _saveload_savebox_free
 `
return

_saveload_savebox_init:
 `
 rem Setup at veru start of game
 saveload.saveloadimg=530 : rem between muzzle flash and image bank
 saveload.saveloadx=(screen width()-600)/2
 saveload.saveloady=(screen height()-350)/2
 `
return

_saveload_savebox_earlygrab:
 `
 `x9rem Grab screen and reduce to JPG file
 `get image saveload.saveloadimg+4,(screen width()/2)-128,(screen height()/2)-128,(screen width()/2)+128,(screen height()/2)+128
 rem X10 new screen grabber
 if gtestgamemodefromeditor=0
  if path exist(myownrootdir$+"gamesaves")=1
   tscrfile$=myownrootdir$+"gamesaves\temp.bmp"
   if file exist(tscrfile$)=1 then delete file tscrfile$
   save screenshot tscrfile$
  endif
 endif
 `
return

_saveload_savebox_initlist:
 `
 rem Create folder if not exist
 if path exist("gamesaves")=0 then make directory "gamesaves"
 `
 rem Load screen previews
 ttfile$="gamesaves\saveload.arr"
 if file exist(ttfile$)=1
  load array ttfile$,saveloadslot$()
 else
  for tclr=1 to 9 : saveloadslot$(tclr)=strarr$(645) : next tclr
 endif
 `
return

_saveload_savebox_load:
 `
 rem Load interface gfx
 saveload.saveloaddir$="languagebank\"+language$+"\gamecore\huds\saveload\"
 load image saveload.saveloaddir$+"load-base.png",saveload.saveloadimg+1
 load image saveload.saveloaddir$+"areyousure.png",saveload.saveloadimg+2
 load image saveload.saveloaddir$+"save-base.png",saveload.saveloadimg+3
 `
 rem Create folder if not exist and init the list
 gosub _saveload_savebox_initlist
 `
 rem Load screen previews
 for sloti=1 to 9
  ttfile$="gamesaves\scrshot"+str$(sloti)+".bmp"
  if file exist(ttfile$)=1
   load image ttfile$,saveload.saveloadimg+10+sloti,1
  else
   if image exist(saveload.saveloadimg+10+sloti)=1 then delete image saveload.saveloadimg+10+sloti
  endif
 next sloti
 `
 rem Text for saveload box
 set text size 16
 `
 rem Reset
 saveload.areyousure=0
 `
return

_saveload_savebox_free:
 `
 rem Free usages
 delete image saveload.saveloadimg+1
 delete image saveload.saveloadimg+2
 delete image saveload.saveloadimg+3
 for sloti=1 to 9
  if image exist(saveload.saveloadimg+10+sloti)=1 then delete image saveload.saveloadimg+10+sloti
 next sloti
 `
return

_saveload_savebox_run:
 `
 rem Mouse coords
 tmmx=saveloadmousex : tmmy=saveloadmousey
 `
 rem Refresh saveload box
 if saveload.loadswitch=1
  pasteimage(saveload.saveloadimg+1,saveload.saveloadx,saveload.saveloady,1)
 else
  pasteimage(saveload.saveloadimg+3,saveload.saveloadx,saveload.saveloady,1)
 endif
 `
 rem Slot names
 ink rgb(32,32,32),0
 if saveload.areyousure=0 then saveload.slothighlight=0
 for sloti=1 to 9
  thoverhighlight=0
  saveload.liney=saveload.saveloady+28+(sloti*27)
  if tmmx>=saveload.saveloadx+20 and tmmx<=saveload.saveloadx+300
   if tmmy>=saveload.liney and tmmy<saveload.liney+26
    if saveload.areyousure=0 then thoverhighlight=1
   endif
  endif
  dink$=""
  if thoverhighlight=1
   if saveload.loadswitch=0 or saveloadslot$(sloti)<>strarr$(645)
    saveload.slothighlight=sloti
    ink rgb(255,255,255),0
    dink$="> "
   endif
  else
   ink rgb(32,32,32),0
  endif
  text saveload.saveloadx+25,saveload.liney+4,dink$+str$(sloti)+"  "+saveloadslot$(sloti)
 next sloti
 `
 rem Preview
 if saveload.slothighlight>0
  slotimg=saveload.saveloadimg+10+saveload.slothighlight
  if image exist(slotimg)=1 then pasteimagesize(slotimg,saveload.saveloadx+318,saveload.saveloady+54,1,270,256)
 endif
 `
 rem Text colour
 ink rgb(255,255,255),0
 `
 rem Are You Sure prompt
 if saveload.areyousure=1
  tareyousurex=saveload.saveloadx+50
  tareyousurey=saveload.saveloady+130
  pasteimage(saveload.saveloadimg+2,tareyousurex,tareyousurey,1)
  rem choice detection
  tyesnochoice1=0 : tyesnochoice2=0
  if tmmy>=tareyousurey+15 and tmmy<tareyousurey+45
   if tmmx>=tareyousurex+400 and tmmx<=tareyousurex+450 then tyesnochoice1=1 : tyesnochoice2=0
   if tmmx>=tareyousurex+450 and tmmx<=tareyousurex+500 then tyesnochoice1=0 : tyesnochoice2=1
  endif
  if saveload.loadswitch=1 then suretext$=strarr$(648)+" "+saveloadslot$(saveload.slothighlight)+"?" else suretext$=strarr$(649)+" "+saveloadslot$(saveload.slothighlight)+"?"
  text tareyousurex+30,tareyousurey+30,suretext$
  dink1$="" : if tyesnochoice1=1 then dink1$=">"
  dink2$="" : if tyesnochoice2=1 then dink2$=">"
  text tareyousurex+380,tareyousurey+30,dink1$+strarr$(650)
  text tareyousurex+450,tareyousurey+30,dink2$+strarr$(651)
  rem select one
  if mouseclick()=1 and (tyesnochoice1=1 or tyesnochoice2=1)
   saveload.areyousure=0 : while mouseclick()=1 : endwhile
   if tyesnochoice1=1 then saveload.slotselected=saveload.slothighlight
  endif
  rem Escape from confirmer box
  if escapekey()=1 then saveload.areyousure=0 : while escapekey()=1 : endwhile
 else
  rem Select slot
  if mouseclick()=1 and saveload.slothighlight>0
   rem Slot X selected
   sloti=saveload.slothighlight
   if saveloadslot$(sloti)=strarr$(645)
    if saveload.loadswitch=0
     saveload.slotselected=saveload.slothighlight
    endif
   else
    rem overwrite?
    saveload.areyousure=1
   endif
  endif
  if escapekey()=1
   saveload.slotselected=-1
   while escapekey()=1 : endwhile
  endif
 endif
 `
return

_saveload_savebox_dosave:
 `
 rem Fill details
 `x9tname$=strarr$(652)+" "+str$(level)
 tname$="LVL"+str$(level)
 tdate$=left$(get time$(),5)+"-"+left$(get date$(),5)
 tnameanddate$=tname$+" "+tdate$
 `
 rem Make entry in slot list and save
 ttfile$="gamesaves\saveload.arr"
 if file exist(ttfile$)=1 then delete file ttfile$
 saveloadslot$(saveload.slotselected)=tnameanddate$
 save array ttfile$,saveloadslot$()
 `
 rem Save BMP to slot
 ttfile$="gamesaves\scrshot"+str$(saveload.slotselected)+".bmp"
 if file exist(ttfile$)=1 then delete file ttfile$
 `x9save image ttfile$,saveload.saveloadimg+4,1
 rem rename the temp.bmp that already exists
 tscrfile$="gamesaves\temp.bmp"
 if file exist(tscrfile$)=1
  move file tscrfile$,ttfile$
 endif
 `
 rem Actual slot filename
 saveloadfile$="gamesaves\slot"+str$(saveload.slotselected)+".dat"
 `
return

_saveload_savebox_doload:
 `
 rem Actual slot filename
 saveloadfile$="gamesaves\slot"+str$(saveload.slotselected)+".dat"

return


`
` SAVELOAD Actual Save and Load Game
`



_saveload_savegame:
 `
 rem CREATE SAVEGAMEDATA FROM GAME DATA
 gosub _saveload_storesavedata
 `
 rem SAVE
 if file exist(saveloadfile$)=1 then delete file saveloadfile$
 open to write 1,saveloadfile$
 version=110 : write file 1,version
 if version>=100
  rem V100
  rem Player
  a#=saveloadgameposition.level : write float 1,a#
  a#=saveloadgameposition.playerx : write float 1,a#
  a#=saveloadgameposition.playery : write float 1,a#
  a#=saveloadgameposition.playerz : write float 1,a#
  a#=saveloadgameposition.playerry : write float 1,a#
  a#=saveloadgameposition.playerhealth : write float 1,a#
  a#=saveloadgameposition.playerlives : write float 1,a#
  a#=saveloadgameposition.playerinventorymax : write float 1,a#
  rem Inventory
  for lsi=0 to 100
   a#=saveloadgamepositionplayerinventory(lsi).new : write float 1,a#
   a#=saveloadgamepositionplayerinventory(lsi).drop : write float 1,a#
   a#=saveloadgamepositionplayerinventory(lsi).index : write float 1,a#
  next lsi
  rem Objectives
  for lsi=0 to 99
   a#=saveloadgamepositionplayerobjective(lsi) : write float 1,a#
  next lsi
  rem Entities
  a#=entityelementmax : write float 1,a#
  for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).spawnleaderid : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ailibindex : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aistate : write float 1,a#
   a#=saveloadgamepositionentity(lsi).active : write float 1,a#
   a#=saveloadgamepositionentity(lsi).dormant : write float 1,a#
   a#=saveloadgamepositionentity(lsi).beenkilled : write float 1,a#
   a#=saveloadgamepositionentity(lsi).x : write float 1,a#
   a#=saveloadgamepositionentity(lsi).y : write float 1,a#
   a#=saveloadgamepositionentity(lsi).z : write float 1,a#
   a#=saveloadgamepositionentity(lsi).rx : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ry : write float 1,a#
   a#=saveloadgamepositionentity(lsi).rz : write float 1,a#
   a#=saveloadgamepositionentity(lsi).floorposy : write float 1,a#
   a#=saveloadgamepositionentity(lsi).currentammo : write float 1,a#
   a#=saveloadgamepositionentity(lsi).health : write float 1,a#
   a#=saveloadgamepositionentity(lsi).collected : write float 1,a#
   a#=saveloadgamepositionentity(lsi).activated : write float 1,a#
   a#=saveloadgamepositionentity(lsi).texturearrayindex : write float 1,a#
  next lsi
  rem Weapons
  for lsi=0 to 10
   a#=saveloadgamepositionweaponslot(lsi).pref : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).got : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).invpos : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).weaponammo : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).weaponclipammo : write float 1,a#
   a#=saveloadgamepositionweaponslot(lsi).weaponhud : write float 1,a#
  next lsi
 endif
 if version>=110
  rem Store mission goal total
  a#=saveloadgameposition.missiongoaltotal : write float 1,a#
  a#=saveloadgameposition.playercrouchmode : write float 1,a#
  rem More Entity Info
  a#=entityelementmax : write float 1,a#
  for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).aioldstate : write float 1,a#
   a#=saveloadgamepositionentity(lsi).animset : write float 1,a#
   a#=saveloadgamepositionentity(lsi).animdo : write float 1,a#
   a#=saveloadgamepositionentity(lsi).collisionactive : write float 1,a#
  next lsi
  rem Restore all waypoint and spawn states of entity
  rem to correct invisible spawns and wrong direction of waypoint users
  for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).actualtarget : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointstate : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointcurrent : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointtracker : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointdirection : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointxstart : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointystart : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointzstart : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointxinc : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointyinc : write float 1,a#
   a#=saveloadgamepositionentity(lsi).waypointzinc : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aiusinginternalai : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aioldwaypointstate : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aioldanimframe : write float 1,a#
   a#=saveloadgamepositionentity(lsi).aiolddestanimframe : write float 1,a#
   a#=saveloadgamepositionentity(lsi).spawnatstart : write float 1,a#
   a#=saveloadgamepositionentity(lsi).spawnupto : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ailastactionmode : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ailastpatrolpoint : write float 1,a#
   a#=saveloadgamepositionentity(lsi).lightislit : write float 1,a#
  next lsi
  rem The orientation of the camera
  a#=saveloadgameposition.playerrx : write float 1,a#
  rem What gun is being carried
  a#=saveloadgameposition.playerholdinggun : write float 1,a#
  rem Object angles fiffer from RX RY RZ
  for lsi=0 to entityelementmax
   a#=saveloadgamepositionentity(lsi).orx : write float 1,a#
   a#=saveloadgamepositionentity(lsi).ory : write float 1,a#
   a#=saveloadgamepositionentity(lsi).orz : write float 1,a#
   a#=saveloadgamepositionentity(lsi).animframe : write float 1,a#
  next lsi
 endif
 close file 1
 `
return

_saveload_loadgame:
 `
 rem LOAD
 open to read 1,saveloadfile$
 read file 1,version
 if version>=100
  rem V100
  rem Player
  read float 1,a# : saveloadgameposition.level=a#
  read float 1,a# : saveloadgameposition.playerx=a#
  read float 1,a# : saveloadgameposition.playery=a#
  read float 1,a# : saveloadgameposition.playerz=a#
  read float 1,a# : saveloadgameposition.playerry=a#
  read float 1,a# : saveloadgameposition.playerhealth=a#
  read float 1,a# : saveloadgameposition.playerlives=a#
  read float 1,a# : saveloadgameposition.playerinventorymax=a#
  rem Inventory
  dim saveloadgamepositionplayerinventory(100) as inventorytype
  for lsi=0 to 100
   read float 1,a# : saveloadgamepositionplayerinventory(lsi).new=a#
   read float 1,a# : saveloadgamepositionplayerinventory(lsi).drop=a#
   read float 1,a# : saveloadgamepositionplayerinventory(lsi).index=a#
  next lsi
  rem Objectives
  dim saveloadgamepositionplayerobjective(99)
  for lsi=0 to 99
   read float 1,a# : saveloadgamepositionplayerobjective(lsi)=a#
  next lsi
  rem Entities
  read float 1,a# : entityelementmax=a#
  dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
  for lsi=0 to entityelementmax
   read float 1,a# : saveloadgamepositionentity(lsi).spawnleaderid=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ailibindex=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aistate=a#
   read float 1,a# : saveloadgamepositionentity(lsi).active=a#
   read float 1,a# : saveloadgamepositionentity(lsi).dormant=a#
   read float 1,a# : saveloadgamepositionentity(lsi).beenkilled=a#
   read float 1,a# : saveloadgamepositionentity(lsi).x=a#
   read float 1,a# : saveloadgamepositionentity(lsi).y=a#
   read float 1,a# : saveloadgamepositionentity(lsi).z=a#
   read float 1,a# : saveloadgamepositionentity(lsi).rx=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ry=a#
   read float 1,a# : saveloadgamepositionentity(lsi).rz=a#
   read float 1,a# : saveloadgamepositionentity(lsi).floorposy=a#
   read float 1,a# : saveloadgamepositionentity(lsi).currentammo=a#
   read float 1,a# : saveloadgamepositionentity(lsi).health=a#
   read float 1,a# : saveloadgamepositionentity(lsi).collected=a#
   read float 1,a# : saveloadgamepositionentity(lsi).activated=a#
   read float 1,a# : saveloadgamepositionentity(lsi).texturearrayindex=a#
  next lsi
  rem Weapons
  dim saveloadgamepositionweaponslot(10) as saveloadgamepositionweaponslottype
  for lsi=0 to 10
   read float 1,a# : saveloadgamepositionweaponslot(lsi).pref=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).got=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).invpos=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).weaponammo=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).weaponclipammo=a#
   read float 1,a# : saveloadgamepositionweaponslot(lsi).weaponhud=a#
  next lsi
 endif
 if version>=101
  rem Player mission goal total
  read float 1,a# : saveloadgameposition.missiongoaltotal=a#
  read float 1,a# : saveloadgameposition.playercrouchmode=a#
  rem More Entities Info
  read float 1,a# : entityelementmax=a#
  dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
  for lsi=0 to entityelementmax
   read float 1,a# : saveloadgamepositionentity(lsi).aioldstate=a#
   read float 1,a# : saveloadgamepositionentity(lsi).animset=a#
   read float 1,a# : saveloadgamepositionentity(lsi).animdo=a#
   read float 1,a# : saveloadgamepositionentity(lsi).collisionactive=a#
  next lsi  
  rem Restore all waypoint and spawn states of entity
  rem to correct invisible spawns and wrong direction of waypoint users
  for lsi=0 to entityelementmax
   read float 1,a# : saveloadgamepositionentity(lsi).actualtarget=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointstate=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointcurrent=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointtracker=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointdirection=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointxstart=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointystart=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointzstart=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointxinc=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointyinc=a#
   read float 1,a# : saveloadgamepositionentity(lsi).waypointzinc=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aiusinginternalai=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aioldwaypointstate=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aioldanimframe=a#
   read float 1,a# : saveloadgamepositionentity(lsi).aiolddestanimframe=a#
   read float 1,a# : saveloadgamepositionentity(lsi).spawnatstart=a#
   read float 1,a# : saveloadgamepositionentity(lsi).spawnupto=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ailastactionmode=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ailastpatrolpoint=a#
   read float 1,a# : saveloadgamepositionentity(lsi).lightislit=a#
  next lsi
  rem Player Orientation and Visible Gun
  read float 1,a# : saveloadgameposition.playerrx=a#
  read float 1,a# : saveloadgameposition.playerholdinggun=a#
  rem Object otation seperated from entity element rotatyion
  for lsi=0 to entityelementmax
   read float 1,a# : saveloadgamepositionentity(lsi).orx=a#
   read float 1,a# : saveloadgamepositionentity(lsi).ory=a#
   read float 1,a# : saveloadgamepositionentity(lsi).orz=a#
   read float 1,a# : saveloadgamepositionentity(lsi).animframe=a#
  next lsi
 endif
 close file 1
 `
 rem Immediate data required (prior to level loading) - 'saveload_retrievesavedata' used after level loaded
 level=saveloadgameposition.level
 `
return

_saveload_storesavedata:
 `
 rem Move player data from actual game to the game data structures
 player(1).x=camerapositionx
 player(1).y=camerapositiony-phyeyeheight#
 player(1).z=camerapositionz
 `
 rem Create savedata arrays and copy game data to them
 saveloadgameposition.level=level
 saveloadgameposition.playerx=player(1).x
 saveloadgameposition.playery=player(1).y
 saveloadgameposition.playerz=player(1).z
 saveloadgameposition.playerrx=camera angle x(playercam)
 saveloadgameposition.playerry=camera angle y(playercam)
 saveloadgameposition.playerhealth=player(1).health
 saveloadgameposition.playerlives=player(1).lives
 saveloadgameposition.playerinventorymax=player(1).inventorymax
 saveloadgameposition.missiongoaltotal=missiongoaltotal
 `150110saveloadgameposition.playerholdinggun=autoloadgun
 saveloadgameposition.playerholdinggun=gunid
 saveloadgameposition.playercrouchmode=crouchmode
 `
 rem Inventory
 dim saveloadgamepositionplayerinventory(100) as inventorytype
 for lsi=0 to 100
  saveloadgamepositionplayerinventory(lsi).new=playerinventory(lsi).new
  saveloadgamepositionplayerinventory(lsi).drop=playerinventory(lsi).drop
  saveloadgamepositionplayerinventory(lsi).index=playerinventory(lsi).index
 next lsi
 rem Objectives
 dim saveloadgamepositionplayerobjective(99)
 for lsi=0 to 99
  saveloadgamepositionplayerobjective(lsi)=playerobjective(lsi)
 next lsi
 rem Entities
 dim saveloadgamepositionentity(entityelementmax) as saveloadgamepositionentitytype
 for lsi=0 to entityelementmax
  saveloadgamepositionentity(lsi).spawnleaderid=entityelement(lsi).spawn.leaderid
  saveloadgamepositionentity(lsi).ailibindex=entityelement(lsi).ai.libindex
  saveloadgamepositionentity(lsi).aistate=entityelement(lsi).ai.state
  saveloadgamepositionentity(lsi).aioldstate=entityelement(lsi).ai.oldstate
  saveloadgamepositionentity(lsi).active=entityelement(lsi).active
  saveloadgamepositionentity(lsi).dormant=entityelement(lsi).dormant
  saveloadgamepositionentity(lsi).beenkilled=entityelement(lsi).beenkilled
  saveloadgamepositionentity(lsi).x=entityelement(lsi).x
  saveloadgamepositionentity(lsi).y=entityelement(lsi).y
  saveloadgamepositionentity(lsi).z=entityelement(lsi).z
  tttobj=entityelement(lsi).obj
  if tttobj>0
   if object exist(tttobj)=1
    lsientid=entityelement(lsi).bankindex
    if entityprofile(lsientid).ischaracter=1
     saveloadgamepositionentity(lsi).rx=0
     saveloadgamepositionentity(lsi).ry=entityelement(lsi).ry
     saveloadgamepositionentity(lsi).rz=0
    else
     saveloadgamepositionentity(lsi).rx=object angle x(tttobj)
     saveloadgamepositionentity(lsi).ry=object angle y(tttobj)
     saveloadgamepositionentity(lsi).rz=object angle z(tttobj)
     saveloadgamepositionentity(lsi).orx=object angle x(tttobj)
     saveloadgamepositionentity(lsi).ory=object angle y(tttobj)
     saveloadgamepositionentity(lsi).orz=object angle z(tttobj)
    endif
   endif
  endif
  saveloadgamepositionentity(lsi).floorposy=entityelement(lsi).floorposy
  saveloadgamepositionentity(lsi).animset=entityelement(lsi).animset
  saveloadgamepositionentity(lsi).animdo=entityelement(lsi).animdo
  saveloadgamepositionentity(lsi).animframe=entityelement(lsi).animframe
  saveloadgamepositionentity(lsi).currentammo=entityelement(lsi).currentammo
  saveloadgamepositionentity(lsi).health=entityelement(lsi).health
  saveloadgamepositionentity(lsi).collected=entityelement(lsi).collected
  saveloadgamepositionentity(lsi).activated=entityelement(lsi).activated
  saveloadgamepositionentity(lsi).texturearrayindex=entityelementtexarrayindex(lsi)
  saveloadgamepositionentity(lsi).collisionactive=entityelement(lsi).collisionactive
  saveloadgamepositionentity(lsi).ailastactionmode=entityelement(lsi).eleprof.aiss.lastactionmode
  saveloadgamepositionentity(lsi).ailastpatrolpoint=0
  saveloadgamepositionentity(lsi).lightislit=entityelement(lsi).eleprof.light.islit
  if tttobj>0
   if AI Entity Exist(tttobj)=1
    saveloadgamepositionentity(lsi).ailastpatrolpoint=AI Get Entity Patrol Control Point(tttobj)
   endif
  endif
 next lsi
 rem Weapons
 dim saveloadgamepositionweaponslot(10) as saveloadgamepositionweaponslottype
 for lsi=0 to 10
  saveloadgamepositionweaponslot(lsi).pref=weaponslot(lsi).pref
  saveloadgamepositionweaponslot(lsi).got=weaponslot(lsi).got
  saveloadgamepositionweaponslot(lsi).invpos=weaponslot(lsi).invpos
  saveloadgamepositionweaponslot(lsi).weaponammo=weaponammo(lsi)
  saveloadgamepositionweaponslot(lsi).weaponclipammo=weaponclipammo(lsi)
  saveloadgamepositionweaponslot(lsi).weaponhud=weaponhud(lsi)
 next lsi
 `
return

_saveload_retrievesavedata:
 `
 rem Create savedata arrays and copy game data to them
 `level=saveloadgameposition.level (already done when loaded savedata)
 player(1).x=saveloadgameposition.playerx
 player(1).y=saveloadgameposition.playery
 player(1).z=saveloadgameposition.playerz
 player(1).health=saveloadgameposition.playerhealth
 player(1).lives=saveloadgameposition.playerlives
 player(1).inventorymax=saveloadgameposition.playerinventorymax
` missiongoaltotal=saveloadgameposition.missiongoaltotal
 rem Inventory
 for lsi=0 to 100
  playerinventory(lsi).new=saveloadgamepositionplayerinventory(lsi).new
  playerinventory(lsi).drop=saveloadgamepositionplayerinventory(lsi).drop
  playerinventory(lsi).index=saveloadgamepositionplayerinventory(lsi).index
 next lsi
 rem Objectives
 gsaveloadobjectivesloaded=1
 for lsi=0 to 99
  playerobjective(lsi)=saveloadgamepositionplayerobjective(lsi)
 next lsi
 rem Entities
 for lsi=1 to entityelementmax
  `
  entityelement(lsi).spawn.leaderid=saveloadgamepositionentity(lsi).spawnleaderid
  entityelement(lsi).active=saveloadgamepositionentity(lsi).active
  entityelement(lsi).dormant=saveloadgamepositionentity(lsi).dormant
  entityelement(lsi).beenkilled=saveloadgamepositionentity(lsi).beenkilled
  `
  lsientid=entityelement(lsi).bankindex
  if entityprofile(lsientid).ischaracter=1
   entityelement(lsi).ai.libindex=saveloadgamepositionentity(lsi).ailibindex
   entityelement(lsi).ai.state=saveloadgamepositionentity(lsi).aistate
   entityelement(lsi).ai.oldstate=saveloadgamepositionentity(lsi).aioldstate
   entityelement(lsi).active=saveloadgamepositionentity(lsi).active
   entityelement(lsi).dormant=saveloadgamepositionentity(lsi).dormant
   entityelement(lsi).beenkilled=saveloadgamepositionentity(lsi).beenkilled
   rem leave ENTITYELEMENT().XYZ (as need to be done AFTER viscol code)
  else
   entityelement(lsi).ai.libindex=saveloadgamepositionentity(lsi).ailibindex
   entityelement(lsi).ai.state=saveloadgamepositionentity(lsi).aistate
   entityelement(lsi).ai.oldstate=saveloadgamepositionentity(lsi).aioldstate
   entityelement(lsi).floorposy=saveloadgamepositionentity(lsi).floorposy
  endif
  `
  entityelement(lsi).animset=saveloadgamepositionentity(lsi).animset
  entityelement(lsi).animdo=saveloadgamepositionentity(lsi).animdo
  entityelement(lsi).animframe=saveloadgamepositionentity(lsi).animframe
  entityelement(lsi).collisionactive=saveloadgamepositionentity(lsi).collisionactive
  entityelement(lsi).currentammo=saveloadgamepositionentity(lsi).currentammo
  entityelement(lsi).health=saveloadgamepositionentity(lsi).health
  entityelement(lsi).collected=saveloadgamepositionentity(lsi).collected
  entityelement(lsi).activated=saveloadgamepositionentity(lsi).activated
  entityelementtexarrayindex(lsi)=saveloadgamepositionentity(lsi).texturearrayindex
  `
  rem V110 - 150110 - assign any AI action mode the entity was in
  entityelement(lsi).eleprof.aiss.actionmode=saveloadgamepositionentity(lsi).ailastactionmode
  entityelement(lsi).eleprof.aiss.savedpatrolpoint=saveloadgamepositionentity(lsi).ailastpatrolpoint
  `
  rem V110 - 190110 - set loaded light state
  entityelement(lsi).eleprof.light.islit=saveloadgamepositionentity(lsi).lightislit
  if gdynamiclightingstate=1
   infinilight(entityelement(lsi).eleprof.light.index).islit=entityelement(lsi).eleprof.light.islit
  endif
  `
  rem OLD X10 stuff (delete when V110 finished)
  `entityelement(lsi).x=saveloadgamepositionentity(lsi).x
  `entityelement(lsi).y=saveloadgamepositionentity(lsi).y
  `entityelement(lsi).z=saveloadgamepositionentity(lsi).z
  `entityelement(lsi).rx=0
  `entityelement(lsi).ry=saveloadgamepositionentity(lsi).ry
  `entityelement(lsi).rz=0
  `entityelement(lsi).floorposy=saveloadgamepositionentity(lsi).floorposy
  rem AND THIS WAS JUST A HACK (low state retention!)
  `lsientid=entityelement(lsi).bankindex
  `if entityprofile(lsientid).ischaracter=1
  ` rem X10 - 131007 - store this so we do not do AIINIT again for characters (roar)
  ` entityelement(lsi).ai.libindex=saveloadgamepositionentity(lsi).ailibindex
  `else
  ` if entityprofile(lsientid).ismarker>0
  `  entityelement(lsi).ai.state=saveloadgamepositionentity(lsi).aistate
  ` endif
  `endif
  `
 next lsi
 rem Weapons
 for lsi=0 to 10
  weaponslot(lsi).pref=saveloadgamepositionweaponslot(lsi).pref
  weaponslot(lsi).got=saveloadgamepositionweaponslot(lsi).got
  weaponslot(lsi).invpos=saveloadgamepositionweaponslot(lsi).invpos
  weaponammo(lsi)=saveloadgamepositionweaponslot(lsi).weaponammo
  weaponclipammo(lsi)=saveloadgamepositionweaponslot(lsi).weaponclipammo
  weaponhud(lsi)=saveloadgamepositionweaponslot(lsi).weaponhud
 next lsi
 rem Waypoint information
 if entityelementmax>0
  for lsi=1 to entityelementmax
   entityelement(lsi).actualtarget=saveloadgamepositionentity(lsi).actualtarget
   entityelement(lsi).ai.waypoint.state=saveloadgamepositionentity(lsi).waypointstate
   entityelement(lsi).ai.waypoint.current=saveloadgamepositionentity(lsi).waypointcurrent
   entityelement(lsi).ai.waypoint.tracker=saveloadgamepositionentity(lsi).waypointtracker
   entityelement(lsi).ai.waypoint.direction=saveloadgamepositionentity(lsi).waypointdirection
   entityelement(lsi).ai.waypoint.xstart=saveloadgamepositionentity(lsi).waypointxstart
   entityelement(lsi).ai.waypoint.ystart=saveloadgamepositionentity(lsi).waypointystart
   entityelement(lsi).ai.waypoint.zstart=saveloadgamepositionentity(lsi).waypointzstart
   entityelement(lsi).ai.waypoint.xinc=saveloadgamepositionentity(lsi).waypointxinc
   entityelement(lsi).ai.waypoint.yinc=saveloadgamepositionentity(lsi).waypointyinc
   entityelement(lsi).ai.waypoint.zinc=saveloadgamepositionentity(lsi).waypointzinc
   entityelement(lsi).ai.usinginternalai=saveloadgamepositionentity(lsi).aiusinginternalai
   entityelement(lsi).ai.oldwaypointstate=saveloadgamepositionentity(lsi).aioldwaypointstate
   entityelement(lsi).ai.oldanimframe=saveloadgamepositionentity(lsi).aioldanimframe
   entityelement(lsi).ai.olddestanimframe=saveloadgamepositionentity(lsi).aiolddestanimframe
   entityelement(lsi).spawn.atstart=saveloadgamepositionentity(lsi).spawnatstart
   entityelement(lsi).spawn.upto=saveloadgamepositionentity(lsi).spawnupto
  next lsi
 endif
 `
 rem Refresh game objects and player with new level states
 playerstartx#=player(1).x
 playerstarty#=player(1).y
 playerstartz#=player(1).z 
 playerstartrx#=saveloadgameposition.playerrx
 playerstartry#=saveloadgameposition.playerry
 playerstarthasweapon=saveloadgameposition.playerholdinggun
 crouchmode=saveloadgameposition.playercrouchmode
 playerstartingfromreload=1
 gosub _player_restart
 playerstartingfromreload=0
 `
 rem Now refresh gun
 gosub _gun_loadonlypresent
 `
 rem Go through all entities and remove those which are no longer in level
 for e=1 to entityelementmax
  `
  rem entity identity
  entid=entityelement(e).bankindex
  obj=entityelement(e).obj
  `
  rem if filled, flag it
  tentityhasbeenkilledsoremove=0 : if entityelement(e).beenkilled=1 then tentityhasbeenkilledsoremove=1
  `
  rem clear entity from col map
  thadcolbit=0
  tx=entityelement(e).x/25
  ty=entityelement(e).y/100
  tz=entityelement(e).z/-25
  if tx>=0 and ty>=0 and tz>=0
   if tx<=viscolx and ty<=viscoly and tz<=viscolz
    if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0 : thadcolbit=1
   endif
  endif
  if obj>0
   if object exist(obj)=1
    if entityelement(e).eleprof.physics<>0
     gosub _physics_switchoffe
    else
     set object collision off obj
    endif
   endif
  endif
  `
  rem Move entity to restore position (AFTER viscol removal)
  entityelement(e).x=saveloadgamepositionentity(e).x
  entityelement(e).y=saveloadgamepositionentity(e).y
  entityelement(e).z=saveloadgamepositionentity(e).z
  `
  if entityelement(e).active<>0 and tentityhasbeenkilledsoremove=0
   `
   rem ENTITY IS IN GAME
   rem update object in relation to this entity
   if obj>0
    rem object itself
    if object exist(obj)=1
     rem position from entity pos, but rotation direct from savedata
     position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
     rem Reversed characters bug, so only apply if character is dead (corpse)
     if entityprofile(entid).ischaracter=1
      if entityelement(e).ai.libindex=entityelement(e).ai.libdestroy
       rotate object obj,saveloadgamepositionentity(e).rx,saveloadgamepositionentity(e).ry,saveloadgamepositionentity(e).rz
      else
       rem must be 0,0,0 before apply physics to the object (for characters)
       rotate object obj,0,0,0
      endif
     else
      rem Need to retain rotation for doors, etc
      rem V110 - 150110 - to solve odd rotating door on reload issue, 
      rem only rotate entities that are not immobile (doors are immobile)
      if entityelement(e).eleprof.isimmobile=0
       rotate object obj,saveloadgamepositionentity(e).orx,saveloadgamepositionentity(e).ory,saveloadgamepositionentity(e).orz
      endif
     endif
     rem Create the physics body
     rem Any active spawned entities should be woken!
     if entityelement(e).spawn.leaderid>0
      if entityelement(e).spawn.leader=0
       entityelement(e).collisionactive=1
       set object collision on obj
       show object obj
      endif
     endif
     rem Only activate physics for certain OBJs and they are active
     if entityelement(e).spawn.leader=1
      rem spawn master does not need physics object
      tobj=obj : gosub _physics_ensurephysicsobjvalid
     else
      if entityelement(e).collisionactive=1 or entityprofile(entid).ischaracter=1
       if entityelement(e).eleprof.physics<>0
        gosub _physics_setupewithphysics
       else
        set object collision on obj
       endif
      endif
     endif
     if entityelement(e).collisionactive=0 and entityprofile(entid).ischaracter=0
      if entityelement(e).eleprof.physics<>0
       gosub _physics_switchoffe
      else
       set object collision off obj
      endif
     endif
     `
     rem Ensure animation is the same
     rem Only set anim for characters, not animating non-character entities
     if entityprofile(entid).ischaracter=1
      rem Only if actually using ANIMATE, not if using SETFRAME, etc
      if entityelement(e).animdo=-1
       rem not animating, but ensure no default anim is playing
       if object exist(obj)=1 then stop object obj
      else
       if entityelement(e).ai.waypoint.state>=99
        entityelement(e).animset=2
       else
        rem Spawn anim and idle one and the same for a reload
        if entityelement(e).animdo=0 then entityelement(e).animdo=1
        entityelement(e).animset=1+entityelement(e).animdo
       endif
       entityelement(e).animdo=0
      endif
     else
      entityelement(e).animset=0
      entityelement(e).animdo=0
     endif
     rem Added animframe to save data, so set it here
     entityelement(e).destanimframe=entityelement(e).animframe
     entityelement(e).animtime=0
     rem V110 - 190110 - ensure object not start from zero, and work towards target animset
`     entityelement(e).animframe=0
     if object exist(obj)=1 then set object frame obj,entityelement(e).animframe
    endif
   endif
   `
   rem replace in colmap
   if thadcolbit=1
    tx=entityelement(e).x/25
    ty=entityelement(e).y/100
    tz=entityelement(e).z/-25
    if tx>=0 and ty>=0 and tz>=0
     if tx<=viscolx and ty<=viscoly and tz<=viscolz
      viscolmap(tx,ty,tz)=e
     endif
    endif
   endif
   `
  else
   `
   rem ENTITY NOT IN GAME
   rem Move entity to restore position (AFTER viscol removal)
   entityelement(e).x=saveloadgamepositionentity(e).x
   entityelement(e).y=saveloadgamepositionentity(e).y
   entityelement(e).z=saveloadgamepositionentity(e).z
   `
   rem Destroy this entity for good
   entityelement(e).active=0
   entityelement(e).dormant=0
   `
   rem Hide the object
   if obj>0
    if object exist(obj)=1
     `
     rem If character in DESTROY script (may be a left corpse), so treat as active during re-load
     if entityprofile(entid).ischaracter=1 and entityprofile(entid).noragdoll=1 and entityelement(e).ai.libindex=entityelement(e).ai.libdestroy
      `
      rem ONLY FOR X9 STYLE CORPSE CHARACTERS (not officially supported in X10)
      rem character as corpse should use last frame of fall over animation, and de-activate (and drop weapon)
      entityelement(e).animset=0
      entityelement(e).animdo=11
      entityelement(e).animtime=0
      entityelement(e).health=0
      entityelement(e).ai.state=0
      entityelement(e).activated=0
      tbaseframe=entityelement(e).animdo : gosub _entity_getactualframefinish : tffinish=tactualframe
      tcorpseanim=entityelement(e).animframe
      stop object obj : set object interpolation obj,100
      set object frame obj,tcorpseanim
      rem final object position different
      tmvszy#=(object size y(obj)/2)*(entityprofile(entid).scale/100.0)
      tmvy#=entityelement(e).y+tmvszy#
      position object obj,entityelement(e).x,tmvy#,entityelement(e).z
      rotate object obj,saveloadgamepositionentity(e).rx,saveloadgamepositionentity(e).ry,saveloadgamepositionentity(e).rz
      `
     else
      `
      rem regular entity destroy
      hide object obj
      if tentityhasbeenkilledsoremove=1
       rem if it has been killed - drain health to zero
       entityelement(e).eleprof.cantakeweapon=0
       entityelement(e).health=0
       entityelement(e).ai.state=0
       entityelement(e).activated=0
       entityelement(e).obj=0
      endif
      `
     endif
     `
    endif
   endif
   `
   rem stop any looping sound
   gosub _ai_stopentsounds
   `
  endif
  `
 next e 
 remstart pre-V110
 for e=1 to entityelementmax
  `
  rem entity identity
  entid=entityelement(e).bankindex
  obj=entityelement(e).obj
  `
  `rem ignore characters (and spawned objects) (complex setups) unless removing them
  tentityhasbeenkilledsoremove=0 : if entityelement(e).beenkilled=1 then tentityhasbeenkilledsoremove=1
  if entityelement(e).spawn.leaderid=0 or tentityhasbeenkilledsoremove=1
  `
  rem clear entity from col map
  thadcolbit=0
  tx=entityelement(e).x/25
  ty=entityelement(e).y/100
  tz=entityelement(e).z/-25
  if tx>=0 and ty>=0 and tz>=0
   if tx<=viscolx and ty<=viscoly and tz<=viscolz
    if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0 : thadcolbit=1
   endif
  endif
  `
  rem remove physics presence of default starting entities (to be restored in next bit)
  if obj>0
   if object exist(obj)=1
    if entityelement(e).eleprof.physics<>0
     gosub _physics_switchoffe
    else
     set object collision off obj
    endif
   endif
  endif
  `
  rem if this entity is still in level, prepare it, place it, set it up
  if entityelement(e).active<>0 and tentityhasbeenkilledsoremove=0
   rem update object in relation to this entity
   if obj>0
    rem object itself
    if object exist(obj)=1
     rem position from entity pos, but rotation direct from savedata
     position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
     rem X10 - 131007 - do not rotate characters (they have already been configured)
     if entityprofile(entid).ischaracter=0
      rotate object obj,saveloadgamepositionentity(e).rx,saveloadgamepositionentity(e).ry,saveloadgamepositionentity(e).rz
     endif
     rem create the physics body (if not child spawn entities)
     tspawnhide=0
     if entityelement(e).spawn.leaderid>0
      if entityelement(e).spawn.leader=0
       tspawnhide=1
      endif
     endif
     if tspawnhide=0
      if entityelement(e).spawn.leader=1
       rem spawn master does not need physics object
       gosub _physics_ensurephysicsobjvalid
      else
       rem everything else has physics to create
       gosub _physics_setupewithphysics
      endif
     else
      rem still need to reserve all obj ids with E
      gosub _physics_ensurephysicsobjvalid
     endif
     rem ensure animation is the same
     entityelement(e).animdo=1+entityelement(e).animset
    endif
   endif
   rem replace in colmap
   if thadcolbit=1
    tx=entityelement(e).x/25
    ty=entityelement(e).y/100
    tz=entityelement(e).z/-25
    if tx>=0 and ty>=0 and tz>=0
     if tx<=viscolx and ty<=viscoly and tz<=viscolz
      viscolmap(tx,ty,tz)=e
     endif
    endif
   endif
  else
   rem destroy this entity for good
   entityelement(e).active=0
   entityelement(e).dormant=0
   rem hide the object
   if obj>0
    if object exist(obj)=1
     hide object obj
     if tentityhasbeenkilledsoremove=1
      rem if it has been killed - drain health to zero
      entityelement(e).eleprof.cantakeweapon=0
      entityelement(e).health=0
      entityelement(e).ai.state=0
      entityelement(e).activated=0
      entityelement(e).obj=0
     endif
    endif
   endif
   rem stop any looping sound
   gosub _ai_stopentsounds
  endif
  `
  rem ignore characters
  endif
  `
 next e
 remend
 `
 rem Go through all inventory items and hide any entities that are currently held by player
 for pi=1 to player(1).inventorymax
  e=playerinventory(1,pi).index
  if e>0
   rem copied from PLRTAKE code (faithful reproduction of the player collect activity)
   obj=entityelement(e).obj
   rem if child of spawn leader, reset spawn count
   spawne=entityelement(e).spawn.leaderid
   if spawne=0 then spawne=e
   entityelement(spawne).spawn.leadercount=entityelement(spawne).spawn.delay
   rem switch off obj
   if obj>0
    gosub _physics_switchoffe
    hide object obj
    set object collision off obj
   endif
   if entityelement(e).eleprof.phyalways<>0
    rem do not kill entity, keep it running
   else
    rem stop any looping sound
    gosub _ai_stopentsounds
    rem reset values
    entityelement(e).beenkilled=1
    entityelement(e).active=0
   endif
   rem clear entity from col map
   tx=entityelement(e).x/25
   ty=entityelement(e).y/100
   tz=entityelement(e).z/-25
   if tx>=0 and ty>=0 and tz>=0
    if tx<=viscolx and ty<=viscoly and tz<=viscolz
     if viscolmap(tx,ty,tz)=e then viscolmap(tx,ty,tz)=0
    endif
   endif
   rem mission objective counter
   gosub _entity_resolveobjective
  endif
 next pi
 `
 rem Refresh AISS be re-calling the AI creates for each entity
 prepareentitiesmode=1 : gosub _aiss_prepareentities
 `
return

function pasteimage(img,x,y,t)
 set sprite 65534,0,0
 sprite 65534,-10000,-10000,img
 size sprite 65534,image width(img),image height(img)
 paste sprite 65534,x,y,t
endfunction

function pasteimagesize(img,x,y,t,sx,sy)
 set sprite 65534,0,0
 sprite 65534,-10000,-10000,img
 size sprite 65534,sx,sy
 paste sprite 65534,x,y,t
endfunction

`
` AI Subsystem Subroutines
`

_aiss_init:
 `
 rem clears the AI system of all data
 AI Start : AI Reset : gaiactive=1
 `
 rem Core Settings
 if 0
  rem No threading
  rem while debugging, use no threading (for debug level running of DarkAI)
  AI SET THREAD MODE 0
 else
  rem N-CORE threading
  AI SET THREAD MODE 1
  AI SET THREAD COUNT 4
 endif
 `
 rem Set common entity radius and avoidance model (22)
 AI Set Radius 20 : AI Set Avoid Mode 5 : rem 5 - avoidance grid system
 AI SET BLOCKING THRESHOLD 3 : rem number of corpses before grid is marked solid
 aissentityradius=30
 `
 rem Universe containers (required for static entities)
 for layer=0 to 19
  if layer>0 then AI Add Container layer
 next layer
 `
return

_aiss_free:
 `
 rem after each level, reset AI so a new level can be loaded
 rem it also frees the OBS file loaded for the obstacle data
 AI Reset
 `
return

_aiss_setup:
 `
 rem Create AI data for player, level, waypoints and safe zones
 gosub _aiss_player
 gosub _aiss_level
 gosub _aiss_zones
 `
return

_aiss_broadcastsound:
 `
 rem 200707 insufficient to give sounds different priorities based on origin
 `if gaiactive=1
 ` if bcsoundstrength#>0
 `  rem create shoot sound for AI (target not person shooing for better AI)
 `  tradius#=bcsoundstrength#*10
 `  rem sound scares off neutral path followers
 `  inc gaispaceoutsounds
 `  if gaispaceoutsounds>20
 `   AI Create Sound bcsoundx#,bcsoundz#,0,tradius#,(bcsoundy#+5)/100
 `   gaispaceoutsounds=0
 `  endif
 ` endif
 `endif 
 `
return

_aiss_player:
 `
 rem Assign the player object to the AI
 tplayerobjectnumber=physicsplayerborble
 `if tplayerobjectnumber=1
 ` make object cube tplayerobjectnumber,35
 ` hide object tplayerobjectnumber
 ` set object collision off tplayerobjectnumber
 `endif
 AI Add Player tplayerobjectnumber,0
 AI Set Player Height 40 : rem from 30 231007
 AI Set Player Radius 15
 `
return

_aiss_level:
 `
 rem Take current universe level, and create AI visibility and containers
 phyunimesh$=myownrootdir$+"levelbank\testlevel\universephy.dbo"
 load object phyunimesh$,physicsuniverseobj
 rem all level for 3D raycasting
 AI Add Alternate Visibility Object physicsuniverseobj,0
 delete object physicsuniverseobj
 `
 rem Perform OBSMAP generation (or quick reload)
 rem 140907 - or a full compile where level changes with each pass
 if tperformuniverseconstruction=1 or gcompilestandaloneexe=1
  rem constructing fully, so generate OBS data
  choiceoflayer=0 : choiceoflayerend=19
  gosub _obs_generate
  gosub _obs_processobstacles
  rem generate obstacles for AI
  obsgeneratenow=1 : gosub _obs_generateobstacles : obsgeneratenow=0
  rem save data after obstacle construction
  gosub _obs_save
 else
  rem use OBS data from last construction
  gosub _obs_load
  rem call this to complete obstacle creation (from loaded data)
  AI Complete Obstacles
 endif
 `
 remstart
 rem new OBSMAP approach above
 rem Take current universe level, and create AI landscape
 phyunimesh$=myownrootdir$+"levelbank\testlevel\universephy.dbo"
 load object phyunimesh$,physicsuniverseobj
 for layer=0 to 19
  if layer>0 then AI Add Container layer
  `rem walls
  `AI Add Obstacle From Level physicsuniverseobj,layer,1,55+(layer*100),10,10
  `rem sandbags to hind behind
  `AI Add Obstacle From Level physicsuniverseobj,layer,0,15+(layer*100),10,10
  rem New raycast accounts for real 3D heights, just calculate obstacles once per layer
  AI Add Obstacle From Level physicsuniverseobj,layer,1,15+(layer*100),10,10
 next layer
 rem all level for 3D raycasting
 AI Add Alternate Visibility Object physicsuniverseobj,0
 delete object physicsuniverseobj
 `
 rem Work out where holes are in floors
 flrx1=40 : flry1=20 : flrz1=40
 flrx2=0 : flry2=0 : flrz2=0
 for layer=0 to 19
  for z=0 to 39
   for x=0 to 39
    ptx#=50+(x*100)
    pty#=(layer*100)
    ptz#=50+(z*-100)
    dst#=static raycast(ptx#,pty#+10,ptz#,ptx#,pty#-10,ptz#)
    if dst#>0
     if x<flrx1 then flrx1=x
     if x>flrx2 then flrx2=x
     if layer<flry1 then flry1=layer
     if layer>flry2 then flry2=layer
     if z<flrz1 then flrz1=z
     if z>flrz2 then flrz2=z
    endif
   next x
  next z
 next layer
 rem can detect holes and generate extra obstacles so entitites do not fall into them
 debugobjforholes=12345
 for layer=flry1 to flry2
  for z=flrz1 to flrz2
   for x=flrx1 to flrx2
    ptx#=50+(x*100)
    pty#=(layer*100)
    ptz#=50+(z*-100)
    dst#=static raycast(ptx#,pty#+10,ptz#,ptx#,pty#-10,ptz#)
    if dst#=0
     rem generate debug spheres where holes are discovered
     if debugobjforholes>0 and 0
      make object box debugobjforholes,80,10,80
      position object debugobjforholes,ptx#,pty#,ptz#
      set object collision off debugobjforholes
      inc debugobjforholes
     endif
     rem create an obstacle to block this hole so entity can avoid it
     ax1#=ptx#-40
     ax2#=ptx#+40
     az1#=ptz#-40
     az2#=ptz#+40
     rem it is important to create the obstacle poly in an anti-clockwise direction
     if ax1#>ax2# then sax1#=ax1# : ax1#=ax2# : ax2#=sax1#
     if az1#>az2# then saz1#=az1# : az1#=az2# : az2#=saz1#
     AI Start New Obstacle
     AI Add Obstacle Vertex ax1#,az1#
     AI Add Obstacle Vertex ax1#,az2#
     AI Add Obstacle Vertex ax2#,az2#
     AI Add Obstacle Vertex ax2#,az1#
     AI End New Obstacle layer,0,0
    endif
   next x
  next z
 next layer
 AI Complete Obstacles
 remend
 `
 rem Connect containers with a container bridge using waypoint data
 for w=1 to waypointmax
  if waypoint(w).count>0
   for wpci=waypoint(w).start to waypoint(w).finish-1
    wpy#=waypointcoord(wpci).y : clyr=(wpy#+5)/100
    nextwpy#=waypointcoord(wpci+1).y : nextclyr=(nextwpy#+5)/100
    if nextclyr=clyr-1 or nextclyr=clyr+1
     rem waypoint path spans containers, a useful gate
     wpx#=waypointcoord(wpci).x
     wpz#=waypointcoord(wpci).z
     nextwpx#=waypointcoord(wpci+1).x
     nextwpz#=waypointcoord(wpci+1).z
     result = AI connect Containers(clyr, wpx#, wpz#, nextclyr, nextwpx#, nextwpz#)
     rem I cannot find a good spot, no matter what is troed..
     if result<>0 and 0
      tradius=1
      tradangle=0
      while result<>0 and tradius<50
       rem it it returns 1, one of the containers did not exist
       rem returns 2 or 3 if one of the points is within an obstacle in their respective containers
       rem returns 0 on success
       if result=2
        twpx#=wpx#+(cos(tradangle)*tradius)
        twpz#=wpz#+(sin(tradangle)*tradius)
       else
        twpx#=wpx#
        twpz#=wpz#
       endif
       if result=3
        tnextwpx#=nextwpx#+(cos(tradangle)*tradius)
        tnextwpz#=nextwpz#+(sin(tradangle)*tradius)
       else
        tnextwpx#=nextwpx#
        tnextwpz#=nextwpz#
       endif
       result = AI connect Containers(clyr, twpx#, twpz#, nextclyr, tnextwpx#, tnextwpz#)
       inc tradangle,22
       if tradangle>360 
        tradangle=0 : inc tradius
       endif
      endwhile
      if result<>0
       exit prompt "AI gate inside obstacle F="+str$(wpx#)+","+str$(wpz#)+" T="+str$(nextwpx#)+","+str$(nextwpz#)+" N="+str$(tdirectionx#)+","+str$(tdirectionz#),"w:"+str$(w)+" result="+str$(result)
       end
      endif
     endif
    endif
   next wpci
  endif
 next w
 `
 rem Create regular AI waypoints (path index matches waypoint index)
 for w=1 to waypointmax
  if waypoint(w).count>0
   AI Make Path w
   for wpci=waypoint(w).start to waypoint(w).finish
    wpx#=waypointcoord(wpci).x
    wpy#=waypointcoord(wpci).y : clyr=(wpy#+5)/100
    wpz#=waypointcoord(wpci).z
    AI Path Add Point w,wpx#,wpz#
   next wpxi
  endif
 next w
 `
return

_aiss_zones:
 `
 rem Record ALL safe zones stored as level markers
 aisafemax=0
 for e=1 to entityelementlist
  if entityelement(e).active=1
   if lower$(entityelement(e).eleprof.name$)="safe zone"
    inc aisafemax
   endif
  endif
 next e
 dim aisafe(aisafemax) as aisafetype
 aisafemax=0
 for e=1 to entityelementlist
  if entityelement(e).active=1
   if lower$(entityelement(e).eleprof.name$)="safe zone"
    if 0
     rem debug objects
     make object cone 200+lee,25
     xrotate object 200+lee,90
     yrotate object 200+lee,entityelement(e).ry
     position object 200+lee,entityelement(e).x,entityelement(e).y+50,entityelement(e).z
     set object collision off 200+lee
     inc lee
    endif
    inc aisafemax
    aisafe(aisafemax).x=entityelement(e).x
    aisafe(aisafemax).y=entityelement(e).y
    aisafe(aisafemax).z=entityelement(e).z
    aisafe(aisafemax).ry=entityelement(e).ry
   endif
  endif
 next e
 `
return

_aiss_setwaypointpaths:
 `
 rem Ensure we pick this cloest waypoint to entity
 waypointindexclosest#=99999
 `
 rem Look for waypoint coordinate closest to SXYZ#, takes E
 waypointindex=0
 for w=1 to waypointmax
  if waypoint(w).count>0
   for wpci=waypoint(w).start to waypoint(w).finish
    wpx#=waypointcoord(wpci).x
    wpy#=waypointcoord(wpci).y
    wpz#=waypointcoord(wpci).z
    dx#=wpx#-sx#
    dy#=wpy#-sy#
    dz#=wpz#-sz#
    dd#=sqrt(abs(dx#*dx#)+abs(dy#*dy#)+abs(dz#*dz#))
    if dd#<entityelement(e).eleprof.ex.maxrange
     if dd#<waypointindexclosest#
      waypointindexclosest#=dd#
      waypointindex=w
     endif
    endif
   next wpci
  endif
 next w
 `
 rem And then assign that waypoint path to the AI entity
 if waypointindex>0
  rem assign this waypoint to entity
  if entityelement(e).eleprof.aiss.savedpatrolpoint>0
   AI Entity Assign Patrol Path aiobjid,waypointindex,entityelement(e).eleprof.aiss.savedpatrolpoint
   entityelement(e).eleprof.aiss.savedpatrolpoint=0
  else
   AI Entity Assign Patrol Path aiobjid,waypointindex  
  endif
 else
  rem no waypoints in range, so make entity stay put
  AI Set Entity Active aiobjid,0
  AI Entity Hold Position aiobjid
 endif
 `
return

_aiss_gotosafeposition:
 `
 rem Find a safe position within range of E
 aisafesel=0 : trange#=1000
 aisafeselseconds=0
 if AI Entity Exist(aiobjid)=1
  currentcontainer=AI Get Entity Container(aiobjid)
  closestdd#=trange#+1
  for aisafei=1 to aisafemax
   dcontainer=(aisafe(aisafei).y+5)/100
   if dcontainer=currentcontainer
    dx#=aisafe(aisafei).x-object position x(aiobjid)
    dz#=aisafe(aisafei).z-object position z(aiobjid)
    dd#=sqrt(abs(dx#*dx#)+abs(dz#*dz#))
    if dd#<trange#
     rem choose closest
     if closestdd#>dd#
      rem check if occupied slot still occupied
      if aisafe(aisafei).occupied>0
       toccupiercankeepspot=0
       aiobjid2=aisafe(aisafei).occupied
       if object exist(aiobjid2)=1
        if AI Entity Exist(aiobjid2)=1
         dx2#=aisafe(aisafei).x-object position x(aiobjid2)
         dz2#=aisafe(aisafei).z-object position z(aiobjid2)
         dd2#=sqrt(abs(dx#*dx#)+abs(dz#*dz#))
         if dd2#<100
          rem occupier gets to keep slot
          toccupiercankeepspot=1
         endif
        endif
       endif
       if toccupiercankeepspot=0
        rem free spot for re-use, it is now vacant
        aisafe(aisafei).occupied=0
       endif
      endif
      rem and only if no-one on the spot
      if aisafe(aisafei).occupied=0
       rem occupy spot with this AI entity
       closestdd#=dd#
       aisafesel=aisafei
      else
       rem if no spots left, chose closest even if occupied
       aisafeselseconds=aisafei
      endif
     endif
    endif
   endif
  next aisafei
 endif
 rem For now, if no slot available, switch to aggressive!
 if aisafesel>0
  rem register interest in this free spot
  if aisafe(aisafesel).occupied=0
   aisafe(aisafesel).occupied=aiobjid
  endif
  rem move to new idle position
  AI Set Entity Idle Position aiobjid,aisafe(aisafesel).x,aisafe(aisafesel).z,(aisafe(aisafesel).y+5)/100
  AI Entity Go To Position aiobjid,aisafe(aisafesel).x,aisafe(aisafesel).z,(aisafe(aisafesel).y+5)/100
  AI Set Entity Control aiobjid,0
  if entityelement(e).eleprof.ex.alignment=0
   rem neutral holds position
   AI Entity Hold Position aiobjid
  else
   rem enemy and ally alert action
   entityelement(e).eleprof.aiss.actionmode=102 : entityelement(e).eleprof.aiss.actioncount=0
  endif
 else
  rem no safe opsition to head for
 `if aisafesel=0 then aisafesel=aisafeselseconds
  if entityelement(e).eleprof.ex.alignment=0
   rem switch to independent stationary position
   AI Set Entity Active aiobjid,0
   AI Entity Hold Position aiobjid
  else
   rem switch to independent aggressive if enemy or ally
   AI Set Entity Stance aiobjid,1
   entityelement(e).eleprof.aiss.actionmode=1
  endif
 endif
 `
return

_aiss_createaientity:
 `
 rem If already existing, recreate by deleting old
 if AI Entity Exist(aiobjid)=1
  AI Kill Entity aiobjid
 endif
 `
 rem Create the Ai entity for aiobjid and e
 yrotate object aiobjid,180
 select entityelement(e).eleprof.ex.alignment
  case 0 : AI Add Neutral aiobjid,0 : endcase
  case 1 : AI Add Enemy aiobjid,0 : endcase
  case 2 : AI Add Friendly aiobjid,0 : endcase
 endselect
 AI Set Entity Control aiobjid,0
 AI Set Entity Position aiobjid,object position x(aiobjid),object position y(aiobjid),object position z(aiobjid)
 AI Set Entity Idle Position aiobjid,object position x(aiobjid),object position z(aiobjid),(object position y(aiobjid)+5)/100
 AI Entity Look At Position aiobjid,newxvalue(object position x(aiobjid),entityelement(e).ry,50.0),newzvalue(object position z(aiobjid),entityelement(e).ry,50.0)
 AI Set Entity View Arc aiobjid,entityelement(e).eleprof.coneangle,entityelement(e).eleprof.coneangle
 AI Set Entity Height aiobjid,entityelement(e).eleprof.coneheight
 AI Set Entity Turn Speed aiobjid,entityelement(e).eleprof.speed*2
 AI Set Entity Speed aiobjid,entityelement(e).eleprof.speed
 AI Set Entity Angle Y aiobjid,entityelement(e).ry
 rem X10 entities with no weapon must have point-blank distance (for melee attack)
 if entityelement(e).eleprof.hasweapon=0
  rem this is not canfire range, just the distance at which the entity distances itself
  AI Set Entity Attack Distance aiobjid,20
  AI Set Entity Defend Distance aiobjid,20
  AI SET ENTITY MELEE MODE aiobjid,1
  AI Set Entity Avoid Distance aiobjid,0
 else
  AI Set Entity Attack Distance aiobjid,entityelement(e).eleprof.ex.attackrange
  AI Set Entity Defend Distance aiobjid,entityelement(e).eleprof.ex.attackrange
  AI SET ENTITY MELEE MODE aiobjid,0
  rem if weapon is flak, we need avoid distance
  tgunid=entityelement(e).eleprof.hasweapon
  if gun(tgunid).settings.flakindex<>0
   AI Set Entity Avoid Distance aiobjid,entityelement(e).eleprof.ex.attackrange
  else
   AI Set Entity Avoid Distance aiobjid,0
  endif
 endif
 AI Set Entity View Range aiobjid,entityelement(e).eleprof.ex.viewrange
 AI Set Entity Hearing Range aiobjid,entityelement(e).eleprof.ex.maxrange
 rem X10 neutrals cannot hear a bean, they always use waypoints and visual only 
 if entityelement(e).eleprof.ex.alignment=0
  rem neutrals cannot hear and do not bother with the avoidance grid
  AI Set Entity Can Hear aiobjid,0
  AI SET ENTITY AVOID MODE aiobjid,1
 else
  AI Set Entity Can Hear aiobjid,entityelement(e).eleprof.ex.canhear
 endif
 AI Set Entity Can Duck aiobjid,entityelement(e).eleprof.ex.canduck
 AI Set Entity Can Strafe aiobjid,entityelement(e).eleprof.ex.canstrafe 
 AI Set Entity Radius aiobjid,aissentityradius
 AI Set Entity Active aiobjid,1
 AI Set Entity Stance aiobjid,0
 if entityelement(e).eleprof.ex.alignment=1
  rem enemy
 else
  if entityelement(e).eleprof.ex.alignment=2
   rem friend must hold position by default
   if entityelement(e).eleprof.ex.initmode=0
    rem inactive while ally waits for player
    AI Set Entity Active aiobjid,0
    entityelement(e).eleprof.ex.initmode=6
   endif
  else
   rem neutral
   AI Set Entity Patrol Time aiobjid,-0.5
   if entityelement(e).eleprof.ex.initmode=0
    rem default behaviour is follow waypoint
    entityelement(e).eleprof.ex.initmode=4
   endif
  endif
 endif
 tnewcontainer=(object position y(aiobjid)+5)/100
 if tnewcontainer<0 then tnewcontainer=0
 if tnewcontainer>19 then tnewcontainer=19
 AI Set Entity Container aiobjid,tnewcontainer
 AI Set Entity Control aiobjid,1
 `
return

_aiss_destroyaientity:
 `
 rem kill the entity in the AI using E
 if gaiactive=1
  aiobjid=entityobjectoffset+e
  if AI Entity Exist(aiobjid)=1
   AI Kill Entity aiobjid
  endif
 endif
 `
return

_aiss_prepareentities:
 `
 rem go through entities and setup AI for all dynamic characters
 for e=1 to entityelementlist
  if entityelement(e).bankindex>0
   `
   rem V109 - 040708 - only DarkAI.FPI should use DarkAI
   tshoulduseAI=0
   if lower$(right$(entityelement(e).eleprof.aimain$,10))="darkai.fpi" then tshoulduseAI=1
   `
   rem X10 - V109 - 170309 - only spawn children, not invisible spawn leader parent!
   rem and only those entities that spawn at the very start (not triggered)
   rem V110 - 150110 - allow both ATSTART and LATERTRIGGERED to be created (needed for saveload prep of entities)
   `if tshoulduseAI=1
   `if tshoulduseAI=1 and entityelement(e).spawn.leader=0 and entityelement(e).spawn.atstart=1
   if tshoulduseAI=1 and entityelement(e).spawn.leader=0
    if entityelement(e).staticflag=0 and entityprofile(entityelement(e).bankindex).ischaracter=1
     aiobjid=entityobjectoffset+e
     if object exist(aiobjid)=1
      gosub _aiss_createaientity
      if prepareentitiesmode=1
       rem X10 - 131007 - means been called from save position, do not fire init action!
      else
       entityelement(e).eleprof.aiss.actionmode=entityelement(e).eleprof.ex.initmode
      endif
     endif
    endif
   endif
  endif
 next e
 `
return

_aiss_fpi_getconditionvalue:
 `
 rem Handle action logic of AI entity (aiobjidvalue in and out)
 rem 0 : ISDARKAISEEING
 rem 1 : ISDARKAIHURT
 rem 2 : ISDARKAIFIRING
 aiobjid=entityobjectoffset+e
 if AI Entity Exist(aiobjid)=1
  select aiobjidvalue
   case 0 :
    targetx# = AI Get Entity Target X(aiobjid)
    targety# = object position y(aiobjid)+30
    targetz# = AI Get Entity Target Z(aiobjid)
    if AI Get Entity Can See(aiobjid,targetx#,targety#,targetz#,1)<>0
     aiobjidvalue=1
    else
     aiobjidvalue=0
    endif
   endcase
   case 1 :
    if entityelement(e).health<entityelement(e).eleprof.ex.hurtvalue
     aiobjidvalue=1
    else
     aiobjidvalue=0
    endif
   endcase
   case 2 :
    if AI Get Entity Can Fire(aiobjid)=1
     aiobjidvalue=1
    else
     aiobjidvalue=0
    endif
   endcase
  endselect
 else
  aiobjidvalue=0
 endif
 `
return

_aiss_fpi_doaction:
 `
 rem aiobjidaction and aiobjidvalue
 rem 0 : DODARKAI (0-init, 1-see, 2-trig, 3-hurt, 4-pauseforgunreload, 5-resumefrompause)
 rem 1 : DODARKAIANIM
 aiobjid=entityobjectoffset+e
 if 1 : rem some entities start off inactive AI Entity Exist(aiobjid)=1
  select aiobjidaction
   case 0 :
    if entityelement(e).eleprof.aiss.actionmode=51
     rem set action of AI entity when paused (resume only)
     if aiobjidvalue=5
      entityelement(e).eleprof.aiss.actionmode=52
      entityelement(e).eleprof.aiss.stateresting=4 : rem ensure old anim resumes too
     endif
    else
     rem set action of AI entity (only 0(noaction) or 6(waiting for player) can be overridden with new action)
     if entityelement(e).eleprof.aiss.actionmode=0 or entityelement(e).eleprof.aiss.actionmode=6
      if aiobjidvalue=0
       entityelement(e).eleprof.aiss.actionmode=entityelement(e).eleprof.ex.initmode
       entityelement(e).eleprof.ex.initmode=0
      endif
      if aiobjidvalue=1
       entityelement(e).eleprof.aiss.actionmode=entityelement(e).eleprof.ex.seemode
       entityelement(e).eleprof.ex.seemode=0
      endif
      if aiobjidvalue=2
       entityelement(e).eleprof.aiss.actionmode=entityelement(e).eleprof.ex.trigmode
       entityelement(e).eleprof.ex.trigmode=0
       AI Set Entity Active aiobjid,1
      endif
      if aiobjidvalue=3
       entityelement(e).eleprof.aiss.actionmode=entityelement(e).eleprof.ex.hurtmode
       entityelement(e).eleprof.ex.hurtmode=0
       AI Set Entity Active aiobjid,1
      endif
      if aiobjidvalue=4
       entityelement(e).eleprof.aiss.actionmode=51       
      endif
     endif
    endif
   endcase
   case 1 :
    rem handle animation of entity from state of AI entity
    rem Gather values from AI, and only initiate new animation if values
    rem have remained unchanged for X frames (reduces glitches caused by rapid state toggles)
    if AI Entity Exist(aiobjid)=1
     tproceedtoanimatecharacter=0
     rem create bitfields based on states
     rem TB1 (0-7) TB2 (8) TB3 (16)
     `120807 - it is the visual angle we must use to modify the animation set
     `tb1=(wrapvalue(atanfull(AI Get Entity Move X(aiobjid),AI Get Entity Move Z(aiobjid)))/45.0)
     tb1=wrapvalue(object angle y(aiobjid))/45.0
     tb2=AI Get Entity Is Ducking(aiobjid)<<3
     tb3=AI Get Entity Is Moving(aiobjid)<<4
     tnewstate=tb1+tb2+tb3    
     if tnewstate<>entityelement(e).eleprof.aiss.lastanimstate
      rem states have remained this way long enough, animate character based on states
      entityelement(e).eleprof.aiss.lastanimstate=tnewstate
      entityelement(e).eleprof.aiss.stateresting=0
     else
      rem if this anim state remains for more than X calls, go with new animation!
      if entityelement(e).eleprof.aiss.stateresting<2
       entityelement(e).eleprof.aiss.stateresting=entityelement(e).eleprof.aiss.stateresting+1
       if entityelement(e).eleprof.aiss.stateresting=2
        rem after X cycles in same state, trigger animation change
        tproceedtoanimatecharacter=1
       endif
      endif
     endif
     rem MOVEMENT angle (not in DarkAI)
     tmovementdst#=abs(AI Get Entity Move X(aiobjid))+abs(AI Get Entity Move Z(aiobjid))
     if tmovementdst#<0.01
      moveangle#=AI Get Entity Angle Y(aiobjid)
     else
      moveangle#=wrapvalue(atanfull(AI Get Entity Move X(aiobjid),AI Get Entity Move Z(aiobjid)))
     endif
     rem ANIMATE based on AI state
     if tproceedtoanimatecharacter=1
      tmpframe1=entityelement(e).animdo
      tmpframedirection=0
      if AI Get Entity Is Ducking(aiobjid)=1
       if AI Get Entity Is Moving(aiobjid)=1
        rem crawl
        tmpframe2=32
       else
        rem crouch
        tmpframe2=31
       endif
      else
       if AI Get Entity Is Moving(aiobjid)=1
        viewangle#=wrapvalue(AI Get Entity Angle Y(aiobjid))
        diffangle#=moveangle#-viewangle# : aiconda#=diffangle#
        if aiconda#>180 then aiconda#=360-aiconda#
        if aiconda#<-180 then aiconda#=aiconda#+360
        if aiconda#<-120.0 or aiconda#>120.0
         rem backwards
         tmpframe2=2
         tmpframedirection=1
        else
         rem strafe
         if aiconda#>80.0 and tmovementdst#>1.0
          tmpframe2=4
         else
          if aiconda#<-80.0 and tmovementdst#>1.0
           tmpframe2=3
          else
           if 0 : rem AI Get Entity Is Running(aiobjid)=1
            rem forward run
            tmpframe2=5
           else
            rem forward walk
            tmpframe2=2
           endif
          endif
         endif
        endif
       else
        rem idle
        tmpframe2=1
       endif
      endif
      if tmpframe1<>tmpframe2 or entityelement(e).animdir<>tmpframedirection
       entityelement(e).animset=1+tmpframe2
       entityelement(e).destanimframe=0
       entityelement(e).animframe=0
       entityelement(e).animtime=0
       entityelement(e).animdir=tmpframedirection
      endif
     endif
     `
     rem X10 240907 - monitor - if MOVING and using an idle anim, change it immediately!!
     if AI Get Entity Is Moving(aiobjid)=1
      rem moving and entity anim is IDLE or RELOAD (081107 - or MELEE)
      if entityelement(e).animset=2 or entityelement(e).animdo=1 or entityelement(e).animdo=6 or entityelement(e).animdo=7 or entityelement(e).animdo=8
`      if entityelement(e).animset=2 or entityelement(e).animdo=1
       rem to prevent sliding characters
       tmpframe2=2 : rem forward walk placeholder
       entityelement(e).animset=1+tmpframe2
       entityelement(e).destanimframe=0
       entityelement(e).animframe=0
       entityelement(e).animtime=0
      endif
     endif
     `
     rem Also place entity based on AI entity position
     entityelement(e).x = AI Get Entity X(aiobjid)
     entityelement(e).z = AI Get Entity Z(aiobjid)
     `
     rem angle of entity based on AI
     entityelement(e).mover.da = curveangle(AI Get Entity Angle Y(aiobjid),entityelement(e).mover.da,3.0)
     `
     rem find floor for this entity (does not use physics - too jittery)
     if AI GET ENTITY CHANGING CONTAINERS(aiobjid)<>0
      tmvszy#=(object size y(aiobjid)/2)
      tfloorstarty#=entityelement(e).y+20
      `tfloory#=static raycast(entityelement(e).x,tfloorstarty#,entityelement(e).z,entityelement(e).x,tfloorstarty#-30,entityelement(e).z)
      `if tfloory#>0 ` entityelement(e).y = tfloorstarty#-tfloory#
      tfloory#=AI RAY CAST(entityelement(e).x,tfloorstarty#,entityelement(e).z,entityelement(e).x,tfloorstarty#-30,entityelement(e).z)
      if tfloory#<>-1
       rem floor contours of floor instantly (step size above)
       entityelement(e).y = tfloorstarty#-(tfloory#*30.0)
      else
       rem artificial gravity to decent ramps and staircases
       toldcontainer=(entityelement(e).y+5)/100
       entityelement(e).y = entityelement(e).y - 8
       rem if fall creates a container transition, do it
       tnewcontainer=(entityelement(e).y+5)/100
       if tnewcontainer<>toldcontainer
        rem entity has dropped into new container
        if tnewcontainer<0 then tnewcontainer=0
        if tnewcontainer>19 then tnewcontainer=19    
        AI Set Entity Container aiobjid,tnewcontainer
       endif
      endif
      AI Set Entity Y Position aiobjid,entityelement(e).y
     endif
     `
    endif
   endcase
  endselect
  `
 endif
 `
return

_aiss_gettargetforshooting:
 `
 rem get targetID from entity about to fire, takes E
 targetID=0
 if object exist(obj)=1
  aiobjid=obj
  if AI Entity Exist(aiobjid)=1
   targetID = AI Get Entity Target ID(aiobjid,1)
  endif
 endif
 if targetID>65535
  rem a bug causes above command to return a HUGE value
  targetID=0
 endif
 `
return

_aiss_handleactions:
 `
 rem Handle action logic of AI entity
 if object exist(aiobjid)=1
  if entityelement(e).eleprof.aiss.actionmode>0
   `
   rem INSTANT ATTACK
   if entityelement(e).eleprof.aiss.actionmode=1
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    if AI Get Entity Following(aiobjid)=0
     rem X10 231007 - only if NOT following at the time!
     AI Set Entity Stance aiobjid,1
    endif
    entityelement(e).eleprof.aiss.actionmode=0
   endif
   `
   rem 2:FIND COVER and 102:WHEN REACH COVER, DEFENSIVE
   if entityelement(e).eleprof.aiss.actionmode=2
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    gosub _aiss_gotosafeposition
   endif
   if entityelement(e).eleprof.aiss.actionmode=102
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    targetx#=AI Get Entity Destination X(aiobjid)
    targetz#=AI Get Entity Destination Z(aiobjid)
    dx#=targetx#-object position x(aiobjid)
    dz#=targetz#-object position z(aiobjid)
    dst#=sqrt(abs(dx#*dx#)+abs(dz#*dz#))
    if dst#<30
     rem STAND AND SHOOT
     AI Set Entity Control aiobjid,1
     AI Set Entity Stance aiobjid,2
     entityelement(e).eleprof.aiss.actionmode=0
    else
     if dst#<80
      entityelement(e).eleprof.aiss.actioncount=entityelement(e).eleprof.aiss.actioncount+1
     endif
     if entityelement(e).eleprof.aiss.actioncount>100
      rem FIND A NEW SAFE SPOT
      gosub _aiss_gotosafeposition
     endif
    endif
   endif
   `
   rem 3: PATROL AREA
   if entityelement(e).eleprof.aiss.actionmode=3
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    rem V110 - 140110 - never had a patrol area which should be random positions   
    remstart
    if AI Get Entity Following(aiobjid)=0
     rem X10 231007 - only if NOT following at the time!
     AI Set Entity Stance aiobjid,0
    endif
    entityelement(e).eleprof.aiss.actionmode=0
    remend
    tpatrolareacode=1
    if tpatrolareacode=1
     if entityelement(e).eleprof.ex.alignment=0
      rem neutral characters do not use PATROL AREA
      AI Set Entity Stance aiobjid,0
      entityelement(e).eleprof.aiss.actionmode=0
     else
      rem not for neutral characters, only enemies and friends
      if rnd(250)=1
       rem Random look position
       tdir=rnd(360)
       tnewroamposx#=newxvalue(entityelement(e).eleprof.startx,tdir,entityelement(e).eleprof.ex.maxrange)
       tnewroamposy#=object position y(aiobjid)+30
       tnewroamposz#=newzvalue(entityelement(e).eleprof.startz,tdir,entityelement(e).eleprof.ex.maxrange)
       AI Entity Look At Position aiobjid,tnewroamposx#,tnewroamposz#
       rem Random new idle position
       tdir=rnd(360)
       tnewroamposx#=newxvalue(entityelement(e).eleprof.startx,tdir,entityelement(e).eleprof.ex.maxrange)
       tnewroamposz#=newzvalue(entityelement(e).eleprof.startz,tdir,entityelement(e).eleprof.ex.maxrange)
       AI Set Entity Idle Position aiobjid,tnewroamposx#,tnewroamposz#,tnewroamposy#
       AI Entity Go To Position aiobjid,tnewroamposx#,tnewroamposz#,tnewroamposy#
       AI Set Entity Control aiobjid,0
       AI Set Entity Stance aiobjid,0
      endif    
      rem V110 - 140110 - if enemy 'sees' target, switch off patrol area
      if entityelement(e).eleprof.ex.alignment=1
       if AI Get Entity Can Fire(aiobjid)=1
        AI Set Entity Control aiobjid,1
        AI Set Entity Stance aiobjid,0
        entityelement(e).eleprof.aiss.actionmode=0
       endif
      endif
     endif
    endif
   endif
   `
   rem 4: FOLLOW WAYPOINT
   if entityelement(e).eleprof.aiss.actionmode=4
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    sx#=object position x(aiobjid)
    sy#=object position y(aiobjid)
    sz#=object position z(aiobjid)
    gosub _aiss_setwaypointpaths
    entityelement(e).eleprof.aiss.actionmode=0
   endif
   `
   rem res
   if entityelement(e).eleprof.aiss.actionmode=5
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    entityelement(e).eleprof.aiss.actionmode=0
   endif
   `
   rem FOLLOW PLAYER or WAIT UNTIL PLAYER IN RANGE, THEN FOLLOW
   if entityelement(e).eleprof.aiss.actionmode=6
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    targetx#=camera position x(playercam)
    targety#=camera position y(playercam)
    targetz#=camera position z(playercam)
    dx#=targetx#-object position x(aiobjid)
    dy#=targety#-object position y(aiobjid)
    dz#=targetz#-object position z(aiobjid)
    dst#=sqrt(abs(dx#*dx#)+abs(dy#*dy#)+abs(dz#*dz#))
    if dst#<entityelement(e).eleprof.ex.attackrange
     rem CLOSE ENOUGH TO ACTIVATE AND JOIN PLAYER
     AI Set Entity Active aiobjid,1
     entityelement(e).eleprof.aiss.actionmode=106
    endif
   endif
   if entityelement(e).eleprof.aiss.actionmode=106
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    AI Entity Follow Player aiobjid,150
    entityelement(e).eleprof.aiss.actionmode=0
   endif
   `
   rem STAND GROUND (reached edge of maxrange) 
   if entityelement(e).eleprof.aiss.actionmode=7
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    targetx# = AI Get Entity Target X(aiobjid)
    targety# = object position y(aiobjid)+30
    targetz# = AI Get Entity Target Z(aiobjid)
    tdx#=targetx#-entityelement(e).eleprof.startx
    tdy#=targety#-entityelement(e).eleprof.starty
    tdz#=targetz#-entityelement(e).eleprof.startz
    tdist#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
    if tdist#>entityelement(e).eleprof.ex.maxrange
     rem 210807 - only if target is outside of characters own maxrange
     if AI Get Entity Following(aiobjid)=0
      rem X10 231007 - only if NOT following at the time!
      AI Set Entity Stance aiobjid,2
     endif
    else
     rem otherwise character can chase into their maxrange even 
     rem if the action has been triggered from being outside maxrange
     tdx#=entityelement(e).x-entityelement(e).eleprof.startx
     tdy#=entityelement(e).y-entityelement(e).eleprof.starty
     tdz#=entityelement(e).z-entityelement(e).eleprof.startz
     tdist#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     if tdist#>=entityelement(e).eleprof.ex.maxrange
      rem and should go aggresive if outside own range, and target inside range!
      if AI Get Entity Following(aiobjid)=0
       rem X10 231007 - only if NOT following at the time!
       AI Set Entity Stance aiobjid,1
      endif
     endif
    endif
    entityelement(e).eleprof.aiss.actionmode=0
   endif
   `
   rem PAUSE ALL AI (for gun reload)
   if entityelement(e).eleprof.aiss.actionmode=51
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    AI Set Entity Active aiobjid,0
   endif
   `
   rem RESUME FROM PAUSE (for gun reload)
   if entityelement(e).eleprof.aiss.actionmode=52
    entityelement(e).eleprof.aiss.lastactionmode=entityelement(e).eleprof.aiss.actionmode
    AI Set Entity Active aiobjid,1
    entityelement(e).eleprof.aiss.actionmode=0
   endif
   `
   `
  endif
 endif
 `
return

_aiss_debugview:
 `
 `if mouseclick()=3 or createdebuginfo=1
 if 0 : rem X10 - 270907 - discontinued for final phase betas
  while mouseclick()=3 : endwhile
  createdebuginfo=0
  triggerinzoneoneoff=11
  if debugview=0
   rem Debug On
   `AI Set Console Output On physicsuniverseobj
   for layer=0 to 19
    AI Debug Show Obstacle Bounds layer,6+(layer*100)
    `AI Debug Show Waypoints layer,15+(layer*100)
   next layer
   if 0
    layer=camera position y(playercam)/100.0
    if layer<0 then layer=0
    if layer>19 then layer=19
    AI DEBUG SHOW AVOIDANCE GRID layer,15+(layer*100)
   endif
   `AI Debug Show Paths 115
   debugview=1
  else
   rem Debug Off
   `set static objects wireframe off
   for layer=0 to 19
    AI Debug Hide Obstacle Bounds layer
    `AI Debug Hide Waypoints layer
    AI DEBUG HIDE AVOIDANCE GRID layer
   next layer
   `AI Debug Hide Paths
   `AI Debug Hide Sounds
   `AI Debug Hide View Arcs
   debugview=0
  endif
 endif
 `if debugview=1
 ` AI Debug Show Sounds camera position y(playercam)-50
 `endif
 `
return

_aiss_playercontrol:
 `
 rem team commands (V110 - 140110 - use scancode for case insensitive)
 if scancode()=33
 `if inkey$()="f"
  for e=1 to entityelementlist
   if entityelement(e).bankindex>0 and entityelement(e).staticflag=0
    aiobjid=entityobjectoffset+e
    if object exist(aiobjid)=1
     if entityelement(e).eleprof.ex.alignment=2
      if AI Entity Exist(aiobjid)=1
       rem V110 - 140110 - need to break MANUAL APTROL AREA code
       if entityelement(e).eleprof.aiss.actionmode=3
        AI Set Entity Control aiobjid,1
        entityelement(e).eleprof.aiss.actionmode=0
       endif
       if entityelement(e).eleprof.aiss.thinkingprompt<>1
        entityelement(e).eleprof.aiss.thinkingprompt=1
        entityelement(e).eleprof.aiss.thinkingcount=50
        AI Set Entity Stance aiobjid,1
        AI Entity Follow Player aiobjid,150
        `
        rem X10 - 231007 - when set allies to follow, wipe out IFSEE condition
        rem as this wills et themto aggressive and they will NOT follow plr
        entityelement(e).eleprof.ex.seemode=0
        entityelement(e).eleprof.ex.trigmode=0
        `
       endif
      endif
     endif
    endif
   endif
  next e
  AI Team Follow Player 150.0 : rem 150807 - no need for team separate, follow and hold change the team state!
 endif
 if scancode()=34
 `if inkey$()="g"
  for e=1 to entityelementlist
   if entityelement(e).bankindex>0 and entityelement(e).staticflag=0
    aiobjid=entityobjectoffset+e
    if object exist(aiobjid)=1
     if entityelement(e).eleprof.ex.alignment=2
      if AI Entity Exist(aiobjid)=1
       rem V110 - 140110 - need to break MANUAL APTROL AREA code
       if entityelement(e).eleprof.aiss.actionmode=3
        AI Set Entity Control aiobjid,1
        entityelement(e).eleprof.aiss.actionmode=0
       endif
       if entityelement(e).eleprof.aiss.thinkingprompt<>2
        entityelement(e).eleprof.aiss.thinkingprompt=2
        entityelement(e).eleprof.aiss.thinkingcount=50
        AI Set Entity Stance aiobjid,1
       endif
      endif
     endif
    endif
   endif
  next e
 endif
 if scancode()=35
 `if inkey$()="h"
  for e=1 to entityelementlist
   if entityelement(e).bankindex>0 and entityelement(e).staticflag=0
    aiobjid=entityobjectoffset+e
    if object exist(aiobjid)=1
     if entityelement(e).eleprof.ex.alignment=2
      if AI Entity Exist(aiobjid)=1
       rem V110 - 140110 - need to break MANUAL APTROL AREA code
       if entityelement(e).eleprof.aiss.actionmode=3
        AI Set Entity Control aiobjid,1
        entityelement(e).eleprof.aiss.actionmode=0
       endif
       if entityelement(e).eleprof.aiss.thinkingprompt<>3
        entityelement(e).eleprof.aiss.thinkingprompt=3
        entityelement(e).eleprof.aiss.thinkingcount=50
        AI ENTITY HOLD POSITION aiobjid
        AI Set Entity Idle Position aiobjid,object position x(aiobjid),object position z(aiobjid),(object position y(aiobjid)+5)/100
        AI Set Entity Stance aiobjid,2
       endif
      endif
     endif
    endif
   endif
  next e
 endif
 `
 rem player ducking and position
 tcamx#=camera position x(playercam)
 if crouchmode=1
  tcamy#=camera position y(playercam)-20
 else
  tcamy#=camera position y(playercam)-40
 endif
 tcamz#=camera position z(playercam)
 `
 rem 250907 - Location of player based on if alive or not
 if player(1).health>0
  rem player in world - enemies bate!
  AI Set Player Position tcamx#,tcamy#,tcamz#
  AI Set Player Ducking crouchmode
 else
  rem player is heaven - out of reach of enemies
  gosub _aiss_playerisheaven
 endif
 `
return

_aiss_playerisheaven:
 `
 rem player is heaven - out of reach of enemies
 AI Set Player Position 0,150000,0
 AI Set Player Ducking 0
 `
return

_aiss_control:
 `
 rem Player container location
 playercontainer=(camera position y(playercam)-30)/100
 if playercontainer<0 then playercontainer=0
 if playercontainer>19 then playercontainer=19
 AI Set Player Container playercontainer

 rem go through all ai entities
 for e=1 to entityelementlist
  rem if exists and activated
  aiobjid=entityobjectoffset+e
  if AI Entity Exist(aiobjid)=1 and entityelement(e).health>0
   `
   rem Built-in logic for AI
   rem X10 - 210807 - when control anim, also check overall distance from
   rem origin, and if greater than maxrange of entity, then go back to the start position 
   if entityelement(e).eleprof.ex.alignment=0 or entityelement(e).eleprof.ex.alignment=1
    rem (only for enemies and neutrals)
    if entityelement(e).eleprof.aiss.lastactionmode<>4
     rem if following a waypoint as last action, don't interupt it
     tdx#=entityelement(e).x-entityelement(e).eleprof.startx
     tdy#=entityelement(e).y-entityelement(e).eleprof.starty
     tdz#=entityelement(e).z-entityelement(e).eleprof.startz
     tdist#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     if tdist#>entityelement(e).eleprof.ex.maxrange
      if entityelement(e).eleprof.aiss.actionmode=0
       entityelement(e).eleprof.aiss.actionmode=7
      endif
     endif
    endif
   endif
   `
   rem Call AI action logic
   gosub _aiss_handleactions
   `
   rem Debug string feedback
   if object in screen(aiobjid)=1
    t$=str$(aiobjid)+"("+str$(entityelement(e).eleprof.aiss.actionmode)+") "+AI Get Entity State$(aiobjid)+" "+str$(AI Get Entity Target ID(aiobjid,1))+" H:"+str$(entityelement(e).health)
    rem V109 - remove debug here so we can view old script behaviour
`    entitydebug$(e)=t$
   endif
   `
   rem redundant?
   if entityelement(e).eleprof.aiss.shootTimer>0
    entityelement(e).eleprof.aiss.shootTimer=entityelement(e).eleprof.aiss.shootTimer-1
   endif
   `
  endif
 next e
 `
 rem Debug view (optional)
 gosub _aiss_debugview
 `
return

rem
rem ENTITIES DATA (shared by X9 and X10)
rem

_entity_loaddata:

rem Blank entity desc
entityprofileheader(entid).desc$=""

rem Ensure entity profile still exists
tprofile$=left$(entdir$+ent$,len(entdir$+ent$)-4)+".bin"
tprofile$=turnfilenameuserlocal(tprofile$)
if isbinaryfileolderthantxtfile(tprofile$,entdir$+ent$)=1 then delete file tprofile$

rem if profile desc exists
if file exist(entdir$+ent$)=1 or file exist(tprofile$)=1

rem Export entity FPE file if flagged
if gexportassets=1
 tthumbbmpfile$=left$(entdir$+ent$,len(entdir$+ent$)-4)+".bmp"
 addfiletocollection(entdir$+ent$) : addfiletocollection(tthumbbmpfile$)
endif

rem X10 - 021107 - submit BIN file as relative (not absolute which filecollection ignores)
trelativeprofile$=right$(tprofile$,len(tprofile$)-len(myownrootdir$))
addfiletocollection(trelativeprofile$)

rem Check if binary version of entity profile exists (DELETE BIN AT MOMEMENT!)
if file exist(tprofile$)=0
 `
 rem Must be reset before parse
 entityprofile(entid).limbmax=0
 entityprofile(entid).animmax=0
 entityprofile(entid).headlimb=-1
 entityprofile(entid).firespotlimb=-1
 entityprofile(entid).physics=1
 entityprofile(entid).phyweight=100
 entityprofile(entid).phyfriction=0
 `
 rem X10 defaults for new fields
 entityprofile(entid).ex.alignment=1
 entityprofile(entid).ex.initmode=3
 entityprofile(entid).ex.seemode=1
 entityprofile(entid).ex.trigmode=1
 entityprofile(entid).ex.hurtmode=2
 entityprofile(entid).ex.hurtvalue=50
 entityprofile(entid).ex.canstrafe=1
 entityprofile(entid).ex.canduck=1
 entityprofile(entid).ex.canhear=1
 entityprofile(entid).ex.loadedweapon=0
 entityprofile(entid).ex.attackrange=150
 entityprofile(entid).ex.viewrange=500
 entityprofile(entid).ex.maxrange=600
 entityprofile(entid).ex.texturearray=1
 entityprofile(entid).ex.showhealthbar=1
 entityprofile(entid).ex.lungcapacity=500
 entityprofile(entid).ex.glassstyle=0
 entityprofile(entid).ex.score=-1
 entityprofile(entid).ex.showallyicon=1
 entityprofile(entid).ex.factor=1
 entityprofile(entid).ex.impactforce=25
 entityprofile(entid).ex.decaytime=10
 entityprofile(entid).ex.jumpheight=50
 entityprofile(entid).ex.autolodmed=0
 entityprofile(entid).ex.autolodlow=0
 entityprofile(entid).hardscalex=0
 entityprofile(entid).hardscaley=0
 entityprofile(entid).hardscalez=0
 entityprofile(entid).noragdoll=0
 for q=0 to 99 : entityanim(entid,q).speed=1 : next q 
 entityprofile(entid).characterinstancingmode=0
 `
 `X10 additions
 entityprofile(entid).objattachmentmaster=0
 `
 rem Load entity Data from file
 dim data$(400)
 load array entdir$+ent$,data$()
 for l=0 to 399
  line$=data$(l)
  if len(line$)>0
   if left$(line$,1)<>";"
    `
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem entity header
    if field$="desc" then entityprofileheader(entid).desc$=value$
    `
    rem entity AI
    tryfield$="aiinit"
    if field$=tryfield$ then entityprofile(entid).aiinit$=value$
    tryfield$="aimain"
    if field$=tryfield$ then entityprofile(entid).aimain$=value$
    tryfield$="aidestroy"
    if field$=tryfield$ then entityprofile(entid).aidestroy$=value$
    tryfield$="aishoot"
    if field$=tryfield$ then entityprofile(entid).aishoot$=value$
    tryfield$="soundset"
    if field$=tryfield$ then entityprofile(entid).soundset$=value$
    tryfield$="soundset1"
    if field$=tryfield$ then entityprofile(entid).soundset1$=value$
    `
    rem entity DARKAI
    tryfield$="alignment"
    if field$=tryfield$ then entityprofile(entid).ex.alignment=value1
    tryfield$="initmode"
    if field$=tryfield$ then entityprofile(entid).ex.initmode=value1
    tryfield$="seemode"
    if field$=tryfield$ then entityprofile(entid).ex.seemode=value1
    tryfield$="trigmode"
    if field$=tryfield$ then entityprofile(entid).ex.trigmode=value1
    tryfield$="hurtmode"
    if field$=tryfield$ then entityprofile(entid).ex.hurtmode=value1
    tryfield$="hurtvalue"
    if field$=tryfield$ then entityprofile(entid).ex.hurtvalue=value1
    tryfield$="canstrafe"
    if field$=tryfield$ then entityprofile(entid).ex.canstrafe=value1
    tryfield$="canduck"
    if field$=tryfield$ then entityprofile(entid).ex.canduck=value1
    tryfield$="canhear"
    if field$=tryfield$ then entityprofile(entid).ex.canhear=value1
    `
    rem cone of sight
    tryfield$="coneheight"
    if field$=tryfield$ then entityprofile(entid).coneheight=value1
    tryfield$="coneangle"
    if field$=tryfield$ then entityprofile(entid).coneangle=value1
    tryfield$="attackrange"
    if field$=tryfield$ then entityprofile(entid).ex.attackrange=value1
    tryfield$="viewrange"
    if field$=tryfield$ then entityprofile(entid).ex.viewrange=value1
    tryfield$="maxrange"
    if field$=tryfield$ then entityprofile(entid).ex.maxrange=value1
    `
    rem entity AI related vars
    tryfield$="usekey"
    if field$=tryfield$ then entityprofile(entid).usekey$=value$
    tryfield$="ifused"
    if field$=tryfield$ then entityprofile(entid).ifused$=value$
    tryfield$="ifusednear"
    if field$=tryfield$ then entityprofile(entid).ifusednear$=value$
    `
    rem entity SPAWN
    tryfield$="spawnmax"
    if field$=tryfield$ then entityprofile(entid).spawnmax=value1
    tryfield$="spawndelay"
    if field$=tryfield$ then entityprofile(entid).spawndelay=value1
    tryfield$="spawnqty"
    if field$=tryfield$ then entityprofile(entid).spawnqty=value1
    `
    rem entity orientation
    tryfield$="model"
    if field$=tryfield$ then entityprofile(entid).model$=value$
    tryfield$="offx"
    if field$=tryfield$ then entityprofile(entid).offx=value1
    tryfield$="offy"
    if field$=tryfield$ then entityprofile(entid).offy=value1
    tryfield$="offz"
    if field$=tryfield$ then entityprofile(entid).offz=value1
    tryfield$="rotx"
    if field$=tryfield$ then entityprofile(entid).rotx=value1
    tryfield$="roty"
    if field$=tryfield$ then entityprofile(entid).roty=value1
    tryfield$="rotz"
    if field$=tryfield$ then entityprofile(entid).rotz=value1
    tryfield$="scale"
    if field$=tryfield$ then entityprofile(entid).scale=value1
    tryfield$="fixnewy"
    if field$=tryfield$ then entityprofile(entid).fixnewy=value1
    tryfield$="forwardfacing"
    if field$=tryfield$ then entityprofile(entid).forwardfacing=value1
    tryfield$="defaultheight"
    if field$=tryfield$ then entityprofile(entid).defaultheight=value1
    tryfield$="defaultstatic"
    if field$=tryfield$ then entityprofile(entid).defaultstatic=value1
    tryfield$="collisionmode"
    if field$=tryfield$ then entityprofile(entid).collisionmode=value1
    tryfield$="materialindex"
    if field$=tryfield$ then entityprofile(entid).materialindex=value1
    tryfield$="debrisshape"
    if field$=tryfield$ then entityprofile(entid).debrisshapeindex=value1
    `
    rem X10 - 171007 - new hard scale (for physical mesh resize to DBO)
    tryfield$="hardscalex"
    if field$=tryfield$ then entityprofile(entid).hardscalex=value1
    tryfield$="hardscaley"
    if field$=tryfield$ then entityprofile(entid).hardscaley=value1
    tryfield$="hardscalez"
    if field$=tryfield$ then entityprofile(entid).hardscalez=value1    
    rem X10 - 100309 - added NORAGDOLL to entity profile
    tryfield$="noragdoll"
    if field$=tryfield$ then entityprofile(entid).noragdoll=value1    
    `
    rem physics setup
    tryfield$="physics"
    if field$=tryfield$ then entityprofile(entid).physics=value1
    tryfield$="phyweight"
    if field$=tryfield$ then entityprofile(entid).phyweight=value1
    tryfield$="phyfriction"
    if field$=tryfield$ then entityprofile(entid).phyfriction=value1
    tryfield$="explodable"
    if field$=tryfield$ then entityprofile(entid).explodable=value1
    `
    rem visual info
    tryfield$="texturepath"
    if field$=tryfield$ then entityprofile(entid).texpath$=value$
    tryfield$="textured"
    if field$=tryfield$ then entityprofile(entid).texd$=value$
    tryfield$="texturealtd"
    if field$=tryfield$ then entityprofile(entid).texaltd$=value$
    tryfield$="effect"
    if field$=tryfield$ then entityprofile(entid).effect$=value$
    tryfield$="transparency"
    if field$=tryfield$ then entityprofile(entid).transparency=value1
    tryfield$="reducetexture"
    if field$=tryfield$ then entityprofile(entid).reducetexture=value1
    tryfield$="castshadow"
    if field$=tryfield$ then entityprofile(entid).castshadow=value1
    tryfield$="texturearray"
    if field$=tryfield$ then entityprofile(entid).ex.texturearray=value1
    tryfield$="glassstyle"
    if field$=tryfield$ then entityprofile(entid).ex.glassstyle=value1
    tryfield$="autolodmed"
    if field$=tryfield$ then entityprofile(entid).ex.autolodmed=value1
    tryfield$="autolodlow"
    if field$=tryfield$ then entityprofile(entid).ex.autolodlow=value1
    `
    rem entity identity details
    tryfield$="strength"
    if field$=tryfield$ then entityprofile(entid).strength=value1
    tryfield$="lives"
    if field$=tryfield$ then entityprofile(entid).lives=value1
    tryfield$="speed"
    if field$=tryfield$ then entityprofile(entid).speed=value1
    tryfield$="hurtfall"
    if field$=tryfield$ then entityprofile(entid).hurtfall=value1
    tryfield$="lungcapacity"
    if field$=tryfield$ then entityprofile(entid).ex.lungcapacity=value1
    `
    tryfield$="isimmobile"
    if field$=tryfield$ then entityprofile(entid).isimmobile=value1
    tryfield$="isobjective"
    if field$=tryfield$ then entityprofile(entid).isobjective=value1
    `
    tryfield$="ischaracter"
    if field$=tryfield$ then entityprofile(entid).ischaracter=value1
    tryfield$="cantakeweapon"
    if field$=tryfield$ then entityprofile(entid).cantakeweapon=value1
    tryfield$="isweapon"
    if field$=tryfield$ then entityprofile(entid).isweapon$=value$
    tryfield$="isammo"
    if field$=tryfield$ then entityprofile(entid).isammo=value1
    tryfield$="hasweapon"
    if field$=tryfield$ then entityprofile(entid).hasweapon$=value$
    tryfield$="ishealth"
    if field$=tryfield$ then entityprofile(entid).ishealth=value1
    tryfield$="isflak"
    if field$=tryfield$ then entityprofile(entid).isflak=value1
    tryfield$="loadedweapon"
    if field$=tryfield$ then entityprofile(entid).ex.loadedweapon=value1
    `
    rem marker extras
    tryfield$="ismarker"
    if field$=tryfield$ then entityprofile(entid).ismarker=value1
    tryfield$="markerindex"
    if field$=tryfield$ then entityprofile(entid).markerindex=value1
    `
    rem light extras
    tryfield$="lightcolor"
    if field$=tryfield$ then entityprofile(entid).light.color=value1
    tryfield$="lightrange"
    if field$=tryfield$ then entityprofile(entid).light.range=value1
    `
    rem trigger extras
    tryfield$="areax"
    if field$=tryfield$ then entityprofile(entid).trigger.areax1=value1 : entityprofile(entid).trigger.areax2=value2
    tryfield$="areay"
    if field$=tryfield$ then entityprofile(entid).trigger.areay1=value1 : entityprofile(entid).trigger.areay2=value2
    tryfield$="areaz"
    if field$=tryfield$ then entityprofile(entid).trigger.areaz1=value1 : entityprofile(entid).trigger.areaz2=value2
    `
    rem entity body part list
    tryfield$="limbmax"
    if field$=tryfield$ then entityprofile(entid).limbmax=value1
    if entityprofile(entid).limbmax>0
     for q=0 to entityprofile(entid).limbmax-1
      tryfield$="limb"+str$(q)
      if field$=tryfield$
       entitybodypart(entid,q)=value1
       if value1=1
        rem record head seperately too
        entityprofile(entid).headlimb=q
       endif
      endif
     next q
    endif
    `
    rem entity decal refs
    tryfield$="decalmax"
    if field$=tryfield$ then entityprofile(entid).decalmax=value1
    if entityprofile(entid).decalmax>0
     for q=0 to entityprofile(entid).decalmax-1
      tryfield$="decal"+str$(q)
      if field$=tryfield$ then entitydecal$(entid,q)=value$
     next q
    endif
    `
    rem entity animation sets
    tryfield$="animmax"
    if field$=tryfield$ then entityprofile(entid).animmax=value1
    if entityprofile(entid).animmax>0
     for q=0 to entityprofile(entid).animmax-1
      tryfield$="anim"+str$(q)
      if field$=tryfield$ then entityanim(entid,q).start=value1 : entityanim(entid,q).finish=value2
     next q
    endif
    `
    rem entity animation speed sets
    if entityprofile(entid).animmax>0
     for q=0 to entityprofile(entid).animmax-1
      tryfield$="animspeed"+str$(q)
      if field$=tryfield$
       entityanim(entid,q).speed=(value1+0.0)/100.0
      endif
     next q
    endif
    `
    rem more data
    tryfield$="quantity"
    if field$=tryfield$ then entityprofile(entid).quantity=value1
    tryfield$="score"
    if field$=tryfield$ then entityprofile(entid).ex.score=value1
    tryfield$="factor"
    if field$=tryfield$ then entityprofile(entid).ex.factor=value1
    tryfield$="impactforce"
    if field$=tryfield$ then entityprofile(entid).ex.impactforce=value1
    tryfield$="decaytime"
    if field$=tryfield$ then entityprofile(entid).ex.decaytime=value1
    `
   endif
  endif
 next l
 undim data$()
 `
 rem Localisation must change desc to local name
 if entityprofileheader(entid).desc$<>""
  if left$(entityprofileheader(entid).desc$,1)<>"%"
   tflocalfilename$="languagebank\"+language$+"\textfiles\library\"+entdir$+ent$
   tflocalfilename$=left$(tflocalfilename$,len(tflocalfilename$)-4)+".loc"
   if file exist(tflocalfilename$)=1
    dim tflocal$(1)
    load array tflocalfilename$,tflocal$()
    entityprofileheader(entid).desc$=tflocal$(0)
    undim tflocal$()
   endif
  endif
 endif
 `
 rem Translate entity references inside entity profile (token translations)
 if lower$(entityprofileheader(entid).desc$)="%key"
  entityprofileheader(entid).desc$=strarr$(472)
 endif
 if lower$(entityprofileheader(entid).desc$)="%light"
  entityprofileheader(entid).desc$=strarr$(473)
 endif
 if lower$(entityprofileheader(entid).desc$)="%remote door"
  entityprofileheader(entid).desc$=strarr$(474)
 endif
 if lower$(entityprofileheader(entid).desc$)="%teleporter in"
  entityprofileheader(entid).desc$=strarr$(615)
 endif
 if lower$(entityprofileheader(entid).desc$)="%teleporter out"
  entityprofileheader(entid).desc$=strarr$(616)
 endif
 if lower$(entityprofileheader(entid).desc$)="%lift"
  entityprofileheader(entid).desc$=strarr$(617)
 endif
 if lower$(entityprofile(entid).usekey$)="%key"
  entityprofile(entid).usekey$=strarr$(472)
 endif
 if lower$(entityprofile(entid).ifused$)="%light"
  entityprofile(entid).ifused$=strarr$(473)
 endif
 if lower$(entityprofile(entid).ifused$)="%remote door"
  entityprofile(entid).ifused$=strarr$(474)
 endif
 if lower$(entityprofile(entid).ifused$)="%teleporter in"
  entityprofile(entid).ifused$=strarr$(615)
 endif
 if lower$(entityprofile(entid).ifused$)="%teleporter out"
  entityprofile(entid).ifused$=strarr$(616)
 endif
 if lower$(entityprofile(entid).ifused$)="%lift"
  entityprofile(entid).ifused$=strarr$(617)
 endif
 `
 rem All profile defaults
 if entityprofile(entid).ismarker<>1
  if entityprofile(entid).lives<1 then entityprofile(entid).lives=1
 endif
 if entityprofile(entid).speed=0 then entityprofile(entid).speed=100
 if entityprofile(entid).hurtfall=0 then entityprofile(entid).hurtfall=100
 if entityprofile(entid).ischaracter=1
  if entityprofile(entid).quantity=0 then entityprofile(entid).quantity=1
 endif
 `
 rem LOD defaults
 if entityprofile(entid).ex.autolodmed=0 then entityprofile(entid).ex.autolodmed=400
 if entityprofile(entid).ex.autolodlow=0 then entityprofile(entid).ex.autolodlow=800
 `
 rem Physics Data Defaults
 if entityprofile(entid).ismarker=0
  rem default physics settings (weight and friction done during object load (we need the obj size!)
  entityprofile(entid).phyalways=0
  entityprofile(entid).phyforcedamage=100
  entityprofile(entid).rotatethrow=1
  entityprofile(entid).explodedamage=100
  entityprofile(entid).phyweight=0
  entityprofile(entid).phyfriction=0
  rem health packs have no physics by default for A compatibility
  if entityprofile(entid).ishealth<>0
   entityprofile(entid).physics=0
  endif
 else
  entityprofile(entid).physics=0
 endif
 `
 rem Score default for non markers
 if entityprofile(entid).ex.score=-1
  if entityprofile(entid).ismarker=0
   entityprofile(entid).ex.score=10
  else
   entityprofile(entid).ex.score=0
  endif
 endif
 `
 rem Spawn defaults
 entityprofile(entid).spawnatstart=1
 entityprofile(entid).spawndelayrandom=0
 entityprofile(entid).spawnqtyrandom=0
 entityprofile(entid).spawnvel=0
 entityprofile(entid).spawnvelrandom=0
 entityprofile(entid).spawnangle=90
 entityprofile(entid).spawnanglerandom=0
 entityprofile(entid).spawnlife=0
 if entityprofile(entid).spawnmax>0
  entityprofile(entid).spawnupto=entityprofile(entid).spawnmax
  entityprofile(entid).spawnafterdelay=1
  if entityprofile(entid).ischaracter=1
   entityprofile(entid).spawnwhendead=1
  else
   entityprofile(entid).spawnwhendead=0
  endif
 else
  entityprofile(entid).spawnupto=0
  entityprofile(entid).spawnafterdelay=0
  entityprofile(entid).spawnwhendead=0
 endif
 `
 rem If animation data insufficient, make up rest with basic null sets
 if entityprofile(entid).animmax>0
  if entityprofile(entid).animmax<100
   rem AI animation code relies on standard animation-set-numbers
   for q=entityprofile(entid).animmax to 99
    entityanim(entid,q).start=0
    entityanim(entid,q).finish=1
    entityanim(entid,q).speed=1
   next q
   entityprofile(entid).animmax=100
  endif
 endif
 `
 rem Save entity profile as binary
 dim tempe(0) as entityprofiletype
 open to write 1,tprofile$
 write string 1,entityprofileheader(entid).desc$
 tempe(0)=entityprofile(entid)
 if memblock exist(1)=1 then delete memblock 1
 tempe(0).aiinit$=free string()
 tempe(0).aimain$=free string()
 tempe(0).aidestroy$=free string()
 tempe(0).aishoot$=free string()
 tempe(0).soundset$=free string()
 tempe(0).soundset1$=free string()
 tempe(0).usekey$=free string()
 tempe(0).ifused$=free string()
 tempe(0).ifusednear$=free string()
 tempe(0).model$=free string()
 tempe(0).texpath$=free string()
 tempe(0).texd$=free string()
 tempe(0).texaltd$=free string()
 tempe(0).effect$=free string()
 tempe(0).isweapon$=free string()
 tempe(0).hasweapon$=free string()
 make memblock from array 1,tempe(0)
 write memblock 1,1
 write string 1,entityprofile(entid).aiinit$
 write string 1,entityprofile(entid).aimain$
 write string 1,entityprofile(entid).aidestroy$
 write string 1,entityprofile(entid).aishoot$
 write string 1,entityprofile(entid).soundset$
 write string 1,entityprofile(entid).soundset1$
 write string 1,entityprofile(entid).usekey$
 write string 1,entityprofile(entid).ifused$
 write string 1,entityprofile(entid).ifusednear$
 write string 1,entityprofile(entid).model$
 write string 1,entityprofile(entid).texpath$
 write string 1,entityprofile(entid).texd$
 write string 1,entityprofile(entid).texaltd$
 write string 1,entityprofile(entid).effect$
 write string 1,entityprofile(entid).isweapon$
 write string 1,entityprofile(entid).hasweapon$
 for q = 0 to entityprofile(entid).animmax-1
  write file 1,entityanim(entid,q).start
  write file 1,entityanim(entid,q).finish
  write file 1,entityanim(entid,q).speed
 next q
 for q = 0 to entityprofile(entid).decalmax-1
  write string 1,entitydecal$(entid,q)
 next q
 close file 1
 delete memblock 1
 undim tempe(0)
 `
else
 `
 rem load binary version of entity profile file
 dim tempe(0) as entityprofiletype
 open to read 1,tprofile$
 read string 1,tstr$ : entityprofileheader(entid).desc$=tstr$
 read memblock 1,1
 make array from memblock tempe(0),1
 entityprofile(entid)=tempe(0)
 read string 1,tstr$ : entityprofile(entid).aiinit$=tstr$
 read string 1,tstr$ : entityprofile(entid).aimain$=tstr$
 read string 1,tstr$ : entityprofile(entid).aidestroy$=tstr$
 read string 1,tstr$ : entityprofile(entid).aishoot$=tstr$
 read string 1,tstr$ : entityprofile(entid).soundset$=tstr$
 read string 1,tstr$ : entityprofile(entid).soundset1$=tstr$
 read string 1,tstr$ : entityprofile(entid).usekey$=tstr$
 read string 1,tstr$ : entityprofile(entid).ifused$=tstr$
 read string 1,tstr$ : entityprofile(entid).ifusednear$=tstr$
 read string 1,tstr$ : entityprofile(entid).model$=tstr$
 read string 1,tstr$ : entityprofile(entid).texpath$=tstr$
 read string 1,tstr$ : entityprofile(entid).texd$=tstr$
 read string 1,tstr$ : entityprofile(entid).texaltd$=tstr$
 read string 1,tstr$ : entityprofile(entid).effect$=tstr$
 read string 1,tstr$ : entityprofile(entid).isweapon$=tstr$
 read string 1,tstr$ : entityprofile(entid).hasweapon$=tstr$
 for q = 0 to entityprofile(entid).animmax-1
  read file 1,a : entityanim(entid,q).start=a
  read file 1,a : entityanim(entid,q).finish=a
  read file 1,a : entityanim(entid,q).speed=a
 next q
 for q = 0 to entityprofile(entid).decalmax-1
  read string 1,entitydecal$(entid,q)
 next q
 close file 1
 delete memblock 1
 undim tempe(0)
 `
endif

rem V110 - 130110 - if from legacy model pack, force NORAGDOLL and also
rem add DDS/JPG/TGA/PNG textures from the final folder to ensure entities
rem have textures when a final standalone executable is created
entnoslash$=ent$
if mid$(entnoslash$,1)="\" then entnoslash$=right$(entnoslash$,len(entnoslash$)-1)
if entityprofile(entid).ischaracter=1
 tlegacypackentity=0
 t$="model pack 4" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="cartoonfantasypack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="dungeonpack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="egyptian characters" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="fantasy characters" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="fantasypack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="freaks and abominations" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="medievalpack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="romanpack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="tropical pack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 t$="vikingpack" : if lower$(left$(entnoslash$,len(t$)))=t$ then tlegacypackentity=1
 if tlegacypackentity=1
  rem No Ragdoll (X9 packs not designed with ragdoll bone structures in mind)
  entityprofile(entid).noragdoll=1
  rem Also scan final folder and scan for all textures that X9 packs used
  trememberolddir$=get dir$()
  if path exist(entdir$+getpath(ent$))=1
   set dir entdir$+getpath(ent$)
   perform checklist for files
   for c=1 to checklist quantity()
    tscannedfile$=lower$(checklist string$(c))
    if tscannedfile$<>"." and tscannedfile$<>".."
     tfileistexture=0
     if right$(tscannedfile$,4)=".dds" then tfileistexture=1
     if right$(tscannedfile$,4)=".jpg" then tfileistexture=1
     if right$(tscannedfile$,4)=".png" then tfileistexture=1
     if right$(tscannedfile$,4)=".tga" then tfileistexture=1
     if tfileistexture=1
      addfiletocollection(entdir$+getpath(ent$)+"\"+tscannedfile$)
     endif
    endif
   next c
   set dir trememberolddir$
  endif
 endif
endif

rem fileexistelse
else
 rem File not exist, provide debug information (only if file specified (old entities can be renamed and still hang around inside FPMs)
 if len(entdir$+ent$)>len("entitybank\")
  debugfilename(entdir$+ent$,tprofile$)
 endif
endif

return

_entity_saveelementsdata:

rem Uses elementfilename$
if elementsfilename$="" then elementsfilename$=myownrootdir$+"mapbank\testmap\map.ele"

rem Reduce list size if later elements blank
e=entityelementlist
while e>0
 if entityelement(e).maintype=0 then dec e else exit
endwhile
entityelementlist=e

rem Save entity element list
dw as DWORD
versionnumbersave=200
if file exist(elementsfilename$)=1 then delete file elementsfilename$
open to write 1,elementsfilename$
 write file 1,versionnumbersave
 write file 1,entityelementlist
 if entityelementlist>0
  for e=1 to entityelementlist
   if versionnumbersave>=101
    rem Version 1.01 - EA
    a=entityelement(e).maintype : write file 1,a
    a=entityelement(e).bankindex : write file 1,a
    a=entityelement(e).staticflag : write file 1,a
    a#=entityelement(e).x : write float 1,a#
    a#=entityelement(e).y : write float 1,a#
    a#=entityelement(e).z : write float 1,a#
    a#=entityelement(e).rx : write float 1,a#
    a#=entityelement(e).ry : write float 1,a#
    a#=entityelement(e).rz : write float 1,a#
    a$=entityelement(e).eleprof.name$ : write string 1,a$
    a$=entityelement(e).eleprof.aiinit$ : write string 1,a$
    a$=entityelement(e).eleprof.aimain$ : write string 1,a$
    a$=entityelement(e).eleprof.aidestroy$ : write string 1,a$
    a=entityelement(e).eleprof.isobjective : write file 1,a
    a$=entityelement(e).eleprof.usekey$ : write string 1,a$
    a$=entityelement(e).eleprof.ifused$ : write string 1,a$
    a$=entityelement(e).eleprof.ifusednear$ : write string 1,a$
    a=entityelement(e).eleprof.uniqueelement : write file 1,a
    a$=entityelement(e).eleprof.texd$ : write string 1,a$
    a$=entityelement(e).eleprof.texaltd$ : write string 1,a$
    a$=entityelement(e).eleprof.effect$ : write string 1,a$
    a=entityelement(e).eleprof.transparency : write file 1,a
    a=entityelement(e).editorfixed : write file 1,a
    a$=entityelement(e).eleprof.soundset$ : write string 1,a$
    a$=entityelement(e).eleprof.soundset1$ : write string 1,a$
    a=entityelement(e).eleprof.spawnmax : write file 1,a
    a=entityelement(e).eleprof.spawndelay : write file 1,a
    a=entityelement(e).eleprof.spawnqty : write file 1,a
    a=entityelement(e).eleprof.hurtfall : write file 1,a
    a=entityelement(e).eleprof.castshadow : write file 1,a
    a=entityelement(e).eleprof.reducetexture : write file 1,a
    a=entityelement(e).eleprof.speed : write file 1,a
    a$=entityelement(e).eleprof.aishoot$ : write string 1,a$
    a$=entityelement(e).eleprof.hasweapon$ : write string 1,a$
    a=entityelement(e).eleprof.lives : write file 1,a
    a=entityelement(e).spawn.max : write file 1,a
    a=entityelement(e).spawn.delay : write file 1,a
    a=entityelement(e).spawn.qty : write file 1,a
    a#=entityelement(e).eleprof.scale : write float 1,a#
    a#=entityelement(e).eleprof.coneheight : write float 1,a#
    a#=entityelement(e).eleprof.coneangle : write float 1,a#
    a=entityelement(e).eleprof.strength : write file 1,a
    a=entityelement(e).eleprof.isimmobile : write file 1,a
    a=entityelement(e).eleprof.cantakeweapon : write file 1,a
    a=entityelement(e).eleprof.quantity : write file 1,a
    a=entityelement(e).eleprof.markerindex : write file 1,a
    dw=entityelement(e).eleprof.light.color : dw=(dw<<8)>>8 : a=dw : write file 1,a
    a=entityelement(e).eleprof.light.range : write file 1,a
    a=entityelement(e).eleprof.trigger.areax1 : write file 1,a
    a=entityelement(e).eleprof.trigger.areay1 : write file 1,a
    a=entityelement(e).eleprof.trigger.areaz1 : write file 1,a
    a=entityelement(e).eleprof.trigger.areax2 : write file 1,a
    a=entityelement(e).eleprof.trigger.areay2 : write file 1,a
    a=entityelement(e).eleprof.trigger.areaz2 : write file 1,a
    a$=entityelement(e).eleprof.basedecal$ : write string 1,a$
   endif
   if versionnumbersave>=102
    a=entityelement(e).eleprof.rateoffire : write file 1,a
    a=entityelement(e).eleprof.damage : write file 1,a
    a=entityelement(e).eleprof.accuracy : write file 1,a
    a=entityelement(e).eleprof.reloadqty : write file 1,a
    a=entityelement(e).eleprof.fireiterations : write file 1,a
    a=entityelement(e).eleprof.lifespan : write file 1,a
    a#=entityelement(e).eleprof.throwspeed : write float 1,a#
    a#=entityelement(e).eleprof.throwangle : write float 1,a#
    a=entityelement(e).eleprof.bounceqty : write file 1,a
    a=entityelement(e).eleprof.explodeonhit : write file 1,a
    a=entityelement(e).eleprof.weaponisammo : write file 1,a
    a=entityelement(e).eleprof.spawnupto : write file 1,a
    a=entityelement(e).eleprof.spawnafterdelay : write file 1,a
    a=entityelement(e).eleprof.spawnwhendead : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
    a=entityelement(e).eleprof.spare1 : write file 1,a
   endif
   if versionnumbersave>=103
    rem V1 first draft - physics
    a=entityelement(e).eleprof.physics : write file 1,a
    a=entityelement(e).eleprof.phyweight : write file 1,a
    a=entityelement(e).eleprof.phyfriction : write file 1,a
    a=entityelement(e).eleprof.phyforcedamage : write file 1,a
    a=entityelement(e).eleprof.rotatethrow : write file 1,a
    a=entityelement(e).eleprof.explodable : write file 1,a
    a=entityelement(e).eleprof.explodedamage : write file 1,a
    a=entityelement(e).eleprof.uniquetimer : write file 1,a
    a=entityelement(e).eleprof.phydw2 : write file 1,a
   endif
   if versionnumbersave>=104
    rem Addition of new physics field for BETA4
    a=entityelement(e).eleprof.phyalways : write file 1,a
   endif
   if versionnumbersave>=105
    rem Addition of new spawn fields for BETA8
    a=entityelement(e).eleprof.spawndelayrandom : write file 1,a
    a=entityelement(e).eleprof.spawnqtyrandom : write file 1,a
    a=entityelement(e).eleprof.spawnvel : write file 1,a
    a=entityelement(e).eleprof.spawnvelrandom : write file 1,a
    a=entityelement(e).eleprof.spawnangle : write file 1,a
    a=entityelement(e).eleprof.spawnanglerandom : write file 1,a
   endif
   if versionnumbersave>=106
    rem Addition of new fields for BETA10
    a=entityelement(e).eleprof.spawnatstart : write file 1,a
    a=entityelement(e).eleprof.spawnlife : write file 1,a
   endif
   if versionnumbersave>=107
    rem FPSCV104RC8 - forgot to save infinilight index (dynamic lights in final build never worked)
    a=entityelement(e).eleprof.light.index : write file 1,a
   endif
   if versionnumbersave>=199
    rem X10 0.9.0 BETA
    a=entityelement(e).eleprof.ex.alignment : write file 1,a
    a=entityelement(e).eleprof.ex.initmode : write file 1,a
    a=entityelement(e).eleprof.ex.seemode : write file 1,a
    a=entityelement(e).eleprof.ex.trigmode : write file 1,a
    a=entityelement(e).eleprof.ex.hurtmode : write file 1,a
    a=entityelement(e).eleprof.ex.hurtvalue : write file 1,a
    a=entityelement(e).eleprof.ex.canstrafe : write file 1,a
    a=entityelement(e).eleprof.ex.canduck : write file 1,a
    a=entityelement(e).eleprof.ex.canhear : write file 1,a
    a=entityelement(e).eleprof.ex.loadedweapon : write file 1,a
    a=entityelement(e).eleprof.ex.attackrange : write file 1,a
    a=entityelement(e).eleprof.ex.viewrange : write file 1,a
    a=entityelement(e).eleprof.ex.maxrange : write file 1,a
    a=entityelement(e).eleprof.ex.texturearray : write file 1,a
    a=entityelement(e).eleprof.ex.showhealthbar : write file 1,a
    a=entityelement(e).eleprof.ex.lungcapacity : write file 1,a
    a=entityelement(e).eleprof.ex.glassstyle : write file 1,a
   endif
   if versionnumbersave>=200
    rem X10 BETA 190707
    a=entityelement(e).eleprof.ex.score : write file 1,a
    a=entityelement(e).eleprof.ex.showallyicon : write file 1,a
    a=entityelement(e).eleprof.ex.factor : write file 1,a
    a=entityelement(e).eleprof.ex.impactforce : write file 1,a
    a=entityelement(e).eleprof.ex.decaytime : write file 1,a
    a=entityelement(e).eleprof.ex.jumpheight : write file 1,a    
   endif
  next e
 endif
close file 1

return

_entity_deleteelementsdata:

rem Free any old elements
gosub _entity_deleteelements

rem Clear counter for new load
entityelementlist=0
entityelementmax=0

return

_entity_loadelementsdata:

rem Free any old elements
gosub _entity_deleteelementsdata

rem Uses elementfilename$
if elementsfilename$="" then elementsfilename$=myownrootdir$+"mapbank\testmap\map.ele"

rem load entity element list
dw as DWORD
versionnumbersupported=200
if file exist(elementsfilename$)=1
 `
 open to read 1,elementsfilename$
  read file 1,versionnumberload
  if versionnumberload<100
   rem Pre-version data - development only
   entityelementlist=versionnumberload
   versionnumberload=100
  else
   read file 1,entityelementlist
  endif
  if versionnumberload<=versionnumbersupported
   if entityelementlist>0
    undim entityelement()
    undim entitydebug$()
    entityelementmax=entityelementlist
    dim entityelement(entityelementmax) as entitytype
    dim entitydebug$(entityelementmax)
    dim entityelementwhichslot(entityelementmax)
    dim entityelementusingode(entityelementmax)
    dim entityelementwhichobj(entityelementmax)
    dim entityelementtexarrayindex(entityelementmax)
    dim entityelementusingrefraction(entityelementmax)
    dim lastentityraycast(entityelementmax)
    dim lastentityraycast2#(entityelementmax)  
    dim lastentityshadowlength#(entityelementmax)
    for e=1 to entityelementlist
     `
     rem actual file data
     if versionnumberload>=101
      rem Version 1.01
      read file 1,a : entityelement(e).maintype=a
      read file 1,a : entityelement(e).bankindex=a
      read file 1,a : entityelement(e).staticflag=a
      read float 1,a# : entityelement(e).x=a#
      read float 1,a# : entityelement(e).y=a#
      read float 1,a# : entityelement(e).z=a#
      read float 1,a# : entityelement(e).rx=a#
      read float 1,a# : entityelement(e).ry=a#
      read float 1,a# : entityelement(e).rz=a#
      read string 1,a$ : entityelement(e).eleprof.name$=a$
      read string 1,a$ : entityelement(e).eleprof.aiinit$=a$
      read string 1,a$ : entityelement(e).eleprof.aimain$=a$
      read string 1,a$ : entityelement(e).eleprof.aidestroy$=a$
      read file 1,a : entityelement(e).eleprof.isobjective=a
      read string 1,a$ : entityelement(e).eleprof.usekey$=a$
      read string 1,a$ : entityelement(e).eleprof.ifused$=a$
      read string 1,a$ : entityelement(e).eleprof.ifusednear$=a$
      read file 1,a : entityelement(e).eleprof.uniqueelement=a
      read string 1,a$ : entityelement(e).eleprof.texd$=a$
      read string 1,a$ : entityelement(e).eleprof.texaltd$=a$
      read string 1,a$ : entityelement(e).eleprof.effect$=a$
      read file 1,a : entityelement(e).eleprof.transparency=a
      read file 1,a : entityelement(e).editorfixed=a
      read string 1,a$ : entityelement(e).eleprof.soundset$=a$
      read string 1,a$ : entityelement(e).eleprof.soundset1$=a$
      read file 1,a : entityelement(e).eleprof.spawnmax=a
      read file 1,a : entityelement(e).eleprof.spawndelay=a
      read file 1,a : entityelement(e).eleprof.spawnqty=a
      read file 1,a : entityelement(e).eleprof.hurtfall=a
      read file 1,a : entityelement(e).eleprof.castshadow=a
      read file 1,a : entityelement(e).eleprof.reducetexture=a
      read file 1,a : entityelement(e).eleprof.speed=a
      read string 1,a$ : entityelement(e).eleprof.aishoot$=a$
      read string 1,a$ : entityelement(e).eleprof.hasweapon$=a$
      read file 1,a : entityelement(e).eleprof.lives=a
      read file 1,a : entityelement(e).spawn.max=a
      read file 1,a : entityelement(e).spawn.delay=a
      read file 1,a : entityelement(e).spawn.qty=a
      read float 1,a# : entityelement(e).eleprof.scale=a#
      read float 1,a# : entityelement(e).eleprof.coneheight=a#
      read float 1,a# : entityelement(e).eleprof.coneangle=a#
      read file 1,a : entityelement(e).eleprof.strength=a
      read file 1,a : entityelement(e).eleprof.isimmobile=a
      read file 1,a : entityelement(e).eleprof.cantakeweapon=a
      read file 1,a : entityelement(e).eleprof.quantity=a
      read file 1,a : entityelement(e).eleprof.markerindex=a
      read file 1,a : dw=a : dw=dw+0xFF000000 : entityelement(e).eleprof.light.color=dw
      read file 1,a : entityelement(e).eleprof.light.range=a
      read file 1,a : entityelement(e).eleprof.trigger.areax1=a
      read file 1,a : entityelement(e).eleprof.trigger.areay1=a
      read file 1,a : entityelement(e).eleprof.trigger.areaz1=a
      read file 1,a : entityelement(e).eleprof.trigger.areax2=a
      read file 1,a : entityelement(e).eleprof.trigger.areay2=a
      read file 1,a : entityelement(e).eleprof.trigger.areaz2=a
      read string 1,a$ : entityelement(e).eleprof.basedecal$=a$
     endif
     if versionnumberload>=102
      rem Version 1.02
      read file 1,a : entityelement(e).eleprof.rateoffire=a
      read file 1,a : entityelement(e).eleprof.damage=a
      read file 1,a : entityelement(e).eleprof.accuracy=a
      read file 1,a : entityelement(e).eleprof.reloadqty=a
      read file 1,a : entityelement(e).eleprof.fireiterations=a
      read file 1,a : entityelement(e).eleprof.lifespan=a
      read float 1,a# : entityelement(e).eleprof.throwspeed=a#
      read float 1,a# : entityelement(e).eleprof.throwangle=a#
      read file 1,a : entityelement(e).eleprof.bounceqty=a
      read file 1,a : entityelement(e).eleprof.explodeonhit=a
      read file 1,a : entityelement(e).eleprof.weaponisammo=a
      read file 1,a : entityelement(e).eleprof.spawnupto=a
      read file 1,a : entityelement(e).eleprof.spawnafterdelay=a
      read file 1,a : entityelement(e).eleprof.spawnwhendead=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
      read file 1,a : entityelement(e).eleprof.spare1=a
     endif
     if versionnumberload>=103
      rem Version 1.03 - V1 draft physics
      read file 1,a : entityelement(e).eleprof.physics=a
      read file 1,a : entityelement(e).eleprof.phyweight=a
      read file 1,a : entityelement(e).eleprof.phyfriction=a
      read file 1,a : entityelement(e).eleprof.phyforcedamage=a
      read file 1,a : entityelement(e).eleprof.rotatethrow=a
      read file 1,a : entityelement(e).eleprof.explodable=a
      read file 1,a : entityelement(e).eleprof.explodedamage=a
      read file 1,a : entityelement(e).eleprof.uniquetimer=a
      read file 1,a : entityelement(e).eleprof.phydw2=a
     endif
     if versionnumberload>=104
      rem Version 1.04 - BETA4 extra field
      read file 1,a : entityelement(e).eleprof.phyalways=a
     endif
     if versionnumberload>=105
      rem Version 1.05 - BETA8 extra fields
      read file 1,a : entityelement(e).eleprof.spawndelayrandom=a
      read file 1,a : entityelement(e).eleprof.spawnqtyrandom=a
      read file 1,a : entityelement(e).eleprof.spawnvel=a
      read file 1,a : entityelement(e).eleprof.spawnvelrandom=a
      read file 1,a : entityelement(e).eleprof.spawnangle=a
      read file 1,a : entityelement(e).eleprof.spawnanglerandom=a
     endif
     if versionnumberload>=106
      rem Version 1.06 - BETA10 extra fields
      read file 1,a : entityelement(e).eleprof.spawnatstart=a
      read file 1,a : entityelement(e).eleprof.spawnlife=a
     endif
     if versionnumberload>=107
      rem FPSCV104RC8 - forgot to save infinilight index (dynamic lights in final build never worked)
      read file 1,a : entityelement(e).eleprof.light.index=a
     endif
     if versionnumberload>=199
      rem X10 BETA
      read file 1,a : entityelement(e).eleprof.ex.alignment=a
      read file 1,a : entityelement(e).eleprof.ex.initmode=a
      read file 1,a : entityelement(e).eleprof.ex.seemode=a
      read file 1,a : entityelement(e).eleprof.ex.trigmode=a
      read file 1,a : entityelement(e).eleprof.ex.hurtmode=a
      read file 1,a : entityelement(e).eleprof.ex.hurtvalue=a
      read file 1,a : entityelement(e).eleprof.ex.canstrafe=a
      read file 1,a : entityelement(e).eleprof.ex.canduck=a
      read file 1,a : entityelement(e).eleprof.ex.canhear=a
      read file 1,a : entityelement(e).eleprof.ex.loadedweapon=a
      read file 1,a : entityelement(e).eleprof.ex.attackrange=a
      read file 1,a : entityelement(e).eleprof.ex.viewrange=a
      read file 1,a : entityelement(e).eleprof.ex.maxrange=a
      read file 1,a : entityelement(e).eleprof.ex.texturearray=a
      read file 1,a : entityelement(e).eleprof.ex.showhealthbar=a
      read file 1,a : entityelement(e).eleprof.ex.lungcapacity=a
      read file 1,a : entityelement(e).eleprof.ex.glassstyle=a
     endif
     if versionnumberload>=200
      rem X10 BETA 190707
      read file 1,a : entityelement(e).eleprof.ex.score=a
      read file 1,a : entityelement(e).eleprof.ex.showallyicon=a
      read file 1,a : entityelement(e).eleprof.ex.factor=a
      read file 1,a : entityelement(e).eleprof.ex.impactforce=a
      read file 1,a : entityelement(e).eleprof.ex.decaytime=a
      read file 1,a : entityelement(e).eleprof.ex.jumpheight=a
     endif
     `
     rem fill in the blanks if load older version
     ttentid=entityelement(e).bankindex
     if versionnumberload<103
      rem Version 1.03 - V1 draft physics (-1 means calculate at entobj-loadtime)
      entityelement(e).eleprof.physics=entityprofile(ttentid).physics
      entityelement(e).eleprof.phyweight=entityprofile(ttentid).phyweight
      entityelement(e).eleprof.phyfriction=entityprofile(ttentid).phyfriction
      entityelement(e).eleprof.phyforcedamage=entityprofile(ttentid).phyforcedamage
      entityelement(e).eleprof.rotatethrow=entityprofile(ttentid).rotatethrow
      entityelement(e).eleprof.explodable=entityprofile(ttentid).explodable
      entityelement(e).eleprof.uniquetimer=0
      entityelement(e).eleprof.phydw2=0
     endif
     if versionnumberload<104
      rem Version 1.04 - BETA4 extra field
      entityelement(e).eleprof.phyalways=entityprofile(ttentid).phyalways
     endif
     if versionnumberload<105
      rem Version 1.05 - BETA8
      entityelement(e).eleprof.spawndelayrandom=entityprofile(ttentid).spawndelayrandom
      entityelement(e).eleprof.spawnqtyrandom=entityprofile(ttentid).spawnqtyrandom
      entityelement(e).eleprof.spawnvel=entityprofile(ttentid).spawnvel
      entityelement(e).eleprof.spawnvelrandom=entityprofile(ttentid).spawnvelrandom
      entityelement(e).eleprof.spawnangle=entityprofile(ttentid).spawnangle
      entityelement(e).eleprof.spawnanglerandom=entityprofile(ttentid).spawnanglerandom
     endif
     if versionnumberload<106
      rem Version 1.06 - BETA10
      entityelement(e).eleprof.spawnatstart=entityprofile(ttentid).spawnatstart
      entityelement(e).eleprof.spawnlife=entityprofile(ttentid).spawnlife
     endif
     if versionnumberload<199
      rem X10 - BETA
      entityelement(e).eleprof.ex=entityprofile(ttentid).ex
     endif
     if versionnumberload<200
      rem X10 - RELEASE
     endif
     `
    next e
   endif
  else
   debugstring(strarr$(101),"")
  endif
 close file 1
 `
 rem 310707 - this code moved into here as without entitiy data, the code is wrong!
 rem and erase any elements that DO NOT have a valid profile (file moved/deleted)
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  if entid>0
   if entid<array count(entitybank$())
    if len(entitybank$(entid))=0
     entityelement(e).bankindex=0
    endif
   endif
  endif
 next e
 `
 rem X10 set uber instance mode if entity re-used more than X times
 for entid=1 to entidmaster
  entityprofile(entid).characterinstancingmode=0
  for e=1 to entityelementlist
   tentid=entityelement(e).bankindex
   if entid=tentid
    entityprofile(entid).characterinstancingmode=entityprofile(entid).characterinstancingmode+1
   endif
  next e  
  if entityprofile(entid).characterinstancingmode>10
   rem we are going to use GPU instancing, keep clones
   entityprofile(entid).characterinstancingmode=1
  else
   rem we are NOT going to use instancing, use regular clone code
   entityprofile(entid).characterinstancingmode=0
   rem 250707 - and delete parent slot clones as we dont need them now (and it will save GPU space)
   if entityprofile(entid).slotcloneobj>0
    for o=0 to entityprofileslotclonequantity-1
     tscobj=entityprofile(entid).slotcloneobj+o
     delete object tscobj
    next o
    entityprofile(entid).slotcloneobj=0
   endif
  endif
 next e
 `
 rem X10 - 240907 - if loading pre-X10 level, change character main AI for DarkAI use
 if versionnumberload<versionnumbersupported
  for e=1 to entityelementlist
   entid=entityelement(e).bankindex
   if entid>0
    if entityprofile(entid).ischaracter=1
     entityelement(e).eleprof.aiinit$="appear1.fpi"
     entityelement(e).eleprof.aimain$="people\darkai.fpi"
     entityelement(e).eleprof.aidestroy$="people\darkdestroy.fpi"
    endif
   endif
  next e
 endif
 `
endif

return

_entity_fillelementfromprofile:
 `
 rem Name
 entityelement(e).eleprof.name$=entityprofileheader(entid).desc$
 `
 rem AI values
 entityelement(e).eleprof.aiinit$=entityprofile(entid).aiinit$
 entityelement(e).eleprof.aimain$=entityprofile(entid).aimain$
 entityelement(e).eleprof.aidestroy$=entityprofile(entid).aidestroy$
 entityelement(e).eleprof.aishoot$=entityprofile(entid).aishoot$
 `
 rem AI use vars
 entityelement(e).eleprof.usekey$=entityprofile(entid).usekey$
 entityelement(e).eleprof.ifused$=entityprofile(entid).ifused$
 entityelement(e).eleprof.ifusednear$=entityprofile(entid).ifusednear$
 `
 rem Spawn
 entityelement(e).eleprof.spawnatstart=entityprofile(entid).spawnatstart
 entityelement(e).eleprof.spawnmax=entityprofile(entid).spawnmax
 entityelement(e).eleprof.spawndelay=entityprofile(entid).spawndelay
 entityelement(e).eleprof.spawnqty=entityprofile(entid).spawnqty
 entityelement(e).eleprof.spawnupto=entityprofile(entid).spawnupto
 entityelement(e).eleprof.spawnafterdelay=entityprofile(entid).spawnafterdelay
 entityelement(e).eleprof.spawnwhendead=entityprofile(entid).spawnwhendead
 entityelement(e).eleprof.spawndelayrandom=entityprofile(entid).spawndelayrandom
 entityelement(e).eleprof.spawnqtyrandom=entityprofile(entid).spawnqtyrandom
 entityelement(e).eleprof.spawnvel=entityprofile(entid).spawnvel
 entityelement(e).eleprof.spawnvelrandom=entityprofile(entid).spawnvelrandom
 entityelement(e).eleprof.spawnangle=entityprofile(entid).spawnangle
 entityelement(e).eleprof.spawnanglerandom=entityprofile(entid).spawnanglerandom
 entityelement(e).eleprof.spawnlife=entityprofile(entid).spawnlife
 `
 rem Scale, Cone
 entityelement(e).eleprof.scale=entityprofile(entid).scale
 entityelement(e).eleprof.coneheight=entityprofile(entid).coneheight
 entityelement(e).eleprof.coneangle=entityprofile(entid).coneangle
 `
 rem Textre and Effect Data (zero to begin with
 entityelement(e).eleprof.uniqueelement=0
 entityelement(e).eleprof.texd$=entityprofile(entid).texd$
 entityelement(e).eleprof.texaltd$=entityprofile(entid).texaltd$
 entityelement(e).eleprof.effect$=entityprofile(entid).effect$
 entityelement(e).eleprof.transparency=entityprofile(entid).transparency
 entityelement(e).eleprof.castshadow=entityprofile(entid).castshadow
 entityelement(e).eleprof.reducetexture=entityprofile(entid).reducetexture
 `
 rem Strength and Quantity
 entityelement(e).eleprof.strength=entityprofile(entid).strength
 entityelement(e).eleprof.lives=entityprofile(entid).lives
 entityelement(e).eleprof.isimmobile=entityprofile(entid).isimmobile
 entityelement(e).eleprof.cantakeweapon=entityprofile(entid).cantakeweapon
 entityelement(e).eleprof.hasweapon$=entityprofile(entid).hasweapon$
 entityelement(e).eleprof.quantity=entityprofile(entid).quantity
 entityelement(e).eleprof.isobjective=entityprofile(entid).isobjective
 entityelement(e).eleprof.speed=entityprofile(entid).speed
 entityelement(e).eleprof.hurtfall=entityprofile(entid).hurtfall
 `
 rem Decal and Soundset Name
 entityelement(e).eleprof.basedecal$=entitydecal$(entid,0)
 entityelement(e).eleprof.soundset$=entityprofile(entid).soundset$
 entityelement(e).eleprof.soundset1$=entityprofile(entid).soundset1$
 `
 rem Marker Data
 entityelement(e).eleprof.markerindex=entityprofile(entid).markerindex
 entityelement(e).eleprof.light=entityprofile(entid).light
 entityelement(e).eleprof.trigger=entityprofile(entid).trigger
 `
 rem Copy over EXTRAS data (from X10)
 entityelement(e).eleprof.ex=entityprofile(entid).ex
 `
 rem Data Extracted From GUN and FLAK
 tgunid$=entityprofile(entid).isweapon$
 gosub _entity_getgunidandflakid
 entityelement(e).eleprof.rateoffire=85
 entityelement(e).eleprof.weaponisammo=0
 if tgunid>0
  entityelement(e).eleprof.accuracy=gun(tgunid).settings.accuracy
  entityelement(e).eleprof.reloadqty=gun(tgunid).settings.reloadqty
  entityelement(e).eleprof.fireiterations=gun(tgunid).settings.iterate
  entityelement(e).eleprof.ex.impactforce=gun(tgunid).settings.impactforce
  if tflakid=0
   entityelement(e).eleprof.damage=gun(tgunid).settings.damage
  else
   entityelement(e).eleprof.damage=flak(tflakid).profile.damage
   entityelement(e).eleprof.lifespan=flak(tflakid).profile.lifespan
   entityelement(e).eleprof.throwspeed=flak(tflakid).profile.zinc
   entityelement(e).eleprof.throwangle=flak(tflakid).profile.yinc
   entityelement(e).eleprof.bounceqty=flak(tflakid).profile.bounceonhit
   entityelement(e).eleprof.explodeonhit=flak(tflakid).profile.explodeonhit
   entityelement(e).eleprof.weaponisammo=tflakid
  endif
 endif
 `
 rem Physics Data
 entityelement(e).eleprof.physics=entityprofile(entid).physics
 entityelement(e).eleprof.phyalways=entityprofile(entid).phyalways
 entityelement(e).eleprof.phyweight=entityprofile(entid).phyweight
 entityelement(e).eleprof.phyfriction=entityprofile(entid).phyfriction
 entityelement(e).eleprof.phyforcedamage=entityprofile(entid).phyforcedamage
 entityelement(e).eleprof.rotatethrow=entityprofile(entid).rotatethrow
 entityelement(e).eleprof.explodable=entityprofile(entid).explodable
 entityelement(e).eleprof.explodedamage=entityprofile(entid).explodedamage
 `
 rem Copy over found data and or load it
 configureobj=0 : gosub _entity_configueelementforuse
 `
return

_entity_fillgrideleproffromprofile:
 `
 rem Name
 grideleprof.name$=entityprofileheader(entid).desc$
 `
 rem AI values
 grideleprof.aiinit$=entityprofile(entid).aiinit$
 grideleprof.aimain$=entityprofile(entid).aimain$
 grideleprof.aidestroy$=entityprofile(entid).aidestroy$
 grideleprof.aishoot$=entityprofile(entid).aishoot$
 `
 rem AI use vars
 grideleprof.usekey$=entityprofile(entid).usekey$
 grideleprof.ifused$=entityprofile(entid).ifused$
 grideleprof.ifusednear$=entityprofile(entid).ifusednear$
 `
 rem Spawn
 grideleprof.spawnatstart=entityprofile(entid).spawnatstart
 grideleprof.spawnmax=entityprofile(entid).spawnmax
 grideleprof.spawndelay=entityprofile(entid).spawndelay
 grideleprof.spawnqty=entityprofile(entid).spawnqty
 grideleprof.spawnupto=entityprofile(entid).spawnupto
 grideleprof.spawnafterdelay=entityprofile(entid).spawnafterdelay
 grideleprof.spawnwhendead=entityprofile(entid).spawnwhendead
 grideleprof.spawndelayrandom=entityprofile(entid).spawndelayrandom
 grideleprof.spawnqtyrandom=entityprofile(entid).spawnqtyrandom
 grideleprof.spawnvel=entityprofile(entid).spawnvel
 grideleprof.spawnvelrandom=entityprofile(entid).spawnvelrandom
 grideleprof.spawnangle=entityprofile(entid).spawnangle
 grideleprof.spawnanglerandom=entityprofile(entid).spawnanglerandom
 grideleprof.spawnlife=entityprofile(entid).spawnlife
 `
 rem Scale, Cone
 grideleprof.scale=entityprofile(entid).scale
 grideleprof.coneheight=entityprofile(entid).coneheight
 grideleprof.coneangle=entityprofile(entid).coneangle
 `
 rem Textre and Effect Data
 grideleprof.uniqueelement=0
 grideleprof.texd$=entityprofile(entid).texd$
 grideleprof.texaltd$=entityprofile(entid).texaltd$
 grideleprof.effect$=entityprofile(entid).effect$
 grideleprof.transparency=entityprofile(entid).transparency
 grideleprof.castshadow=entityprofile(entid).castshadow
 grideleprof.reducetexture=entityprofile(entid).reducetexture
 `
 rem Strength and Quantity
 grideleprof.strength=entityprofile(entid).strength
 grideleprof.lives=entityprofile(entid).lives
 grideleprof.isimmobile=entityprofile(entid).isimmobile
 grideleprof.cantakeweapon=entityprofile(entid).cantakeweapon
 grideleprof.hasweapon$=entityprofile(entid).hasweapon$
 grideleprof.quantity=entityprofile(entid).quantity
 grideleprof.isobjective=entityprofile(entid).isobjective
 grideleprof.hurtfall=entityprofile(entid).hurtfall
 grideleprof.speed=entityprofile(entid).speed
 `
 rem Decal and Sound Name
 grideleprof.basedecal$=entitydecal$(entid,0)
 grideleprof.soundset$=entityprofile(entid).soundset$
 grideleprof.soundset1$=entityprofile(entid).soundset1$
 `
 rem Marker Data
 grideleprof.markerindex=entityprofile(entid).markerindex
 grideleprof.light=entityprofile(entid).light
 grideleprof.trigger=entityprofile(entid).trigger
 `
 rem Copy over EXTRAS data (from X10)
 grideleprof.ex=entityprofile(entid).ex
 `
 rem Data Extracted From GUN and FLAK
 tgunid$=entityprofile(entid).isweapon$
 gosub _entity_getgunidandflakid
 grideleprof.rateoffire=85
 grideleprof.weaponisammo=0
 if tgunid>0
  grideleprof.accuracy=gun(tgunid).settings.accuracy
  grideleprof.reloadqty=gun(tgunid).settings.reloadqty
  grideleprof.fireiterations=gun(tgunid).settings.iterate
  grideleprof.ex.impactforce=gun(tgunid).settings.impactforce  
  if tflakid=0
   grideleprof.damage=gun(tgunid).settings.damage
  else
   grideleprof.damage=flak(tflakid).profile.damage
   grideleprof.lifespan=flak(tflakid).profile.lifespan
   grideleprof.throwspeed=flak(tflakid).profile.zinc
   grideleprof.throwangle=flak(tflakid).profile.yinc
   grideleprof.bounceqty=flak(tflakid).profile.bounceonhit
   grideleprof.explodeonhit=flak(tflakid).profile.explodeonhit
   grideleprof.weaponisammo=tflakid
  endif
 endif
 `
 rem Physics Data
 grideleprof.physics=entityprofile(entid).physics
 grideleprof.phyalways=entityprofile(entid).phyalways
 grideleprof.phyweight=entityprofile(entid).phyweight
 grideleprof.phyfriction=entityprofile(entid).phyfriction
 grideleprof.phyforcedamage=entityprofile(entid).phyforcedamage
 grideleprof.rotatethrow=entityprofile(entid).rotatethrow
 grideleprof.explodable=entityprofile(entid).explodable
 grideleprof.explodedamage=entityprofile(entid).explodedamage
 `
return

rem
rem OBSMAP GENERATION SUBROUTINES
rem

_obs_generate_pertile:
 `
 gosub _obs_getmapvalues
 if ismapanoverlay=0
    rem BASE SEGMENT
    if mapid=0
     rem void
     maplines(l,x,y,0)=0
    else
     rem something
     maplines(l,x,y,0)=1
     rem no-floor flag
     if mapsymbol=1 then maplines(l,x,y,0)=0
     rem CSG for doors must be considered!!
     rem walls
     if maptile=00 then maplines(l,x,y,OBS_NN)=0
     if maptile=01 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_SS)=1 : maplines(l,x,y,OBS_WW)=1
     if maptile=02 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=1 : maplines(l,x,y,OBS_WW)=1
     if maptile=03 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=1
     if maptile=04 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=1 : maplines(l,x,y,OBS_WW)=0
     if maptile=05 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
     if maptile=06 then maplines(l,x,y,OBS_NN)=0
     if maptile=07 then maplines(l,x,y,OBS_NN)=0
     if maptile=08 then maplines(l,x,y,OBS_NN)=0
     if maptile=09 then maplines(l,x,y,OBS_NN)=0
     if maptile=10 then maplines(l,x,y,OBS_NN)=0
     if maptile=11 then maplines(l,x,y,OBS_NN)=0
     if maptile=12 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
     if maptile=13 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
     if maptile=14 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
     if maptile=15 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=0 : maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=1
     rem 280807 - switch off walls if the segment associated with the tile does not have any walls
     if segmentswhichchangeobsdatanowalls(mapselection)=1
      maplines(l,x,y,OBS_NN)=0 : maplines(l,x,y,OBS_EE)=0
      maplines(l,x,y,OBS_SS)=0 : maplines(l,x,y,OBS_WW)=0
     endif
     if maprotate>0
      rem rotate lines data
      while maprotate>0
       rem rotate once
       ssNN=maplines(l,x,y,OBS_NN)
       ssEE=maplines(l,x,y,OBS_EE)
       ssSS=maplines(l,x,y,OBS_SS)
       ssWW=maplines(l,x,y,OBS_WW)
       maplines(l,x,y,OBS_NN)=ssWW
       maplines(l,x,y,OBS_EE)=ssNN
       maplines(l,x,y,OBS_SS)=ssEE
       maplines(l,x,y,OBS_WW)=ssSS
       dec maprotate
      endwhile
     endif
    endif
 endif
 if ismapanoverlay=1
    rem OVERLAY SEGMENT
    if mapid<>0
     rem something, so fill space so AI can walk on it (platforms, corridors)
     maplines(l,x,y,0)=1
    endif
 endif
 if ismapanoverlay=2
    rem OVERLAY SEGMENT FOR DOORS / PUNCH WALLS OUT
    if mapid<>0
     if mapselection>0
      if segmentswhichchangeobsdata(mapselection)=1
       rem doors punch out walls!
       if maporient=0 then maplines(l,x,y,OBS_NN)=0
       if maporient=1 then maplines(l,x,y,OBS_EE)=0
       if maporient=2 then maplines(l,x,y,OBS_SS)=0
       if maporient=3 then maplines(l,x,y,OBS_WW)=0
       if maporient=0 and y>0 then maplines(l,x,y-1,OBS_SS)=0
       if maporient=1 and x<39 then maplines(l,x+1,y,OBS_WW)=0
       if maporient=2 and y<39 then maplines(l,x,y+1,OBS_NN)=0
       if maporient=3 and x>0 then maplines(l,x-1,y,OBS_EE)=0
       rem add door posts
       maplines(l,x,y,OBS_DR)=1+maporient
      endif
      if segmentswhichchangeobsdata(mapselection)=2
       rem window has no effect here
      endif
      if segmentswhichchangeobsdata(mapselection)=4
       rem these segments are entire blocks (stairs, teleporters, large central blocking things)
       maplines(l,x,y,OBS_CC)=1
      endif
      if segmentswhichchangeobsdata(mapselection)>=5 and segmentswhichchangeobsdata(mapselection)<=9
       rem add walls based on corridor symbols (segment blueprint MODE)
       rem 3=straight (5)
       if segmentswhichchangeobsdata(mapselection)=5
        if maporient=0 then maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_WW)=1
        if maporient=1 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_SS)=1
        if maporient=2 then maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_WW)=1
        if maporient=3 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_SS)=1
       endif
       rem 4=corner (6)
       if segmentswhichchangeobsdata(mapselection)=6
        if maporient=0 then maplines(l,x,y,OBS_CC)=2
        if maporient=1 then maplines(l,x,y,OBS_CC)=3
        if maporient=2 then maplines(l,x,y,OBS_CC)=4
        if maporient=3 then maplines(l,x,y,OBS_CC)=5
       endif
       rem 5=tjunction (7)
       if segmentswhichchangeobsdata(mapselection)=7
        if maporient=0 then maplines(l,x,y,OBS_NN)=1
        if maporient=1 then maplines(l,x,y,OBS_EE)=1
        if maporient=2 then maplines(l,x,y,OBS_SS)=1
        if maporient=3 then maplines(l,x,y,OBS_WW)=1
       endif
       rem 6=cross (8)
       if segmentswhichchangeobsdata(mapselection)=8
        rem no walls
       endif
       rem 7=deadend (9)
       if segmentswhichchangeobsdata(mapselection)=9
        if maporient=0 then maplines(l,x,y,OBS_WW)=1 : maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=1
        if maporient=1 then maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_SS)=1
        if maporient=2 then maplines(l,x,y,OBS_WW)=1 : maplines(l,x,y,OBS_EE)=1 : maplines(l,x,y,OBS_SS)=1
        if maporient=3 then maplines(l,x,y,OBS_WW)=1 : maplines(l,x,y,OBS_NN)=1 : maplines(l,x,y,OBS_SS)=1
       endif
      endif
     endif
    endif
 endif
 `
return

_obs_generate:
 `
 rem OBSMAP Structures and Arrays
 OBS_NN=1 : OBS_EE=2 : OBS_SS=3 : OBS_WW=4 : OBS_CC=5 : OBS_DR=6
 dim maplines(layermax,maxx,maxy,OBS_DR)
 dim obs(1,5) : obsindex=0
 `
 rem mark which segments are doors (as they punch through obs walls)
 dim segmentswhichchangeobsdata(segidmaster)
 dim segmentswhichchangeobsdatanowalls(segidmaster)
 for segid=1 to segidmaster
  `
  rem find DOORS
  segmentswhichchangeobsdata(segid)=0
  for tp=0 to segmentprofileheader(segid).partmax
   rem look for segments with CSG punch
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=lower$(segmentprofile(segid,tp).meshname$)
    for n=len(tmeshname$) to 1 step -1
     if mid$(tmeshname$,n)="\" or mid$(tmeshname$,n)="/"
      tmeshname$=right$(tmeshname$,len(tmeshname$)-n)
      if left$(tmeshname$,4)="door"
       rem ALL FPSC DOORS must have 'door' as the first four characters
       rem in order for the maker to punch the doors out of the walls
       if segmentprofileheader(segid).preventai=1
        rem an exception to this is FAKE doors, and crawlspace doors
        rem which have been flagged as not allowing entities to enter
        segmentswhichchangeobsdata(segid)=2
       else
        segmentswhichchangeobsdata(segid)=1
       endif
      else
       if right$(tmeshname$,7)="punch.x"
        rem any other type of CSG punch should not cause a blocking
        rem fill in the obs map (like windows, portholes)
        segmentswhichchangeobsdata(segid)=2
       endif
      endif
     endif
    next n
   endif
  next tp
  rem find STRAIGHT,CORNERS,TJUNC,CROSS,DEADEND
  if segmentprofile(segid).blueprint.mode>=3 and segmentprofile(segid).blueprint.mode<=7
   rem 3=straight (5)
   rem 4=corner (6)
   rem 5=tjunction (7)
   rem 6=cross (8)
   rem 7=deadend (9)
   if segmentprofile(segid).blueprint.mode=3 then segmentswhichchangeobsdata(segid)=5
   if segmentprofile(segid).blueprint.mode=4 then segmentswhichchangeobsdata(segid)=6
   if segmentprofile(segid).blueprint.mode=5 then segmentswhichchangeobsdata(segid)=7
   if segmentprofile(segid).blueprint.mode=6 then segmentswhichchangeobsdata(segid)=8
   if segmentprofile(segid).blueprint.mode=7 then segmentswhichchangeobsdata(segid)=9
  endif
  rem find full BLOCKERS (not covered by above)
  if segmentswhichchangeobsdata(segid)=0
   rem ALL FPSC overlays that are simply large blocking onstructions to
   rem the current layer such as stairs, teleporters, etc
   segmentswhichchangeobsdata(segid)=4
  endif
  `
  rem No Walls Check (floors)
  `if segmentprofile(seg).vis.f<>-1 then show limb obj,segmentprofile(seg).vis.f
  `if segmentprofile(seg).vis.r<>-1 then show limb obj,segmentprofile(seg).vis.r
  tnowalls=1
  if segmentprofile(segid).vis.ctl<>-1 then tnowalls=0
  if segmentprofile(segid).vis.ctr<>-1 then tnowalls=0
  if segmentprofile(segid).vis.cbr<>-1 then tnowalls=0
  if segmentprofile(segid).vis.cbl<>-1 then tnowalls=0
  if segmentprofile(segid).vis.octl<>-1 then tnowalls=0
  if segmentprofile(segid).vis.octr<>-1 then tnowalls=0
  if segmentprofile(segid).vis.ocbr<>-1 then tnowalls=0
  if segmentprofile(segid).vis.ocbl<>-1 then tnowalls=0
  segmentswhichchangeobsdatanowalls(segid)=tnowalls
  `
 next segid
 `
 rem go through entire level map
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    for olay=0 to 1
     if olay=0 then tolaymax=0
     if olay=1
      tolaymax=0 : olayindex=mapolay(l,x,y)
      while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
      dec tolaymax
     endif
     if tolaymax>=0
      for olayti=0 to tolaymax
       if olay=0 then mapid=map(l,x,y) : ismapanoverlay=0
       if olay=1 then mapid=olaylist(olayindex,olayti) : ismapanoverlay=1
       if mapid<>0
        gosub _obs_generate_pertile
       endif
      next olayti
     endif
    next olay
   next x
  next y
 next l
 `
 rem go through level again for door punching / make blockers / etc
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    olay=1
    tolaymax=0 : olayindex=mapolay(l,x,y)
    while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
    dec tolaymax
    if tolaymax>=0
     for olayti=0 to tolaymax
      mapid=olaylist(olayindex,olayti) : ismapanoverlay=2
      if mapid<>0
       gosub _obs_generate_pertile
      endif
     next olayti
    endif
   next x
  next y
 next l
 `
 rem create natural universe lines to confine all AI
 rem only where there are segments on the border (non-voids)
 for l=0 to layermax-1
  for x=0 to maxx-1
   if maplines(l,x,0,0)=1 then maplines(l,x,0,OBS_NN)=1
   if maplines(l,x,39,0)=1 then maplines(l,x,39,OBS_SS)=1
  next x
  for y=0 to maxy-1
   if maplines(l,0,y,0)=1 then maplines(l,0,y,OBS_WW)=1
   if maplines(l,39,y,0)=1 then maplines(l,39,y,OBS_EE)=1
  next y
 next l
 `
return

_obs_processobstacles:
 `
 rem find gaps, and eat them to make obstacle blocks
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    if maplines(l,x,y,0)=0
     rem found a gap
     startx=x
     starty=y
     endx=x
     endy=y
     rem expand X and expand Y
     for scanx=startx to 39
      if maplines(l,scanx,y,0)<>0 then exit
     next scanx
     endx=scanx-1
     for scany=starty to 39
      texit=0
      for scanx=startx to endx
       if maplines(l,scanx,scany,0)<>0 then texit=1 : exit
      next scanx
      if texit=1 then exit
     next scany
     endy=scany-1
     rem fill in
     for scany=starty to endy
      for scanx=startx to endx
       maplines(l,scanx,scany,0)=2
      next scanx
     next scany
     rem convert to obstacle block
     inc obsindex : dim obs(obsindex,5)
     obs(obsindex,0)=1
     obs(obsindex,1)=startx*100
     obs(obsindex,2)=starty*100
     obs(obsindex,3)=(endx+1)*100
     obs(obsindex,4)=(endy+1)*100
     obs(obsindex,5)=l
     rem cancel maplines
     if 1
      for scany=starty to endy
       for scanx=startx to endx
        if scany<39 then maplines(l,scanx,scany+1,OBS_NN)=0
        if scany>0 then maplines(l,scanx,scany-1,OBS_SS)=0
        if scanx>0 then maplines(l,scanx-1,scany,OBS_EE)=0
        if scany<39 then maplines(l,scanx+1,scany,OBS_WW)=0
       next scanx
      next scany
     endif
    endif
   next x
  next y
 next l
 `
 rem find connecting lines and create obstacle strips from them
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    for sides=OBS_NN to OBS_WW
     if maplines(l,x,y,sides)=1
      rem found a line
      startx=x
      starty=y
      endx=x
      endy=y
      rem expand along line
      if sides=OBS_NN or sides=OBS_SS
       for scanx=startx to 39
        if maplines(l,scanx,y,sides)=0 then exit
       next scanx
       endx=scanx-1
      endif
      if sides=OBS_EE or sides=OBS_WW
       for scany=starty to 39
        if maplines(l,x,scany,sides)=0 then exit
       next scany
       endy=scany-1
      endif
      rem cancel maplines and convert to obstacle strip
      for scany=starty to endy
       for scanx=startx to endx
        maplines(l,scanx,scany,sides)=2
       next scanx
      next scany
     inc obsindex : dim obs(obsindex,5)
      obs(obsindex,0)=1
      if sides=OBS_NN
       obs(obsindex,1)=(startx*100)
       obs(obsindex,2)=(starty*100)
       obs(obsindex,3)=(endx+1)*100
       obs(obsindex,4)=(endy*100)+20
      endif
      if sides=OBS_SS
       obs(obsindex,1)=(startx*100)
       obs(obsindex,2)=(starty+1)*100
       obs(obsindex,3)=(endx+1)*100
       obs(obsindex,4)=((endy+1)*100)+20
      endif
      if sides=OBS_EE
       obs(obsindex,1)=((startx+1)*100)
       obs(obsindex,2)=(starty*100)
       obs(obsindex,3)=((endx+1)*100)+20
       obs(obsindex,4)=(endy+1)*100
      endif
      if sides=OBS_WW
       obs(obsindex,1)=(startx*100)
       obs(obsindex,2)=(starty*100)
       obs(obsindex,3)=(endx*100)+20
       obs(obsindex,4)=(endy+1)*100
      endif
      obs(obsindex,5)=l
     endif
    next sides
   next x
  next y
 next l
 `
 rem find corners and create obstacle triangles
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    if maplines(l,x,y,OBS_CC)>=2
     inc obsindex : dim obs(obsindex,5)
     obs(obsindex,0)=maplines(l,x,y,OBS_CC)
     obs(obsindex,1)=(x*100)
     obs(obsindex,2)=(y*100)
     obs(obsindex,3)=(x+1)*100
     obs(obsindex,4)=(y+1)*100
     obs(obsindex,5)=l
    endif
   next x
  next y
 next l
 `
 rem find corners and create obstacle blocks
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    if maplines(l,x,y,OBS_CC)=1
     inc obsindex : dim obs(obsindex,5)
     obs(obsindex,0)=maplines(l,x,y,OBS_CC)
     obs(obsindex,1)=(x*100)
     obs(obsindex,2)=(y*100)
     obs(obsindex,3)=(x+1)*100
     obs(obsindex,4)=(y+1)*100
     obs(obsindex,5)=l
    endif
   next x
  next y
 next l
 `
 rem find all doors and create posts
 for l=choiceoflayer to choiceoflayerend
  for y=0 to 39
   for x=0 to 39
    if maplines(l,x,y,OBS_DR)>0
     if maplines(l,x,y,OBS_DR)=1
      rem north
      inc obsindex : dim obs(obsindex,5)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+0
      obs(obsindex,2)=(y*100)+0
      obs(obsindex,3)=(x*100)+20
      obs(obsindex,4)=(y*100)+20
      obs(obsindex,5)=l
      inc obsindex : dim obs(obsindex,5)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+80
      obs(obsindex,2)=(y*100)+0
      obs(obsindex,3)=(x*100)+100
      obs(obsindex,4)=(y*100)+20
      obs(obsindex,5)=l
     endif
     if maplines(l,x,y,OBS_DR)=2
      rem east
      inc obsindex : dim obs(obsindex,5)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+80
      obs(obsindex,2)=(y*100)+0
      obs(obsindex,3)=(x*100)+100
      obs(obsindex,4)=(y*100)+20
      obs(obsindex,5)=l
      inc obsindex : dim obs(obsindex,5)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+80
      obs(obsindex,2)=(y*100)+80
      obs(obsindex,3)=(x*100)+100
      obs(obsindex,4)=(y*100)+100
      obs(obsindex,5)=l
     endif
     if maplines(l,x,y,OBS_DR)=3
      rem south
      inc obsindex : dim obs(obsindex,5)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+0
      obs(obsindex,2)=(y*100)+80
      obs(obsindex,3)=(x*100)+20
      obs(obsindex,4)=(y*100)+100
      obs(obsindex,5)=l
      inc obsindex : dim obs(obsindex,5)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+80
      obs(obsindex,2)=(y*100)+80
      obs(obsindex,3)=(x*100)+100
      obs(obsindex,4)=(y*100)+100
      obs(obsindex,5)=l
     endif
     if maplines(l,x,y,OBS_DR)=4
      rem west
      inc obsindex : dim obs(obsindex,5)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+0
      obs(obsindex,2)=(y*100)+0
      obs(obsindex,3)=(x*100)+20
      obs(obsindex,4)=(y*100)+20
      obs(obsindex,5)=l
      inc obsindex : dim obs(obsindex,5)
      obs(obsindex,0)=1
      obs(obsindex,1)=(x*100)+0
      obs(obsindex,2)=(y*100)+80
      obs(obsindex,3)=(x*100)+20
      obs(obsindex,4)=(y*100)+100
      obs(obsindex,5)=l
     endif
    endif
   next x
  next y
 next l
 `
return

_obs_getmapvalues:
 `
 rem mapid in
 mapselection    = ( mapid && %11111111111100000000000000000000 ) >> 20
 mapscaler       = ( mapid && %00000000000011110000000000000000 ) >> 16
 mapground       = ( mapid && %00000000000000001100000000000000 ) >> 14
 maprotate       = ( mapid && %00000000000000000011000000000000 ) >> 12
 maporient       = ( mapid && %00000000000000000000110000000000 ) >> 10
 mapsymbol       = ( mapid && %00000000000000000000001111110000 ) >> 4
 maptile         = ( mapid && %00000000000000000000000000001111 )
 `
return

_obs_save:
 `
 if 1
  for t=0 to 19
   tfile$=myownrootdir$+"levelbank\testlevel\map"+str$(t)+".obs"
   if file exist(tfile$)=1 then delete file tfile$
   AI SAVE OBSTACLE DATA t,tfile$
   addfiletocollection(tfile$)
  next t
 else
  tfile$=myownrootdir$+"levelbank\testlevel\map.obs"
  if file exist(tfile$)=1 then delete file tfile$
  if file exist(tfile$+"h")=1 then delete file tfile$+"h"
  save array tfile$,obs()
  open to write 1,tfile$+"h"
   write file 1,obsindex
   write string 1,str$(obsindex)
  close file 1
  gtotalobstaclecount=obsindex
  addfiletocollection(tfile$)
 endif
 `
return

_obs_load:
 `
 rem load OBS data
 `if 1
  for t=0 to 19
   tfile$=myownrootdir$+"levelbank\testlevel\map"+str$(t)+".obs"
   AI LOAD OBSTACLE DATA t,tfile$
   addfiletocollection(tfile$)
  next t
 `else
  `tfile$=myownrootdir$+"levelbank\testlevel\map.obs"
  `open to read 1,tfile$+"h"
  ` read file 1,obsindex
  `close file 1
  `dim obs(obsindex,5)
  `load array tfile$,obs()
  `gtotalobstaclecount=obsindex
 `endif
 `
return

_obs_generateobstacles:
 `
 rem debug
 if obsgeneratenow=0
  set cursor 16,10
  print "OBSTACLE = "+str$(obsindex)
  if inkey$()="0" then viewobslevel=0
  if inkey$()="1" then viewobslevel=1
  if inkey$()="2" then viewobslevel=2
  if inkey$()="3" then viewobslevel=3
  if inkey$()="4" then viewobslevel=4
  if inkey$()="5" then viewobslevel=5
  if inkey$()="6" then viewobslevel=6
  if inkey$()="7" then viewobslevel=7
 endif
 `
 rem create all AI obstacles
 if obsindex>0
  if obsgeneratenow=0 then randomize 42
  for o=1 to obsindex
   if obs(o,0)=1
    if obsgeneratenow=1
     rem create an obstacle to block this hole so entity can avoid it
     ax1#=obs(o,1) : az1#=obs(o,2)*-1 : ax2#=obs(o,3) : az2#=obs(o,4)*-1
     rem it is important to create the obstacle poly in an anti-clockwise direction
     if ax1#>ax2# then sax1#=ax1# : ax1#=ax2# : ax2#=sax1#
     if az1#>az2# then saz1#=az1# : az1#=az2# : az2#=saz1#
     AI Start New Obstacle
     AI Add Obstacle Vertex ax1#,az1#
     AI Add Obstacle Vertex ax1#,az2#
     AI Add Obstacle Vertex ax2#,az2#
     AI Add Obstacle Vertex ax2#,az1#
     AI End New Obstacle obs(o,5),0,0
    else
     if obs(o,5)=viewobslevel
      ink rgb(rnd(255),rnd(255),rnd(255)),0
      bxx=16 : byy=32
      xx1=bxx+(obs(o,1)/5)
      yy1=byy+(obs(o,2)/5)
      xx2=bxx+(obs(o,3)/5)
      yy2=byy+(obs(o,4)/5)
      box xx1/5,yy1/5,xx2/5,yy2/5
      ink rgb(255,255,255),0
     endif
    endif
   endif
   if obs(o,0)>=2 and obs(o,0)<=5
    xx1=obs(o,1) : yy1=obs(o,2)*-1 : xx2=obs(o,3) : yy2=obs(o,4)*-1
    if obs(o,0)=2 then xxa=xx1 : yya=yy1 : xxb=xx2 : yyb=yy1 : xxc=xx1 : yyc=yy2
    if obs(o,0)=3 then xxa=xx1 : yya=yy1 : xxb=xx2 : yyb=yy1 : xxc=xx2 : yyc=yy2
    if obs(o,0)=4 then xxa=xx2 : yya=yy1 : xxb=xx2 : yyb=yy2 : xxc=xx1 : yyc=yy2
    if obs(o,0)=5 then xxa=xx1 : yya=yy1 : xxb=xx2 : yyb=yy2 : xxc=xx1 : yyc=yy2
    if obsgeneratenow=1
     rem it is important to create the obstacle poly in an anti-clockwise direction
     AI Start New Obstacle
     AI Add Obstacle Vertex xxa,yya
     AI Add Obstacle Vertex xxb,yyb
     AI Add Obstacle Vertex xxc,yyc
     AI End New Obstacle obs(o,5),0,0
    else
     if obs(o,5)=viewobslevel
      ink rgb(rnd(255),rnd(255),rnd(255)),0
      bxx=16 : byy=32
      xx1=bxx+(obs(o,1)/5)
      yy1=byy+(obs(o,2)/5)
      xx2=bxx+(obs(o,3)/5)
      yy2=byy+(obs(o,4)/5)
      line xxa,yya,xxb,yyb
      line xxb,yyb,xxc,yyc
      line xxc,yyc,xxa,yya
      ink rgb(255,255,255),0
     endif
    endif
   endif
  next o
 endif
 AI Complete Obstacles
 `
return

rem
rem AGE RATING (MATURE)
rem

_agerating_init:
 `
 rem MATURE has full blood
 bloodmode$="on"
 `
 rem MATURE has full ragdoll no fades
 gosub _physics_ragdollon
 gfadeoutragdolls=0
 `
return

_agerating_handleblood:
 `
 rem MATURE as no decal modification
 `
return

rem
rem PHYSICS SYSTEM
rem

_physics_init:

rem PHYSX Initiaise
gphysicshasbeeninitialised=1
if physxedition=1
 `
 rem Init PHYSC
 gosub _phy_init
 `
else
 `
 rem Init ODE
 ode start : rem set to regular world stepping
 `
 rem X10 graivty stronger
 `switch on gravity after warm-up so entities do not drift down at sraer
 `ode set world gravity physicsgravx#,physicsgravy#,physicsgravz#
 ode set world gravity 0,0,0
 `
 rem 030707 - made ragdolls mode solid by decreasing CFM (need this for ragdolls onyl)
 ode set world cfm 0.000002 : rem this is good for ragdolls who hold their fixed joints
 ode set world erp 0.2 : rem 0.1 soft for ragdolls and crates
 `
endif

rem make physics universe
if object exist(physicsuniverseobj)=1 then delete object physicsuniverseobj
phyunimesh$=myownrootdir$+"levelbank\testlevel\universephy.dbo"
if file exist(phyunimesh$)=0
 load object myownrootdir$+"levelbank\testlevel\universe.dbo",physicsuniverseobj
 make mesh from object physicsuniverseobj,physicsuniverseobj
 convert mesh to vertexdata physicsuniverseobj
 delete object physicsuniverseobj
 make object physicsuniverseobj,physicsuniverseobj,0
 delete mesh physicsuniverseobj
 rem FPSCV104RC9-accelerate loading
 save object phyunimesh$,physicsuniverseobj
else
 load object phyunimesh$,physicsuniverseobj
endif
debugviewtext(321,"Created static geometry for physics universe")
if physxedition=1
 gosub _phy_universe
else
 ode create static triangle mesh physicsuniverseobj
endif
delete object physicsuniverseobj
if physicsproto=1
 load static objects myownrootdir$+"levelbank\testlevel\universe.dbo",0
endif
debugviewtext(322,"Submitted geometry to physics engine")

rem create entity assignments
for e=1 to entityelementmax
 `
 rem Sentinel disables physics for common non-physics items (non-multiplayer)
 entid=entityelement(e).bankindex
 if physicson>0 and gmultiplayergame=0
  rem and promotes others to specific types (1-normal,2-ignorestatic,3-becomestatic)
  rem Weapons, Ammo, Non-Objects, Immobile
  if entityprofile(entid).isweapon<>0 or entityprofile(entid).isammo<>0
   entityelement(e).eleprof.physics=0
  else
   if entityprofile(entid).ischaracter=1
    entityelement(e).eleprof.physics=2
   endif
   if entityelement(e).eleprof.isimmobile=1
    entityelement(e).eleprof.physics=3
   endif
  endif
  if entityelement(e).obj=0
   entityelement(e).eleprof.physics=0
  endif
 else
  rem usually no physics (most made static after loadentities see gamemain)
  entityelement(e).eleprof.physics=0
  rem multiplayer needs 'windows' as physics objects
  if gmultiplayergame=1
   if entityprofile(entid).isweapon=0 and entityprofile(entid).isammo=0 and entityprofile(entid).ischaracter=0
    if entityelement(e).eleprof.isimmobile=1
     entityelement(e).eleprof.physics=3
    endif
   endif
  endif
 endif
 `
 rem Safety trap, can cancel if entity not complete
 if entityelement(e).eleprof.physics<>0
  if entityelement(e).profileobj>0
   if object exist(entityelement(e).profileobj)=0
    entityelement(e).eleprof.physics=0
   endif
  else
   entityelement(e).eleprof.physics=0
  endif
 endif
 `
 rem X10 - 220807 - if multiplayer, characters have no physics
 if gmultiplayergame=1 
  if entityprofile(entid).ischaracter=1
   rem offset to correct position
   offset limb tobj,0,0,0,0
  endif
 endif
 `
 rem apply physics creation of object
 if entityelement(e).eleprof.physics<>0
  rem for physics bodies that have a center of mass, entity positions need altering to reflect correct position
  tobj=entityelement(e).obj
  rem X10 - 070307 - it seens chars need this, so that 
  rem all the other stuff works (bullet ray check, ODE box pos)
  rem X10 removed this in favour of controlling ODE object offset instead
  `if entityelement(e).eleprof.physics<>3
  if entityelement(e).eleprof.physics=1
   if tobj>0
    if object exist(tobj)=1
     tprofileobj=entityelement(e).profileobj
     tadj#=object collision center y(tprofileobj)
     tadj#=tadj#+5 : rem slight adjustment for thin objects that are spit out by physics geom collision
     entityelement(e).y=entityelement(e).y+tadj#
     position object tobj,object position x(tobj),object position y(tobj)+tadj#,object position z(tobj)
    endif
   endif
  endif
  rem create the physics body (if not child spawn entities)
  tspawnhide=0
  if entityelement(e).spawn.leaderid>0
   if entityelement(e).spawn.leader=0
    tspawnhide=1
   endif
  endif
  if tspawnhide=0
   if entityelement(e).spawn.leader=1
    rem spawn master does not need physics object
    gosub _physics_ensurephysicsobjvalid
   else
    rem everything else has physics to create
    gosub _physics_setupewithphysics
   endif
  else
   rem still need to reserve all obj ids with E
   gosub _physics_ensurephysicsobjvalid
  endif
 endif
 `
next e

rem Report progress
debugviewtext(323,"Applied physics settings to dynamic elements")

rem eat any old physics messages
if physxedition=1
 gosub _phy_collisionmessages_eat
else
 while ODE COLLISION MESSAGE EXISTS()
  ODE COLLISION GET MESSAGE
 endwhile
endif

rem shadow light position for global shadow effect
set point light 0,20*100,25*100,-20*100
set ambient light 75

rem no need for dbpro standard collision 'automated' system
SET GLOBAL COLLISION OFF

return

_physics_ensurephysicsobjvalid:
 `
 rem redim new size (takes tobj and e)
 tmax=array count(phyobjele())
 if tobj>tmax
  tmax=tobj
  dim phyobjvelocity#(tmax)
  dim phylasttravelled#(tmax)
  dim phylastfloorstop#(tmax)
  dim phyobjsounding(tmax)
  dim phyobjremove(tmax)
  dim phyobjele(tmax)
  dim phyobjelenudged(tmax)
  dim shadowobj(tmax)
 endif
 rem setup inits
 phyobjvelocity#(tobj)=0
 phylasttravelled#(tobj)=0
 phylastfloorstop#(tobj)=0
 phyobjsounding(tobj)=0
 phyobjremove(tobj)=0
 phyobjele(tobj)=e
 phyobjelenudged(tobj)=0
 shadowobj(tobj)=0
 `
return

_physics_loadmateriallist:
`
rem load material list
tfile$="audiobank\materials\materialdefault.txt"
addfiletocollection(tfile$)
if file exist(rootdir$+tfile$)=1
 `
 rem Load Data from file
 dim data$(999)
 load array rootdir$+tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem load max materials
    tryfield$="materialmax" : if field$=tryfield$ then gmaterialmax=value1 : dim material(gmaterialmax) as materialsettingstype
    `
    rem load material data
    for m=0 to gmaterialmax
     tryfield$="matdesc"+str$(m) : if field$=tryfield$ then material(m).name$=value$
     tryfield$="matwave"+str$(m) : if field$=tryfield$ then material(m).tred0$=value$
     tryfield$="matwaves"+str$(m) : if field$=tryfield$ then material(m).scrape$=value$
     tryfield$="matwavei"+str$(m) : if field$=tryfield$ then material(m).impact$=value$
     tryfield$="matwaved"+str$(m) : if field$=tryfield$ then material(m).destroy$=value$
     tryfield$="matfreq"+str$(m) : if field$=tryfield$ then material(m).freq=value1
     tryfield$="matdecal"+str$(m) : if field$=tryfield$ then material(m).decal$=value$
    next m
    `
   endif
  endif
 next l
 undim data$()
endif
`
rem Fill in material defaults if info lacking
for m=0 to gmaterialmax
 if file exist(rootdir$+material(m).scrape$)=0 then material(m).scrape$=material(m).tred0$
 if file exist(rootdir$+material(m).impact$)=0 then material(m).impact$=material(m).tred0$
 if file exist(rootdir$+material(m).destroy$)=0 then material(m).destroy$=material(m).tred0$
 material(m).tred1$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A1.wav"
 material(m).tred2$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A2.wav"
 material(m).tred3$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A3.wav"
 material(m).tred0$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A4.wav"
 if material(m).freq=0 then material(m).freq=22000
next m
`
rem Load material sounds into memory
tbase=materialsoundoffset
for m=0 to gmaterialmax
 if material(m).name$<>""
  rem load tred sound (all five)
  snd$=material(m).tred0$
  if file exist(rootdir$+snd$)=1
   load 3dsound rootdir$+snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).noise=tbase
   inc tbase
  else
   material(m).noise=0
  endif
  rem load scrape
  snd$=material(m).scrape$
  if file exist(rootdir$+snd$)=1
   load 3dsound rootdir$+snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).scrapeid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).scrapeid=0
  endif
  rem load impact
  snd$=material(m).impact$
  if file exist(rootdir$+snd$)=1
   load 3dsound rootdir$+snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).impactid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).impactid=0
  endif
  rem load destroy
  snd$=material(m).destroy$
  if file exist(rootdir$+snd$)=1
   load 3dsound rootdir$+snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).destroyid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).destroyid=0
  endif
 endif
next m
materialsoundmax=(tbase-1)-materialsoundoffset
`
rem Load decals for materials
for m=0 to gmaterialmax
 material(m).decalid=0
 if material(m).name$<>""
  decal$=material(m).decal$
  gosub _decal_find
  if decalid<0 then decalid=0
  if decalid>0
   material(m).decalid=decalid
   decal(decalid).active=1
  endif
 endif
next m
`
return

_physics_triggermaterialsound:
 `
 rem when trigger, play a material sound
 if tsoundtrigger>0
  sbase=tsoundtrigger
  for tchannels=0 to 4
   ts=sbase+tchannels
   if sound exist(ts)=1
    if sound playing(ts)=0
     playinternalBC3dsound(ts,tsx#,tsy#,tsz#,25.0)
     tsndvolume#=80.0+(tvol#*0.2)
     tsndvolume#=(tsndvolume#/100.0)*soundvolumes(1)
     set sound volume ts,tsndvolume#
     if tspd#>2000 and tspd#<55000 then set sound speed ts,tspd#
     exit
    endif
   endif
  next tchannels
 endif
 `
return

_physics_setupewithphysics:
 tobj=entityelement(e).obj
 if tobj>0
  if object exist(tobj)=1
   tprofileobj=entityelement(e).profileobj
   if tprofileobj>0
    if object exist(tprofileobj)=1
     `
     rem prepare visual alighment for regular physics objects (not floaters or statics)
     if entityelement(e).eleprof.physics=1
      offset limb tprofileobj,0,object collision center x(tprofileobj)*-1,object collision center y(tprofileobj)*-1,object collision center z(tprofileobj)*-1
      offset limb tobj,0,object collision center x(tprofileobj)*-1,object collision center y(tprofileobj)*-1,object collision center z(tprofileobj)*-1
     endif
     set object collision off tobj
     `
     rem ensure entitydriven and pseudo-static start with null rotation
     if entityelement(e).eleprof.physics=2 or entityelement(e).eleprof.physics=3
      rem record object angle before apply physics to object
      entityelement(e).rx=object angle x(tobj)
      entityelement(e).ry=object angle y(tobj)
      entityelement(e).rz=object angle z(tobj)
      rem must ensure default matrix in ODE is unrotated to begin with (RY controls angle)
      yrotate object tobj,0
     endif
     `
     rem physics object is static or dynamic
     if entityelement(e).eleprof.physics=3
      rem static (dynamic response identical to static behaviour)
      if physxedition=1
       gosub _phy_pseudostaticentity
      else
       ode create dynamic box tobj : ode set response tobj,2 : ode set gravity tobj,0
      endif
     else
      `
      rem dynamic character or entity
      if entityprofile(entid).ischaracter=1
       rem X10 -081007 - character as box (slightly smaller than physical object size - top stop jiggle)
       tcharobjsizex#=object size x(tobj,1)*0.8
       tcharobjsizey#=object size y(tobj,1)*0.8
       tcharobjsizez#=object size z(tobj,1)*0.8
       if physxedition=1
         gosub _phy_characterentity
       else
        ode create dynamic box tobj,tcharobjsizex#,tcharobjsizey#,tcharobjsizez#
       endif
      else
       rem entity
       if physxedition=1
        gosub _phy_dynamicentity
       else
        if entityprofile(entid).collisionmode=3
         ode create dynamic cylinder tobj
        else
         if entityprofile(entid).collisionmode=4
          ode create dynamic sphere tobj
         else
          ode create dynamic box tobj
         endif
        endif
       endif
      endif
      if physxedition=1
       rem PHYSX tweaks - none
      else
       rem ODE specific tweaks
       rem X10 - 280907 - for VERY SMALL OBJECTS, new ray cast code to stop them falling through world
       if object size x(tobj)<5 or object size y(tobj)<5 or object size z(tobj)<5
        ode set ray cast tfobj,1
       endif
       rem pre-test code to assign internally (now done in mapeditor)
       entityelement(e).floorposy=object position y(tobj)
       ode set contact fdir1 tobj, entityelement(e).eleprof.phyfriction
       ode set body mass tobj,entityelement(e).eleprof.phyweight
       rem some objects ignore static geom and gravity
       if entityelement(e).eleprof.physics=2 then ode set response tobj,1 : ode set gravity tobj,0
       rem stabalize the object
       ode set linear velocity tobj,0,0,0
       ode set angular velocity tobj,0,0,0
       rem recalc adjustment for objects that must find the floor perfectly
       centx#=ODE GET BODY ADJUSTMENT X(tobj)
       centy#=ODE GET BODY ADJUSTMENT Y(tobj)
       centz#=ODE GET BODY ADJUSTMENT Z(tobj)
       rem FPSCV101 - compensate for character model issues with a hack
       if entityprofile(entid).ischaracter=1
        rem X10 adjustment now done when entity is created/cloned
       else
        rem regular object full XYZ center needed
        offset limb tobj,0,(object collision center x(tprofileobj)*-1)+centx#,(object collision center y(tprofileobj)*-1)+centy#,(object collision center z(tprofileobj)*-1)+centz#
       endif
      endif
     endif
     `
     rem ensure entitydriven and pseudo-static than uses RY for rotation
     if entityelement(e).eleprof.physics=2 or entityelement(e).eleprof.physics=3
      if physxedition=1
       gosub _phy_rotateentity
      else
       ode set body rotation tobj,0,entityelement(e).ry,0
      endif
     endif
     `
    else
     hide object tobj
    endif
   else
    hide object tobj
   endif
  endif
 endif
 rem redim new size and init vars
 gosub _physics_ensurephysicsobjvalid
return

_physics_pushusingtvelandangle:
 `
 tobj=entityelement(e).obj
 if tobj>0
  if object exist(tobj)=1
   rem only for regular physics objects, not entitydriven characters, or statics (doors)
   if entityelement(e).eleprof.physics=1
    if physxedition=1
     gosub _phy_dynamicvelocity
    else
     tvel#=tvel*2.0
     if tvel<>0
      tvelx#=newxvalue(0,entityelement(e).ry,tvel#)
      tvelz#=newzvalue(0,entityelement(e).ry,tvel#)
      tangle#=sin(tangle)*tvel#
      tvelx#=tvelx#*cos(tangle)
      tvelz#=tvelz#*cos(tangle)
      ode set linear velocity tobj,tvelx#,tangle#,tvelz#
     endif
     if entityelement(e).eleprof.rotatethrow<>0
      trotate#=entityelement(e).eleprof.rotatethrow/10.0
      ode set angular velocity tobj,trotate#,0,trotate#
     endif
    endif
   endif
  endif
 endif
 `
return

_physics_switchoffe:
 `
 ttobj=entityelement(e).obj
 if ttobj>0
  if object exist(ttobj)=1
   if entityelement(e).eleprof.physics<>0
    if shadowobj(ttobj)=1
     set shadow shading off ttobj
     shadowobj(ttobj)=0
    endif
    if physxedition=1
     gosub _phy_removeentity
    else
     ode destroy object ttobj
    endif
    rem restore rotation of object (ode influence deleted)
    tentid=entityelement(e).bankindex
    if entityprofile(tentid).noragdoll=1
     rem V110 - 120210 - in restoring throw anims, final resting angle needed fixing
     rotate object ttobj,entityelement(e).rx,entityelement(e).ry+180,entityelement(e).rz
    else
     rotate object ttobj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
    endif
    rem X10 also reset player gravity flag in case important ODE change means player change
    if physxedition=1
     rem PHYSX requires no reset
    else
     if object exist(physicsplayerborble)=1
      ode set active physicsplayerborble,1
      ode set gravity physicsplayerborble,1     
      phytotalmotioncount=0
      physuspendgravity=0
     endif
    endif
   endif
  endif
 endif
 `
return

_physics_ensureeisnotpenetrated:
 rem performed when physics object activates its presence (COLON)
 if physxedition=1
  rem PHYSX not needed
 else
  rem ODE stability tweak
  todee=e : todeobj=entityelement(e).obj
  for tte=1 to entityelementmax
   ttobj=entityelement(tte).obj
   if entityelement(tte).eleprof.physics<>0 and ttobj>0
    ttdy#=object position y(ttobj)-object position y(todeobj)
    if abs(ttdy#)<250
     rem if Ys close enough, do complete distance test
     ttdx#=object position x(ttobj)-object position x(todeobj)
     ttdz#=object position z(ttobj)-object position z(todeobj)
     ttdd#=sqrt(abs(ttdx#*ttdx#)+abs(ttdz#*ttdz#)+abs(ttdy#*ttdy#))
     if ttdd#<object size(todeobj)+object size(ttobj)
      rem give a nudge so it uses its own physics body to work out how to get out (brutal but efective)
      ode set linear velocity ttobj,0,0.01,0
     endif
    endif
   endif
  next tte
 endif
return

_physics_playerborble:
 `
 rem can call this to force player to camerapositionx,y,z
 rem borble that rattles around inside player ellipse
 phycrouched#=10.0 : phystood#=40.0
 phycrouchedellipsevolumesize#=0.25
 phystoodellipsevolumesize#=1.0
 if crouchmode<>0
  rem V110 - 190110 - handle starting player physics in crouch mode
  ellipsevolumesize#=phycrouchedellipsevolumesize#
  phyeyeheight#=phycrouched#
 else
  ellipsevolumesize#=phystoodellipsevolumesize#
  phyeyeheight#=phystood#
 endif
 ctx#=camerapositionx
 cty#=camerapositiony
 ctz#=camerapositionz
 `
 rem PHYSX or ODE
 if physxedition=1
  `
  rem PHYSX prepare object and physics for player
  if object exist(physicsplayerborble)=1
   gosub _phy_plr_delete
   delete object physicsplayerborble
  endif
  make object box physicsplayerborble,20,75,20
  color object physicsplayerborble,rgb(255,255,0)
  set object collision off physicsplayerborble
  position object physicsplayerborble,camerapositionx,(camerapositiony-phyeyeheight#)+1,camerapositionz
  if physicsdebug=1
   set object wireframe physicsplayerborble,1
   set object cull physicsplayerborble,0
  else
   hide object physicsplayerborble
  endif
  gosub _phy_plr_make
  `
  rem X10 added to keep ode_sounds from crashing
  e=0 : tobj=physicsplayerborble : gosub _physics_ensurephysicsobjvalid
  `
  rem ensure player has default gravity
  physuspendgravity=0
  phytotalmotioncount=0
  phytotalmotion#=0
  `
 else
  `
  rem ODE prepare object and physics for player
  if object exist(physicsplayerborble)=1
   ode destroy object physicsplayerborble
   delete object physicsplayerborble
  endif
  make object sphere physicsplayerborble,38
  color object physicsplayerborble,rgb(255,255,0)
  set object collision off physicsplayerborble
  position object physicsplayerborble,camerapositionx,(camerapositiony-phyeyeheight#)+1,camerapositionz
  if physicsdebug=1
   set object wireframe physicsplayerborble,1
   set object cull physicsplayerborble,0
  else
   hide object physicsplayerborble
  endif
  ode create dynamic sphere physicsplayerborble
  ode set contact fdir1 physicsplayerborble,500
  ode set body mass physicsplayerborble,physicsplayerweight#
  ode set linear velocity physicsplayerborble,0,0,0
  ode set angular velocity physicsplayerborble,0,0,0
  `
  rem X10 added to keep ode_sounds from crashing
  e=0 : tobj=physicsplayerborble : gosub _physics_ensurephysicsobjvalid
  `
  rem ensure player has default gravity
  ode set gravity physicsplayerborble,1
  physuspendgravity=0
  phytotalmotioncount=0
  phytotalmotion#=0
  `
  rem X10 I think the player kept falling through the floor
  rem becuse it was usin gravity when it did not need to
  ode set gravity physicsplayerborble,0
  `
 endif
 `
return

_physics_cleanup:

rem free universe
if physxedition=1
 delete static objects
endif

rem delete physics universe and free ode static collision
if physxedition=1
 gosub _phy_close
else
 ode destroy object physicsuniverseobj
endif
if object exist(physicsuniverseobj)=1
 delete object physicsuniverseobj
endif

rem delete physics player borble
if physxedition=1
 gosub _phy_plr_delete
else
 ode destroy object physicsplayerborble
endif
if object exist(physicsplayerborble)=1
 delete object physicsplayerborble
endif

rem free assignments
for e=1 to entityelementmax
 tobj=entityelement(e).obj
 if tobj>0
  if entityelement(e).eleprof.physics<>0
   if object exist(tobj)=1
    if physxedition=1
     ttobj=tobj : gosub _phy_removeentity
    else
     ode destroy object tobj
    endif
   endif
  endif
 endif
next e

rem end physics
gphysicshasbeeninitialised=0
if physxedition=1
 gosub _phy_close
else
 ode end
endif

rem free material sounds
gosub _physics_deletematerialsounds

return

_physics_startgravityafterwarmup:
 `
 rem entities can be pushed under floor during warmup
 if physxedition=1
  rem not needed for PHYSX
 else
  ode set world gravity physicsgravx#,physicsgravy#,physicsgravz#
 endif
 `
return

_physics_deletematerialsounds:
 `
 rem delete all material sounds
 for s=materialsoundoffset to materialsoundoffset+materialsoundmax
  if sound exist(s)=1 then delete sound s
 next s
 `
return

`
` Player Controls
`

_physics_unmark:
 `
 rem remove player from viscol prior to movement (use vis from write state)
 tx=viscx#/25 : ty=viscy#/100 : tz=viscz#/-25 : tty=ty
 if gmultiplayergame=1
  if ty>=0 and ty<=viscoly
   if tx>=0 and tz>=0
    if tx<=viscolx and tz<=viscolz
     if viscolmap(tx,ty,tz)=-1 then viscolmap(tx,ty,tz)=0
    endif
   endif
  endif
 else
  if tty>=0 and tty<=viscoly
   for ttx=tx-1 to tx+1
    for ttz=tz-1 to tz+1
     if ttx>=0 and ttz>=0
      if ttx<=viscolx and ttz<=viscolz
       if viscolmap(ttx,tty,ttz)=-1 then viscolmap(ttx,tty,ttz)=0
      endif
     endif
    next ttz
   next ttx
  endif
 endif
 `
return

_physics_mark:
 `
 rem place viscol data back after player movement
 tx=camerapositionx/25 : ty=camerapositiony/100 : tz=camerapositionz/-25 : tty=ty
 if gmultiplayergame=1
  if ty>=0 and ty<=viscoly
   if tx>=0 and tz>=0
    if tx<=viscolx and tz<=viscolz
     if viscolmap(tx,ty,tz)=0 then viscolmap(tx,ty,tz)=-1
    endif
   endif
  endif
 else
  if tty>=0 and tty<=viscoly
   for ttx=tx-1 to tx+1
    for ttz=tz-1 to tz+1
     if ttx>=0 and ttz>=0
      if ttx<=viscolx and ttz<=viscolz
       if viscolmap(ttx,tty,ttz)=0 then viscolmap(ttx,tty,ttz)=-1
      endif
     endif
    next ttz
   next ttx
  endif
 endif
 viscx#=camerapositionx : viscy#=camerapositiony : viscz#=camerapositionz
 `
return

_physics_playerrelocations:
 `
 rem handle lift mechanism for player
 if meridinglift<>0
  tobj=entityelement(meridinglift-1).obj
  rem X10 - 081007 - if underwater, and lift not moved, do not other holding player put
  tokay=1
  if waterisbelowplayer=2
   if meridingliftlastypos<>0
    if int(object position y(tobj))=int(meridingliftlastypos)
     tokay=0
    endif
   endif
   meridingliftlastypos=object position y(tobj)
  endif
  if tokay=1
   meridinglifty#=object position y(tobj)+60
   tmex#=camerapositionx : tmey#=camerapositiony : tmez#=camerapositionz
   tdstx#=object position x(tobj)-tmex#
   tdstz#=object position z(tobj)-tmez#
   tdstt#=sqrt(abs(tdstx#*tdstx#)+abs(tdstz#*tdstz#))
   position camera playercam,camerapositionx,meridinglifty#,camerapositionz
   camerapositionx=camera position x(playercam)
   camerapositiony=camera position y(playercam)
   camerapositionz=camera position z(playercam)
   gosub _physics_playerborble
   if tdstt#>90
    meridinglift=0
   endif
   grav#=0 : gravlasty#=tmey#
  endif
 else
  rem reset ypos if no association with lift
  meridingliftlastypos=0
 endif
 `
 rem handle transporter mechanism for player
 if meridingtransporter=1
  rem player coord moved to new location, must deactivate camera collision for movement
  position camera playercam,tranmex#,tranmey#,tranmez#
  rotate camera playercam,0,tranmeangley#,0
  lastcamangx#=camera angle x(playercam)
  lastcamangy#=camera angle y(playercam)
  cx#=camera position x(playercam) : cy#=camera position y(playercam) : cz#=camera position z(playercam)
  cox#=cx# : coy#=cy# : coz#=cz#
  camerapositionx=camera position x(playercam)
  camerapositiony=camera position y(playercam)
  camerapositionz=camera position z(playercam)
  gosub _physics_playerborble
  meridingtransporter=0
 endif
 if memovingx#<>0.0
  memovingx#=0.0
 endif
 if memovingy#<>0.0
  memovingy#=0.0
 endif
 if memovingz#<>0.0
  memovingz#=0.0
 endif
 `
return

_physics_ensurephysicsisreset:
 `
 rem ensure physics has been reset when game loop begins
 if gphysicshasbeeninitialised=1
  if physxedition=1
   gosub _phy_update
  else
   ode update 0.001
  endif
 endif
 `
return

_physics_playercamera:

rem Camera in control of player one
plrid=1

rem Key configuration
if gtestgamemodefromeditor=1
 rem Preset TEST GAME Keys
 plrkeyW=17
 plrkeyA=30
 plrkeyS=31
 plrkeyD=32
 plrkeyQ=16
 plrkeyE=18
 plrkeyC=46
 plrkeyZ=44
 plrkeyR=19
 plrkeySPACE=57
 plrkeyRETURN=28
 plrkeySHIFT=42
 plrkeyF12=88
else
 rem from BUILD GAME config keys
 plrkeyW=listkey(1)
 plrkeyS=listkey(2)
 plrkeyA=listkey(3)
 plrkeyD=listkey(4)
 plrkeySPACE=listkey(5)
 plrkeyC=listkey(6)
 plrkeyRETURN=listkey(7)
 plrkeyR=listkey(8)
 plrkeyQ=listkey(9)
 plrkeyE=listkey(10)
 plrkeySHIFT=listkey(11)
 plrkeyZ=44
 plrkeyF12=88
endif

rem Read keys from config, and use in player control actions
if keystate(plrkeyW)=1 then plrkeyW=1 else plrkeyW=0
if keystate(plrkeyA)=1 then plrkeyA=1 else plrkeyA=0
if keystate(plrkeyS)=1 then plrkeyS=1 else plrkeyS=0
if keystate(plrkeyD)=1 then plrkeyD=1 else plrkeyD=0
if keystate(plrkeyQ)=1 then plrkeyQ=1 else plrkeyQ=0
if keystate(plrkeyE)=1 then plrkeyE=1 else plrkeyE=0
if keystate(plrkeyC)=1 then plrkeyC=1 else plrkeyC=0
if keystate(plrkeyZ)=1 then plrkeyZ=1 else plrkeyZ=0
if keystate(plrkeyR)=1 then plrkeyR=1 else plrkeyR=0
if keystate(plrkeySPACE)=1 then plrkeySPACE=1 else plrkeySPACE=0
if keystate(plrkeyRETURN)=1 then plrkeyRETURN=1 else plrkeyRETURN=0
if keystate(plrkeySHIFT)=1 then plrkeySHIFT=1 else plrkeySHIFT=0

rem hard coded arrow keys
if upkey()=1 then plrkeyW=1
if leftkey()=1 then plrkeyA=1
if downkey()=1 then plrkeyS=1
if rightkey()=1 then plrkeyD=1

rem Camera old information
ctox#=ctx# : ctoy#=cty# : ctoz#=ctz#

rem camera eye height (eye drops to base of elipse when no health)
if player(plrid).health<=0
 if ellipsevolumesize#=1.0 and (plrkeyC)=0
  phyeyeheight#=phyeyeheight#-1.0
  if phyeyeheight#<10.0 then phyeyeheight#=10.0
 else
  phyeyeheight#=phycrouched#
 endif
endif

rem get latest camera position
camerapositionx=object position x(physicsplayerborble)
camerapositiony=object position y(physicsplayerborble)+phyeyeheight#
camerapositionz=object position z(physicsplayerborble)
realcx#=camerapositionx : realcy#=camerapositiony : realcz#=camerapositionz

rem Umark player pos in viscolmap
gosub _physics_unmark

rem Handle any sudden playe relocations (transportation)
gosub _physics_playerrelocations

rem V109 - 100209 - extra code to handle swimming along surface of water
tnearsurfaceofwater=abs(camera position y(playercam)-waterlevel#)

rem X10 player can swim underwater
`if waterisbelowplayer=2 `V109
if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
 rem underwater
 if physxedition=1
  gosub _phy_plr_gravityoff
 else
  ode set gravity physicsplayerborble,0
 endif
else
 if physxedition=1
  gosub _phy_plr_gravityon
 else
  ode set gravity physicsplayerborble,1
 endif
endif

rem flyforce bleeds into camforce X and Y and Z
if camflyforcex#<0 then tsig=-1 else tsig=1
tamount#=camflyforcex# : if abs(tamount#)>60 then tamount#=60*tsig
camflyforcex#=(camflyforcex#-tamount#)*0.8
camforcex#=camforcex#+tamount#
if camflyforcez#<0 then tsig=-1 else tsig=1
tamount#=camflyforcez# : if abs(tamount#)>60 then tamount#=60*tsig
camflyforcez#=(camflyforcez#-tamount#)*0.8
camforcez#=camforcez#+tamount#

rem All controls when player has health
movement=0
if player(plrid).health>0
 `
 rem Peek controls (and adjustment)
 if ((plrkeyQ)=1 or (plrkeyE)=1) and onladder=0
  if peekfreeze=0
   if (plrkeyQ)=1 and peeklean#>-10.0 then peeklean#=peeklean#-4.0 : movement=1
   if (plrkeyE)=1 and peeklean#<10.0 then peeklean#=peeklean#+4.0 : movement=1
  endif
 else
  peeklean#=curvevalue(0,peeklean#,4.0)
  if abs(peeklean#)<1.0 then peeklean#=0.0 : peekfreeze=0
 endif
 `
 rem Gun Zoom Control
 if gunzoommode>0
  if gunzoommode>=1 and gunzoommode<=8 then inc gunzoommode
  if gunzoommode>=11 and gunzoommode<=19 then inc gunzoommode
  if gunzoommode<10
   plrzoomin#=gunzoommode : plrzoominchange=1
  endif
  if gunzoommode=10
   rem in full zoom
  endif
  if gunzoommode>10
   plrzoomin#=10-(gunzoommode-10) : plrzoominchange=1
  endif
 endif
 `
 rem Handle optical effect of zoom
 if plrzoominchange=1
  if plrzoomin#>1.0
   tresultfov#=75.0-(plrzoomin#*7)-gunzoommag#
   set camera fov playercam,tresultfov#
   if camera exist(2)=1 then set camera fov 2,tresultfov#
   if camera exist(4)=1 then set camera fov 4,tresultfov#
   if camera exist(5)=1 then set camera fov 5,tresultfov#
   if internalzoomhud>0 then hudid=internalzoomhud : hud(hudid).hide=0 : set sprite alpha hudid,(255.0/10.0)*plrzoomin#
  else
   tresultfov#=75.0
   set camera fov playercam,tresultfov#
   if camera exist(2)=1 then set camera fov 2,tresultfov#
   if camera exist(4)=1 then set camera fov 4,tresultfov#
   if camera exist(5)=1 then set camera fov 5,tresultfov#
   if internalzoomhud>0 then hudid=internalzoomhud : hud(hudid).hide=1
  endif
 endif
 plrzoominchange=0
 `
 rem crouch control
 if (plrkeyC)=1
  if crouchmode=0 and onladder=0 and jumpaction=0 then crouchmode=1
 else
  if crouchmode=1 then crouchmode=0
  if crouchmode=2 then crouchmode=3
 endif
 `
 rem Control camera movement
 if crouchmode<>0
  basespeed#=20
 else
  if (plrkeySHIFT)=1
   basespeed#=55
  else
   basespeed#=35
  endif
 endif
 if jumpaction=0
  rem regular speed from manouver
  speed#=basespeed#
 else
  rem fixed speed whilst jumping
  speed#=jumpspeed#
 endif
 `
 rem Movement (forward,backward,strafe)
 camerareachatrun#=0.0
 plrbasespeed#=basespeed#
 if jumpaction=0 then moveroty#=camera angle y(playercam) else moveroty#=jumpangle#
 if onladder=0
  if (plrkeyW)=0 and (plrkeyA)=0 and (plrkeyD)=0 and (plrkeyS)=0
   cameraspeed=0
  endif
  if peeklean#=0.0
   if (plrkeyW)=1
    if (plrkeyA)=1 then dec moveroty#,35
    if (plrkeyD)=1 then inc moveroty#,35
   else
    if (plrkeyS)=1
     if (plrkeyA)=0 and (plrkeyD)=0 then inc moveroty#,180
     if (plrkeyA)=1 then dec moveroty#,145
     if (plrkeyD)=1 then inc moveroty#,145
    else
     if (plrkeyA)=1 then dec moveroty#,90
     if (plrkeyD)=1 then inc moveroty#,90
    endif
   endif
   phyangle#=moveroty#
   if (plrkeyW)=1 or (plrkeyS)=1 or (plrkeyA)=1 or (plrkeyD)=1
    movement=1 : if crouchmode<>0 then movement=2
    tcameraspeed#=speed#*playerspeedratio#*(0.5+(cameradampen#/2.0))
    if cameraspeed<tcameraspeed# then inc cameraspeed,5
    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
   endif
  endif
  if camerareachatrun#<cameraspeed/3.0 then camerareachatrun#=cameraspeed/3.0
  if camerareachatrun#<0 then camerareachatrun#=0
 else
`ladder?
`  phyangle#=moveroty#
`  if (plrkeyW)=1
`   movement=1
`   tcameraspeed#=speed#
`   if cameraspeed<tcameraspeed#
`    inc cameraspeed,5
`    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
`   endif
`  endif
`  if (plrkeyS)=1
`   movement=1 : onladder=0
`   tcameraspeed#=speed#*-1
`   if cameraspeed<tcameraspeed#
`    inc cameraspeed,5
`    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
`   endif
`  endif
 endif
 `
 rem Obtain motion from player borble
 if physxedition=1
  gosub _phy_plr_getmotion
 else
  tmotionx#=ode get body linear velocity x(physicsplayerborble)
  tmotiony#=ode get body linear velocity y(physicsplayerborble)
  tmotionz#=ode get body linear velocity z(physicsplayerborble)
 endif
 `
 rem Only suspend gravity if total movement small
 `if waterisbelowplayer=2 `V109
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  rem no gravity to suspend if underwater
 else
  tmotion#=abs(tmotionx#)+abs(tmotiony#)+abs(tmotionz#)
  phytotalmotion#=phytotalmotion#+tmotion#
  inc phytotalmotioncount
  if phytotalmotioncount>20
   phytotalmotion#=phytotalmotion#/phytotalmotioncount
   if physxedition=1
    if phytotalmotion#<0.15
     physuspendgravity=1
    else
     physuspendgravity=0
    endif
   else
    if phytotalmotion#<10.0
     physuspendgravity=1
    else
     physuspendgravity=0
    endif
   endif
   phytotalmotioncount=0 
   phytotalmotion#=0
  endif
  rem update gravity with current motion
  grav#=tmotiony#
  rem suspend so can stand on slopes/stairs
  if movement<>0 or jumpaction=1 then physuspendgravity=0
  if physuspendgravity=1 or onladder=1
   if physxedition=1
    gosub _phy_plr_gravityoff
   else
    ode set gravity physicsplayerborble,0
   endif
   if physuspendgravity=1 then grav#=0
  else
   if physxedition=1
    gosub _phy_plr_gravityon
   else
    ode set gravity physicsplayerborble,1
   endif
  endif
 endif
 if physicsdebug=1 then print "GRAVITY VALUE=";grav#
 `
 rem movement velocity
 `if waterisbelowplayer=2 `V109
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  rem reduce influence of movement when underwater
  tunderwaterspeed#=timeelapsed#*0.1
  camvelx#=tmotionx#+((newxvalue(0,phyangle#,cameraspeed))*tunderwaterspeed#)
  if (plrkeyS)=1
   camvely#=tmotiony#+((sin(camera angle x(playercam))*cameraspeed*1)*tunderwaterspeed#*2)
  else
   camvely#=tmotiony#+((sin(camera angle x(playercam))*cameraspeed*-1)*tunderwaterspeed#*2)
  endif
  camvelz#=tmotionz#+((newzvalue(0,phyangle#,cameraspeed))*tunderwaterspeed#)
  camvelx#=camvelx#*cos(camera angle x(playercam))
  camvelz#=camvelz#*cos(camera angle x(playercam))
 else
  camvelx#=newxvalue(0,phyangle#,cameraspeed)
  camvely#=grav#
  camvelz#=newzvalue(0,phyangle#,cameraspeed)
 endif
 `
 rem X10 - V109 - 290409 - if you are underwater or swimming on surface
 tallowjumpingnotinwater=1
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  rem no jump action allowed
  tallowjumpingnotinwater=0
  jumpaction=0
 endif
 `
 rem Jump Control
 if onladder=0 and tallowjumpingnotinwater=1
  if player(plrid).health>0  
   if (plrkeySPACE)=1 and jumpaction=0 and meridinglift=0 and crouchmode=0 and jumpactionnorepeat=0 and grav#>-1
    if player(1).jumpheight>0
     jumpspeed#=speed# : jumpangle#=camera angle y(playercam) : leapedlanded=1
     camvely#=0 : camforcey#=player(1).jumpheight*(0.5+(cameradampen#/2.0))
     if physxedition=1
      jumpmotionx#=camvelx#
      jumpmotionz#=camvelz#
      gosub _phy_plr_jump
     else
      jumpmotionx#=tmotionx#
      jumpmotionz#=tmotionz#
     endif
     if playersound(plrid,10)>0
      broadcast3dplrsound(camerapositionx,camerapositiony,camerapositionz,15.0)
      set sound volume playersound(plrid,10),soundvolumes(0)
      play sound playersound(plrid,10)
     endif
     jumpaction=1
     if physxedition=1
      jumpactionnorepeat=50
     else
      jumpactionnorepeat=5
     endif
    endif
   endif
  endif
 endif
 rem X10 - 070409 - track jump action from leap to land 
 if physxedition=1
  if jumpactionnorepeat>0
   if jumpactionnorepeat>45 then dec jumpactionnorepeat
   if jumpactionnorepeat>25 and jumpactionnorepeat<=45 and grav#<0.0 then jumpactionnorepeat=25
   if jumpactionnorepeat>25 and jumpactionnorepeat<=45 then dec jumpactionnorepeat
   if jumpactionnorepeat>0 and jumpactionnorepeat<=25 and grav#>=0.0 then jumpactionnorepeat=0
   if jumpactionnorepeat>0 and jumpactionnorepeat<=25 then dec jumpactionnorepeat
   if jumpactionnorepeat=0 then jumpaction=0
  endif
 else
  if jumpactionnorepeat>0
   if jumpactionnorepeat>1 then dec jumpactionnorepeat
   if jumpactionnorepeat=1 and grav#<0 then jumpactionnorepeat=0
  endif
 endif
 if jumpaction<>0
  camvelx#=jumpmotionx# : camvelz#=jumpmotionz#
 endif
 `
 rem and apply any force here
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  camvelx#=(camvelx#+camforcex#)/1.1 : camforcex#=0
  camvely#=(camvely#+camforcey#)/1.1 : camforcey#=0
  camvelz#=(camvelz#+camforcez#)/1.1 : camforcez#=0
 else
  camvelx#=camvelx#+camforcex# : camforcex#=0
  camvely#=camvely#+camforcey# : camforcey#=0
  camvelz#=camvelz#+camforcez# : camforcez#=0
 endif
 `
else
 `
 rem player has no health
 cameraspeed=0
 camvelx#=0 : camforcex#=0
 camvely#=0 : camforcey#=0
 camvelz#=0 : camforcez#=0
 movement=0
 grav#=0
 `
endif

rem Is player moving or not
player(plrid).state.moving=movement

rem Mark player position is viscolmap
gosub _physics_mark

return

`leetimestamp as DWORD
`leetimeshow as DWORD
`leetime as DWORD
`leetime1 as DWORD
`leetime2 as DWORD
`leetimec as DWORD

_physics_playeraftermove:

rem Camera in control of player one (unmark as slide may change pos)
plrid=1
gosub _physics_unmark
movement=player(plrid).state.moving

rem Collisions
colmaterialtype=-1
tgravitydefeated=0

rem Check for physicsobjects collisions (and perform physics collision sounds)
`x9 optimize ODE so not as many triggers are added to stack so
`we can speed up this bit considerably
rem x10 try again now fixed while drain
gosub _physics_sounds

rem control player interaction
if gmultiplayergame=1 then gosub _multi_plrradial

rem Special Get Out of Jail Free collision key
if inkey$()<>"K" then tkickout=0
if inkey$()="K" and tkickout=0
 if playertrailmax>0
  trailx#=playertrial(playertrailmax).x
  traily#=playertrial(playertrailmax).y
  trailz#=playertrial(playertrailmax).z
  dec playertrailmax : if playertrailmax<1 then playertrailmax=100
  if playertrial(playertrailmax).time=0
   inc playertrailmax : if playertrailmax>100 then playertrailmax=1
  else
   camerapositionx=trailx#
   camerapositiony=traily#+phyeyeheight#
   camerapositionz=trailz#
   position camera playercam,camerapositionx,camerapositiony,camerapositionz
   cx#=camera position x(playercam) : cy#=camera position y(playercam) : cz#=camera position z(playercam)
   cox#=cx# : coy#=cy# : coz#=cz#
   gosub _physics_playerborble
   meridingtransporter=0
   meridinglift=0
  endif
 endif
 tkickout=1
endif

rem Ellipse Collision with static scene
if deactivatecollision=0 and skipcol=0
 `
 rem check ellipse against movement
 ctx#=camerapositionx+(camvelx#/4.0)
 `if waterisbelowplayer=2 `V109
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  cty#=camerapositiony+(camvely#/4.0)
 else
  cty#=camerapositiony
 endif
 ctz#=camerapositionz+(camvelz#/4.0)
 rem check if can rouch down from stood
 if crouchmode=1
  if static volume(ctox#,ctoy#-28,ctoz#,ctx#,(cty#-28)-15,ctz#,0.25)=1
   if physicsdebug=1 then print "willgetstyckifcrouch"
  else
   ellipsevolumesize#=phycrouchedellipsevolumesize#
   phyeyeheight#=phycrouched#
   cty#=camerapositiony-12
   ctoy#=ctoy#-12
   crouchmode=2
  endif
 endif
 rem check if can stand up from crouch
 if crouchmode=3
  if static volume(ctox#,(ctoy#-9)+5,ctoz#,ctx#,(cty#-9)+40+5,ctz#,0.25)=1
   if physicsdebug=1 then print "willhitheadifgetup"
  else
   ellipsevolumesize#=phystoodellipsevolumesize#
   phyeyeheight#=phystood#
   cty#=camerapositiony+30+5
   ctoy#=ctoy#+30+5
   crouchmode=0
  endif
 endif
 rem determine center of ellipse (crouch and stood) (need contact with floor=walksound)
 if phyeyeheight#=phystood# then ellipsecentery#=35 else ellipsecentery#=23
 `
 rem ellipse test for final player mode (stood or crouch) - only to augment ODE
 rem X10 disable static voluem check (for now)
 if physxedition=0
  if static volume(ctox#,ctoy#-ellipsecentery#,ctoz#,ctx#,cty#-ellipsecentery#,ctz#,ellipsevolumesize#)=1
   if physicsdebug=1 then print "volumecollision"
   adjx#=get static collision x()
   adjy#=get static collision y()
   adjz#=get static collision z()
   colmaterialtype=get static collision value()-1
   sctx#=ctx#
   scty#=cty#
   sctz#=ctz#
   ctx#=ctox#+adjx#
   cty#=ctoy#+adjy#
   ctz#=ctoz#+adjz#
   tstaticfloor=get static collision floor()
   if tstaticfloor=1 and grav#<0 then tgravitydefeated=1
   if jumpaction<>0 and camvely#>5.0 and cty#-scty#<0.0 then camvely#=camvely#*-1 : jumpaction=0
   if abs(ctx#-sctx#)+abs(ctz#-sctz#)>8
    rem event when collision hits something solid (not floor)
    camvelx#=ctx#-camerapositionx
    camvely#=cty#-camerapositiony
    camvelz#=ctz#-camerapositionz
    jumpmotionx#=0 : jumpmotionz#=0 : jumpaction=0
    if cameraspeed>5 then cameraspeed=5
    if camvely#>0 then camvely#=0
    rem wipe out flyforce too as hit something to stop hero
    camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
   endif
  endif
 endif
 `
 rem If gravity defeated by player (ODE)
 thurttheplayerwhenlandhard=0
 if physxedition=1
  `
  rem PHYSX - detect when player lands and if hurts themselves
  if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
   rem no gravity when underwater
  else
   rem gravity effects
   if newlevelobjectivevoid=0
    rem player lands after a jump
    `if (grav#<-60.0 and jumpaction=0) or (grav#<-40.0 and jumpaction<>0)
    if 0
     rem deck plate sound too
     leapedlanded=1
    endif
    rem determine if fall hurt player
    `if cty#<gravlasty#-playerhurtfall
    if 0
     rem avoid hurt when using stairs
     if (abs(camvelx#)+abs(camvelz#)/2.0)<15.0
      tokayhurt=1
     else
      tokayhurt=0
     endif
     if gmultiplayergame=0
      rem cannot hurt by falling in arena game
      if tokayhurt=1
       rem level substantial different from last stood on ground
       thurttheplayerwhenlandhard=1
      endif
     endif
    endif
   endif
  endif
  `
  rem ODE variables not used
  camerastoodonphyobj=0
  tgravitydefeated=0
  `  
 else
  `
  rem ODE - detect when player lands and if hurts themselves
  if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
   rem no gravity tech when underwater
   tgravitydefeated=0
  else
   if tgravitydefeatedbyphy<>0
    rem if object entity driven, player can be moved by it
    if entityelement(tgravitydefeatedbyphye).eleprof.physics=2
     if camerastoodonphyobj=0
      lcamerastoodonphyobjmovingx#=object position x(tgravitydefeatedbyphy)
      lcamerastoodonphyobjmovingz#=object position z(tgravitydefeatedbyphy)
     endif
     camerastoodonphyobj=tgravitydefeatedbyphy
    else
     camerastoodonphyobj=0
    endif
    rem record stood on phy obj
    if jumpactionnorepeat>1
     rem when in jump mode, and touching phyobj, do not interfere with a defeat flag
    else
     tgravitydefeated=1
    endif
   else
    rem when not detect phy obj, keep record until
    if tgravitydefeated=1
     rem stood on static floor (must have walked off phy obj)
     camerastoodonphyobj=0
    endif
   endif
   if camerastoodonphyobj<>0
    if object exist(camerastoodonphyobj)=0 then camerastoodonphyobj=0
   endif
   if camerastoodonphyobj<>0
    rem V110 - 140110 - when riding on antigrav platform, need correct speed!
    `camerastoodonphyobjmovingx#=object position x(camerastoodonphyobj)-lcamerastoodonphyobjmovingx#
    `camerastoodonphyobjmovingz#=object position z(camerastoodonphyobj)-lcamerastoodonphyobjmovingz#
    rem only influence of object beneath player borble
    if object position y(camerastoodonphyobj)<object position y(physicsplayerborble)
     rem V110 - 140110 - when riding on antigrav platform, need correct speed!
     `camvelx#=camvelx#+(camerastoodonphyobjmovingx#*10)
     `camvelz#=camvelz#+(camerastoodonphyobjmovingz#*10)
     if camerastoodrelativecoordinatex#=-1 or jumpaction<>0 or movement<>0
      camerastoodrelativecoordinatex#=mex#-object position x(camerastoodonphyobj)
      camerastoodrelativecoordinatez#=mez#-object position z(camerastoodonphyobj)
     else
      rem work out drift from original stood coordinate to where me is now
      tshouldbex#=object position x(camerastoodonphyobj)+camerastoodrelativecoordinatex#
      tshouldbez#=object position z(camerastoodonphyobj)+camerastoodrelativecoordinatez#
      camvelx#=camvelx#+((tshouldbex#-mex#)*10)
      camvelz#=camvelz#+((tshouldbez#-mez#)*10)
     endif        
    endif
    rem V110 - 140110 - when riding on antigrav platform, need correct speed!
    `lcamerastoodonphyobjmovingx#=object position x(camerastoodonphyobj)
    `lcamerastoodonphyobjmovingz#=object position z(camerastoodonphyobj)
   else
    camerastoodrelativecoordinatex#=-1
   endif
  endif
  if tgravitydefeated=1
   if physicsdebug=1 then print "andgravitydefeated"
   rem a few cycles grace at start of level (avoid urg sound when retstart)
   if newlevelobjectivevoid=0
    rem player lands after a jump
    if (grav#<-60.0 and jumpaction=0) or (grav#<-40.0 and jumpaction<>0)
     rem deck plate sound too
     leapedlanded=1
    endif
    rem determine if fall hurt player
    if cty#<gravlasty#-playerhurtfall
     rem avoid hurt when using stairs
     tokayhurt=0
     if (abs(camvelx#)+abs(camvelz#)/2.0)<15.0
      tokayhurt=1
     else
      rem raycast behind plr (stairs would be there)
      tpmb#=-100.0
      tppx#=newxvalue(camerapositionx,camera angle y(playercam),tpmb#)
      tppz#=newzvalue(camerapositionz,camera angle y(playercam),tpmb#)
      tdst#=static raycast(camerapositionx,camerapositiony-phyeyeheight#,camerapositionz,tppx#,camerapositiony-phyeyeheight#,tppz#)
      if tdst#=0 then tokayhurt=1
     endif
     if gmultiplayergame=0
      rem cannot hurt by falling in arena game
      if tokayhurt=1
       rem level substantial different from last stood on ground
       tdamage=1+((abs(cty#-gravlasty#)-playerhurtfall)/5.0)
       thurttheplayerwhenlandhard=tdamage
      endif
     endif
    endif
   endif
   rem record last ground player stood on
   gravlasty#=cty#
   rem landing sound
   jumpaction=0
  else
   if movement<>0 then onladder=0
  endif
 endif
 `
 rem Trigger player hurt damage
 if thurttheplayerwhenlandhard>0
  rem player urg sound
  if playersound(plrid,11)>0
   broadcast3dplrsound(camera position x(playercam),camera position y(playercam),camera position z(playercam),10.0)
   set sound volume playersound(plrid,11),soundvolumes(0)
   play sound playersound(plrid,11)
  endif
  rem player takes damage
  tdamage=thurttheplayerwhenlandhard
  gosub _player_takedamage
  thurttheplayerwhenlandhard=0
 endif
 `
 rem Jump ends when camera starts decending
 rem X10 and build enough speed to defeat auto-deactivate of physics
 if physxedition=1
  if camvely#<0.0 then jumpaction=0
 else
  if camvely#<-25.0 then jumpaction=0
 endif
 `
 rem debug object
 if physicsdebug=1
  if object exist(98789)=0
   make object sphere 98789,20
   set object cull 98789,0
   set object wireframe 98789,1
   set object collision off 98789
  else
   position object 98789,ctx#,cty#-ellipsecentery#,ctz#
   scale object 98789,100,300*ellipsevolumesize#,100
  endif
 endif
 `
endif

rem ladder control
if onladder=1
` rem climb ladder mode
` cx#=onladderx# : cz#=onladderz#
` if movement<>0
`  grav#=camera angle x()/10.0
`  if grav#<-3.0 then grav#=-3.0
`  if grav#>3.0 then grav#=3.0
` else
`  grav#=0.0
` endif
` rem ladder grasp will kill jump action
` jumpaction=0
endif

rem new barrier code using physics force
if ctx#<25.0 then camvelx#=10.0
if ctz#>-25.0 then camvelz#=-10.0
if ctx#>(maxx*100.0)-25 then camvelx#=-10.0
if ctz#<(maxy*-100.0)+25 then camvelz#=10.0

rem Only if not ghost or fly
if gghostrunmode=0 and gcameraflymode=0
 `
 rem Camera rotation speeds
 if showgamemenu=0
  if debugviewmode=0 or (debugviewmode=1 and x10effectmenudata.tmouselook=1)
   rem X10 also uses mouse when in TAB debug X10 effecte menu 'debugviewmode'
   cammovex#=mousemovex() : cammovey#=mousemovey()
  else
   cammovex#=0 : cammovey#=0
  endif
 else
  cammovex#=0 : cammovey#=0
 endif
 if gdisablecamerasmoothing=1
  rem V109 - 100209 - new mode to skip the camera smoothing system (for min.spec PCs)
  rem and see below as well
  camrotspeed#=0.25
 else
  energyofmovement#=abs(cammovex#)+abs(cammovey#)
  t=energyofmovement#
  if t=1 then camrotspeed#=0.05
  if t=2 then camrotspeed#=0.1
  if t=3 then camrotspeed#=0.15
  if t=4 then camrotspeed#=0.2
  if t>=5 then camrotspeed#=0.25
 endif
 if plrzoomin#>0 then camrotspeed#=camrotspeed#/plrzoomin#
 `
 rem Control camera view (even when no health)
 `camangx#=camera angle x(playercam)+((cammovey#*camrotspeed#)) `smoothing code below
 `camangy#=camera angle y(playercam)+((cammovex#*camrotspeed#))
 camangx#=lastcamangx#+((cammovey#*camrotspeed#))
 camangy#=lastcamangy#+((cammovex#*camrotspeed#))
 rem FPSXCV104RC5 - zoom mode wobble based on accuracy
 if plrzoomin#<>0.0
  plrzoomaccuracyangle#=wrapvalue(plrzoomaccuracyangle#+((2+rnd(4)+(11-plrzoomin#))/10.0))
  camangx#=camangx#+cos(plrzoomaccuracyangle#*2.0)*plrzoomaccuracy#*plrzoomin#*0.008*(sin(plrzoomaccuracyangle#)*1.2)
  camangy#=camangy#+sin(plrzoomaccuracyangle#*4.0)*plrzoomaccuracy#*plrzoomin#*0.005
 endif
 camangxweight#=85*cameradampen#
 if wrapvalue(camangx#)>85 and wrapvalue(camangx#)<180 then camangx#=85.0
 if wrapvalue(camangx#)>180 and wrapvalue(camangx#)<360-camangxweight# then camangx#=camangxweight#*-1
 `
 rem used to swoosh to an angle (picking up object off-center)
 if camturntofacemode>0
  camangy#=curveangle(camturntoface#,camangy#,10.0)
  dec camturntofacemode
 endif
 `
 rem X10 - 011107 - Record last camera angles minus smoothing
 lastcamangx#=camangx# : lastcamangy#=camangy#
 `
 rem X10 - 011107 - camera smoothing lowers response time, but looks nice
 rem so only use this on a value so we can alter it based on users requirements
 if gdisablecamerasmoothing=1
  rem V109 - 100209 - new mode to skip the camera smoothing system (for min.spec PCs)
  smoothcamera#=1.0
 else
  smoothcamera#=4.0-(energyofmovement#/15.0)
  if smoothcamera#<1.0 then smoothcamera#=1.0
 endif
 camangx#=curveangle(camangx#,camera angle x(playercam),smoothcamera#)
 camangy#=curveangle(camangy#,camera angle y(playercam),smoothcamera#)
 `
 rem final camera rotation update
 rotate camera playercam,camangx#,camangy#,camera angle z(playercam)
 `
endif

rem Mark player position in viscolmap
gosub _physics_mark

rem leave a trial for any enemies to follow
trailaction=0 : trailx#=camerapositionx : traily#=camerapositiony-phyeyeheight# : trailz#=camerapositionz
gosub _player_leavetrail

rem apply a visual adjustment to camera
if player(plrid).health>0 and peeklean#<>0.0
 peekadjx#=newxvalue(0,camera angle y(playercam)+90,peeklean#)
 peekadjz#=newzvalue(0,camera angle y(playercam)+90,peeklean#)
 if static raycast(camerapositionx,camerapositiony,camerapositionz,camerapositionx+peekadjx#,camerapositiony,camerapositionz+peekadjz#)=0
  camerapositionx=camerapositionx+peekadjx#
  camerapositionz=camerapositionz+peekadjz#
 else
  peekfreeze=1
 endif
endif

rem if sharp upward velocity (20+), and not jump
if jumpaction=0
 if camvely#>10
  rem ensure it is dampened so small floor features not send player high (window/door sills,etc)
  camvely#=10.0
 endif
endif

rem if borble ever leaves camera vicinity (ODE bug) restore
if physicsplayerborble>0
 if physicsdebug=1
  print "camera"
  print "x=";camerapositionx
  print "y=";camerapositiony
  print "z=";camerapositionz
  print
 endif
 if object exist(physicsplayerborble)=1
  if physicsdebug=1
   print "borble"
   print "x=";object position x(physicsplayerborble)
   print "y=";object position y(physicsplayerborble)
   print "z=";object position z(physicsplayerborble)
   print
   print "volume"
   print "x=";ctx#
   print "y=";cty#
   print "z=";ctz#
   print
  endif
  tborbdistx#=abs(object position x(physicsplayerborble)-camerapositionx)
  tborbdisty#=abs(object position y(physicsplayerborble)-camerapositiony)
  tborbdistz#=abs(object position z(physicsplayerborble)-camerapositionz)
  tborbdist1#=sqrt((tborbdistx#*tborbdistx#)+(tborbdisty#*tborbdisty#)+(tborbdistz#*tborbdistz#))
  if physicsdebug=1
   print "borble distance=";tborbdist1#
  endif
  tborbdistx#=abs(ctx#-camerapositionx)
  tborbdisty#=abs(cty#-camerapositiony)
  tborbdistz#=abs(ctz#-camerapositionz)
  tborbdist2#=sqrt((tborbdistx#*tborbdistx#)+(tborbdisty#*tborbdisty#)+(tborbdistz#*tborbdistz#))
  if physicsdebug=1
   print "volume distance=";tborbdist2#
  endif
  if tborbdist1#>100 or tborbdist2#>100
   if physicsdebug=1
    print "Camera seperated from collision system"
   endif
  endif
 endif
endif

rem apply new velocities for future movement
if player(plrid).health>0
 rem cap these velocities to prevent borble fling away
 if camvelx#<-60 then camvelx#=-60
 if camvelx#>60 then camvelx#=60
` this prevents realistic gravity acceleration for player fall
` if camvely#<-60 then camvely#=-60
` if camvely#>60 then camvely#=60
 if camvelz#<-60 then camvelz#=-60
 if camvelz#>60 then camvelz#=60
 if physxedition=1
  gosub _phy_plr_move
 else
  ode set linear velocity physicsplayerborble,camvelx#,camvely#,camvelz#
  ode set angular velocity physicsplayerborble,0,0,0
 endif
else
 rem ensures player does not slide away after died
 if physxedition=1
  gosub _phy_plr_stop
 else
  ode set linear velocity physicsplayerborble,0,0,0
  ode set angular velocity physicsplayerborble,0,0,0
 endif
endif

rem calculate some simply shake movement
camshakey#=0.0
if abs(camshake#)<>0
 camshakedir=1-camshakedir
 if camshakedir=0
  camshakey#=camshakey#+camshake#
 else
  camshakey#=camshakey#-camshake#
 endif
 if abs(camshake#)<1.0
  camshake#=0.0
 else
  camshake#=camshake#*0.9
 endif
endif

rem arena-eyes adjustment
if gmultiplayergame=1
 if crouchmode=0
  arenaadjustd#=-5.0
 else
  arenaadjustd#=2.0
 endif
else
 arenaadjustd#=0
endif
if movement<>0
 rem X10 - V109 - 180309 - tame head bobble with frame rate indie
 camerawobblespeed=24.0*timeelapsed#
 camerawobble#=wrapvalue(camerawobble#+camerawobblespeed)
 if (plrkeySHIFT)=1
  arenaadjust#=arenaadjustd#+(cos(camerawobble#)*0.50)
 else
  arenaadjust#=arenaadjustd#+(cos(camerawobble#)*0.25)
 endif
else
 arenaadjust#=curvevalue(arenaadjustd#,arenaadjust#,5.0)
 camerawobble#=0.0
endif

remstart
rem finally update camera with smoothing (cty# is absolute staticvolume camypos)
finalcamy#=curvevalue(camerapositiony,camera position y(playercam),2.0)
if finalcamy#>cty#-8 then finalcamy#=cty#-8
if playersystemdisabled=0
 `
 rem X10 - 280907 - basic ghost run camera
 if gghostrunmode=1 or gcameraflymode=1
  `
  rem camera fly mode or ghost mode
  if gcameraflymode=1
   `
   rem entire camera fly mode logic here   
   if ghostrunstage=0
    rem start off at player start marker position
    ghostrunx#=camerapositionx
    ghostruny#=camerapositiony
    ghostrunz#=camerapositionz
    ghostrunrx#=camangx#
    ghostrunry#=camangy#
    ghostrunrz#=camera angle z(playercam)
    ghostrunstage=1
    playercam=4 : rem change playercam to the reflection camera (so it does not move)
   endif
   `
   rem manual control of ghost using camera fly controls
   cammovex#=0 : cammovey#=0
   if showgamemenu=0
    if debugviewmode=0 or (debugviewmode=1 and x10effectmenudata.tmouselook=1)
     cammovex#=mousemovex() : cammovey#=mousemovey()
    endif
   endif
   camrotspeed#=1.0
   ghostrunrx#=camera angle x(5)+((cammovey#*camrotspeed#))
   ghostrunry#=camera angle y(5)+((cammovex#*camrotspeed#))
   moveroty#=ghostrunry#
   cameraspeed=0
   if (plrkeyW)=1
    cameraspeed=2
    if (plrkeyA)=1 then dec moveroty#,35
    if (plrkeyD)=1 then inc moveroty#,35
   else
    if (plrkeyS)=1
     cameraspeed=2
     if (plrkeyA)=0 and (plrkeyD)=0 then inc moveroty#,180
     if (plrkeyA)=1 then dec moveroty#,145
     if (plrkeyD)=1 then inc moveroty#,145
    else
     if (plrkeyA)=1 then dec moveroty#,90 : cameraspeed=2
     if (plrkeyD)=1 then inc moveroty#,90 : cameraspeed=2
    endif
   endif
   camvelx#=newxvalue(0,moveroty#,cameraspeed)
   if (plrkeyW)=1
    camvely#=0-(sin(ghostrunrx#)*cameraspeed)
   else
    if (plrkeyS)=1
     camvely#=sin(ghostrunrx#)*cameraspeed
    else
     camvely#=0
    endif
   endif
   camvelz#=newzvalue(0,moveroty#,cameraspeed)
   ghostrunx#=ghostrunx#+camvelx# : camvelx#=0
   ghostruny#=ghostruny#+camvely# : camvely#=0
   ghostrunz#=ghostrunz#+camvelz# : camvelz#=0
   `
   rem update each cycle
   rotate camera 5,ghostrunrx#,ghostrunry#,ghostrunrz#
   position camera 5,ghostrunx#,ghostruny#,ghostrunz#
   `
  else
   `
   rem entire ghost run logic here (for simplicity)
   if ghostrunstage=0
    rem ghost run starts
    ghostrunx#=camerapositionx
    ghostruny#=camerapositiony
    ghostrunz#=camerapositionz
    ghostrunrx#=camangx#
    ghostrunry#=camangy#
    ghostrunrz#=camera angle z(playercam)
    ghostrunstage=1
   else
    if ghostrunstage=1
     rem ghost run control - get next nearest ghost run marker
     ghostrunmarkerindex=0
     tclosestmarker#=999999
     for e=1 to entityelementlist
      if entityelement(e).active=1
       entid=entityelement(e).bankindex
       if entityprofile(entid).ismarker<>0
        if lower$(entityelement(e).eleprof.name$)="ghost run marker"
         tgrx#=entityelement(e).x-ghostrunx#
         tgry#=(entityelement(e).y+65)-ghostruny#
         tgrz#=entityelement(e).z-ghostrunz#
         tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
         if tgrdist#<tclosestmarker#
          tclosestmarker#=tgrdist#
          ghostrunmarkerindex=e
         endif
        endif
       endif
      endif
     next e
     if ghostrunmarkerindex>0
      rem work out camera rotation speed based on now and then
      tgrx#=entityelement(ghostrunmarkerindex).x-ghostrunx#
      tgry#=(entityelement(ghostrunmarkerindex).y+65)-ghostruny#
      tgrz#=entityelement(ghostrunmarkerindex).z-ghostrunz#
      tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
      trotnow#=wrapvalue(camera angle y(playercam))
      trotdest#=wrapvalue(entityelement(ghostrunmarkerindex).ry)
      trotdifference#=trotdest#-trotnow#
      if trotdifference#>180 then trotdifference#=trotdifference#-360
      if trotdifference#<-180 then trotdifference#=trotdifference#+360
      trotspeedincremental#=trotdifference#/tgrdist#
      rem set for movement to new marker
      entityelement(ghostrunmarkerindex).active=0
      ghostrunstage=2
     else
      rem no more markers - exit this level as a winner
      if triggergameexitfade=0
       triggergameexitfade=1 : levelwon=1
      endif
      camerapositionx=ghostrunx#
      camerapositiony=ghostruny#
      camerapositionz=ghostrunz#
      ghostrunstage=0
     endif
    endif
    if ghostrunstage=2
     rem ghost run control - move to that marker
     tgrx#=entityelement(ghostrunmarkerindex).x-ghostrunx#
     tgry#=(entityelement(ghostrunmarkerindex).y+65)-ghostruny#
     tgrz#=entityelement(ghostrunmarkerindex).z-ghostrunz#
     tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
     tgrx#=tgrx#/tgrdist#
     tgry#=tgry#/tgrdist#
     tgrz#=tgrz#/tgrdist#
     ghostrunx#=curvevalue(ghostrunx#+(tgrx#*timebasepercycle#*15),ghostrunx#,5.0)
     ghostruny#=curvevalue(ghostruny#+(tgry#*timebasepercycle#*15),ghostruny#,5.0)
     ghostrunz#=curvevalue(ghostrunz#+(tgrz#*timebasepercycle#*15),ghostrunz#,5.0)
     ghostrunry#=curveangle(entityelement(ghostrunmarkerindex).ry-(trotspeedincremental#*tgrdist#),ghostrunry#,3.0)
     if tgrdist#<25
      ghostrunstage=1
     endif
    endif
   endif
   rem finally update player cam with new ghost run position and angle
   if gghostrunmode=1
    rem if still ghost run mode (not cancelled)
    rotate camera playercam,ghostrunrx#,ghostrunry#,ghostrunrz#
    position camera playercam,ghostrunx#,ghostruny#,ghostrunz#
   endif
   `
  endif
  `
 else
  `
  rem regular player camera
  position camera playercam,curvevalue(camerapositionx,camera position x(playercam),2.0),finalcamy#+arenaadjust#+(camshakey#/10.0),curvevalue(camerapositionz,camera position z(playercam),2.0)
  `
 endif
  
endif

rem update listener
gosub _physics_listener

return
remend

rem finally update camera with smoothing (cty# is absolute staticvolume camypos)
finalcamy#=curvevalue(camerapositiony,camera position y(playercam),2.0)
if finalcamy#>cty#-8 then finalcamy#=cty#-8
if playersystemdisabled=0
 `
 rem X10 - 280907 - basic ghost run camera
 if gghostrunmode=1 or gcameraflymode=1
  `
  rem camera fly mode or ghost mode
  if gcameraflymode=1
   `
   rem entire camera fly mode logic here   
   if ghostrunstage=0
    rem start off at player start marker position
    ghostrunx#=camerapositionx
    ghostruny#=camerapositiony
    ghostrunz#=camerapositionz
    ghostrunrx#=camangx#
    ghostrunry#=camangy#
    ghostrunrz#=camera angle z(playercam)
    ghostrunstage=1
    playercam=4 : rem change playercam to the reflection camera (so it does not move)
   endif
   `
   rem manual control of ghost using camera fly controls
   cammovex#=0 : cammovey#=0
   if showgamemenu=0
    if debugviewmode=0 or (debugviewmode=1 and x10effectmenudata.tmouselook=1)
     cammovex#=mousemovex() : cammovey#=mousemovey()
    endif
   endif
   camrotspeed#=1.0
   ghostrunrx#=camera angle x(5)+((cammovey#*camrotspeed#))
   ghostrunry#=camera angle y(5)+((cammovex#*camrotspeed#))
   moveroty#=ghostrunry#
   cameraspeed=0
   if (plrkeyW)=1
    cameraspeed=2
    if (plrkeyA)=1 then dec moveroty#,35
    if (plrkeyD)=1 then inc moveroty#,35
   else
    if (plrkeyS)=1
     cameraspeed=2
     if (plrkeyA)=0 and (plrkeyD)=0 then inc moveroty#,180
     if (plrkeyA)=1 then dec moveroty#,145
     if (plrkeyD)=1 then inc moveroty#,145
    else
     if (plrkeyA)=1 then dec moveroty#,90 : cameraspeed=2
     if (plrkeyD)=1 then inc moveroty#,90 : cameraspeed=2
    endif
   endif
   camvelx#=newxvalue(0,moveroty#,cameraspeed)
   if (plrkeyW)=1
    camvely#=0-(sin(ghostrunrx#)*cameraspeed)
   else
    if (plrkeyS)=1
     camvely#=sin(ghostrunrx#)*cameraspeed
    else
     camvely#=0
    endif
   endif
   camvelz#=newzvalue(0,moveroty#,cameraspeed)
   ghostrunx#=ghostrunx#+camvelx# : camvelx#=0
   ghostruny#=ghostruny#+camvely# : camvely#=0
   ghostrunz#=ghostrunz#+camvelz# : camvelz#=0
   `
   rem update each cycle
   rotate camera 5,ghostrunrx#,ghostrunry#,ghostrunrz#
   position camera 5,ghostrunx#,ghostruny#,ghostrunz#
   `
  else
   `
   rem entire ghost run logic here (for simplicity)
   if ghostrunstage=0
    rem ghost run starts
    ghostrunx#=camerapositionx
    ghostruny#=camerapositiony
    ghostrunz#=camerapositionz
    ghostrunrx#=camangx#
    ghostrunry#=camangy#
    ghostrunrz#=camera angle z(playercam)
    ghostrunstage=1
   else
    if ghostrunstage=1
     rem ghost run control - get next nearest ghost run marker
     ghostrunmarkerindex=0
     tclosestmarker#=999999
     for e=1 to entityelementlist
      if entityelement(e).active=1
       entid=entityelement(e).bankindex
       if entityprofile(entid).ismarker<>0
        if lower$(entityelement(e).eleprof.name$)="ghost run marker"
         tgrx#=entityelement(e).x-ghostrunx#
         tgry#=(entityelement(e).y+65)-ghostruny#
         tgrz#=entityelement(e).z-ghostrunz#
         tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
         if tgrdist#<tclosestmarker#
          tclosestmarker#=tgrdist#
          ghostrunmarkerindex=e
         endif
        endif
       endif
      endif
     next e
     if ghostrunmarkerindex>0
      rem work out camera rotation speed based on now and then
      tgrx#=entityelement(ghostrunmarkerindex).x-ghostrunx#
      tgry#=(entityelement(ghostrunmarkerindex).y+65)-ghostruny#
      tgrz#=entityelement(ghostrunmarkerindex).z-ghostrunz#
      tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
      trotnow#=wrapvalue(camera angle y(playercam))
      trotdest#=wrapvalue(entityelement(ghostrunmarkerindex).ry)
      trotdifference#=trotdest#-trotnow#
      if trotdifference#>180 then trotdifference#=trotdifference#-360
      if trotdifference#<-180 then trotdifference#=trotdifference#+360
      trotspeedincremental#=trotdifference#/tgrdist#
      rem set for movement to new marker
      entityelement(ghostrunmarkerindex).active=0
      ghostrunstage=2
     else
      rem no more markers - exit this level as a winner
      if triggergameexitfade=0
       triggergameexitfade=1 : levelwon=1
      endif
      camerapositionx=ghostrunx#
      camerapositiony=ghostruny#
      camerapositionz=ghostrunz#
      ghostrunstage=0
     endif
    endif
    if ghostrunstage=2
     rem ghost run control - move to that marker
     tgrx#=entityelement(ghostrunmarkerindex).x-ghostrunx#
     tgry#=(entityelement(ghostrunmarkerindex).y+65)-ghostruny#
     tgrz#=entityelement(ghostrunmarkerindex).z-ghostrunz#
     tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
     tgrx#=tgrx#/tgrdist#
     tgry#=tgry#/tgrdist#
     tgrz#=tgrz#/tgrdist#
     ghostrunx#=curvevalue(ghostrunx#+(tgrx#*timebasepercycle#*15),ghostrunx#,5.0)
     ghostruny#=curvevalue(ghostruny#+(tgry#*timebasepercycle#*15),ghostruny#,5.0)
     ghostrunz#=curvevalue(ghostrunz#+(tgrz#*timebasepercycle#*15),ghostrunz#,5.0)
     ghostrunry#=curveangle(entityelement(ghostrunmarkerindex).ry-(trotspeedincremental#*tgrdist#),ghostrunry#,3.0)
     if tgrdist#<25
      ghostrunstage=1
     endif
    endif
   endif
   rem finally update player cam with new ghost run position and angle
   if gghostrunmode=1
    rem if still ghost run mode (not cancelled)
    rotate camera playercam,ghostrunrx#,ghostrunry#,ghostrunrz#
    position camera playercam,ghostrunx#,ghostruny#,ghostrunz#
   endif
   `
  endif
  `
 else
  `
  rem regular player camera
  position camera playercam,curvevalue(camerapositionx,camera position x(playercam),2.0),finalcamy#+arenaadjust#+(camshakey#/10.0),curvevalue(camerapositionz,camera position z(playercam),2.0)
  `
 endif
 `
endif

rem update listener
gosub _physics_listener

return

_physics_listener:
 `
 rem handle player with affecting listener properties (full CPU intense)
 if 0
  position listener camera position x(playercam)/10.0,camera position y(playercam)/10.0,camera position z(playercam)/10.0
  rotate listener 0,camera angle y(playercam),0
 else
  rem quick approx. of listener position (CPU friendly)
  roughx=camera position x(playercam)/10.0 : roughx=(roughx/5)*5
  roughy=camera position y(playercam)/10.0 : roughy=(roughy/5)*5
  roughz=camera position z(playercam)/10.0 : roughz=(roughz/5)*5
  if roughx<>lastroughx or roughy<>lastroughy or roughz<>lastroughz
   lastroughx=roughx : lastroughy=roughy : lastroughz=roughz
   position listener roughx,roughy,roughz
  endif
  `rotate listener 0,camera angle y(0),0  `want my rotspeed back!
  roughaa=camera angle y(playercam)/45.0
  if roughaa<>lastroughaa
   rotate listener 0,roughaa*45,0
   lastroughaa=roughaa
  endif
 endif
 `
return

_physics_playerpickup:

rem Track which object closest
tclosestpickable=0
if tclosestpickable=0
 bestdst#=99999.9 : bestay#=360 : beste=0
 for e=1 to entityelementmax
  if entityelement(e).eleprof.physics=1 and entityelement(e).active=1
   tobj=entityelement(e).obj
   if tobj>0
    if object exist(tobj)=1
     tdx#=object position x(tobj)-camerapositionx
     `V110 - 080110 - shaded entities have HUGE sizey, so remove this factor!
     `tdy#=(object position y(tobj)+(object size(tobj)/2))-camerapositiony
     profileobj=entityelement(e).profileobj
     tdy#=(object position y(tobj)+(object size(profileobj)/2))-camerapositiony
     tdz#=object position z(tobj)-camerapositionz
     td#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     tda#=wrapvalue(atanfull(tdx#,tdz#)-camera angle y(playercam))
     tday#=wrapvalue(atanfull(tdy#,td#)+camera angle x(playercam))
     if tda#>180 then tda#=360-tda#
     if tday#>180 then tday#=360-tday#
     if tda#<15 and tday#<70
      if td#<camerareachmax#
       if entityelement(e).eleprof.phyweight<cameracarryweight#
        if tday#<bestay#
         bestdst#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
         `V110 - 080110 - shaded entities have HUGE sizey, so remove this factor!
         `minsize#=25.0+(object size(tobj)/2)
         profileobj=entityelement(e).profileobj
         minsize#=25.0+(object size(profileobj)/2)
         if bestdst#<minsize# then bestdst#=minsize#
         bestay#=tday# : beste=e : bestang#=atanfull(tdx#,tdz#)
        endif
       endif
      endif
     endif
    endif
   endif
  endif
  print
 next e
 if beste>0
  tclosestpickable=beste
 endif
endif

rem PLR pickup/drop/throw
if camerapickup=1
 if keystate(20)=1 or mouseclick()=2
  if camerapickupkeyrelease=0
   camerapickupkeyrelease=1
   if camerapicked=0
    if tclosestpickable>0
     `
     rem if object being stood on
     bendarm#=0 : armretract#=0
     if camerastoodonphyobj=entityelement(beste).obj
      if physxedition=1
       rem PHYSX - cannot move or pickup object stood on
      else
       rem try to push object away - can eventually pick it up
       thx#=newxvalue(0,camera angle y(playercam),10.0)
       thy#=ode get body linear velocity y(entityelement(beste).obj)
       thz#=newzvalue(0,camera angle y(playercam),10.0)
       ode set linear velocity entityelement(beste).obj,thx#,thy#,thz#
       rem this kicks the object forward to grab it again
       camerapickupkeyrelease=0
       rem realise player might fall - use gravity again
       physuspendgravity=0 : camforcey#=5.0
      endif
     else
      rem if not, pick up the object
      camerareach#=bestdst#
      camturntofacemode=5 : camturntoface#=bestang#
      camerapickedangle#=camturntoface#
      camerapickede=beste : camerapicked=entityelement(camerapickede).obj
      profileobj=entityelement(camerapickede).profileobj
      camerapickedsize=object size(profileobj)
      if cameradampenactive=1
       rem if player must slow down when carrying, dampen is the factor
       cameradampen#=cameracarryweight#/entityelement(camerapickede).eleprof.phyweight
       if cameradampen#<0.1 then cameradampen#=0.1
       if cameradampen#>1.0 then cameradampen#=1.0
      endif
      rem put weapon away
      if gunid<>0 then gunmode=31 : gunselectionafterhide=0
      if physxedition=1
       gosub _phy_plr_pickup
      else
       rem ODE - prepare object for pickup
       ode set body rotation camerapicked,-1,-1,-1 : rem special hack to reset GRAB rotation matrix feature
       ode set body rotation camerapicked,0,0,0
       rem object reduces mess so not pushing other objects around (inc player)
       ode set body mass camerapicked,entityelement(camerapickede).eleprof.phyweight/10.0
       rem player takes on mass of object
       ode set body mass physicsplayerborble,physicsplayerweight#+entityelement(camerapickede).eleprof.phyweight
      endif
      rem ensure new shadow depth created for object that needs to cast 75.depth area
      shadowobj(camerapicked)=2
     endif
     `
    endif
   else
    camerapickeddrop=1
   endif
  endif
 else
  camerapickupkeyrelease=0
 endif
endif
rem if anything hides it, drop it
if camerapicked>0
 if object visible(camerapicked)=0
  camerapickedthrown=0
  cameradampen#=1.0
  cameraholding=0
  camerapicked=0
 endif
endif
if camerapicked>0
 rem work out difference between actual and ideal position
 tdx#=holdx#-object position x(camerapicked)
 tdy#=(holdy#-object position y(camerapicked))-0.75
 tdz#=holdz#-object position z(camerapicked)
 tdd1#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
 rem and work out movement of item by mouse
 tdx#=abs(holdx#-lastholdx#)
 tdy#=abs(holdy#-lastholdy#)
 tdz#=abs(holdz#-lastholdz#)
 tdd2#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
 tmv#=curvevalue(tdd2#,tmv#,10.0)
 if cameraholding=1
  rem if confirmed as carrying
  tdx1#=holdx#-camera position x(playercam)
  tdy1#=holdy#-camera position y(playercam)
  tdz1#=holdz#-camera position z(playercam)
  tdx2#=object position x(camerapicked)-camera position x(playercam)
  tdy2#=object position y(camerapicked)-camera position y(playercam)
  tdz2#=object position z(camerapicked)-camera position z(playercam)
  rem work out difference in angles
  tbendarm1#=atanfull(tdx1#,tdz1#)
  tbendarm#=(atanfull(tdx2#,tdz2#)-tbendarm1#)
  if tdd1#>=2.0
   rem bend arm if resistance between actual and ideal
   if tmv#<1.0 then bendarm#=bendarm#+tbendarm#
   rem retract arm if stress greater than retraction value
   if tdd1#>armretract# then armretract#=tdd1#
  endif
  rem only once held, see if head inside item
  `V110 - 080110 - shaded entities have HUGE sizey, so remove this factor!
  `tamountinside#=object size(camerapicked)-sqrt(abs(tdx2#*tdx2#)+abs(tdy2#*tdy2#)+abs(tdz2#*tdz2#))
  tamountinside#=camerapickedsize-sqrt(abs(tdx2#*tdx2#)+abs(tdy2#*tdy2#)+abs(tdz2#*tdz2#))
  if tamountinside#>0
   if tamountinside#>5 then tamountinside#=5
   if bendarm#<0.0
    bendarm#=bendarm#-(tamountinside#*2)
   else
    bendarm#=bendarm#+(tamountinside#*2)
   endif
  endif
 else
  rem confirm carrying?
  if tdd1#<8.0 then cameraholding=1
 endif
 rem retract arm if carry item into wall/obstacle
 bendreduce#=50.0
 if bendarm#<0 and cammovex#<0 then bendreduce#=50.0+(cammovex#*3)
 if bendarm#>0 and cammovex#>0 then bendreduce#=50.0-(cammovex#*3)
 if bendreduce#<1.0 then bendreduce#=1.0
 bendarm#=curvevalue(0,bendarm#,bendreduce#)
 armretract#=curvevalue(0,armretract#,50.0)
 rem carry
 if physxedition=1
  gosub _phy_plr_carry
 else
  holdangley#=camera angle y(playercam)+bendarm#
  lastholdx#=holdx# : lastholdy#=holdy# : lastholdz#=holdz#
  holdx#=newxvalue(camerapositionx,holdangley#,(camerareach#+camerareachatrun#)-armretract#)
  `holdy#=newxvalue(camerapositiony-(object size(camerapicked)/3.0),0-camera angle x(playercam),(camerareach#+camerareachatrun#)-armretract#)-((entityelement(camerapickede).eleprof.phyweight/100.0)*(1.0-cameradampen#))
  holdy#=newxvalue(camerapositiony-(camerapickedsize/3.0),0-camera angle x(playercam),(camerareach#+camerareachatrun#)-armretract#)-((entityelement(camerapickede).eleprof.phyweight/100.0)*(1.0-cameradampen#))
  holdz#=newzvalue(camerapositionz,holdangley#,(camerareach#+camerareachatrun#)-armretract#)
  tangle#=wrapvalue(camera angle y(playercam)-camerapickedangle#)
  ode set body rotation camerapicked,0,tangle#,0
  bendspeed#=4.0
  tholdforcex#=(holdx#-object position x(camerapicked))*bendspeed#
  tholdforcey#=(holdy#-object position y(camerapicked))*bendspeed#
  tholdforcez#=(holdz#-object position z(camerapicked))*bendspeed#
  rem if arm is bend to far, drop item with zero velocity
  if abs(bendarm#)>50 then camerapickeddrop=1 : tholdforcex#=0 : tholdforcey#=0 : tholdforcez#=0
  ode set linear velocity camerapicked,tholdforcex#,tholdforcey#,tholdforcez#
 endif
 rem set shadow on carried object
 `V110 - 080110 - shaded entities have HUGE sizey, so remove this factor!
 `entityelement(camerapickede).floorposy=camerapositiony-(object size(camerapicked)*3)
 `entityelement(camerapickede).floorposy=camerapositiony-(object size(camerapicked)*3)
 entityelement(camerapickede).floorposy=camerapositiony-(camerapickedsize*3)
 entityelement(camerapickede).floorposy=camerapositiony-(camerapickedsize*3)
 rem throw
 if mouseclick()=1 then camerapickeddrop=1 : camerapickedthrown=1
 rem drop
 if camerapickeddrop=1
  rem restore object and pickup states
  camerapickeddrop=0
  if camerapickedthrown=1
   rem calc throw distance, elevation and final velocity
   throwdistance#=(entityelement(camerapickede).eleprof.phyweight/1000.0)
   rem a limit so small objects do not leave scene
   if throwdistance#<2.0 then throwdistance#=2.0
   tthrowheight#=((camerathrowelev#+sin(camera angle x(playercam))*-100)/throwdistance#)
   throwdistance#=camerathrow#/throwdistance#
   taddx#=camvelx# : taddy#=camvely# : taddz#=camvelz#
   rem X10 control force with restrictor
   tdx#=taddx#+sin(camera angle y(playercam))*throwdistance#
   tdy#=taddy#+tthrowheight#
   tdz#=taddz#+cos(camera angle y(playercam))*throwdistance#
   gosub _physics_limitforce
   if physxedition=1
    gosub _phy_plr_dropvelocity
   else
    ode set linear velocity camerapicked,tdx#,tdy#,tdz#
    if entityelement(camerapickede).eleprof.rotatethrow<>0
     trotate#=entityelement(camerapickede).eleprof.rotatethrow
     ode set angular velocity camerapicked, ((rnd(1)*2.0)-1.0)*trotate#, 0, ((rnd(1)*2.0)-1.0)*trotate#
    endif
   endif
   rem reset throw
   camerapickedthrown=0
  endif
  if physxedition=1
   gosub _phy_plr_dropmass
  else
   rem restore object max
   ode set body mass camerapicked,entityelement(camerapickede).eleprof.phyweight
   rem player restores mass
   ode set body mass physicsplayerborble,physicsplayerweight#
  endif
  rem reset final values for camera pickup
  cameradampen#=1.0
  cameraholding=0
  camerapicked=0
 endif
endif

return

_physics_sounds:
 `
 rem Collision with objects causes borble to change player position
 tgravitydefeatedbyphy=0
 physicscollisionmessage=1
 while physicscollisionmessage=1
  `
  rem get any colliison message
  if physxedition=1
   gosub _phy_getcollisionmessage
  else
   physicscollisionmessage=ODE COLLISION MESSAGE EXISTS()
   if physicscollisionmessage=1
    ODE COLLISION GET MESSAGE
    phya=ODE GET OBJECT A() : phyb=ODE GET OBJECT B()
   endif
  endif
  if physicscollisionmessage<>0
  `
  rem ensure exists (could have been deleted since collisions)
  if phya>0
   if object exist(phya)=0 then phya=0
  endif
  if phyb>0
   if object exist(phyb)=0 then phyb=0
  endif
  `
  if phya>0
   rem X10 keep physics objects alive if they are involved in any contact
   if phyobjelenudged(phya)>0
    phyobjelenudged(phya)=phyobjelenudged(phya)-1
    if physxedition=1
     gosub _phy_nudgeentity
    else
     ode set active phya,1
    endif
   endif
  endif
  if phyb>0
   rem X10 keep physics objects alive if they are involved in any contact
   if phyobjelenudged(phyb)>0
    phyobjelenudged(phyb)=phyobjelenudged(phyb)-1
    if physxedition=1
     gosub _phy_nudgeentity
    else
     ode set active phyb,1
    endif
   endif
  endif
  `
  rem player phyobject stood on another phy object
  if physxedition=1
   rem PHYSX - handles collision with stood-on entities automatically
  else
   tdownward#=0.0 : ttouchedobj=0 : toverallveldiff#=0
   if (phya=physicsplayerborble and phyb<>0) then tdownward#=ODE GET OBJECT A VELOCITY Y() : ttouchedobj=phyb : toverallveldiff#=abs(ODE GET OBJECT B VELOCITY X())+abs(ODE GET OBJECT B VELOCITY Y())+abs(ODE GET OBJECT B VELOCITY Z())
   if (phyb=physicsplayerborble and phya<>0) then tdownward#=ODE GET OBJECT B VELOCITY Y() : ttouchedobj=phya : toverallveldiff#=abs(ODE GET OBJECT A VELOCITY X())+abs(ODE GET OBJECT A VELOCITY Y())+abs(ODE GET OBJECT A VELOCITY Z())
   if ttouchedobj<>0 and ttouchedobj=camerapicked then lastttouchede=ttouchede
   if ttouchedobj<>0 and ttouchedobj<>camerapicked
    ttouchede=phyobjele(ttouchedobj)
    if ttouchede>0
     entid=entityelement(ttouchede).bankindex
     colmaterialtype=entityprofile(entid).materialindex-1
     if tdownward#<2.0
      rem player landed on physics object, so register this and use gravity again
      tgravitydefeatedbyphy=ttouchedobj
      tgravitydefeatedbyphye=ttouchede
      physuspendgravity=0
     endif
     ttspeedatwhichurt#=120.0
     if toverallveldiff#>ttspeedatwhichurt#
      if ttouchede<>lastttouchede
       rem player damage if entity moving at force (uses phyforcedamage)
       tdamage=((toverallveldiff#-ttspeedatwhichurt#)/10.0) : if tdamage<1 then tdamage=1
       magnifydamage#=entityelement(ttouchede).eleprof.phyforcedamage/100.0
       tdamage=tdamage*magnifydamage# : gosub _player_takedamage
       lastttouchede=ttouchede
      endif
     else
      rem object not hitting player any more
      if lastttouchede=ttouchede
       lastttouchede=0
      endif
     endif
    endif
   endif
  endif
  `
  rem sounds processd here too
  bangobj=0
  bangcontact=0
  phyvelocity#=0
  phytotalvelocity#=0
  phyhorizontalscrape=0
  if phya<>0
   bangobj=phya : bangotherobj=phyb
   if physxedition=1
    gosub _phy_getvelocitya
   else
    phyvelocity#=abs(ODE GET OBJECT A VELOCITY X())+abs(ODE GET OBJECT A VELOCITY Y()/4)+abs(ODE GET OBJECT A VELOCITY Z())
    phyvelocity#=phyvelocity#+abs(ODE GET OBJECT A ANGULAR VELOCITY X())+abs(ODE GET OBJECT A ANGULAR VELOCITY Y())+abs(ODE GET OBJECT A ANGULAR VELOCITY Z())
    if bangobj<>physicsplayerborble
     bangcontact=ODE GET OBJECT A CONTACT()
     if bangcontact<>0
      phyfloorstop#=ODE GET OBJECT A VELOCITY Y()
      if phylastfloorstop#(bangobj)<1 and phyfloorstop#>-1
       phyhorizontalscrape=1
      endif
      phylastfloorstop#(bangobj)=phyfloorstop#
     endif
    endif
   endif
   phyvelocitya#=phyvelocity#
   phytotalvelocity#=phytotalvelocity#+phyvelocity#
  else
   phyvelocitya#=0
  endif
  if phyb<>0
   bangobj=phyb : bangotherobj=phya
   if physxedition=1
    gosub _phy_getvelocityb
   else
    phyvelocity#=abs(ODE GET OBJECT B VELOCITY X())+abs(ODE GET OBJECT B VELOCITY Y()/4)+abs(ODE GET OBJECT B VELOCITY Z())
    phyvelocity#=phyvelocity#+abs(ODE GET OBJECT B ANGULAR VELOCITY X())+abs(ODE GET OBJECT B ANGULAR VELOCITY Y())+abs(ODE GET OBJECT B ANGULAR VELOCITY Z())
    if bangobj<>physicsplayerborble
     bangcontact=ODE GET OBJECT B CONTACT()
     if bangcontact<>0
      phyfloorstop#=ODE GET OBJECT B VELOCITY Y()
      if phylastfloorstop#(bangobj)<1 and phyfloorstop#>-1
       phyhorizontalscrape=1
      endif
      phylastfloorstop#(bangobj)=phyfloorstop#
     endif
    endif
   endif
   phyvelocityb#=phyvelocity#
   phytotalvelocity#=phytotalvelocity#+phyvelocity#
  else
   phyvelocityb#=0
  endif
  if bangobj<>0 and bangobj<>physicsplayerborble and bangobj<>camerapicked
   rem impact calcs
   phyimpact#=abs(phyvelocity#-phyobjvelocity#(bangobj))
   phyimpactstop#=phyobjvelocity#(bangobj)-phyvelocity#
   phyobjvelocity#(bangobj)=phyvelocity#
   rem deal with damage of colliding objects
   phymagnitude#=0
   rem ensure player is not a damaging physics object (as stealth may require sliding along windows)
   e1=0 : e1m#=0
   if bangobj>0 and bangobj<>physicsplayerborble
    e1=phyobjele(bangobj)
    if e1<0 then e1=0
    if e>0 then e1m#=entityelement(e1).health*5
   endif
   e2=0 : e2m#=0
   if bangotherobj>0 and bangotherobj<>physicsplayerborble
    e2=phyobjele(bangotherobj)
    if e2<0 then e2=0
    if e>0 then e2m#=entityelement(e2).health*5
   endif
   rem or very weak objects that will break under duress (duress caused by size and speed of fragile object)
   if e1m#>20 then e1m#=20
   if e2m#>20 then e2m#=20
   if bangcontact=1
    if phyvelocitya#>e1m# and e1>0 and entityelement(e1).health<5 then phymagnitude#=11.0+(phyimpactstop#/4.0)
    if phyvelocityb#>e2m# and e2>0 and entityelement(e2).health<5 then phymagnitude#=11.0+(phyimpactstop#/4.0)
   endif
   rem collision with raised velocity
   if phytotalvelocity#>20.0
    if phya<>0 and phyb<>0
     if bangobj=physicsplayerborble or bangotherobj=physicsplayerborble
      rem if window strength 1-4, player CAN smash it through by running into it
      if e1>0 and entityelement(e1).health>=5 then e1=0
      if e2>0 and entityelement(e2).health>=5 then e2=0
     endif
     rem only deal damage to immobile objects (as movable ones can get out the way before damage)
     rem FPSCV104RC7 - moving entities CAN cause damage if damage force high enough
     if e1>0
      magnifydamage#=entityelement(e1).eleprof.phyforcedamage/12.0
      phymagnitude#=magnifydamage#
     endif
     if e2>0
      magnifydamage#=entityelement(e2).eleprof.phyforcedamage/12.0
      if magnifydamage#>phymagnitude#
       phymagnitude#=magnifydamage#
      endif
     endif
    endif
   endif
   `
   rem if bangobj is flak, calc bounce
   tflakindex=0
   if bangobj>0
    if object visible(bangobj)=1
     if bangobj>=flakelementoffset and bangobj<=flakelementoffset+flakelementmax
      tflakindex=phya-flakelementoffset
     endif
     tf=tflakindex
     if tf>array count(flakelement()) then tflakindex=0
    endif
    if tflakindex>0
     rem can now impact and detonate
     tf=tflakindex
     if flakelement(tf).profile.bounceonhit>1
      flakelement(tf).profile.bounceonhit=flakelement(tf).profile.bounceonhit-1
      if flakelement(tf).profile.bounceonhit>1
       tflakid=flakelement(tf).flakid
       rem X10 - 301007 - added object to draw position from
       tttobj=bangobj
       if tttobj>0
        if object exist(tttobj)=1
         playinternal3dsound(flak(tflakid).sound.sndbounceid,object position x(tttobj),object position y(tttobj),object position z(tttobj))
        endif
       endif
      endif
     endif
     if flakelement(tf).profile.bounceonhit<=1
      rem handle explode on hit, when bounce done or no bounce used
      if flakelement(tf).profile.explodeonhit=1 then flakelement(tf).profile.explodeonhit=2
     endif
    endif
   endif
   `
   rem bangobj e
   e=phyobjele(bangobj)
   if e>0
    rem entity profile id
    entid=entityelement(e).bankindex
    rem only deal damage if neither object part of player-carry-collisio n
    if camerapicked>0 and (bangobj=camerapicked or bangotherobj=camerapicked)
     phymagnitude#=0.0
    endif
    rem only allow damage if other object is NOT a debris fragment
    if bangotherobj>0 and bangotherobj<=array count(phyobjele())
     if phyobjele(bangotherobj)=0 then phymagnitude#=0.0
    endif
    rem if magnitude high enough, cause damage
    if phymagnitude#>10.0
     rem damage both objects involved in impact
     tdamage=(phymagnitude#-10.0) : tdamagesource=0 : timpacttype=1
     if tdamage>2 and tdamagebybangcount=0
      rem entity damage here
      tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
      if e1>0 then e=e1 : entid=entityelement(e).bankindex : gosub _entity_deducthealth : tdamagebybangcount=20
      if e2>0 then e=e2 : entid=entityelement(e).bankindex : gosub _entity_deducthealth : tdamagebybangcount=20
     endif
     rem bangobj e refresh
     e=phyobjele(bangobj)
     if e>0
      entid=entityelement(e).bankindex
     endif
    endif
    rem deal with sound
    matindex=entityprofile(entid).materialindex-1
    if matindex>=0 and matindex<=gmaterialmax
     rem monitor travelling value
     ttravelled#=0.0
     if phyhorizontalscrape=1
      rem as long as no sudden stopping, continue travel value for scrape
      if bangobj=phya then ttravelled#=phyvelocitya#
      if bangobj=phyb then ttravelled#=phyvelocityb#
     endif
     rem impact controls volume
     tvol#=100 : rem (phyimpact#-1.0)*10.0 : if tvol#>100.0 then tvol#=100.0
     tspd#=material(matindex).freq+rnd(material(matindex).freq/10.0)
     sbase=0
     rem only play impact if slowed/stopped and was
     if phyimpactstop#>0 and phyimpact#>4.0
      sbase=material(matindex).impactid
     endif
     if ttravelled#>10.0
      if phylasttravelled#(bangobj)>10.0
       rem continuation of travel, switch to scrape
       sbase=material(matindex).scrapeid
       tvol#=ttravelled#*2.0 : if tvol#>100.0 then tvol#=100.0
      endif
     endif
     phylasttravelled#(bangobj)=ttravelled#
     rem play sound of material impact
     if sbase>0
      for tchannels=0 to 4
       s=sbase+tchannels
       if sound exist(s)=1
        if sound playing(s)=0 and phyobjsounding(bangobj)=0
         playinternalBC3dsound(s,object position x(bangobj),object position y(bangobj),object position z(bangobj),25.0)
         phyobjsounding(bangobj)=5
         tsndvolume#=80.0+(tvol#*0.2)
         tsndvolume#=(tsndvolume#/100.0)*soundvolumes(1)
         set sound volume s,tsndvolume#         
         if tspd#>2000 then set sound speed s,tspd#
         exit
        endif
       endif
      next tchannels
     endif
    endif
    if phyimpact#>2.0
     rem adjust entity floor position (for shadow calc)
     entityelement(e).floorposy=object position y(bangobj)-(object size y(bangobj)/2)
     rem recalc adjustment for objects that must find the floor perfectly
     if entityelement(e).eleprof.physics=1
      if physxedition=1
       rem PHYSX can handle small objects, tweak not needed
      else
       rem ODE tweaks
       centx#=ODE GET BODY ADJUSTMENT X(bangobj)
       centy#=ODE GET BODY ADJUSTMENT Y(bangobj)
       centz#=ODE GET BODY ADJUSTMENT Z(bangobj)
       tprofileobj=entityelement(e).profileobj
       offset limb bangobj,0,(object collision center x(tprofileobj)*-1)+centx#,(object collision center y(tprofileobj)*-1)+centy#,(object collision center z(tprofileobj)*-1)+centz#
      endif
     endif
    endif
    if phyobjsounding(bangobj)>0 then phyobjsounding(bangobj)=phyobjsounding(bangobj)-1
   else
    rem (E=0) physics object has no entity (can only be debris particle)
    rem and only if not flak debris
    if tflakindex=0
     `
     rem X10 - 011107 - this is an bug because only BANGOBJ was checked for E=0 (not PHYA/B so it could remove an actual object from the scene unjustly, floating gun issue)
     if bangobj>0 and bangobj<physicsuniverseobj
      if object in screen(bangobj)=0
       rem remove from simulation if not in screen
       `if phyobjele(bangobj)>=0 `should not auto remove an actual physics based obj, just the E=0 ones!
       if phyobjele(bangobj)=0
        rem and only if not guns (which use E=-1)
        if physxedition=1
         ttobj=bangobj : gosub _phy_removeentity
        else
         ode destroy object bangobj
        endif
        hide object bangobj
       endif
      endif
     endif
     `
    endif
   endif
   `
  endif
  endif
  `
 endwhile
 `
 rem Reduce bang damage counter (so bang damage does not machine gun and drain all entity health)
 if tdamagebybangcount>0
  dec tdamagebybangcount
 endif
 `
 rem also handle shadows
 gosub _physics_shadowcontrol
 `
 rem now go through all objects to see how they react in water out of water
 gosub _physics_waterandgravity
 `
return

_physics_shadowcontrol:
 `
 rem also handles physics object destruction within entity element loop
 rem for out of universe error if no debug cursor reset
 if physicsdebug=0 then set cursor 0,0
 `
 rem Number of shadows allowed in scene (performance hit here)
 if gautoshadowreducer=0
  rem Do not use shadow slider, sacrifice performance for all shadows we asked for
  numberofshadowstoshow=hudshadowquantity
 else
  if timer()>shadowquantitysliderpacer+1000
   shadowquantitysliderpacer=timer()
   if screen fps()<60
    if shadowquantityslider>0 then dec shadowquantityslider
   else
    if screen fps()>75
     if shadowquantityslider<hudshadowquantity then inc shadowquantityslider
    endif
   endif
  endif
  numberofshadowstoshow=shadowquantityslider
 endif
 `
 rem work out closest X number of characters for final shadow control
 shadowfadeindistance#=400.0 : rem default point at which shadow fades out
 for e=1 to entityelementmax : entityelement(e).eleprof.castshadow=0 : next e
 countentitiesfightingforshadows=0
 for nsts=1 to numberofshadowstoshow
  theclosestcharactertome#=99999.99
  theclosestcharactertomee=0
  for e=1 to entityelementmax
   tentid=entityelement(e).bankindex
   if entityprofile(tentid).ischaracter=1
    if entityelement(e).eleprof.castshadow=0
     if entityelement(e).plrdist<theclosestcharactertome#
      theclosestcharactertome#=entityelement(e).plrdist
      theclosestcharactertomee=e
     endif
     if nsts=numberofshadowstoshow
      if entityelement(e).plrdist<400.0
       inc countentitiesfightingforshadows
      endif
     endif
    endif
   endif
  next e
  if theclosestcharactertomee>0
   e=theclosestcharactertomee
   entityelement(e).eleprof.castshadow=1
   if nsts=numberofshadowstoshow and countentitiesfightingforshadows>numberofshadowstoshow
    rem there are more characters than shadow resources within range, so
    rem reduce shadow fade in distance so hide the popping
    shadowfadeindistance#=theclosestcharactertome#
    if shadowfadeindistance#>400.0 then shadowfadeindistance#=400.0
    if shadowfadeindistance#<100.0 then shadowfadeindistance#=100.0
   endif
  endif
 next nsts
 `
 rem slowly curve the shadow fade in distance for graceful shadow LOD
 if int(shadowfadeindistance#)<>int(shadowfadeindistancea#)
  shadowfadeindistancea#=curvevalue(shadowfadeindistance#,shadowfadeindistancea#,10.0)
 endif
 `
 rem adjust shadows of all physics objects
 yesyes=0
 for e=1 to entityelementmax
  `
  rem get entity element
  tobj=entityelement(e).obj
  tflag=0 : tentid=entityelement(e).bankindex
  if tobj>0 then tflag=1
  if tflag=1
   `
   rem X10 shadow control (shows non-char & character shadows close to player, blob the rest
   tobjshadowreach#=0.0
   if entityprofile(tentid).ischaracter=0
    rem non character shadow
    standardfadeinforcrates#=500.0
    `rem ensure only cast shadows on those entities with the flag
    `if entityelement(e).eleprof.castshadow=1 and entityelement(e).plrdist<standardfadeinforcrates# and entityelement(e).active<>0
    if entityelement(e).plrdist<standardfadeinforcrates# and entityelement(e).active<>0
     rem all dynamic entities within range of player
     if entityprofile(tentid).ismarker=0
      if entityprofile(tentid).isimmobile=0
       rem only shadow none markers and dynamic
       if camera position y(playercam)>entityelement(e).y
        tallowshadowtobecreated=1
       else
        tallowshadowtobecreated=0
       endif
       if tallowshadowtobecreated=1
        set shadow shading on tobj,-1,standardfadeinforcrates#,1
        tshadowcastdistance#=500 : set object radius tobj,tshadowcastdistance#
        shadowobj(tobj)=1
       else
        rem 10 - 031007 - switch off shadows which have casters higher than players eye
        set shadow shading off tobj
        shadowobj(tobj)=0
       endif
      endif
     endif
    else
     rem dynamic entities just switch off their shadows after range or inactive
     set shadow shading off tobj
     shadowobj(tobj)=0
    endif
   else
    rem character shadow
    if entityelement(e).eleprof.castshadow=1
     rem only use shadows if entity raycast from player is unobstructed
     rem and that the player is above the base position of the entity (downward casting only)
     rem which resolves shadow artifacts when shadow volume cuts through walls/floors
     if camera position y(playercam)>entityelement(e).y
      tallowshadowtobecreated=1
     else
      tallowshadowtobecreated=0
     endif
     if tallowshadowtobecreated=1
      rem shadows from elements closer than X
      set shadow shading on tobj,-1,shadowfadeindistancea#,1
      rem only hide blob shadow if not experiencing shadow resource fighting
      if countentitiesfightingforshadows<=numberofshadowstoshow
       rem the reason is that even though real shadow used, it can be faint!
       shadowobj(tobj)=1
      endif
     else
      rem no shadow if cannot see entity that casts it (see above reason)
      set shadow shading off tobj
      shadowobj(tobj)=0      
     endif
    else
     rem shadows further use blob shadow instead
     set shadow shading off tobj
     shadowobj(tobj)=0
    endif
    `
    rem Control length of shadow cast on valid shadows
    rem (by raycasting from caster in direction away from light to solid surface)
    if shadowobj(tobj)=1
     `
     remstart
     rem 150807 - too many problems casting 'LONG' horiz-based shadows given the
     rem time remaining before Christmas. I have a few new ideas based on baking
     rem world normals into the scene, and only shading those polygons that are
     rem facing the source of the volume. This means clipping is only required
     rem for larger blockers such as walls/floors (another challenge)
     rem perhaps do this gradually so shadow expand and shrink as raycast hits
     rem various static blockers both incidental and substantial when moving
     tlightdirx#=entityelement(e).x-avlightposx#
     tlightdiry#=(entityelement(e).y+30)-avlightposy#
     tlightdirz#=entityelement(e).z-avlightposz#
     tlightdirdst#=sqrt(abs(tlightdirx#*tlightdirx#)+abs(tlightdiry#*tlightdiry#)+abs(tlightdirz#*tlightdirz#))
     tlightdirx#=tlightdirx#/tlightdirdst#
     tlightdiry#=tlightdiry#/tlightdirdst#
     tlightdirz#=tlightdirz#/tlightdirdst#
     tlightdirx#=entityelement(e).x+(tlightdirx#*1000.0)
     tlightdiry#=(entityelement(e).y+65)+(tlightdiry#*1000.0)
     tlightdirz#=entityelement(e).z+(tlightdirz#*1000.0)
     rem X10 new ray cast quicker
     if 1
      tcastersrcx=entityelement(e).x
      tcastersrcy=entityelement(e).y+65
      tcastersrcz=entityelement(e).z
      tshadowcastdistance#=static raycast(tcastersrcx,tcastersrcy,tcastersrcz,tlightdirx#,tlightdiry#,tlightdirz#)
     else
      `tried it and the distance was incorrect - not far enough caused shadow corruption
      `and i need the normal back from the test to do elongated volume calculation
      `tshadowcastdistance#=AI ray cast(entityelement(e).x,entityelement(e).y+65,entityelement(e).z,tlightdirx#,tlightdiry#,tlightdirz#)
      `if tshadowcastdistance#<>-1
      ` dstx#=tlightdirx#-entityelement(e).x
      ` dsty#=tlightdiry#-(entityelement(e).y+65)
      ` dstz#=tlightdirz#-entityelement(e).z
      ` tshadowcastdistance#=tshadowcastdistance#*sqrt(abs(dstx#*dstx#)+abs(dsty#*dsty#)+abs(dstz#*dstz#))
      `else
      ` tshadowcastdistance#=0.0
      `endif
     endif
     tavoidclipartefactbuffer#=5.0
     if tshadowcastdistance#>0.0
      rem get normal from raycast hit
      tnx#=checklist fvalue a(7)
      tny#=checklist fvalue b(7)
      tnz#=checklist fvalue c(7)
      rem get look vector of camera position to impact of ray coordinate
      timpx#=checklist fvalue a(6)
      timpy#=checklist fvalue b(6)
      timpz#=checklist fvalue c(6)
      tcamx#=timpx#-camera position x(playercam)
      tcamy#=timpy#-camera position y(playercam)
      tcamz#=timpz#-camera position z(playercam)
      tcamdst#=sqrt(abs(tcamx#*tcamx#)+abs(tcamy#*tcamy#)+abs(tcamz#*tcamz#))
      tcamx#=tcamx#/tcamdst#
      tcamy#=tcamy#/tcamdst#
      tcamz#=tcamz#/tcamdst#
      rem 2D dot product (between camera and wall/floor)
      tdot2#=(tnx#*tcamx#)+(tny#*tcamy#)+(tnz#*tcamz#)
      rem 2D dot product (between caster and wall/floor)
      tcamx#=timpx#-entityelement(e).x
      tcamy#=timpy#-(entityelement(e).y+65)
      tcamz#=timpz#-entityelement(e).z
      tcamdst#=sqrt(abs(tcamx#*tcamx#)+abs(tcamy#*tcamy#)+abs(tcamz#*tcamz#))
      tcamx#=tcamx#/tcamdst#
      tcamy#=tcamy#/tcamdst#
      tcamz#=tcamz#/tcamdst#      
      tdot1#=(tnx#*tcamx#)+(tny#*tcamy#)+(tnz#*tcamz#)      
      if tdot2#>=0.0
       rem when camera look vector faces the 'BACK' of the shadow hitting surface, clip
       rem 150807 - when shadow heading toward player, reduce length by how much it faces plr
       tavoidclipartefactbuffer#=(tshadowcastdistance#*-1)*tdot2#
      else
       rem when camera look vector is facing surface on which shadow cast, be generous
       tavoidclipartefactbuffer#=abs((tshadowcastdistance#/2.0)*tdot2#)
       rem tdot1# adds extra to buffer when shadow angle to wall not dead on (need longer shadow to cast 'along' wall)
       inc tavoidclipartefactbuffer#,(1.0-abs(tdot1#))*500.0
      endif
     endif
     lastentityshadowlength#(e)=curvevalue(tshadowcastdistance#+tavoidclipartefactbuffer#,lastentityshadowlength#(e),5.0)
     remend
     lastentityshadowlength#(e)=150
     `
    endif
    if entityprofile(tentid).scale<30
     rem X10 - V109 - 160309 - avoids cull bug when large scaled objects offset out of view
     set object radius tobj,0
    else
     set object radius tobj,lastentityshadowlength#(e)
    endif
    `
   endif
   `
   rem if object needs destroying, do it here
   if phyobjremove(tobj)<>0
    rem used when want to disturb another phy obj (ie move up slightly, then remove on next pass)
    if phyobjremove(tobj)=1
     rem this will nudge anything sitting on obj
     if physxedition=1
      ttobj=phyobjremove(tobj) : gosub _phy_nudgeentityup
     else
      ode set linear velocity phyobjremove(tobj),0,10,0
     endif
     phyobjremove(tobj)=2
    else
     if phyobjremove(tobj)=2
      rem this will nudge anything sitting on obj further
      if physxedition=1
       ttobj=phyobjremove(tobj) : gosub _phy_nudgeentityup
      else
       ode set linear velocity phyobjremove(tobj),0,5,0
      endif
      phyobjremove(tobj)=3
     else
      rem this finally removes the phy obj from the simulation
      gosub _physics_switchoffe
      phyobjremove(tobj)=0
      rem X10, if character, use ragdoll destruction
      tentid=entityelement(e).bankindex
      `if entityprofile(tentid).ischaracter=1 `X10 V109 - 100309 - NORAGDOLL flag
      if entityprofile(tentid).ischaracter=1 and entityprofile(tentid).noragdoll=0
       if entityelementusingode(e)=0
        storeobj=obj
        obj=tobj : gosub _slot_ode_collapse
        obj=storeobj
       endif
      else
       rem and then hide the object if not already hidden
       hide object tobj
      endif
     endif
    endif
   endif
   `
   rem if corpse of character fades out, do it here
   if entityprofile(tentid).ischaracter=1
    if entityelementusingode(e)>0
     if entityelementusingode(e)>1
      entityelementusingode(e)=entityelementusingode(e)-1
      rem X20 - 251007 - During ragdoll sequence, fade out alpha of the object
      if gfadeoutragdolls=1
       tperc#=entityelementusingode(e)-80 : rem 081107 - shorter and faster
       if tperc#<0 then tperc#=0
       if tperc#>100 then tperc#=100
       set alpha mapping on tobj,tperc#
       if entityelementusingode(e)=95
        rem 081107 - one time in the fade out code, create puff of smoke
        if particlecorpsedust<>0
         inc particlecorpsedust
         if particlecorpsedust>15 then particlecorpsedust=11
         emit particle particlecorpsedust,object position x(tobj),object position y(tobj),object position z(tobj)
        endif  
       endif
      endif
     else
      if entityelementusingode(e)=1 and (object in screen(tobj)=0 or gfadeoutragdolls=1)
       rem but only after decaytime has elapsed
       if gfadeoutragdolls=1
        rem remove immediately after fade out
        tremovebodyfromgame=1
        rem and put alpha value back to normal
        set alpha mapping on tobj,100
       else
        tremovebodyfromgame=0
        if entityelement(e).eleprof.ex.decaytime>0
         if timer()-entityelement(e).timekilled>(entityelement(e).eleprof.ex.decaytime*1000)
          tremovebodyfromgame=1
         endif
        endif
       endif
       if tremovebodyfromgame=1
        rem remove ragdoll altogether
        if physxedition=1
         rem PHYSX - no ragdoll
        else
         ODE destroy ragdoll tobj
        endif
        if ragdollcountingame>0 then dec ragdollcountingame
        rem ensure this is called only once
        entityelementusingode(e)=0
        gosub _physics_switchoffe
        rem actually hide the clone ragdoll in case it needed for respawn later
        hide object tobj : position object tobj,-50000,-50000,-50000
        exclude object on tobj : rem X10 - 241007 - removes from collision and update work!
        rem X10 - 101007 - do not remove OBJ value, need it for respawning!
        `entityelement(e).obj=0 : tobj=0
        rem X10 clear the undesirable flag when corpse is removed
        if entityelement(e).eleprof.aiss.corpsecontainer>=0 and entityelement(e).eleprof.aiss.corpsecontainer<20
         AI CLEAR UNDESIRABLE GRID SPACE entityelement(e).eleprof.aiss.corpsecontainer,entityelement(e).eleprof.aiss.corpsex,entityelement(e).eleprof.aiss.corpsez
         entityelement(e).eleprof.aiss.corpsecontainer=-1
        endif
       endif
      endif
     endif
    endif
   endif   
   `
   rem serious error, object has left the universe (through hole in geom!)
   if showfpsinrealgame=2
    if tobj>0
     if object position y(tobj)<-20
      position object tobj,object position x(tobj),-25,object position z(tobj)
      print "Object ";e;entityelement(e).eleprof.name$;" has left the universe at ";str$(int(object position x(tobj)));",";str$(int(object position z(tobj)))
     endif
    endif
   endif
   `
  endif
 next e
 `
return

_physics_waterandgravity_item:
 `
 rem obj is twaterobj, optional e
 rem if have associated entity
 twatere=phyobjele(twaterobj)
 rem depth of surface resistance
 depth#=40.0
 rem if deep enough to cover entity, switch gravity off
 tactualtopofobject#=object position y(twaterobj)+(object size y(twaterobj)/2.0)
 if twatere>0
  rem if character, test higher
  if entityprofile(entityelement(twatere).bankindex).ischaracter=1
   tactualtopofobject#=tactualtopofobject#+25.0
  endif
  rem if ragdoll, have no Y pos, use last entity Y pos
  if entityelementusingode(twatere)>0
   tactualtopofobject#=entityelement(twatere).y+55 : rem 241007 - used to be 25
  endif
 endif
 if tactualtopofobject#<waterlevel#
  rem no gravity
  if physxedition=1
   ttobj=twaterobj : gosub _phy_gravityentityoff
  else
   ode set gravity twaterobj,0
  endif
  rem current velocity of entity (natural damping)
  tvelokay=1
  if twatere>0
   if entityelementusingode(twatere)>0
    rem ragdolls have a natural downward sink underwater
    oldvelx#= 0.0
    oldvely#=-4.0
    oldvelz#= 0.0
    tvelokay=0
   endif
  endif
  if tvelokay=1
   rem regular underwater handling
   if physxedition=1
    ttobj=twaterobj : gosub _phy_getentityvelocity
   else
    oldvelx#=ODE GET BODY LINEAR VELOCITY X(twaterobj)*0.97
    oldvely#=ODE GET BODY LINEAR VELOCITY Y(twaterobj)*0.97
    oldvelz#=ODE GET BODY LINEAR VELOCITY Z(twaterobj)*0.97
   endif
   rem resist zero gravity and entity leaves surface of water (very subtle!)
   if object position y(twaterobj)>waterlevel#-depth#
    resistby#=depth#-abs(object position y(twaterobj)-waterlevel#)
    oldvely#=oldvely#-(resistby#*0.0005)
   endif
   rem raise/lower entity based on weight (750 = 10x10x10 cube) (based on depth)
   depthfactor#=abs(object position y(twaterobj)-waterlevel#)/100.0
   if twatere>0
    depthdecent#=((entityelement(twatere).eleprof.phyweight-2000)/5000.0)*depthfactor#
    oldvely#=oldvely#-depthdecent#
   else
    rem if not entity (debris or ragdoll) sink
    depthdecent#=0.0001
    oldvely#=oldvely#-0.0001
   endif
  endif
  rem 220707 - random chaos in water based on water speed
  if hudwaterspeed>0
   rem nudge in X and Z randomly factored by water speed
   tnudge#=((depthdecent#/25.0)*(hudwaterspeed+0.1))
   cyclicchaos#=cyclicchaos#+0.03
   if rnd(5)<>1 then tnudge#=0.0
   oldvelx#=oldvelx#+(cos(cyclicchaos#)*tnudge#)
   oldvelz#=oldvelz#+(sin(cyclicchaos#)*tnudge#)
  endif
  rem finally apply new velocity
  if physxedition=1
   ttobj=twaterobj : gosub _phy_setentityvelocity
  else
   ode set linear velocity twaterobj,oldvelx#,oldvely#,oldvelz#
  endif
 else
  rem gravity on
  if physxedition=1
   ttobj=twaterobj : gosub _phy_gravityentityon
  else
   ode set gravity twaterobj,1
  endif
 endif
 `
return

_physics_waterandgravity:
 `
 rem go through all entities
 for e=1 to entityelementmax
  twaterobj=entityelement(e).obj
  if twaterobj>0
   if entityelement(e).eleprof.physics=1 or entityelementusingode(e)>0
    rem only physics objects that are subject to ODE gravity
    twatere=e : gosub _physics_waterandgravity_item
   endif
  endif
 next e
 `
 rem go through all debris
 for twaterobj=fragmentobjectoffset to fragmentobjectoffsetmax
  if object exist(twaterobj)=1
   if object visible(twaterobj)=1
    if twaterobj>0
     twatere=0 : gosub _physics_waterandgravity_item
    endif
   endif
  endif
 next twaterobj
 `
return

_physics_applyforce:
 `
 rem X10 takes todee,tdx#,tdy#,tdz#,todeforce#,todefalloff#,tpx#,tpy#,tpz#
 tobj=entityelement(todee).obj
 if tobj>0
  td#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
  tdx#=tdx#/td# : tdy#=tdy#/td# : tdz#=tdz#/td#
  todeforce#=todeforce#*10.0 : rem bring force to affect physics ODE correctly
  tbulletforce#=(todeforce#/500.0)*(500.0-td#)*todefalloff#
  tbulletforce#=tbulletforce#+(todeforce#*(1.0-todefalloff#))
  massconsideration#=entityelement(todee).eleprof.phyweight/200.0
  if massconsideration#<1.0 then massconsideration#=1.0
  tbulletforce#=tbulletforce#/massconsideration#
  rem simpler force limiter
  tdx#=tdx#*tbulletforce#
  tdy#=tdy#*tbulletforce#
  tdz#=tdz#*tbulletforce#
  gosub _physics_limitforce
  if physxedition=1
   ttobj=tobj : gosub _phy_applyentityforce
  else
   if twithpointforce=1
    ode add force tobj,tdx#*4,tdy#*4,tdz#*4,tpx#,tpy#,tpz#
   else
    tda#=atanfull(tdx#,tdz#)
    ode set linear velocity tobj,tdx#,tdy#,tdz#
    tspinforce#=tbulletforce#/100.0
    if tspinforce#>1.0 then tspinforce#=1.0
    if tspinforce#<-1.0 then tspinforce#=-1.0
    ode set angular velocity tobj,sin(tda#)*(2.5*tspinforce#),0,cos(tda#)*(2.5*tspinforce#)
   endif
  endif
  rem register force with physics object (nudge so SET ACTIVE can be called)
  rem use a random number to send a unique ripple (so we dont keep nudging everything)
  if tobj<array count(phyobjelenudged()) then phyobjelenudged(tobj)=2
 endif
 `
return

_physics_limitforce:
 `
 maxforce#=50.0
 if tdx#>maxforce# then tdx#=maxforce#
 if tdx#<maxforce#*-1 then tdx#=maxforce#*-1
 if tdz#>maxforce# then tdz#=maxforce#
 if tdz#<maxforce#*-1 then tdz#=maxforce#*-1
 if tdy#>maxforce# then tdy#=maxforce#
 if todelimitgobelow=0
  if tdy#<0.01 then tdy#=0.01 : rem apply no downward force (objs get stuck!)
 else
  if tdy#<0.01 then tdy#=tdy#/5.0 : rem reduce so does not enter floor
 endif
 `
return

_physics_applypointforce:
 `
 rem apply point force (tpx#,tpy#,tpz#)
 twithpointforce=1
 gosub _physics_applyforce
 `
return

_physics_entitydrivenphysics:
 `
 rem use entity data to drive object via physics (character)
 todeobj=entityelement(todee).obj
 tmvx#=entityelement(todee).x-object position x(todeobj)
 todeentid=entityelement(todee).bankindex
 `x9tmvszy#=(object size y(todeobj)/2)*(entityprofile(todeentid).scale/100.0)
 `tmvszy#=(object size y(todeobj)/2) `X10 V109 - 090309 - scale is back!
 tmvszy#=(object size y(todeobj)/2)*(entityprofile(todeentid).scale/100.0)
 tmvy#=(entityelement(todee).y+tmvszy#+thover#)-object position y(todeobj)
 tmvz#=entityelement(todee).z-object position z(todeobj)
 tstress#=sqrt(abs(tmvx#)+abs(tmvy#)+abs(tmvz#))
 entitydebug$(todee)="ENTITY DRIVEN PHYSICS ("+str$(int(tmvx#))+","+str$(int(tmvz#))+")"
 rem X10 do not apply controlling position force if no health (so ragdoll can use the force that caused health to hit zero)
 if entityelement(todee).health>0
  `240907 smooth out entity char movement ode set linear velocity todeobj,tmvx#*4,tmvy#*4,tmvz#*4
  rem noticed a bug where E is used, but the element index is TODEE
  tmvx#=tmvx#+entityelement(e).eleprof.aiss.knockbackx
  tmvz#=tmvz#+entityelement(e).eleprof.aiss.knockbackz
  entityelement(e).eleprof.aiss.knockbackx=entityelement(e).eleprof.aiss.knockbackx/2
  entityelement(e).eleprof.aiss.knockbackz=entityelement(e).eleprof.aiss.knockbackz/2
  `X10 101007 - faster vertical - ode set linear velocity todeobj,tmvx#*2,tmvy#*2,tmvz#*2
  if physxedition=1
   ttobj=todeobj : gosub _phy_entitydrivenphysics
  else
   ode set linear velocity todeobj,tmvx#*2,tmvy#*4,tmvz#*2
   if entityelement(todee).norotate=0
    ode set body rotation todeobj,0,entityelement(todee).ry,0
   else
    ode set body rotation todeobj,0,0,0
   endif
  endif
 endif
 `
return

_physics_entitydrivenstaticphysics:
 `
 rem as above but for the pseudo-static objects (door/window)
 todeobj=entityelement(todee).obj
 if physxedition=1
  ttobj=todeobj : gosub _phy_entitydrivenstaticphysics
 else
  if entityelement(todee).norotate=0
   ode set body rotation todeobj,0,entityelement(todee).ry,0
  else
   ode set body rotation todeobj,0,0,0
  endif
 endif
 `
return

_physics_update:
 `
 rem debug info on entities
 if physicsdebug=1
  for e=1 to entityelementmax
   if entityelement(e).active=1
    if entityelement(e).eleprof.physics<>0
     tobj=entityelement(e).obj
     if tobj>0
      if object exist(tobj)=1
       if object in screen(tobj)=1
        center text object screen x(tobj),object screen y(tobj),"size="+str$(object size(tobj))
        center text object screen x(tobj),object screen y(tobj)+16,"weight="+str$(entityelement(e).eleprof.phyweight)
        if e=tclosestpickable
         center text object screen x(tobj),object screen y(tobj)-16,"CLOSEST="+str$(camerareach#)
        endif
       endif
      endif
     endif
    endif
   endif
  next e
 endif
 `
 rem speed gain by disabling physics objects well out of players 'interest'
 if physxedition=1
  rem PHYSX - keep entire scene active
 else
  for e=1 to entityelementmax
   if entityelement(e).active=1
    if entityelement(e).eleprof.physics<>0
     tobj=entityelement(e).obj
     if tobj>0
      if object exist(tobj)=1
       tentid=entityelement(e).bankindex
       if allentsfulllogicatstartcount>0 or entityelement(e).plrdist<500.0 or entityprofile(tentid).ischaracter=1
        rem if within range, keep enabled for player interaction
        ode set enabled tobj,1
       else
        rem only disable if not moving significantly (and not always active)
        tmotionx#=ode get body linear velocity x(tobj)
        tmotiony#=ode get body linear velocity y(tobj)
        tmotionz#=ode get body linear velocity z(tobj)
        tmotion#=abs(tmotionx#)+abs(tmotiony#)+abs(tmotionz#)
        if entityelement(e).eleprof.phyalways=0 and tmotion#<0.005
         ode set active tobj,0
         ode set enabled tobj,0
         entityelement(e).dormant=1
        else
         ode set enabled tobj,1
        endif
       endif
      endif
     endif
    endif
   endif
  next e
 endif
 `
 rem update physics
 if physxedition=1
  gosub _phy_update
 else
  ode update
 endif
 `
 rem for next run - debug readouts
 if physicsdebug=1 then set cursor 0,0
 `
return

rem
rem Called from outside this source file
rem

_physics_ragdollon:
 ode set ragdoll mode 1
return

_physics_gravityon:
 ode set gravity obj,1
return
 
_physics_gravityoff:
 ode set gravity obj,0
return

_physics_setvelocity:
 ode set linear velocity ttobj,ttx#,tty#,ttz#
return

_physics_deleteentity:
 ode destroy object tobj
return

_physics_getvelocityy:
 velocity#=abs(ODE GET BODY LINEAR VELOCITY Y(ttobj))
return

_physics_destroyjustragdoll:
  ODE destroy ragdoll ttobj
return

_physics_destroyragdoll:
  ode set linear velocity obj,0,0,0
  ode set angular velocity obj,0,0,0
  ODE destroy ragdoll tobj
return

_physics_stopvelocity:
 ode set linear velocity tobj,0,0,0
 ode set angular velocity tobj,0,0,0
return

_physics_applyphysicstoattachment:
   ode create dynamic box tobj
   tfriction=(object size x(tobj)*75)+(object size y(tobj)*75)+(object size z(tobj)*75)
   tweight=(object size x(tobj)*25)+(object size y(tobj)*25)+(object size z(tobj)*25)
   tweight=(tweight/50)*50 : tfriction=(tfriction/50)*50
   if tweight<200 then tweight=200
   ode set contact fdir1 tobj,tfriction
   ode set body mass tobj,tweight
   ode set linear velocity tobj,0,0,0
   ode set angular velocity tobj,0,0,0
   ode set gravity tobj,1
   ode set body rotation tobj,0,entityelement(e).ry,0
return

_physics_createragdoll:
 ODE Create Ragdoll from bone model obj,0.6 : rem was 0.8 up to 171007 (was 0.6 on 300707)
 rem set friction and weight for the character as a ragdoll
 ode set contact fdir1 obj,entityprofile(tttentid).phyfriction
 rem ragdoll must use 'percentage' as each bone has its own mass
 ode set body mass obj,1.0
 rem stabalize the object
 ode set linear velocity obj,0,0,0
 ode set angular velocity obj,0,0,0
return

_physics_createfragment:
  ode create dynamic sphere tfobj
  rem X10 - 280907 - new ray cast code for projectile physics
  ode set ray cast tfobj,1
  tfriction=(5*75)+(5*75)+(5*75) : tweight=(5*25)+(5*25)+(5*25)
  tweight=(tweight/50)*50 : tfriction=(tfriction/50)*50
  if tweight<200 then tweight=200
  ode set contact fdir1 tfobj,tfriction
  ode set body mass tfobj,tweight
  rem add one as we need an extra for the detonate bounce
  flakelement(tf).profile.bounceonhit=flakelement(tf).profile.bounceonhit+1
  flakelement(tf).noimpactdelay=50
  rem flak bounces, set physics accordingly
  tdx#=flakelement(tf).profile.xinc*4
  tdy#=flakelement(tf).profile.yinc*4
  tdz#=flakelement(tf).profile.zinc*4
  rem 200807 - a very slight inaccuracy for the human error of characters
  tdx#=tdx#+((rnd(100)-50)/100.0)
  tdz#=tdz#+((rnd(100)-50)/100.0)
  todelimitgobelow=1 : gosub _physics_limitforce : todelimitgobelow=0
  ode set linear velocity tfobj,tdx#*4,tdy#*2,tdz#*4
return

_physics_createdebrisshape:
  select bitdetails(debrisshapeindex).collisionmode
   case 2 : ode create dynamic box fragmento : endcase
   case 3 : ode create dynamic cylinder fragmento : endcase
   case 4 : ode create dynamic sphere fragmento : endcase
  endselect
  ode set contact fdir1 fragmento,50
  ode set body mass fragmento,10
  if debrisexplodable=3
   tdx#=debrisblastawayx#*debrisblastaway
   tdy#=debrisblastawayy#*debrisblastaway
   tdz#=debrisblastawayz#*debrisblastaway
   gosub _physics_limitforce
   ode set linear velocity fragmento,tdx#,tdy#,tdz#
   ode set angular velocity fragmento,2.5+rnd(10)/10.0,1.5+rnd(5)/10.0,rnd(2)/10.0
  else
   if debrisexplodable=1
    ode add force fragmento,0,-1,0,object position x(fragmento),object position y(fragmento)+object size y(fragmento),object position z(fragmento)
    ode set angular velocity fragmento,2.5+rnd(10)/10.0,1.5+rnd(5)/10.0,rnd(2)/10.0
   else
    ode set linear velocity fragmento,0,-20,0
    ode set angular velocity fragmento,0,0,0
   endif
  endif
return

_physics_updatesmall:
 `
 rem update physics engine
 if physxedition=1
  gosub _phy_update
 else
  ode update 0.001
 endif
 `
return

_phy_init:
_phy_update:
_phy_close:
_phy_collisionmessages_eat:
_phy_universe:
_phy_pseudostaticentity:
_phy_characterentity:
_phy_dynamicentity:
_phy_rotateentity:
_phy_removeentity:
_phy_dynamicvelocity:
_phy_nudgeentity:
_phy_nudgeentityup:
_phy_gravityentityoff:
_phy_gravityentityon:
_phy_getentityvelocity:
_phy_setentityvelocity:
_phy_applyentityforce:
_phy_entitydrivenphysics:
_phy_entitydrivenstaticphysics:
_phy_getcollisionmessage:
_phy_getvelocitya:
_phy_getvelocityb:
_phy_plr_make:
_phy_plr_move:
_phy_plr_jump:
_phy_plr_stop:
_phy_plr_delete:
_phy_plr_getmotion:
_phy_plr_gravityon:
_phy_plr_gravityoff:
_phy_plr_pickup:
_phy_plr_carry:
_phy_plr_dropvelocity:
_phy_plr_dropmass:
return    